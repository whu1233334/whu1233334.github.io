<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风起之时</title>
  
  
  <link href="https://fqzs.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://fqzs.netlify.app/"/>
  <updated>2023-06-10T16:27:50.581Z</updated>
  <id>https://fqzs.netlify.app/</id>
  
  <author>
    <name>风起之时</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多地址指令实际访存次数</title>
    <link href="https://fqzs.netlify.app/undefined/7566551b.html"/>
    <id>https://fqzs.netlify.app/undefined/7566551b.html</id>
    <published>2023-06-10T10:44:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;&lt;code&gt;指令&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;机器指令按照含有的地址数目可以分为1,2,3,4地址指令。&lt;br&gt;其中指令中存放的地址都是虚拟地址，不是实际物理地</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>English</title>
    <link href="https://fqzs.netlify.app/undefined/e33e3b9c.html"/>
    <id>https://fqzs.netlify.app/undefined/e33e3b9c.html</id>
    <published>2023-06-08T11:44:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><p><strong>定语</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><p><strong>状语</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><p><strong>同位语</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><p><strong>插入语</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五大基本句型&quot;&gt;&lt;a href=&quot;#五大基本句型&quot; class=&quot;headerlink&quot; title=&quot;五大基本句型&quot;&gt;&lt;/a&gt;五大基本句型&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>acdemic_gpt添加slack-Claude模型</title>
    <link href="https://fqzs.netlify.app/undefined/6ca9ded9.html"/>
    <id>https://fqzs.netlify.app/undefined/6ca9ded9.html</id>
    <published>2023-06-07T23:16:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从GitHub仓库中获取acdemic_gpt&lt;/li&gt;
&lt;li&gt;创建Slac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://fqzs.netlify.app/undefined/e255a10a.html"/>
    <id>https://fqzs.netlify.app/undefined/e255a10a.html</id>
    <published>2023-06-03T17:23:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h1 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被服务的</span><br><span class="line">关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资源有限同时发</span><br><span class="line">消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主要指</span><br><span class="line">下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上与服务端进</span><br><span class="line">    行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服务端又</span><br><span class="line">是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境当中，下载的</span><br><span class="line">主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一点点</span><br><span class="line">   交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电话(释放</span><br><span class="line">链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，然后再</span><br><span class="line"> 由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段的占用链路，</span><br><span class="line"> 不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机发出报</span><br><span class="line">  文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入10bit</span><br><span class="line">信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间被称为</span><br><span class="line">排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被称为处</span><br><span class="line">理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h2 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h1 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h1><h2 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h2 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h1 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h1><hr><h2 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h2><h3 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h3 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h3 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步(SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载app，网络</span><br><span class="line">断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用户数据</span><br><span class="line">报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返回确认</span><br><span class="line">信息后，才会发送下一段内容；如果没有接收到确认信息，那么会一直发送</span><br><span class="line">当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无需确认</span><br><span class="line">这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发消息，</span><br><span class="line">qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进行区分</span><br><span class="line">例如请qq的消息端口号是1，接收方端口号1的进程(qq)接收该条消息；微</span><br><span class="line">信端口号2，接收方端口号2的进程(微信)接受该条消息</span><br><span class="line">5.拥塞控制</span><br><span class="line">- 传输层协议</span><br><span class="line">1.TCP</span><br><span class="line">2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服务，网</span><br><span class="line">  络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则进行对</span><br><span class="line">分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制校验)</span><br><span class="line">4.拥塞控制：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里开始，</span><br><span class="line">到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合走可</span><br><span class="line">  在链路上传输</span><br><span class="line">- </span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><h3 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h2 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h1 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h1><h2 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h2 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识计算机网络&quot;&gt;&lt;a href=&quot;#认识计算机网络&quot; class=&quot;headerlink&quot; title=&quot;认识计算机网络&quot;&gt;&lt;/a&gt;认识计算机网络&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>字扩展与多模块存储器区别</title>
    <link href="https://fqzs.netlify.app/undefined/a9bcdbf2.html"/>
    <id>https://fqzs.netlify.app/undefined/a9bcdbf2.html</id>
    <published>2023-06-01T22:23:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于存储器的一部分。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg&quot; alt=&quot;星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哪些方法可以判断一个有向图是否有环</title>
    <link href="https://fqzs.netlify.app/undefined/d30215e4.html"/>
    <id>https://fqzs.netlify.app/undefined/d30215e4.html</id>
    <published>2023-05-24T22:03:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg&quot; alt=&quot;房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>模4补码与模2补码</title>
    <link href="https://fqzs.netlify.app/undefined/f711f08b.html"/>
    <id>https://fqzs.netlify.app/undefined/f711f08b.html</id>
    <published>2023-05-22T22:13:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg&quot; alt=&quot;女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码、模与运算</title>
    <link href="https://fqzs.netlify.app/undefined/b988fae0.html"/>
    <id>https://fqzs.netlify.app/undefined/b988fae0.html</id>
    <published>2023-05-22T16:32:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg&quot; alt=&quot;晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码的移位</title>
    <link href="https://fqzs.netlify.app/undefined/fe859f5c.html"/>
    <id>https://fqzs.netlify.app/undefined/fe859f5c.html</id>
    <published>2023-05-21T22:55:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对补码左移运算&lt;/code&gt;&lt;br&gt;书里介绍的</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="补码" scheme="https://fqzs.netlify.app/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://fqzs.netlify.app/undefined/8d4b7ae1.html"/>
    <id>https://fqzs.netlify.app/undefined/8d4b7ae1.html</id>
    <published>2023-05-08T20:07:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg" alt="白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 </span><br><span class="line">  入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B</span><br><span class="line">               电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那就需</span><br><span class="line"> 要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10条字选</span><br><span class="line"> 线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内全部</span><br><span class="line">      刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期变为</span><br><span class="line">  1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功耗低</span><br><span class="line">  价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始都为0)</span><br><span class="line">如果表加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位表示块</span><br><span class="line">  号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要6bit位表</span><br><span class="line">  示</span><br><span class="line">--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit数字就是Cache中的块号大小</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></p><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞</span><br><span class="line">  状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块中，因</span><br><span class="line">此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主存块大小相等)</span><br><span class="line">因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑对应，所以出现了一个映射表，存储块号与页号</span><br><span class="line">  的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;01 转换地址 000001(操作码) 01(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺序编</span><br><span class="line"> 址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表示SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码</span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg&quot; alt=&quot;白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Telegram</title>
    <link href="https://fqzs.netlify.app/undefined/fd45428c.html"/>
    <id>https://fqzs.netlify.app/undefined/fd45428c.html</id>
    <published>2023-04-28T18:47:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用bot&quot;&gt;&lt;a href=&quot;#常用bot&quot; class=&quot;headerlink&quot; title=&quot;常用bot&quot;&gt;&lt;/a&gt;常用bot&lt;/h1&gt;&lt;p&gt;&lt;code&gt;@SMS24.me&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plainte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python安装</title>
    <link href="https://fqzs.netlify.app/undefined/ae5c380e.html"/>
    <id>https://fqzs.netlify.app/undefined/ae5c380e.html</id>
    <published>2023-04-14T18:11:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg" alt="绘梨衣壁纸_彼岸壁纸.jpg"></p><h1 id="配置python"><a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><hr><ul><li><code>下载好python环境，将文件夹配置到环境变量当中</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355861.png" alt="image.png"></li></ul><ul><li><code>CMD输入python查看版本信息，若显示说明配置成功</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355755.png" alt="image.png"></li></ul><ul><li><code>若不显示，打开CMD窗口，where python查看python安装位置 path查看环境变量配置</code></li><li><code>不显示，而是打开微软商店，需要将变量中的python移到Microsoft上方,或者删除Microsoft环境变量</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355535.png" alt="image.png"></li></ul><h1 id="添加pip"><a href="#添加pip" class="headerlink" title="添加pip"></a>添加pip</h1><hr><p><strong>pip</strong>是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包</p><ul><li>将图中<code>\python311\Script</code>配置到环境变量当中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355943.png" alt="image.png"></li></ul><ul><li><code>查看配置是否成功</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure></li></ul><h1 id="最便捷方式"><a href="#最便捷方式" class="headerlink" title="最便捷方式"></a>最便捷方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装python后，install前勾选pip to path</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg&quot; alt=&quot;绘梨衣壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置python&quot;&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://fqzs.netlify.app/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CMD命令</title>
    <link href="https://fqzs.netlify.app/undefined/3e5cd712.html"/>
    <id>https://fqzs.netlify.app/undefined/3e5cd712.html</id>
    <published>2023-04-12T23:12:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg" alt="可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="调出远程桌面控制"><a href="#调出远程桌面控制" class="headerlink" title="调出远程桌面控制"></a>调出远程桌面控制</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><p><code>输入ip地址</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352256.png" alt="image.png"></p><h1 id="查看连接过的wifi密码"><a href="#查看连接过的wifi密码" class="headerlink" title="查看连接过的wifi密码"></a>查看连接过的wifi密码</h1><hr><p><code>1.查看历史所有wifi</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure></p><p><code>2.查看指定wifi的密码</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile name=&quot;wifi名&quot; key=clear</span><br></pre></td></tr></table></figure></p><h1 id="查询本机当前ip地址"><a href="#查询本机当前ip地址" class="headerlink" title="查询本机当前ip地址"></a>查询本机当前ip地址</h1><hr><ul><li><code>查看当前局域网ip和其他信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353460.png" alt="image.png"></li></ul><ul><li><code>查看更详细信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353598.png" alt="image.png"></li></ul><ul><li><code>查看当前外网地址</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L ip.tool.lu</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353405.png" alt="image.png"></li></ul><h1 id="ping检测ip地址或服务器网络情况"><a href="#ping检测ip地址或服务器网络情况" class="headerlink" title="ping检测ip地址或服务器网络情况"></a>ping检测ip地址或服务器网络情况</h1><hr><ul><li><code>短暂监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353128.png" alt="image.png"></li></ul><ul><li><code>持续监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名) -t</span><br></pre></td></tr></table></figure></li></ul><h1 id="调出资源监测器"><a href="#调出资源监测器" class="headerlink" title="调出资源监测器"></a>调出资源监测器</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfmon.msc</span><br></pre></td></tr></table></figure><p><code>监测磁盘、网络、CPUz占用率</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353676.png" alt="image.png"></p><h1 id="查看电脑当前所有用户"><a href="#查看电脑当前所有用户" class="headerlink" title="查看电脑当前所有用户"></a>查看电脑当前所有用户</h1><hr><p><code>查看用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354885.png" alt="image.png"></p><p><code>删除用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user 名字 /del</span><br></pre></td></tr></table></figure></p><h1 id="修复丢失或损坏的系统文件"><a href="#修复丢失或损坏的系统文件" class="headerlink" title="修复丢失或损坏的系统文件"></a>修复丢失或损坏的系统文件</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具可以允许用户扫描所有受保护的系统文件，并且检查系统文件的完整性，然后恢复Windows损坏的系统文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg&quot; alt=&quot;可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="cmd" scheme="https://fqzs.netlify.app/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>C语言(三)</title>
    <link href="https://fqzs.netlify.app/undefined/1db5c403.html"/>
    <id>https://fqzs.netlify.app/undefined/1db5c403.html</id>
    <published>2023-04-10T21:42:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg" alt="北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jpg"></p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="补码解析"><a href="#补码解析" class="headerlink" title="补码解析"></a>补码解析</h2><hr><ul><li><code>补码</code>：计算机只能加法运算<code>2+(-5)</code>,所以需要补码，补码大小是<code>原码取反+1</code></li><li><p><code>原码</code>：补码取反+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0101     //5的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5    fffffffb </span><br></pre></td></tr></table></figure><p><code>由于X8架构采用的是小端存储</code>：低字节在前(低地址)，高字节在后(高地址) —&gt; <code>fbffffff</code></p></li><li><p><code>补码原码相加</code>：对应位置相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010     //2的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5 </span><br><span class="line"></span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1101     //补码 -3 =2+(-5)  --&gt;依次相加</span><br></pre></td></tr></table></figure></li><li><p>对于有符号数，最高位为1，就是负数</p></li></ul><h2 id="整型不同类型"><a href="#整型不同类型" class="headerlink" title="整型不同类型"></a>整型不同类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">整型类型</th><th style="text-align:center">符号</th><th style="text-align:center">字节</th><th style="text-align:center">整型数范围</th></tr></thead><tbody><tr><td style="text-align:left">基本整型</td><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31~(2^31-1)</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15~(2^15-1)</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:center">long</td><td style="text-align:center">(32位)4;(64位)8</td><td style="text-align:center">-2^31~(2^31-1)或-2^63~(-2^63-1)</td></tr><tr><td style="text-align:left">无符号整型</td><td style="text-align:center">unsigned int</td><td style="text-align:center">4</td><td style="text-align:center">0~2^32-1</td></tr><tr><td style="text-align:left">无符号短整型</td><td style="text-align:center">unsigned short</td><td style="text-align:center">2</td><td style="text-align:center">0~2^16-1</td></tr><tr><td style="text-align:left">无符号长整型</td><td style="text-align:center">unsigned long</td><td style="text-align:center">(32位)4;(62位)8</td><td style="text-align:center">0~(2^32-1)或0~(-2^64-1)</td></tr></tbody></table></div><ul><li><code>有符号数</code>：最高位只表示正负，不代表大小</li><li><code>无符号数</code>：最高位代表大小，不表示正负</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short最小数字：</span><br><span class="line">1000 0000 0000 0000  //补码 -32768 </span><br><span class="line">1000 0000 0000 0000  //原码  32768</span><br></pre></td></tr></table></figure><h2 id="溢出解析"><a href="#溢出解析" class="headerlink" title="溢出解析"></a>溢出解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">32767</span>;   <span class="comment">//01111 1111 1111 1111     32767</span></span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);  <span class="comment">//10000 0000 0000 0000    -32768 </span></span><br><span class="line"><span class="comment">//解决办法是用更大的空间存储</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=a+<span class="number">1</span>;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304111919441.png" alt="image.png"></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><h3 id="浮点数IEE754标准解析"><a href="#浮点数IEE754标准解析" class="headerlink" title="浮点数IEE754标准解析"></a>浮点数IEE754标准解析</h3><hr><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>格式</th><th>SEEEEEEE</th><th>EMMMMMMM</th><th>MMMMMMMM</th><th>MMMMMMMM</th></tr></thead><tbody><tr><td>二进制</td><td>01000000</td><td>10010000</td><td>00000000</td><td>00000000</td></tr><tr><td>十六进制</td><td>40</td><td>90</td><td>00</td><td>00</td></tr></tbody></table></div><ul><li><code>S</code>：符号位1表示正，0表示负</li><li><code>E</code>：指数部分，(指数部分的值规定只能是1到254，不能是全0，全1)，指数部分运算前都要减去127(这是EEE-754的规定)，因为还要表示负指数。这里的<code>10000001</code>转换为十进制数为129,129-127=2，即实际指数部分为2.<code>表示小数部分小数点往后移两位</code></li><li><code>M</code>：小数部分 <code>0010000 00000000 00000000</code> 左边默认省略了一个1，应该是<code>1.0010000 00000000 00000000(二进制数)</code></li></ul><blockquote><p>分析上面浮点数<br>S=0，表示正数<br>E=2^0+2^7-127=129-127=2,表示小数点向后移动两位<br>M=<code>0010000 00000000</code> ，前面默认有个1，<code>1.0010000 00000000 00000000</code><br>因为E，M小数点向后移动两位，<code>100.10000 00000000 00000000</code> =2^2 + 2^-1 =4.5</p></blockquote><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><hr><ul><li>浮点型变量分为单精度（float）型、双精度（double）型</li><li>float的数值范围：<code>2^-126~2^127</code>(因为指数部分值1~254，再减去127，得到的-126~127，也就是二进制位数小数点后126位，到小数点前127位)</li><li>float的精度：<code>6~7位</code></li><li>double数值范围：<code>2^-1022~2^1023</code></li><li>double的精度：<code>15~16位</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们赋给a的值为1.23456789e10,加20后，应该得到的值为1.234567892e10,</span><br><span class="line">但b输出结果却是b=12345678848.000000,变得更小了。我们将这种现象称为精度丢失，因</span><br><span class="line">为float型数据能够表示的有效数字为7位，最多只保证1.234567e10的正确性，要使结果正确，</span><br><span class="line">就需要把a和b均改为double型，因为double可以表示的精度为15~16位。</span><br></pre></td></tr></table></figure><code>int 溢出 可以考虑改用double存储</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg&quot; alt=&quot;北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jp</summary>
      
    
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git远程仓库</title>
    <link href="https://fqzs.netlify.app/undefined/3f8bae1e.html"/>
    <id>https://fqzs.netlify.app/undefined/3f8bae1e.html</id>
    <published>2023-04-09T18:20:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg" alt="Uploading file...0i2ar"></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>当安装Git后首先要做的事情是设置用户名称和emailt地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息</p><ul><li><code>git config --global user.name &quot;itcast&quot;</code></li><li><code>git config --global user.email &quot;hello@iteast.cn&quot;</code></li></ul><p>查看用户信息</p><ul><li><code>git config --global user.name</code></li><li><code>git config --global user.email</code></li></ul><h1 id="获取本地仓库及其基础操作指令"><a href="#获取本地仓库及其基础操作指令" class="headerlink" title="获取本地仓库及其基础操作指令"></a>获取本地仓库及其基础操作指令</h1><ul><li>初始化仓库文件夹：<code>git init</code></li><li><code>git status</code>：查看的修改的状态（暂存区、工作区）</li><li><code>git add 单个文件名|通配符.</code>：工作区-&gt;暂存区</li><li><code>git commit -m &#39;注释内容&#39;</code>：暂存区-&gt;本地仓库的当前分支</li><li><code>git-log</code>：查看提交日志</li><li><code>git reset --hard commitID</code>：版本回退；commitID 可以使用 git-log 或 git log 指令查看</li><li><code>git push -f -u origin master</code>：把修改推送至远程</li><li><code>git branch</code>：查看本地分支</li><li><code>git branch 分支名</code>：创建本地分支</li><li><code>git checkout 分支名</code>：切换本地分支</li><li><code>git merge 分支名称</code>：一个分支上的提交合并到另一个分支上</li><li><code>git branch -d 分支名</code>：删除分支，不能删除当前分支<h1 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h1></li></ul><hr><ul><li>生成SSH公钥：<code>ssh-keygen -t rsa</code>   不断回车; 如果公钥已经存在，则自动覆盖</li><li>获取公钥：<code>cat ~/.ssh/id_rsa.pub</code></li><li>公钥获取后，将其添加到github仓库设置中，以获取推送权限</li><li>验证是否配置成功: <code>ssh-T:git@github.com</code></li></ul><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><hr><ul><li>命令：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354039.png" alt="image.png"></li></ul></li></ul><h1 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h1><hr><ul><li>命令：<code>git remote</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354389.png" alt="image.png"></li></ul><h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><hr><ul><li>命令：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>当前分支已经和远端分支关联，则可以省略分支名和远端名<code>git push</code></li><li><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<br><code>git push --set-upstream origin master</code></li></ul><h1 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h1><hr><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354898.png" alt="image.png"></li></ul><h1 id="从远程仓库抓取和拉取"><a href="#从远程仓库抓取和拉取" class="headerlink" title="从远程仓库抓取和拉取"></a>从远程仓库抓取和拉取</h1><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code> </li><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li><p>如果不指定远端名称和分支名，则抓取所有分支。</p></li><li><p>拉取 命令：<code>git pull [remote name] [branch name]</code></p></li><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul><h1 id="其他基础命令"><a href="#其他基础命令" class="headerlink" title="其他基础命令"></a>其他基础命令</h1><h2 id="查看当前仓库大小"><a href="#查看当前仓库大小" class="headerlink" title="查看当前仓库大小"></a>查看当前仓库大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354114.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg&quot; alt=&quot;Uploading file...0i2ar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本</summary>
      
    
    
    
    
    <category term="git" scheme="https://fqzs.netlify.app/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>白鲸vpn无限白嫖</title>
    <link href="https://fqzs.netlify.app/undefined/e47230b0.html"/>
    <id>https://fqzs.netlify.app/undefined/e47230b0.html</id>
    <published>2023-04-09T11:23:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181102465.jpg" alt="232826-1622906906220f.jpg"></p><h2 id="官网下载地址"><a href="#官网下载地址" class="headerlink" title="官网下载地址"></a>官网下载地址</h2><p><a href="https://www.bjchuhai.com/?mid=3020">https://www.bjchuhai.com/?mid=3020</a></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ul><li>随便填写一个邮箱，密码随意，没有二次验证</li><li>邀请码可以填写安卓手机端的账户邀请码，可以延长30天试用时间，并加速5%<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351374.png" alt="image.png"></li></ul><h2 id="重复注册"><a href="#重复注册" class="headerlink" title="重复注册"></a>重复注册</h2><ul><li>注册之后重新注册一个账号<br>一般情况提示账户密码错误<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351877.png" alt="image.png"></li></ul><ul><li><p>找到<code>‪C:\ProgramData\Whale</code> 路径下的文件，并将所有文件删除<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352313.png" alt="image.png"></p></li><li><p>再次注册即可</p></li></ul><h1 id="手机端-安卓"><a href="#手机端-安卓" class="headerlink" title="手机端(安卓)"></a>手机端(安卓)</h1><h2 id="手机注册"><a href="#手机注册" class="headerlink" title="手机注册"></a>手机注册</h2><p>与pc注册步骤一致</p><h2 id="重复注册-1"><a href="#重复注册-1" class="headerlink" title="重复注册"></a>重复注册</h2><p>手机最多注册两个账号，且无法像pc端进行重复注册操作<br>有两个方法：</p><ul><li>安装安卓模拟器(推荐voms pro)：通过手机模拟器，注册账号，并改变模拟器虚拟机的设备信息，实现重复注册，再通过填写邀请码延长时间</li><li>利用电脑端重复注册时，填写手机账号的邀请码，延长手机账号使用时间</li><li>注意,pc端，手机端 账号<code>不通用</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;pc端&quot;&gt;&lt;a href=&quot;#pc端&quot; class=&quot;headerlink&quot; title=&quot;pc端&quot;&gt;&lt;/a&gt;pc端&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-roo</summary>
      
    
    
    
    
    <category term="VPN 白嫖 备用" scheme="https://fqzs.netlify.app/tags/VPN-%E7%99%BD%E5%AB%96-%E5%A4%87%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>C语言(一)</title>
    <link href="https://fqzs.netlify.app/undefined/cc777f4a.html"/>
    <id>https://fqzs.netlify.app/undefined/cc777f4a.html</id>
    <published>2023-04-06T22:42:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108759.jpg" alt="大海 棕榈树 海滩沙滩 帆船 岛 插图风景 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td>形式-&gt;0.123 或 1.23e-1</td></tr><tr><td>double</td><td>8字节</td><td>双精度浮点型</td></tr><tr><td>char</td><td>1字节</td><td>与int类型可通用，printf(“%c\n”,c+32);—&gt;a</td></tr><tr><td>字符串</td><td>字符数+1</td><td>字符串结尾\0字符不显示，用于判断字符串结束，因此+1</td></tr></tbody></table></div><p><code>一个字节byte = 8 bit</code><br>-&gt; 1 byte = 0000 0000 </p><p><code>补充</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h1 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h1><div class="note blue [icon] modern"><p>printf函数的具体代码格式</p></div><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">带符号整数,-左对齐，不带右对齐(printf函数默认靠右对齐)</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">无符号十六进制数，用小写字母</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">无符号十六进制数，用大写字母</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点数；%5.2f显示5位数字，并带有2位小数的浮点数</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">一串字符，%10s代表占用10个字符位置</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号整数</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">一个指针</td></tr></tbody></table></div><h1 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><div class="table-container"><table><thead><tr><th style="text-align:left">数组初始化</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">（1）在定义数组时对数组元素赋初值。</td><td style="text-align:left">int a[10]={0,1,2,3,4,5,6,7,8,9};不能写成int a[10];a[10]={0,1,2,3,4,5,6,7,8,9}</td></tr><tr><td style="text-align:left">（2）可以只给一部分元素赋值</td><td style="text-align:left">int a[10]={0,1,2,3,4};</td></tr><tr><td style="text-align:left">（3）使一个数组中全部元素的值为 0，那么可以写为</td><td style="text-align:left">int a[10]={0,0,0,0,0,0,0,0,0,0};或int a[10]={0};</td></tr><tr><td style="text-align:left">（4）在对全部数组元素赋初值时，数据的个数，可以不指定数组的长度</td><td style="text-align:left">int a[]={1,2,3,4,5};</td></tr></tbody></table></div><ul><li>数组名a存的是数组的起始地址，数组名传递到子函数后，形参接收到的是数组起始地址</li><li>指针在64为计算机上是8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[k]; --&gt;<span class="comment">//有的编译器支持，但是有的编译器不支持，尽量还是不要这样使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外不能直接给指针赋值一个数组</span></span><br><span class="line"><span class="type">int</span> *data;</span><br><span class="line">data=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; --&gt; 错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *data</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">data=arr         --&gt; 正确</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，数组名是一个常量指针，它指向数组第一个元素，无法被修改</span></span><br><span class="line"><span class="comment">//如果要修改，需要定义一个指针变量</span></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">arr++;  --&gt;错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *data=arr;</span><br><span class="line">data++; --&gt;正确</span><br></pre></td></tr></table></figure></li></ul><h1 id="调试debug"><a href="#调试debug" class="headerlink" title="调试debug"></a>调试debug</h1><p><code>进入子函数</code></p><ul><li>按向下箭头进入子函数</li><li>按拐弯箭头越过子函数，只在当前函数一步一步走下去<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091733716.png" alt="image.png"></li></ul><p><code>查看变量内存视图</code></p><ul><li>点击内存视图</li><li>输入&amp;i，i为要查看内存视图的变量<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102154125.png" alt="image.png"></li></ul><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>指针在64位计算机上站8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* 在变量定义中的意思</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span>* pa = &amp;a; <span class="comment">//这里的*声明定义的p是指针,指向的是a的内存地址</span></span><br><span class="line"><span class="type">int</span> ** p = &amp;pa; <span class="comment">//二级指针，** 声明该指针是 指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 在变量赋值运算中的意思</span></span><br><span class="line">*pa == <span class="number">1</span>; <span class="comment">//这里*是取值得意思 pa的值</span></span><br><span class="line">*p == pa;</span><br><span class="line">**p == *pa == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针进行+运算</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061516769.png" alt="image.png"></li></ul><h1 id="struct结构体"><a href="#struct结构体" class="headerlink" title="struct结构体"></a>struct结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><hr><ul><li><p>方式1</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，每次结构体声明都要<code>struct student s；</code>指针声明<code>struct student *p*;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方式2</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，结构体声明方式直接<code>stu s；</code>结构体指针<code>pstu p;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span><span class="comment">//下面起了别名stu后student可以省略不写</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;stu,*pstu; <span class="comment">//stu结构体别名；*pstu结构体指针别名</span></span><br></pre></td></tr></table></figure></li><li><p>结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> val;</span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明单独结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">x</span>;</span></span><br><span class="line"><span class="comment">//声明结构体数组</span></span><br><span class="line">Stack st; <span class="comment">//最大容量MaxSize,无需手动分配空间，默认MaxSize</span></span><br><span class="line"><span class="comment">//声明结构体二维数组</span></span><br><span class="line">Stack b[<span class="number">10</span>]; <span class="comment">//声明一个名为b的结构体数组的数组，包含10个结构体数组</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="typedef的使用"><a href="#typedef的使用" class="headerlink" title="typedef的使用"></a>typedef的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Element;<span class="comment">//重命名int类型  Element i;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *p;<span class="comment">//重命名指针类型      p k;</span></span><br><span class="line">trpedef <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span><span class="comment">//如上，重命名结构体类型 stu s;</span></span><br></pre></td></tr></table></figure><h1 id="循环体循环判断"><a href="#循环体循环判断" class="headerlink" title="循环体循环判断"></a>循环体循环判断</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(a&lt;i);找到第i个结点</span><br><span class="line">while(a&lt;=i);找到第i+1个结点</span><br><span class="line">同理&gt;;&gt;=</span><br></pre></td></tr></table></figure><h1 id="二的次方"><a href="#二的次方" class="headerlink" title="二的次方"></a>二的次方</h1><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td><td>256</td><td>512</td><td>1024</td><td>2048</td><td>4096</td><td>8192</td><td>16384</td><td>32768</td><td>65536</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108759.jpg&quot; alt=&quot;大海 棕榈树 海滩沙滩 帆船 岛 插图风景 动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="https://fqzs.netlify.app/undefined/f134a8e5.html"/>
    <id>https://fqzs.netlify.app/undefined/f134a8e5.html</id>
    <published>2023-04-06T21:13:00.000Z</published>
    <updated>2023-06-10T16:27:50.581Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181116370.jpg" alt="唯美 梦幻 鲸鱼 女孩 Сè 日落 大海 动漫 高清 壁纸_彼岸壁纸.jpg"></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><ul><li>text    文字</li><li>color可选，背景顏色，默认为 default</li><li>default/blue/pink/red/purple/orange/green</li></ul><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="表格写法"><a href="#表格写法" class="headerlink" title="表格写法"></a>表格写法</h2><hr><blockquote><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">写法1</button></li><li class="tab"><button type="button" data-href="#test1-2">效果1</button></li><li class="tab"><button type="button" data-href="#test1-3">写法2</button></li><li class="tab"><button type="button" data-href="#test1-4">效果2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p></blockquote><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><hr><p>标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">语法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h1 id="分栏显示"><a href="#分栏显示" class="headerlink" title="分栏显示"></a>分栏显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab 栏目1--&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目2--&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目3--&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">栏目1</button></li><li class="tab"><button type="button" data-href="#test1-2">栏目2</button></li><li class="tab"><button type="button" data-href="#test1-3">栏目3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>这里是1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">语法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>color</td><td>顔色(default / blue / pink / red / purple / orange / green)</td></tr><tr><td>icon</td><td>可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td>可以覆盖配置中的 style（simple/modern/flat/disabled）</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="note blue [icon] modern"><p>效果展示</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="大量内容隐藏"><a href="#大量内容隐藏" class="headerlink" title="大量内容隐藏"></a>大量内容隐藏</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">写法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;  </span><br><span class="line">&lt;summary&gt;点击打开&lt;/summary&gt;  </span><br><span class="line">隐藏的内容  </span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><details>  <summary>显示的文字</summary>  隐藏的内容  </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181116370.jpg&quot; alt=&quot;唯美 梦幻 鲸鱼 女孩 Сè 日落 大海 动漫 高清 壁纸_彼岸壁纸.jpg&quot;</summary>
      
    
    
    
    
    <category term="markdown" scheme="https://fqzs.netlify.app/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://fqzs.netlify.app/undefined/79666db.html"/>
    <id>https://fqzs.netlify.app/undefined/79666db.html</id>
    <published>2023-04-06T18:10:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181106524.jpg" alt="崩坏 星穹铁道 女孩 相机 星空 高清壁纸_彼岸壁纸 (1).jpg"></p><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><hr><blockquote><p>概念：</p><ul><li>数据元素：一个数据体，考虑为一个人，一份订单…</li><li>数据项：数据体内的各项，人的信息项，订单的信息项…</li><li>数据对象：具有相同性质，数据元素的集合<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302328740.png" alt="image.png"></li><li>数据类型：是指一个值得集合，和定义在此集合上一组操作的总称<ul><li>原子类型：基本数据类型<br>  结构体运算：+ - * % …</li><li>结构类型：结构体(可以再分为若干分量)<br>  结构体运算—&gt;封装为函数</li><li>抽象数据类型：抽象数据组织及与之相关操作(描述了数据的<code>逻辑结构</code>和<code>抽象运算</code>)，可以用其定义一个完整的数据结构</li><li>数据结构：相互间存在一种或多种特定关系的数据元素的集合</li></ul></li></ul><p>数据结构三要素：</p><ul><li><code>逻辑结构</code><ul><li>线性结构</li><li>非线性结构(集合结构、树形结构、图状结构)</li></ul></li><li><code>存储结构</code><ul><li>链式存储：离散存放的</li><li>顺序存储：占用大片连续空间</li><li>索引存储</li><li>散列存储</li></ul></li><li><code>数据的运算</code>：比如，栈的抽象运算是<code>先进后出</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341139.png" alt="image.png"></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341254.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.数据的逻辑结构独立于其存储结构，逻辑结构是抽象表达方式，例如图的逻辑结构，采用顶点与边</span><br><span class="line">而图的存储结构采用二维数组(顺序存储)或链表结点(链式存储)</span><br><span class="line"></span><br><span class="line">2.存储数据时，不仅要存储数据的值，还要存储数据元素之间的关系(例如顺序表存储元素有下标，表示与其他数据元素的位置关系)</span><br><span class="line"></span><br><span class="line">3.对于两种不同的数据结构，他们的逻辑结构完全有可能相同，</span><br><span class="line"></span><br><span class="line">4.举例说明，对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同？</span><br><span class="line">线性表，可以顺序存储，可以链式存储，顺序存储方式，插入删除操作要平均移动一半元素，O(n)</span><br><span class="line">链式存储方式，插入删除时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">5.以下与数据存储结构无关的术语是：D</span><br><span class="line">  A 循环队列  B 链表  C 哈希表  D 栈 </span><br><span class="line">  解析：栈是一种抽象数据类型，可采用顺序存储，链式存储，只表示逻辑结构</span><br><span class="line"></span><br><span class="line">6.以下属于逻辑结构的是（c）。</span><br><span class="line">A.顺序表</span><br><span class="line">B.哈希表</span><br><span class="line">C.有序表</span><br><span class="line">·D.单链表</span><br><span class="line"></span><br><span class="line">顺序表体现数组存储方式，哈希表体现散列存储方式，单链表体现链式存方式，有序表体现有序的逻辑结构</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><blockquote><p>算法：求解问题的步骤<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304061942250.png" alt="image.png"><br>-算法特性：</p><ul><li>有穷性，有限步骤内完成，有穷时间内完成</li><li>确定性，意义明确，无歧义；给定相同的输入，输出结果确定唯一</li><li>可行性，可以通过基本运算执行有限次来实现</li><li>输入，0个或多个输入</li><li>输出，1个或多个输出</li></ul><p>好的算法具备特质：</p><ul><li>正确性，能正确实现目的</li><li>可读性，容易理解阅读</li><li>健壮性，可以灵活处理数据中的非法数据，给出反应进行处理</li><li>高效率地存储需求，花费时间少(时间复杂度低)，不费内存(空间复杂度低)</li></ul><p><mark class="hl-label blue">时间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th>a</th><th>结论</th></tr></thead><tbody><tr><td>1</td><td>顺序执行的代码只影响常数项</td></tr><tr><td>2</td><td>只需要挑去循环当中的某一个基本操作分析它的执行次数与n的关系</td></tr><tr><td>3</td><td>如果有多层嵌套循环，只需要关注最深层得循环执行了几次</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072136217.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072140867.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072141426.png" alt="image.png"></p><blockquote><p><mark class="hl-label blue">空间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">普通程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">只需关注存储空间大小与问题规模相关的变量</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">分析所占空间x与问题规模n的关系 x=f(n)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">递归程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">找到递归深度x与问题规模n的关系</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072151890.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072152388.png" alt="image.png"></p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">总结</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:center">数据类型同类型、有限、有序(先后顺序)</td></tr><tr><td style="text-align:center">位序</td><td style="text-align:center">线性表数据元素的位序从1开始(数组下标以0开始)</td></tr><tr><td style="text-align:center">基本操作</td><td style="text-align:center">创销、增删改查；判空、判长、打印输出</td></tr><tr><td style="text-align:center">注意</td><td style="text-align:center">函数名要有可读性、见名知意</td></tr><tr><td style="text-align:center">包括</td><td style="text-align:center">链表(链式存储)、顺序表(顺序存储)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072231315.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072232709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造方法框架：</span><br><span class="line">InitL1st(&amp;L）:初始化表。构造一个空的线性表。</span><br><span class="line">Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetE1em(L,i):按位查找操作。获取表L中第1个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e.</span><br><span class="line">ListDelete(&amp;L,i,&amp;e):别除操作，别除表L中第1个位置的元素，并用e返回别除元素的值。</span><br><span class="line">Pr1 ntList(L):输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L):判空操作。若L为空表，则返回true,否则返回false.</span><br><span class="line">DestroyList(&amp;L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><h1 id="线性表顺序存储"><a href="#线性表顺序存储" class="headerlink" title="线性表顺序存储"></a>线性表顺序存储</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表定义"><a href="#顺序表定义" class="headerlink" title="顺序表定义"></a>顺序表定义</h3><hr><blockquote><p>顺序表实现方式：<br><code>静态分配</code>：ElemType data[MaxSize]（存储空间不可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data [MaxSize];</span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; <span class="comment">//定义的是结构体的数据类型</span></span><br></pre></td></tr></table></figure><p><code>动态分配</code>：ElemType  * data （存储空间可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize10 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data ;</span><br><span class="line"><span class="type">int</span> Maxsize;<span class="comment">//记录最大容量</span></span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line"><span class="comment">//用ma11oc函数申请一片连续的存储空间</span></span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(Initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">L.MaxSize=Initsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Increasesize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="type">int</span> *p=L.data;</span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//申请另一块内存空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">L.data[i]=p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize=L.MaxSize+len;<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344408.png" alt="image.png"></p><p>顺序表特点</p><ul><li>随机访问：可以在O(1)时间内找到第i给元素</li><li>存储密度高，只能存储数据本身，不能存储指针信息</li><li>拓展容量不方便：每次拓展容量都需要开拓一个新的内存空间，并复制过去</li><li>插入删除元素不方便，需要移动大量的元素</li></ul></blockquote><h3 id="顺序表插入操作"><a href="#顺序表插入操作" class="headerlink" title="顺序表插入操作"></a>顺序表插入操作</h3><hr><blockquote><p>健壮性，异常处理：</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>方法要进行，判满，判断插入位置是否有效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList&amp;L <span class="type">int</span> i，<span class="type">int</span> e)</span>&#123;<span class="comment">//i插入位置，e要插入元素</span></span><br><span class="line"><span class="keyword">if</span>（i&lt;<span class="number">1ll</span>i&gt;L.length+<span class="number">1</span>） <span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">if</span>（L.length&gt;=MaxSize） <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">for</span>（intj=L.length;j&gt;=i；j--） <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>]；</span><br><span class="line">L.data[i<span class="number">-1</span>]=e； <span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++； <span class="comment">//长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>；</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：插入到表尾i=n+1，无需移动元素 <code>O(1)</code></li><li>最坏：插入到表头i=1，全部后移一位<code>O(n)</code></li><li>平均：假设新元素插入到任何一个位置的概率相同，即i=1,2,3,,length+1的概率都是p=1/n+1,i=1,循环n次：i=2时，循环n-1次：i=3,循环n-2次…i=n+1时，循环0次;平均循环次数=np+(n-1)p+(n-2)p+…+1p=n/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的删除操作"><a href="#顺序表的删除操作" class="headerlink" title="顺序表的删除操作"></a>顺序表的删除操作</h3><hr><blockquote><p>健壮性异常处理</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>判空、判断删除位置i是否有效</li><li>要加一个变量e(注意要&amp;e)，将被删除元素的值带回来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;<span class="comment">//引用，否则无法带回数据</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> i&gt;L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：删除表尾i=n，无需移动元素 <code>O(1)</code></li><li>最坏：删除表头i=1，全部前移一位<code>O(n)</code></li><li>平均：假设删除任何一个位置的概率相同，即i=1,2,3,,length的概率都是p=1/n,i=1,循环n-1次：i=2时，循环n-2次：i=3,循环n-3次…i=n时，循环0次;平均循环次数=(n-1)p+(n-2)p+(n-3)p+…+1p=n-1/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h3><hr><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SeqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(1)</code></p><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L,ElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;<span class="number">1</span>++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//数组下标为i的元素值等于e,返回其位i+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环，说明查找失败</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>最好：<code>O(1)</code> 查找元素在表头</li><li>最坏：<code>O(n)</code> 查找元素在表尾</li><li>平均：<code>O(n)</code>  循环n+1/2次</li></ul><h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li><li class="tab"><button type="button" data-href="#test1-10">10</button></li><li class="tab"><button type="button" data-href="#test1-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.从顺序表中别除具有最小值的元素（假设唯一）并由函数返回被别元素的值。空出的位</span></span><br><span class="line"><span class="comment">//置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_min</span><span class="params">(SqList T,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]&lt;T.data[min])&#123;</span><br><span class="line">min=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e=T.data[min];</span><br><span class="line">T.data[min]=T.data[length<span class="number">-1</span>];</span><br><span class="line">T.length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O（1）,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inverse</span><span class="params">(SqList T)</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp=T.data[i];</span><br><span class="line">T.data[i]=T.data[T.length-i];</span><br><span class="line">T.data[T.length-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.对长度为n的顺序表L,编写一个时间复杂度为O（n）、空间复杂度为O（1）的算法，该算</span></span><br><span class="line"><span class="comment">法别除线性表中所有值为x的数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void delet(Sqlist T,int pos)&#123;</span></span><br><span class="line"><span class="comment">if(T.length=0||pos&gt;T.length||pos&lt;0)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int i=pos;i&lt;=T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">T.data[i]=T.data[i+1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void delet_x(Sqlist T,int x)&#123;</span></span><br><span class="line"><span class="comment">int* arr;</span></span><br><span class="line"><span class="comment">int k=0;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">if(T.data[i]=x)&#123;</span></span><br><span class="line"><span class="comment">arr[k]=i;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(k;k&gt;=0;k--)&#123;</span></span><br><span class="line"><span class="comment">delet(T,arr[k]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//上述代码，不符合时间复杂度与空间复杂度要求</span></span><br><span class="line"><span class="comment">//解法1.正确思路：用k记录值不等于x的元素的个数，然后，将不等于x的值移到下标为x的位置，然后调整k位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]!=x)&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2，用k记录值等于x的元素个数，边扫描L边统计k,并将不等于x的元素前移k位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]==x)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.len=L.len-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.从顺序表中删除其值在给定值s与t之间(要求s&lt;t)的所有元素，若s或t不合理</span></span><br><span class="line"><span class="comment">或顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法1.用k记录不符合删除条件的元素个数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(T.data[i]&gt;s&amp;&amp;T.data[i]&lt;t))&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2.用k记录在s和t之间的元素个数，并边扫描，边统计k，将不在s和t之间的元素前移k位</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]&gt;s&amp;&amp;L.data[i]&lt;t)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.length-=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqTable</span>&#123;</span>  </span><br><span class="line">    <span class="type">int</span>* data;  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">&#125;Sqlist;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos+<span class="number">1</span>;i&lt;T.length;i++)&#123;  </span><br><span class="line">        T.data[i<span class="number">-1</span>]=T.data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    T.length--;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;T.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(j==T.length)&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(T.data[i]==T.data[j])&#123;  </span><br><span class="line">                delet(T,j);  </span><br><span class="line">                j--;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化思路，先排序，后遍历删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先排序</span></span><br><span class="line">    qsort(T.data, T.length, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; T.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T.data[i] != T.data[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            T.data[i] = T.data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序的时间复杂度为O(nlogn),遍历的时间复杂度为O(n),所以总时间复杂度为O(nlogn)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*6.将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表*/</span></span><br><span class="line"><span class="comment">//算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看</span></span><br><span class="line"><span class="comment">//哪个表还有剩余，将剩下的部分加到新的顺序表后面。</span></span><br><span class="line">Sqlist <span class="title function_">merge</span><span class="params">(Sqlist T1,Sqlist T2)</span>&#123;  </span><br><span class="line">    Sqlist T3;  </span><br><span class="line">    T3.data=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(T1.length+T2.length));  </span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length&amp;&amp;j&lt;T2.length)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(T1.data[i]&lt;=T2.data[j])&#123;  </span><br><span class="line">            T3.data[k]=T1.data[i];  </span><br><span class="line">            i++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            T3.data[k]=T2.data[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length)&#123;  </span><br><span class="line">        T3.data[k]=T1.data[i];  </span><br><span class="line">        k++;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(j&lt;T2.length)&#123;  </span><br><span class="line">        T3.data[k]=T2.data[j];  </span><br><span class="line">        k++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    T3.length=k;  </span><br><span class="line">    <span class="keyword">return</span> T3;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.[2010统考真题]设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间</span></span><br><span class="line"><span class="comment">两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置，即将R</span></span><br><span class="line"><span class="comment">中的数据由(X0,X1,…,Xn-1)变换为(XpXp+1,…,Xn-1,X0,X1,…,Xp-1).要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度和空间复杂度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">答：</span></span><br><span class="line"><span class="comment">1.可以将问题看做将数组ab转换成ba,可以先将a逆转置，再将b逆置，再将整体逆置，就得到ba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_singel</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> bengin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(begin,end;begin&lt;end;begin++,end--)&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=T.data[begin];</span><br><span class="line">T.data[begin]=T.data[end];</span><br><span class="line">T.data[end]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_all</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,p,n<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上算法中三个reserve_all的时间复杂度分别是O(p/2),O((n-p)/2),O(n/2);</span></span><br><span class="line"><span class="comment">//总时间复杂度是O(n),空间复杂度O(1)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8.线性表(a1,a2,a3,an)中元素递增有序且按顺序存储于计算机内。要求设计一算法完成用最少时间在表中查找数值为x的元素，若找到将其与后继元素位置相交换，若找不到将其插入表中并使表中元素仍递增有序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//算法思路：二分查找函数+交换函数+插入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(SSTable &amp;S,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=S.len)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=S.data[i];</span><br><span class="line">S.data[i]=S.data[i+<span class="number">1</span>];</span><br><span class="line">S.data[i+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">(SSTable &amp;S,<span class="type">int</span> x,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=S.len<span class="number">-1</span>;i&gt;=pos;i--)&#123;</span><br><span class="line">S.data[i+<span class="number">1</span>]=S.data[i];</span><br><span class="line">&#125;</span><br><span class="line">S.len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Binary_Search_insert</span><span class="params">(SSTable S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=S.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(S.data[mid]==x)&#123;</span><br><span class="line">Swap(S,mid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(S.data[mid]&lt;x)&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Insert(S,x,low);  <span class="comment">//没有查到，那么low所指向位置，就是插入位置,low一定是比x大的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050853124.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050947008.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051013253.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMissMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> *B;</span><br><span class="line">B=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//创建一个存放标记的数组</span></span><br><span class="line"><span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*n*);  <span class="comment">//赋值初始0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;=n)&#123;</span><br><span class="line">B[A[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线性表链式存储"><a href="#线性表链式存储" class="headerlink" title="线性表链式存储"></a>线性表链式存储</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><hr><ul><li>定义结构体</li><li>初始化</li><li>判空</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">不带头结点的链表</button></li><li class="tab"><button type="button" data-href="#test1-2">带头结点链表</button></li><li class="tab"><button type="button" data-href="#test1-3">区别</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=<span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点,同时为了防止脏数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L =<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123; <span class="comment">//内存不足，分配失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空的表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344241.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位插入不带头结点</button></li><li class="tab"><button type="button" data-href="#test1-2">按位插入带头结点</button></li><li class="tab"><button type="button" data-href="#test1-3">指定结点的前插操作O(n)</button></li><li class="tab"><button type="button" data-href="#test1-4">指定结点的前插操作O(1)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344545.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345110.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定结点，这种方式，先找到指定节点的前驱结点--&gt;遍历</span><br><span class="line">平均复杂度O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345224.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种方式，无需找到指定结点前驱结点，先插入到后面，然后交换data,等效为前插</span><br><span class="line">O(1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345353.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><hr><div class="note blue [icon] [style] flat"><p>这里就不讨论不带头结点的链表删除情况了</p></div><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位序删除</button></li><li class="tab"><button type="button" data-href="#test1-2">指定结点删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按位置删除，只能通过遍历找到第i-1个结点</span><br><span class="line">最坏，平均都是O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345569.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种指定节点删除方式，时间复杂度`O(1)`,但是极限情况，当p最后结点的时候</span><br><span class="line">就无法通过转移数据的方式完成删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345879.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h3><hr><h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><p><code>时间复杂度O(n)</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">优化前</button></li><li class="tab"><button type="button" data-href="#test1-2">优化后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Linklist p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li><code>无需再定义一个p指针用来遍历，直接用头结点L进行遍历，然后返回L，由于L没有用引用,最终并不会改变L</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">Linklist <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line"><span class="keyword">while</span> (L !=<span class="literal">NULL</span>&amp;&amp;L-&gt;data!=e)</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//找到后返回该结点指针，否则返回WULL</span></span><br></pre></td></tr></table></figure></p><h4 id="统计表长"><a href="#统计表长" class="headerlink" title="统计表长"></a>统计表长</h4><p><code>时间复杂度O(n)</code></p><h3 id="单链表建立"><a href="#单链表建立" class="headerlink" title="单链表建立"></a>单链表建立</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_head_insert</span><span class="params">(LNode* &amp;L)</span>&#123;  </span><br><span class="line">    L= (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//给L申请一个头结点结点空间  </span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;<span class="comment">//读取的第一个元素  </span></span><br><span class="line">    LinkList s;<span class="comment">//用来指向新节点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));<span class="comment">//给s申请一个新的空间  </span></span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//实现头插法，s成为第一个结点  </span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//L作为头结点，任然指向第一个结点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//读取x的值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>重要性质：头插法实现的链表数据是逆置的，用于链表的逆置</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346377.png" alt="image.png"></p><p><code>链表逆置：循环依次读取老链表数据，然后用头插法依次建立新链表/再次用头插法插入到之后，这样就是实现了链表逆置</code></p><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点 ,将L赋给s,r ,相当于s,r,L都是头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  <span class="comment">//将s赋给r,r重新指向尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了克服单链表无法直接通过一个结点访问其前驱</span><br><span class="line">提出了双链表</span><br><span class="line">双链表结点结构体，有两个指针，一个指向前驱，另一个指向后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表中结点类型的描述如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DNode</span><span class="params">(            <span class="comment">//定义双链表结点类型</span></span></span><br><span class="line"><span class="params">ElemType data;               <span class="comment">//数据域</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> DNode *prior,*next;   <span class="comment">//前驱和后继指针</span></span></span><br><span class="line"><span class="params">&#125;DNode,*DLinklist;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346859.png" alt="image.png"></p><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，</span><br><span class="line">循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</span><br><span class="line"></span><br><span class="line">循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执</span><br><span class="line">行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，因</span><br><span class="line">此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346340.png" alt="image.png"></p><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态链表借助数组，表示链式存储结构</span><br><span class="line">需要大片的连续的空间，删除或增加结点不需要移动其他元素</span><br><span class="line">结点有指针域(下一个结点的数组下标)，数据域(存储的数据)；</span><br><span class="line">静态链表以next=-1表示结束</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50           <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">ElemType data;               <span class="comment">//存储数据元素</span></span><br><span class="line"><span class="type">int</span> next;                    <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList [Maxsize];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346580.png" alt="image.png"></p><h2 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.静态链表中指针表示的是（C）。</span></span><br><span class="line"><span class="comment">A.下一元素的地址</span></span><br><span class="line"><span class="comment">B.内存储器地址</span></span><br><span class="line"><span class="comment">C.下一个元素在数组中的位置</span></span><br><span class="line"><span class="comment">D.左链或右链指向的元素的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：静态链表就是用数组(顺序存储)的链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用（C）</span></span><br><span class="line"><span class="comment">最节省时间。</span></span><br><span class="line"><span class="comment">A.不带头结点的单循环链表</span></span><br><span class="line"><span class="comment">B.双链表</span></span><br><span class="line"><span class="comment">C不带头结点且有尾指针的单循环链表</span></span><br><span class="line"><span class="comment">D.单链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.[2021统考真题]已知头指针h指向一个带头结点的非空单循环链表，结点结构为</span></span><br><span class="line"><span class="comment">【data next】</span></span><br><span class="line"><span class="comment">,其中next是指向直接后继结，点的指针，p是尾指针，q是临时指针。现要</span></span><br><span class="line"><span class="comment">删除该链表的第一个元素，正确的语句序列是（D）。</span></span><br><span class="line"><span class="comment">A.h-&gt;nextsh-&gt;next-&gt;next;q=h-&gt;next;free(q)</span></span><br><span class="line"><span class="comment">B.q=h-&gt;next;h-&gt;next=h-&gt;next-&gt;next;free(q);</span></span><br><span class="line"><span class="comment">C.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p!=q) p=h;free(q);.</span></span><br><span class="line"><span class="comment">D.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p==q) p=h;free(q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：如果删除的元素是尾结点，则需要判断是否是尾结点，是则将尾指针指向头结点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.[2009统考真题]已知一个带有表头结，点的单链表，结点结构为</span></span><br><span class="line"><span class="comment">data link</span></span><br><span class="line"><span class="comment">假设该链表只给出了头指针11st。在不改变链表的前提下，请设计一个尽可能高效的</span></span><br><span class="line"><span class="comment">算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结</span></span><br><span class="line"><span class="comment">点的data域的值，并返回l;否则，只返回0。要求：</span></span><br><span class="line"><span class="comment">1)描述算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)描述算法的详细实现步骤。</span></span><br><span class="line"><span class="comment">3)根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言</span></span><br><span class="line"><span class="comment">实现），关健之处请给出简要注释。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本思路：设置p、q两个指针，p指针先走当p指针走到底k的结点时，q开始移动，当p移动到尾部时，q停止</span></span><br><span class="line"><span class="comment">//此时q所指得结点就是倒数第k个结点</span></span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">search_k</span><span class="params">(LinkList L,<span class="type">int</span> k)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    LinkList p=L-&gt;next;  </span><br><span class="line">    LinkList q=L-&gt;next;<span class="comment">//p、q起点可以不是L-&gt;next,因为求得是倒数，只要倒数个数比起点更右端即可  </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            q=q-&gt;next;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> q;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.[2012统考真题]假定采用带头结点的单链表保存单词，当两个单词有相同的后缎时，</span></span><br><span class="line"><span class="comment">可共享相同的后缀存储空间；例如，loading和being的存储映像如下图所示。</span></span><br><span class="line"><span class="comment">   str1</span></span><br><span class="line"><span class="comment">  头结点1 -&gt; l -&gt; o -&gt; a -&gt; d ----&gt; i -&gt; n -&gt; g</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">   str2                            |</span></span><br><span class="line"><span class="comment">  头结点2 -&gt; b -&gt; e ----------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设str1和str2分别指向两个单词所在单链表的头结点，链表结，点结构为[data next]</span></span><br><span class="line"><span class="comment">请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀</span></span><br><span class="line"><span class="comment">的起始位置(如图中字符1所在结点的位置p)。要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解：因为是单链表无法，从后往前遍历，于是只能单向从前往后遍历，p 、q指针分别指向str1 str2的头结点，判断str1和str2的长度m、n.如果m&gt;n则p先走，使得p q到尾结点的距离一致。然后p、q共同移动直到遇到结点内容一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历两条链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出共同后缀起始地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_same_str</span><span class="params">(LinkList str1,LinkList str2)</span>&#123;</span><br><span class="line">m=Get_length(str1);</span><br><span class="line">n=Get_length(str2);</span><br><span class="line"><span class="keyword">for</span>(str1;m&gt;n;m--)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(str2;n&gt;m;n--)&#123;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(str1-&gt;next!=<span class="literal">NULL</span>&amp;&amp;str1-&gt;next!=str2-&gt;next)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度 m+n+(m-n)+2(n-x)=2m+2n-2x 所以时间复杂度为O(m+n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.将链表L&#123;a1,a2 a3 a4 a5...an-2 an-1an&#125;--&gt;L&#123;a1 an a2 an-1 a3...&#125;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resort</span><span class="params">(LinkNode *L)</span>&#123;</span><br><span class="line">LinkNode *k,kk=L;</span><br><span class="line">LinkNode *r,s;</span><br><span class="line"><span class="keyword">while</span>(kk-&gt;next)&#123;</span><br><span class="line">k=k-&gt;next;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(kk-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表后半段逆置</span></span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=k-&gt;next;</span><br><span class="line">k-&gt;next=kk;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">s=L-&gt;next;</span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=s-&gt;next;</span><br><span class="line">s-&gt;next=q;</span><br><span class="line">s=q-&gt;next;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><hr><p><code>定义</code>：一种只允许在一端进行插入或删除<code>的线性表</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">栈实现(顺序存储)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line">typeof <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;  <span class="comment">//栈针</span></span><br><span class="line">&#125;SqStack</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">S.top=<span class="number">-1</span>;  <span class="comment">//初始指向-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span>  <span class="title function_">isEmpty</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.data[++S.top]=x; <span class="comment">//先+，后赋值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x=S.data[S.top--]; <span class="comment">//先赋值，后-</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h2 id="栈在括号匹配中应用"><a href="#栈在括号匹配中应用" class="headerlink" title="栈在括号匹配中应用"></a>栈在括号匹配中应用</h2><hr><blockquote><p><code>括号匹配问题</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后出现的左括号，最先被匹配</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051432873.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051433730.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遇到左括号--&gt;入栈</span><br><span class="line">遇到右括号--&gt;出栈，并且匹配检查</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051434299.png" alt="image.png"></p><p><code>算法实现</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051439016.png" alt=""></p></blockquote><h2 id="栈在表达式求值应用"><a href="#栈在表达式求值应用" class="headerlink" title="栈在表达式求值应用"></a>栈在表达式求值应用</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051442887.png" alt="image.png"></p><blockquote><p><code>前缀、中缀、后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051522948.png" alt="image.png"></p><p><code>中缀转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051524252.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然两种后序表达式都是正确的，但是由于计算机运算遵循左优先原则，尽可能的先算左边运算符</span><br><span class="line">这样就保证运算顺序唯一</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051529561.png" alt="image.png"></p><p><code>用栈实现后缀表达式的计算</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从左往右依次扫描</span><br><span class="line">2.扫描到数字，则压入栈</span><br><span class="line">3.扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，继续1</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051548740.png" alt="image.png"></p><p><code>用栈实现中缀表达式转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051613746.png" alt="image.png"></p><p><code>用栈实现中缀表达式求值</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中缀转后缀+后缀计算</span><br><span class="line"></span><br><span class="line">1.扫描中缀表达式，从左往右</span><br><span class="line">2.扫描到数，入数栈；扫描到符号，入符号栈</span><br><span class="line">3.扫描到符号如果前面有优先级更高的，则要先弹出高优先级，再入栈当前符号，并弹出两个操作数</span><br><span class="line">  与弹出的符号运算，并将结果入回数栈顶部</span><br><span class="line">4.如果扫描到的符号前面没有优先级更高的，则无需操作，继续扫描</span><br><span class="line">5.遇到 ( 则 直接入栈，遇到 ) 依次弹出栈内运算符，并弹出相应数进行运算，直到弹出 ( 为止</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051619822.png" alt="image.png"></p></blockquote><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><hr><blockquote><p><code>递归工作栈</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051744820.png" alt="image.png"></p></blockquote><h2 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">3</button></li><li class="tab"><button type="button" data-href="#test1-5">4</button></li><li class="tab"><button type="button" data-href="#test1-6">5</button></li><li class="tab"><button type="button" data-href="#test1-7">6</button></li><li class="tab"><button type="button" data-href="#test1-8">7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051804701.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051939158.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本操作是指能直接实现的操作，ACD都属于基本操作，但是B栈不能直接删除栈底元素，需要一个一个移开上面元素，再删除，再放回之前的元素</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052010610.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052024207.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链栈,头指针为栈顶--&gt;才能实现先进后出</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3个不同元依次进栈，能得到（B)种不同的出栈序列。</span><br><span class="line">A.4</span><br><span class="line">B.5</span><br><span class="line">C.6</span><br><span class="line">D.7</span><br><span class="line"></span><br><span class="line">解析：卡特兰数，(6x5x4)/(3x2x1)/4=5</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052151736.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符可以字母，下划线开头，不可以数字开头</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">共享栈，可以节省存储空间，降低发生上溢的可能</span><br><span class="line"></span><br><span class="line">共享栈是一种两个栈共享同一片存储空间的数据结构。它的特点是两个栈的栈底在这片存储空间的两</span><br><span class="line">端，当元素入栈时，两个栈的栈顶指针相向而行。这样可以更有效地利用存储空间，只有在整个空间</span><br><span class="line">满时才会发生上溢</span><br><span class="line"></span><br><span class="line">共享栈栈满条件判断有两种：</span><br><span class="line">栈顶指针初始指向-1:</span><br><span class="line">栈顶指针初始指向0：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052212674.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052231925.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><hr><p><code>是只允许在一端进行插入，在另一端删除的线性表</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">队列(顺序存储)</button></li><li class="tab"><button type="button" data-href="#test1-2">队列(链式存储-带头结点)</button></li><li class="tab"><button type="button" data-href="#test1-3">队列(链式存储-不带头结点)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> rear,front;</span><br><span class="line">&#125;SqSueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//为空</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.data[Q.rear]=x;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize; </span><br><span class="line"><span class="comment">//取模，例如x%7,最终得到的值只能是0,1,2,3,4,5,6</span></span><br><span class="line"><span class="comment">//循环往复变化，采用取模方式的队列，被称为&quot;循环队列&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051245346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 队列中元素个数=(rear+MaxSize-front)%MaxSize</span><br><span class="line">- 队列中最多存储MaxSize-1个元素，留一个空位给rear用来(rear+1)%MaxSize判定</span><br><span class="line">  否则，全装满，rear=front,那么判空，判满无法区分</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种判断队列空满的方法，增加辅助变量，可以充分利用存储单元，可以装满</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051252761.png" alt="image.png"></p><p><code>回顾</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051257769.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051400428.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，带头结点                           </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;                </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">Q.front=Q.rear=L;                        </span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;                   </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)&#123;                         </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                                 </span><br><span class="line">&#125;                                           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;                               </span><br><span class="line">&#125;                                            </span><br><span class="line"></span><br><span class="line"><span class="comment">//无需判满，链表可以无限长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，带头结点                             </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;           </span><br><span class="line">LinkList s;                                  </span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">s-&gt;data=x;                                     </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;                                </span><br><span class="line">Q.rear-&gt;next=s;                              </span><br><span class="line">Q.rear=s;                                        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;  <span class="comment">//x将出队元素带出</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">LinkList p=Q.front-&gt;next;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)&#123;  <span class="comment">//如果是出队队尾元素，要考虑rear的变化</span></span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;                            </span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051416101.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//盘空，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">linkList s;</span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=x; </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.front-&gt;next=s;</span><br><span class="line">Q.rear=s;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Linklist p=Q.front;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p==Q.rear)&#123;  <span class="comment">//如果删除的最后一元素</span></span><br><span class="line">Q.rear=<span class="literal">NULL</span>:</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><blockquote><p><code>注意</code>：顺序存储，<code>rear</code>指向的是尾部元素的后一位；链式存储，<code>rear</code>指向的就是尾部元素</p></blockquote><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于判断输出序列的合法性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051419921.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051424490.png" alt="image.png"></p><h2 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061135804.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这题实质上问的需要多少个队列</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061155791.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061203327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迷宫求解，本质是岔路选择，遇到选择则入栈</span><br><span class="line"></span><br><span class="line">缓冲区，本质是一个队列，将信息，按原本顺序输出(先入先出)，作用是缓存信息(延长信息存在时间)，以防止计算机反应慢接收不到</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.一个问题的递归算法求解和其相对应的非递归算法求解，（B）。</span><br><span class="line">A.递归算法通常效率高一些 B.非递归算法通常效率高一些</span><br><span class="line">C.两者相同    D.无法比较</span><br><span class="line"></span><br><span class="line">解析：递归算法--&gt;代码简洁，容易理解，但是效率低，因为递归存在大量重复运算；非递归算法--&gt;代码繁琐，但是效率较高，没有多余运算</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">2.执行（B）操作时，需要使用队列作为辅助存储空间。</span><br><span class="line">A.查找散列（哈希）表 B 广度优先搜索图</span><br><span class="line">C．前序（根）遍历二叉树 D.深度优先搜索图</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">B：图的广度优先遍历：以广度为优先考虑，使用队列</span><br><span class="line">C：前中后序遍历二叉树，在递归方法中都隐含 递归栈。 那么非递归方法中必然是使用栈来进行这些  </span><br><span class="line">   相关操作的。</span><br><span class="line"></span><br><span class="line">3.下列说法中正确的是（A）。</span><br><span class="line">A.消除递归不一定需要使用栈</span><br><span class="line">B。对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同</span><br><span class="line">C.通常使用队列来处理函数或过程调用</span><br><span class="line">D.队列和栈都是运算受限的线性表，只允许在表的两端进行运算</span><br><span class="line"></span><br><span class="line">解析：A本来没必要使用递归的算法，使用递归，那么消除递归就不一定需要使用栈替代</span><br><span class="line"></span><br><span class="line">4.为解决计算包主机省打印机之间速度不匹配问题，通常设置一个打印数缓冲区，庄机将要输出的数据依次写入该缓冲，而打机则依次从该缓冲区中取出数据。该缓冲区的逻辑结应该是(A)</span><br><span class="line">A.栈</span><br><span class="line">B.队列</span><br><span class="line">C.树</span><br><span class="line">D.图</span><br><span class="line"></span><br><span class="line">5.某汽车轮渡口，过江渡船每次能载10辆车过江。过江车辆分为客车类和货车类，上渡船有如下规定：同类车先到先上船；客车先于货车上渡船，且每上4辆客车，才允许放上一辆货车；若等待客车不足4辆，则以货车代替；若无货车等待，允许客车都上船。试设计一个算法模拟渡口管理。</span><br><span class="line"></span><br><span class="line">“同类车先到先上船’一一队列。一个队列负责一种车。</span><br><span class="line">接下来是按照条件进行按顺序上车。</span><br><span class="line">每次上限是10，也就是4客车+1货车，4客车+1货车。</span><br><span class="line">最后两个条件，其实就是“没客车的话货车可以替代客车”和“没货车的话客车可以替代货车”。</span><br><span class="line">写两个函数，用于上客车和上货车，每一个内部再进行判断是否够用。</span><br><span class="line">经过上面的过程，整个算法的思路就明确下来了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061647514.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;        <span class="comment">//保存n</span></span><br><span class="line"><span class="type">double</span> val;   <span class="comment">//保存Pn的值</span></span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comculate</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">Stack a; <span class="comment">//结构体数组，最大限制100</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>,i;</span><br><span class="line"><span class="keyword">for</span>(i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">top++;</span><br><span class="line">a[top].n=i;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> fv1=<span class="number">1</span>,fv2=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">while</span>(top&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">a.[top].val=<span class="number">2</span>*x*fv2<span class="number">-2</span>*(a.[top].n)*fv1;</span><br><span class="line">fv1=fv2;</span><br><span class="line">fv2=a.[top].val;</span><br><span class="line">top--;     <span class="comment">//出栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> fv1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fv2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><hr><ul><li><code>分支结点</code>：有左孩子或右孩子或都有的结点</li><li><code>叶子结点</code>：没有左右孩子的结点</li><li><code>结点之间的路径</code>：结点与结点之间的边的数量，只能单方向从上往下</li><li><code>结点的层次(深度)</code>：从上往下数，<code>默认从1开始</code></li><li><code>结点的高度</code>：从下往上数</li><li><code>树的高度(深度)</code></li><li><code>结点的度</code>：结点有多少个分支</li><li><code>树的度</code>：各结点的度的最大值</li><li><code>森林</code>：m个(m&gt;=0)互不相交的树组成</li><li><code>前驱</code>：<code>遍历后的顺序</code>，当前节点的前一个节点为该节点的前驱节点</li><li><code>后继</code>：<code>遍历后的顺序</code>，当前节点的后一个节点为该节点的前驱节点</li></ul><h2 id="树的常考性质"><a href="#树的常考性质" class="headerlink" title="树的常考性质"></a>树的常考性质</h2><hr><ul><li>1.结点数=总度数+1<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336588.png" alt="image.png"></li></ul><ul><li>2.度为m的树第i层最多有<code>m^(i-1)</code>个结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336371.png" alt="image.png"></li></ul><ul><li>3.高度为h的m叉树最多有<code>(m^h - 1)/(m - 1)</code>个结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337980.png" alt="image.png"></li></ul><ul><li>4.具有n个结点的m叉树的最小高度为[logm(n(m-1)+1)]<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337731.png" alt="image.png"></li></ul><ul><li>5.具有n个结点的二叉树，总共有n+1个空链域</li></ul><h2 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h2><ul><li><code>满二叉树</code>：度全为2或0</li><li><p><code>完全二叉树</code>:最多只有一个度为1的结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338981.png" alt="image.png"></p></li><li><p><code>二叉排序树</code>：左子树上所有节点均小于根节点，右子树上均大于根节点</p></li><li><code>平衡二叉树</code>：树上任意结点的左子树和右子树的深度只差不超过1,能有更高的搜索效率<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338997.png" alt="image.png"></li></ul><h2 id="二叉树的常考性质"><a href="#二叉树的常考性质" class="headerlink" title="二叉树的常考性质"></a>二叉树的常考性质</h2><p><code>1.具有n个结点的完全二叉树的高度</code><br><code>向上取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338666.png" alt="image.png"></p><p><code>向下取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339299.png" alt="image.png"></p><p><code>2.完全二叉树，度为0、1、2的结点个数</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设度为0、1、2的结点个数分别为n0、n1、n2</span><br><span class="line">yw 是完全二叉树</span><br><span class="line">sy n0=0或1</span><br><span class="line">yw n0=n2+1</span><br><span class="line">sy n0+n2--&gt;奇数</span><br><span class="line">sy n0+n2+n0的奇偶性看n1</span><br><span class="line">sy 当n1=1时，结点数是偶数；当n1=0时，结点数为奇数</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul><li><code>顺序存储(指的是顺序表的结构实现)</code>：<ul><li><code>完全二叉树</code><ul><li>如果结点从1开始</li><li>i结点的左孩子：2i</li><li>i结点的右孩子：2i+1</li><li>i的父节点：i/2向下取整</li><li>i所在层次：参照3.4</li></ul></li><li><code>不完全二叉树</code><ul><li>判断是否有左右孩子就没有规律了</li><li>这样的顺序表的数组没被填满，造成存储空间浪费</li></ul></li><li><code>结论</code><ul><li>顺序存储只适合于存储完全二叉树</li></ul></li></ul></li><li><code>链式存储(链表结点实现)</code>：</li></ul><h2 id="课后习题-5"><a href="#课后习题-5" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1.树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是树的高度-1</span><br><span class="line"></span><br><span class="line">2.[2010统考真题]在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结</span><br><span class="line">点，1个度为2的结，点，10个度为1的结点，则树T的叶结点个数是（82）</span><br><span class="line"></span><br><span class="line">解析：结点总数=20x4+10x3+1x2+10x1+1=123;又因为结点总数=有度结点（20+10+1+10）+无度结点所以</span><br><span class="line">123-41=82;</span><br><span class="line"></span><br><span class="line">3.度为2的有序树不一定是二叉树，因为，二叉树的每个结点都有左右次序，若一个树有两个结点但是没有左右次序，那么就不算是二叉树</span><br><span class="line"></span><br><span class="line">4.重要--&gt;n个结点的完全二叉树的高度为(log2n) + 1  或log2(n+1)</span><br><span class="line"></span><br><span class="line">5.设二叉树有2n个结点，且m&lt;n,则不可能存在（）的结点。</span><br><span class="line">A.n个度为0</span><br><span class="line">B.2m个度为0</span><br><span class="line">C.2m个度为1</span><br><span class="line">D.2m个度为2</span><br><span class="line"></span><br><span class="line">解析：因为2n=n0 + n1 + 2n2，所以n1=2(n-n2)-1是奇数</span><br><span class="line"></span><br><span class="line">5.重要总结：高度为h的满二叉树的结点个数=2^h-1--&gt;类比，二进制位计算</span><br><span class="line"></span><br><span class="line">6.[2009统考真题]已知一棵完全二叉树的第6层(设根为第1层)有8个叶结，点，则该</span><br><span class="line">完全二叉树的结点个数最多是（）</span><br><span class="line">A.39</span><br><span class="line">B.52</span><br><span class="line">C.111</span><br><span class="line">D.119</span><br><span class="line"></span><br><span class="line">解析：第六层有8个叶子结点，说明树有可能6层有可能7层，最多就是7层的时候，计算得到111</span><br><span class="line"></span><br><span class="line">7.[2011统考真题]若一棵完全二叉树有768个结，点，则该二叉树中叶结点的个数是（）。</span><br><span class="line">A.257</span><br><span class="line">B.258</span><br><span class="line">C.384</span><br><span class="line">D.385</span><br><span class="line"></span><br><span class="line">解析：完全二叉树最后一个分支结点的序号是n/2，有小数舍去小数部分</span><br><span class="line"></span><br><span class="line">8.2018统考真题]设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结</span><br><span class="line">点都有2个子结点。若T有k个叶结点，则T的结点总数是（）。</span><br><span class="line">A.2k-1</span><br><span class="line">B.2k</span><br><span class="line">C.2^k</span><br><span class="line">D.2^k-1</span><br><span class="line"></span><br><span class="line">解析：A</span><br><span class="line"></span><br><span class="line">9.[2020统考真题]对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构</span><br><span class="line">保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存</span><br><span class="line">储单元数量至少是（）。</span><br><span class="line">A.31</span><br><span class="line">B.16</span><br><span class="line">C.15</span><br><span class="line">D.10</span><br><span class="line"></span><br><span class="line">解析：顺序存储，数组存放，又因为逻辑结构的二叉树高5层，却只有10个结点，说明没有放满</span><br><span class="line">想象成一颗5层的满二叉树 A</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序-深度优先遍历"><a href="#先序-深度优先遍历" class="headerlink" title="先序/深度优先遍历"></a>先序/深度优先遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339295.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339938.png" alt="image.png"></p><h2 id="递归遍历求树的深度"><a href="#递归遍历求树的深度" class="headerlink" title="递归遍历求树的深度"></a>递归遍历求树的深度</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339775.png" alt="image.png"></p><h2 id="层序-广度优先遍历-BFS"><a href="#层序-广度优先遍历-BFS" class="headerlink" title="层序/广度优先遍历(BFS)"></a>层序/广度优先遍历(BFS)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339790.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340204.png" alt="image.png"></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340268.png" alt="image.png"></p><h2 id="确定一颗二叉树"><a href="#确定一颗二叉树" class="headerlink" title="确定一颗二叉树"></a>确定一颗二叉树</h2><ul><li><code>如果只是给定一个二叉树的前\中\后\层序\遍历序列中的一种，那么是无法确定唯一的一颗二叉树的</code></li><li>至少要知道两种不同遍历的序列：<code>前+中</code>、<code>后+中</code>、<code>层序+中</code></li><li>基本思路都是通过<code>前\后\层序遍历</code>确定根节点，再通过<code>中序遍历</code>确定左右子树</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前序+中序</button></li><li class="tab"><button type="button" data-href="#test1-2">后序+中序</button></li><li class="tab"><button type="button" data-href="#test1-3">层序+中序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><code>前+中</code><br>前序遍历，可以确定序列<code>第一个是根节点</code><br>—&gt;然后再中序遍历中找到根节点位置，根节点左边就是<code>左子树</code>，右边就是<code>右子树</code><br>—&gt;接着，可以找出前序遍历中左子树的位置，和右子树的位置，分别看做新的独立二叉树<br>—&gt;找出左子树的根节点，和右子树的根结点，再分别在中序遍历中找出对应根结点位置<br>—&gt;重复直到确定一颗二叉树所有结点位置</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340641.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340184.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340293.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><hr><h2 id="线索二叉树定义"><a href="#线索二叉树定义" class="headerlink" title="线索二叉树定义"></a>线索二叉树定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尾部结点的左右指针，由指向NULL转变为指向前驱和后继</span><br><span class="line">这样有利于二叉树寻找前驱和后继</span><br><span class="line">疑问？那如果左右指针不是空的结点该如何指向自己的前驱后继呢？</span><br></pre></td></tr></table></figure><ul><li><code>注意</code>：这里讲的前驱，后继是指的是遍历后<code>序列</code>顺序的前后结点，不是二叉树结构上的前后关系<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341836.png" alt="image.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,<span class="title">rchild</span></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ltag</span>,<span class="title">rtag</span>;</span><span class="comment">//左右线索标记</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当线索标记为1时，左右指针才作为线索，指向前驱后继</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341247.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中序线索二叉树、后序线索二叉树、前序线索二叉树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341794.png" alt="image.png"></p><h2 id="线索二叉树的实现"><a href="#线索二叉树的实现" class="headerlink" title="线索二叉树的实现"></a>线索二叉树的实现</h2><ul><li>这里只举例<code>中序遍历线索化</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">本质就是二叉树的中序遍历</span><br><span class="line"></span><br><span class="line">只是在参数里多传递了一个前驱指针pre</span><br><span class="line"></span><br><span class="line">主要结构 左、根、右 --&gt;就是一个中序遍历结构</span><br><span class="line"></span><br><span class="line">pre指向的是p的前驱</span><br><span class="line">当遍历到最底层时，开始执行访问结点操作，也就是中间黄色代码操作</span><br><span class="line">如果p左节点为空，那么可以转为线索指向前驱pre,标记变为1</span><br><span class="line">接着如果pre的右结点有空位，也可以指向前驱p</span><br><span class="line">接着，pre后移为后继p</span><br><span class="line">p后移为后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree spre)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">InThread(p-&gt;<span class="number">1</span>child,pre); <span class="comment">//递归，线索化左子树</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)(  <span class="comment">//左子树为空，建立前驱线索</span></span></span><br><span class="line"><span class="params">p-&gt;lchild=pre;</span></span><br><span class="line"><span class="params">p-&gt;<span class="number">1</span>tag=<span class="number">1</span>:</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;<span class="number">6</span>pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">pre-&gt;rchild=p;           <span class="comment">//建立前驱结点的后继线索</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">pre=p;                                <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span></span><br><span class="line"><span class="params">InThread(p-&gt;rchild,pre); <span class="comment">//递归，线索化右子树</span></span></span><br><span class="line"><span class="params">&#125;<span class="comment">//if (p!=NULL)</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="type">void</span> CreateInThread(ThreadTree T)&#123;</span></span><br><span class="line"><span class="params">ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//pre传入的是NULL,因为递归遍历到最低部结点(序列第一个结点)，没有前驱</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//非空二叉树，线索化</span></span></span><br><span class="line"><span class="params">InThread(T,pre);</span></span><br><span class="line"><span class="params"><span class="comment">//线索化二叉树</span></span></span><br><span class="line"><span class="params">pre-&gt;rchild=<span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//处理遍历的最后一个结点</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304152226551.png" alt="image.png"></p><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只举例中序线索二叉树的遍历</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">p=p-&gt;lchi1d;<span class="comment">//最左下结点（不一定是叶结点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p的后继</span></span><br><span class="line">TreadNode *<span class="title function_">Nextnode</span><span class="params">(TreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Firstnode(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;right;<span class="comment">//rtsg==1直接返回线索</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综合上述两个方法，能够写出遍历中序线索二叉树的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(TreadNode *T)</span>&#123;</span><br><span class="line">TreadNode *p;</span><br><span class="line"><span class="keyword">for</span>(p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课后习题-6"><a href="#课后习题-6" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.引入线索二叉树的目的是（）</span><br><span class="line">A,加快查找结点的前驱或后继的速度</span><br><span class="line">B.为了能在二叉树中方便插入和删除</span><br><span class="line">C.为了能方便找到双亲</span><br><span class="line">D.使二叉树的遍历结果唯一</span><br><span class="line"></span><br><span class="line">解析：线索是结点的前驱和后继结点的指针，可以加快遍历</span><br><span class="line"></span><br><span class="line">2.线索二叉树是一种(C)结构。</span><br><span class="line">A.逻辑B.逻辑和存储C.物理D.线性</span><br><span class="line"></span><br><span class="line">解析：二叉树是一种逻辑结构。</span><br><span class="line">而线索二义树明确指明了在存储过程中的数据存放方式(指明了线索是标记为1的时候)，就是物理结构了。</span><br><span class="line">(物理结构=存储结构)</span><br><span class="line"></span><br><span class="line">3.n个结点的线索二叉树上含有的线索数为(B)</span><br><span class="line">A.2n</span><br><span class="line">B.n-1</span><br><span class="line">C.n+l</span><br><span class="line">D.n.</span><br><span class="line"></span><br><span class="line">解析：每个结点有两条链域指针，总共2n条，每个结点被一条指针指向，剩余的构成线索，2n-(n-1)</span><br><span class="line"></span><br><span class="line">4.二叉树在线索化后，仍不能有效求解的问题是（D）。</span><br><span class="line">A.先序线索二叉树中求先序后继</span><br><span class="line">B.中序线索二叉树中求中序后继</span><br><span class="line">C.中序线索二叉树中求中序前驱</span><br><span class="line">D.后序线索二叉树中求后序后继</span><br><span class="line"></span><br><span class="line">4.注意，前序、中序线索树的遍历不需要通过弹栈的方式来遍历后继结点，因为后继都可以通过线索来指向</span><br><span class="line">但是，后序线索二叉树的遍历必须通过弹栈的方式，返回上一层及的后继结点，如下图所示，结点3既没有左右孩子指针指向4结点，又没有后继线索指向4结点(左右子树占用了线索)</span><br><span class="line"></span><br><span class="line">所以，中序，前序线索二叉树不需要栈支持了，但是后序线索二叉树任然需要</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231343369.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5.[2011统考真题]一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1,</span><br><span class="line">该二叉树的中序遍历序列不会是（C）。</span><br><span class="line">A.1,2,3,4</span><br><span class="line">B.2,3,4,1</span><br><span class="line">C.3,2,4,1</span><br><span class="line">D.4,3,2,1</span><br><span class="line"></span><br><span class="line">解析：前后序遍历序列相反，说明每个结点只能有左孩子或只能有右孩子,不会同时存在两个子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.编写后序遍历二叉树的非递归算法</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路先将左子树遍历到底，再遍历右子树，最后根</span></span><br><span class="line"><span class="comment">//1.沿着根的左孩子，依次入栈，直到左孩子为空</span></span><br><span class="line"><span class="comment">//2.读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1;否则，栈顶元素出栈并访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack S; 指针访问标记r ; 当前指针p; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">push(S,p);</span><br><span class="line">p=p-&gt;lift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Getop(S,p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right&amp;&amp;p-&gt;right!=r)&#123; <span class="comment">//标记r,结点弹栈之后要防止原来的再入栈</span></span><br><span class="line">p=p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pop(S,p);</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">r=p;</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.试给出二叉树的自下而上、从右到左的层次遍历算法。</span><br><span class="line"></span><br><span class="line">解析：思路，按照层序遍历遍历，新增一个栈，用于存放出队列的结点，这样就能将原有序列取反，并在最后通过弹栈进行后续操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InvertLevel</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Queue Q;</span><br><span class="line">Init(Q);</span><br><span class="line">BiTree q;</span><br><span class="line">Q.EnQueue(T); <span class="comment">//入栈T</span></span><br><span class="line"><span class="keyword">while</span>(!iSEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line">Push(S,q);<span class="comment">//出队列，入栈</span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">Pop(S,p);</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.采用非递归算法，遍历一棵树并得到树的高度</span></span><br><span class="line"><span class="comment">//思路，采用层序遍历的方式，设置变量level记录当前层数。设置变量last,指向当前层的最后一个结点，当辅助队列的front=last时，就表示，当前层的结点遍历完了,那么level+1；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">BiNode data[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">level_order</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">int</span> level=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">Queue Q;</span><br><span class="line">InitQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(!T)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EnQueue(T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">BiTree p=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">EnQueue(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">EnQueue(Q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q.front=last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072029018.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">BiTree data[MaxSize];</span><br><span class="line"><span class="type">int</span> level[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Qu;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BiWide</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max i;</span><br><span class="line">Qu Q;</span><br><span class="line">Q.front=Q.rear=<span class="number">-1</span>;</span><br><span class="line">Q.rear++;   <span class="comment">//T入队</span></span><br><span class="line">Q.data[rear]=T</span><br><span class="line">Q.level[rear]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q.front&lt;Q.rear)&#123;</span><br><span class="line">Q.front++;  <span class="comment">//出队</span></span><br><span class="line">q=Q.data[front];</span><br><span class="line">k=Q.level[front];</span><br><span class="line"><span class="keyword">if</span>(q-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;left;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;right;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历level数组，看那个层次的个数最多</span></span><br><span class="line">max=<span class="number">0</span>;i=<span class="number">0</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear)&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear&amp;&amp;k==Q.level[i])&#123;  <span class="comment">//统计第k层的结点的个数</span></span><br><span class="line">i++;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">k=Q.level[i];</span><br><span class="line"><span class="keyword">if</span>(n&gt;max)&#123;</span><br><span class="line">max=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062342344.png" alt="image.png"></p><p>10.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设有一颗满二叉树，已知其先序序列为pre,设计一个算法求其后序序列post</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProToPost</span><span class="params">(Element pre[],<span class="type">int</span> l1,<span class="type">int</span> h1,Element post[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>)&#123;</span><br><span class="line"><span class="type">int</span> half;</span><br><span class="line"><span class="keyword">if</span>(l1&lt;=h1)&#123;</span><br><span class="line">post[h2]=pro[l1];</span><br><span class="line">half=(l1+h1)/<span class="number">2</span>;</span><br><span class="line">ProToPost(pre,l1+<span class="number">1</span>,l1+half,post,l2,l2+half<span class="number">-1</span>); <span class="comment">//转换左子树</span></span><br><span class="line">ProToPost(pre,l1+half+<span class="number">1</span>,h1,post,l2+half,h2<span class="number">-1</span>); <span class="comment">//转换右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072042893.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11.设一颗二叉树中各个结点的值不相同，其先序遍历和中序遍历的序列分别存放在数组A[1..n]和数组B[1..n]中，试编写一个算法建立该二叉树的二叉链表</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.现根据先序序列确定树的根节点</span></span><br><span class="line"><span class="comment">//2.在结合中序遍历，确定左子树右子树节点个数--&gt;划分左右子树--&gt;也就是划分数组中左右</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">BiTree <span class="title function_">BuildTree</span><span class="params">(ElemType A[],<span class="type">int</span> l1,<span class="type">int</span> h1,ElemType B[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>&#123;</span><br><span class="line"><span class="comment">//初始调用时，设l1,l2=1，h1,h2=n</span></span><br><span class="line">BiTree root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode))  <span class="comment">//建立根节点</span></span><br><span class="line">root-&gt;data=A[l1];                          <span class="comment">//将根节</span></span><br><span class="line"><span class="type">int</span> i=l2;</span><br><span class="line"><span class="keyword">while</span>(A[l1]!=B[i])&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">llen=i-l2;   <span class="comment">//左子树结点个数</span></span><br><span class="line">rlen=h2-i;  <span class="comment">//右子树结点个数</span></span><br><span class="line"><span class="keyword">if</span>(llen)&#123;   <span class="comment">//对左子树递归</span></span><br><span class="line">root-&gt;left=BuildTree(A,l1+<span class="number">1</span>,l1+llen,B,l2,l2+llen<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;     <span class="comment">//左子树为空</span></span><br><span class="line">root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rlen)&#123;</span><br><span class="line">root-&gt;right=BuildTree(A,h1-rlen+<span class="number">1</span>,h1,B,h2-rlen+<span class="number">1</span>,h2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071436493.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取层次遍历算法，将所有结点入队(包括空节点，当遍历遇到空节点时，如果是满二叉树，其后必定是全部为空，如果还有非空节点就不是完全二叉树)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsCompelet</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">init(Q);</span><br><span class="line">EnQueue(Q,T);</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line">EnQueue(q-&gt;left);</span><br><span class="line">EnQueue(q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">    q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line"><span class="keyword">return</span> fasle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071454344.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取任意一种遍历算法即可，这里采取最基本的中序遍历算法，对当前节点处理时，判断其是否存在左右孩子，并设置一个static变量用于统计具有双分支结点的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">InOrder(T-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>&amp;&amp;T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">InOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><h2 id="什么是森林？"><a href="#什么是森林？" class="headerlink" title="什么是森林？"></a>什么是森林？</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062345931.png" alt="image.png"></p><h2 id="树、森林转化为二叉树"><a href="#树、森林转化为二叉树" class="headerlink" title="树、森林转化为二叉树"></a>树、森林转化为二叉树</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先将树转化为二叉树</span><br><span class="line">将树转化为二叉树</span><br><span class="line">1.给兄弟加线</span><br><span class="line">2.将除长子外的与父节点的线去掉</span><br><span class="line">3.最后层次调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070951715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将森林转化为二叉树</span><br><span class="line">1.先将所有树先转化为二叉树</span><br><span class="line">2.将第一课树的根节点，将自己的子树森林转化为左子树，右子树指向下一棵树的根节点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071001666.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071002020.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树、森林、二叉树遍历序列等价问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071103398.png" alt="image.png"></p><h2 id="课后习题-7"><a href="#课后习题-7" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062357926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070943205.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071004393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071008954.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设树原始分支只有一条</span><br><span class="line">想象树每多一条分支，就会出现一个叶子结点，且多一组兄弟结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071021560.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.若森林F有15条边、25个结点，则F包含树的个数是</span><br><span class="line">A.8</span><br><span class="line">B.9</span><br><span class="line">C.10</span><br><span class="line">D.11</span><br><span class="line"></span><br><span class="line">解析：对于一棵树而言，除了根节点，其他每个结点都由一条边指向，也就是说，其他每个结点都对应一条边，所以，一棵树的结点数=边数+1</span><br><span class="line">所以，结点数-边数=25-15=10，所以有10棵树</span><br><span class="line"></span><br><span class="line">2.编程求以孩子兄弟表示法存储的森林的叶子结点数。</span><br><span class="line"></span><br><span class="line">解析：题目意思是，求在森林转化的二叉树中，找到原森林中叶子结点的个数</span><br><span class="line">找规律发现，森林中的叶子结点，在二叉树中都没有左子树，所以可以通过遍历二叉树，每次碰到结点判断一下该节点是否有左孩子，没有就num++</span><br><span class="line"></span><br><span class="line">3.在二叉树中有两个结点m和n,如果m是n的祖先，使用（C）可以找到从m到n的路径。</span><br><span class="line">A.先序遍历</span><br><span class="line">B.中序遍历</span><br><span class="line">C.后序遍历</span><br><span class="line">D.层次遍历</span><br><span class="line"></span><br><span class="line">解析：后序遍历是从后往前，在找到n之后，层层往上层父节点寻找，这个过程一定能找到m，并且父节点入栈顺序是按照从后往前的顺序。</span><br><span class="line">但是先序遍历，在找到n之后，因为在这之间先访问了父节点，所以这个父节点入栈顺序是从前往后，从一开始就要入栈的话，就无法保证找到n</span><br><span class="line">中序遍历一样抽象</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结点的带权路径长度：从树的根节点到该结点的路径长度(经过的边数)与该结点上值得乘积</span><br><span class="line">树的带权路径长度：树种所有叶子结点的带权路径之和(WPL,Weight Path Length)</span><br><span class="line">带权路径长度最小的二叉树被称为哈夫曼树，也称最优二叉树</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树是为了达到 使编码串变短的目的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>编码问题</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>S=AAABBACCCDEEA<br>T(S)=000000000001001000010010010011100100000</p><p><code>S中出现次数</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">为了使得编码变短，尽量将出现次数较多的编码缩短</span><br><span class="line">于是建立如下哈夫曼树</span><br><span class="line"></span><br><span class="line">1.将字符按出现次数从多到少排列</span><br><span class="line">2.从最少的两个次数相加组成 次数结点</span><br><span class="line">3.同样的过程完全建立一颗抽象的树状结构</span><br><span class="line">4.在树上左分支0,右分支1</span><br><span class="line">5.向右寻找一位,编码1，向左寻找一位编码0</span><br><span class="line">6.例如 B --&gt; 110</span><br><span class="line">7.A次数最多5--&gt;编码最短0  ；D次数最少1--&gt;编码最长1110</span><br><span class="line">8.达到了编码串缩短的目的</span><br><span class="line"></span><br><span class="line">如何解码呢？</span><br><span class="line">从左到右逐个扫描编码串字符，0向左走，1向右走，如果走到叶子结点（字符位置），就读取</span><br><span class="line">然后再次回到根节点，没有就继续扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707509.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707805.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.权值越大的字符，离根节点越近(权值看做字符的次数)</span><br><span class="line">2.哈夫曼树中，没有度为1的结点，这类树叫做&quot;正则二叉树&quot;(严格二叉树)</span><br><span class="line">3.哈夫曼树的带权路径长度最短(也称最优二叉树)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707715.png" alt="image.png"></p><h2 id="二叉树的估计"><a href="#二叉树的估计" class="headerlink" title="二叉树的估计"></a>二叉树的估计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右侧的分别是表示遍历后的顺序 黑色表示要删除的</span><br><span class="line">注意：前后结果相反，有两种情况，没有左(L)或没有右(R)都满足</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707899.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708586.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708670.png" alt="image.png"></p><h2 id="二叉存储表达式"><a href="#二叉存储表达式" class="headerlink" title="二叉存储表达式"></a>二叉存储表达式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据二叉存储表达式建立二叉树：3+4*5*(2+3)</span><br><span class="line">手工方法：1.加括号明确运算次序(3+((4*5)*(2+3)))</span><br><span class="line">         2.列出数字元素 3  4  5  2  3 作为叶子结点</span><br><span class="line">         3.按运算次序 用运算符作为分支节点 建立二叉树</span><br><span class="line">栈方法：不介绍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708561.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用树，来求表达式的值 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708601.png" alt="image.png"></p><h2 id="课后习题-8"><a href="#课后习题-8" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.前缀码是一种编码系统，通常是可变长度码，在其中的每个码字，都具备「前缀性质」(prefix property)，也就说，在编码中的每个码字，都不能被其他码字当成前置部位。例如，编码字&#123;9,55&#125;具备了前缀性质，但编码字&#123;9,5,59,55&#125;就不具备，因为其中的&quot;5”，是59&quot;及&quot;55&quot;的前缀</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目已对两个字符编码1和01，因为哈夫曼树只对叶子结点进行编码，所以1和01两个结点就是叶子结点，不能继续延伸。故只能往左下继续寻找，最终如图，注意要数的是叶子结点的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061929244.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树如果有n个叶子结点，那么总共有2n-1个结点</span><br><span class="line">因为n个叶子结点，经过n-1次整合，构建出n-1个非叶子结点，总共2n-1个结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061936631.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次整合需要m个，之后整合只需m-1个叶子结点，每次整合有一个非叶子结点，所以n-1/m-1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061956033.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1对于哈夫曼树的说法错误的是（D）</span><br><span class="line">A.对应一组权值构造出来的哈夫曼树一能不是唯一的</span><br><span class="line">B.哈夫曼树具有最小的带权路径长度</span><br><span class="line">C.哈夫曼树中没有度为1的结点</span><br><span class="line">D.哈夫曼树中除了度为1的结点外，还有度为2的结点和叶结点</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">A:确实不唯一。仅思考两个结点的情况：1和2，就有两种：1在左子树2在右子树和反过来。</span><br><span class="line">B:正确。正是我们使用哈夫曼树进行编码的意义所在。</span><br><span class="line">C:正确。任意非叶子结点都是由两个树（数据元素）构成的，因此不存在度为1的结点。</span><br><span class="line">D:解析同C,因此错误。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓定长编码集，就是所有字符编码位数都一样，0001 1100 1010 ..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062100296.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062127393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="课后习题-9"><a href="#课后习题-9" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.图中有关路径的定义是(A).</span><br><span class="line">A.由顶点和相邻顶点序偶构成的边所形成的序列</span><br><span class="line">B.由不同顶，点所形成的序列</span><br><span class="line">C.由不同边所形成的序列</span><br><span class="line">D.上述定义都不是</span><br><span class="line"></span><br><span class="line">解析：A路径是由顶点与相邻顶点序偶构成的边的序列 例如顶点A到顶点D的路劲 &lt;A B&gt; &lt;B C&gt; &lt;C D&gt; ; B路劲不是由顶点构成 ；C没有讲明是由相邻的边形成的序列</span><br><span class="line"></span><br><span class="line">2.[2017统考真题]已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶</span><br><span class="line">点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是（11）</span><br><span class="line"></span><br><span class="line">解析：无向图边数的2倍等于各顶点度数的总和。为求至少的顶点数，应使每个顶点的度取最大，由</span><br><span class="line">于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x,列出方程4×3+3×4+2x=16×2,</span><br><span class="line">解得x=4。因此至少包含4+4+3=11个顶点。</span><br><span class="line"></span><br><span class="line">3.图G是一个非连通无向图，共有28条边，该图至少有多少个项点？</span><br><span class="line"></span><br><span class="line">解析：由于图G是一个非连通无向图，在边数固定时，顶点数最少的情况是该图由两个连通子图构</span><br><span class="line">成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全</span><br><span class="line">图的边数为n(n-1)2=28,得n=8。所以该图至少有1+8=9个顶点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图的逻辑结构-王道"><a href="#图的逻辑结构-王道" class="headerlink" title="图的逻辑结构(王道)"></a>图的逻辑结构(王道)</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顶点与顶点的关系</span><br><span class="line">- 路径一一顶点v到顶点v之间的一条路径是指顶点序列</span><br><span class="line">- 回路一一第一个顶点和最后一个顶点相同的路径称为回路或环</span><br><span class="line">- 简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。</span><br><span class="line">- 简单回路一一除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</span><br><span class="line">- 路径长度一一路径上边的数目</span><br><span class="line">- 点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到的距离</span><br><span class="line">  若从u到v根本不存在路径，则记该距离为无穷(∞)。</span><br><span class="line">- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的</span><br><span class="line">- 有向图中，若从项点到项w和从项点w到项点之间都有路径，则称这两个项点是强连通的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162341036.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连通图、强连通图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162353758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部图的研究--子图</span><br><span class="line">- 子图：部分顶点，与部分边构成的较小的局部图</span><br><span class="line">- 生产子图：包含原图所有顶点的子图，不一定要所有边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162355746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连通分量--描述无向图</span><br><span class="line">- 包含尽可能多的顶点和边</span><br><span class="line">- 下面三个部分都是极大连通子图，属于单独的一个分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162357370.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">强连通分量--描述有向图</span><br><span class="line">同上</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305170000437.png" alt="image.png"></p><h2 id="图逻辑结构-天勤"><a href="#图逻辑结构-天勤" class="headerlink" title="图逻辑结构(天勤)"></a>图逻辑结构(天勤)</h2><ul><li>图由<code>顶点</code>和<code>边</code>构成</li><li><code>无向图</code>：边没有指向方向 (A1,A3)   没有指向 </li><li><code>有向图</code>：边有箭头方向    <A1,A3> 表示A1—&gt;A3 ,不能反过来</li><li><code>顶点的度</code>：多少条边与该顶点相连<ul><li>无向图：A1的度为3</li><li>有向图：A1入度为1，出度为2，度为3</li></ul></li><li><code>简单图</code>：不存在重复的边，并且没有指向自身的边</li><li><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302311509.png" alt="image.png"></p></li><li><p><code>无向完全图</code>：任意两个顶点之间，都存在边，总共<code>n(n-1)/2</code>条边</p></li><li><p>有向完全图：任意两个顶点之间，都存在两条方向相反的边，总共<code>n(n-1)</code>条边<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302312402.png" alt="image.png"></p></li><li><p>若边含有权值则称为网<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342083.png" alt="image.png"></p></li><li><p><code>路径</code>：一个顶点到相邻顶点序偶构成的<code>边</code>的序列,例如：（A1 A2）（A2 A3）（ A3 A6）</p></li><li><code>简单路径</code>：序列中顶点不重复出现的路径 例如：A1 A2 A3 A2 A4就不是简单路径，其中A2重复了</li><li><code>回路(环)</code>：第一个顶点和最后一个顶点相同，例如：A1 A4 A3 A1</li><li><p><code>简单回路</code>：除了第一个顶点和最后顶点，中间没有重复出现顶点</p></li><li><p><code>连通图</code>：针对<code>无向图</code>不一定要闭合，只要任意顶点间有路径即可<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342495.png" alt="image.png"></p></li><li><p><code>非连通图</code>：<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342005.png" alt="image.png"></p></li></ul><ul><li><code>强连通图</code>：针对有向图。如果有向图中的任意两个节点都可以互相到达，则该有向图是强连通的</li><li><code>弱连通图</code>：针对有向图。如果将有向图中的所有有向边都看作无向边，得到的无向图是连通的，则该有向图是弱连通的。</li><li><code>极大强连通子图（强连通分量）</code>：针对有向图</li><li><code>极小强连通子图</code>：针对有向图</li></ul><h2 id="极小连通子图与最小生成树"><a href="#极小连通子图与最小生成树" class="headerlink" title="极小连通子图与最小生成树"></a>极小连通子图与最小生成树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 极小连通子图是指一个无向图的子图，如果它是连通的，并且在保持子图连通的前提下，不能从子图中删除任何边，那么它就是极小连通子图。</span><br><span class="line"></span><br><span class="line">- 最小生成树是指一个连通无向图的生成树，它包含图中所有的顶点，并且边的权值之和最小。生成树是一种特殊的极小连通子图，它没有环，并且边数等于顶点数减1。如果一个极小连通子图是一个树，那么它也是原图的生成树。但是，并不是所有的极小连通子图都是树，也不是所有的极小连通子图都是最小生成树。</span><br></pre></td></tr></table></figure><h2 id="有向-无向图的连通问题"><a href="#有向-无向图的连通问题" class="headerlink" title="有向-无向图的连通问题"></a>有向-无向图的连通问题</h2><hr><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161023514.png" alt="image.png"></p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只讨论有向图强连通，弱连通就是无向图的情况，不再讨论</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161039922.png" alt="image.png"></p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><hr><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用一个二维数组，形成的一个矩阵表示顶点之间的关系</span><br><span class="line">这里演示的是带权的路径</span><br><span class="line">用行标、列标组合表示两个顶点之间路径</span><br><span class="line">按行列找到的数值就是路径权值，例如(1,0)=2,表示1--&gt;0的路径权值为2</span><br><span class="line">这里规定对角线上的值为无穷，也就是顶点到自身的路径为无穷(有的地方也规定为0)</span><br><span class="line"></span><br><span class="line">注意：当二位数组对称，说明是无向图，互相指向；当二维数组不对称，说明是有向图</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342024.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0行 X 3列</span><br><span class="line">只有0行与3列对应相乘都不为0时才有值</span><br><span class="line">结果=3，说明有3个点，与0和3都存在路径</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343697.png" alt="image.png"></p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只能表示出边，或只能表示入边</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于稀疏图，避免矩阵造成大量空间的浪费</span></span><br><span class="line"><span class="comment">//采用了顺序存储+链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;        <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode,AdjList[MaxSize]   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">AdjList vertice;       <span class="comment">//顶点数组指针(也可以说顶点数组)</span></span><br><span class="line"><span class="type">int</span> n,e                <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下图邻接表由两部分构成，左边的顶点数组(存着下标信息)+右边的边结点链表(1.数字是顶点下标，2.右侧是相接该顶点的另一条边的指针)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各个边在边组成链表中出现的先后顺序不是固定的，所以图邻接表的表示方式并不唯一，</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011638260.png" alt="image.png"></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">针对有向图</span><br><span class="line">只能用于存储有向图</span><br><span class="line">由于邻接表无法表示入边，与出边，所以改进为十字链表</span><br><span class="line">左结构体--&gt;顶点   右结构体--&gt;边</span><br><span class="line">in表示入边，out表示出边，由first引出第一条，由next引出下一条，01、14、20...表示边(有方向)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639953.png" alt="image.png"></p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">针对无向图</span><br><span class="line">左结构体--&gt;顶点  右结构体--&gt;边</span><br><span class="line">由于边是双向</span><br><span class="line">接下来有点抽象自己看^o^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639673.png" alt="image.png"></p><h4 id="课后习题-10"><a href="#课后习题-10" class="headerlink" title="课后习题"></a>课后习题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.邻接表可以用于存储无向图，，只是把每条边都视为两条方向相反的有向边，因此需要存储两次</span><br><span class="line"></span><br><span class="line">2.在有向图的邻接表存储结构中，顶，点v在边表中出现的次数是（C）。</span><br><span class="line">A顶点v的度</span><br><span class="line">B.顶点v的出度</span><br><span class="line">C:顶点v的入度</span><br><span class="line">D.依附于顶，点v的边数</span><br><span class="line"></span><br><span class="line">3.n个顶点的无向图的邻接表最多有(B)个边表结点。</span><br><span class="line">A.n2</span><br><span class="line">B.n(n-1)</span><br><span class="line">C.n(n+1)·</span><br><span class="line">D.n(n-1)/2</span><br><span class="line"></span><br><span class="line">解析：n个顶点的无向图最多有(n-1)/2条边，每条边在邻接表中存储两次，所以边表结点最多为</span><br><span class="line">n(n-l)个。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.带权有向图G用邻接矩阵存储，则的入度等于邻接矩阵中(D).</span><br><span class="line">A.第i行非∞的元素个数</span><br><span class="line">B.第i列非∞的元素个数：</span><br><span class="line">C.第i行非∞且非0的元素个数</span><br><span class="line">D.第i列非∞且非0的元素个数</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.写出从图的邻接表表示转换成邻接矩阵表示的算法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思路：通过普通的遍历，依次序的遍历所有的顶点，并修改邻接矩阵的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert</span><span class="params">(AlGraph *G,<span class="type">int</span> [M][N])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ArcNode *p = G-&gt;v[i].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="type">int</span>[i][p-&gt;adjv]=<span class="number">1</span>;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152205562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点的连通图，最多有n(n-1)/2条边--&gt;每个顶点与其他n-1个顶点相连，最后每条边重复考虑了一次。</span><br><span class="line">所以28条边的连通图最少有8个顶点，要是非连通图则+1顶点 与其他顶点隔离 --&gt;8+1=9</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152210169.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点，组成连通无向图，边最少n-1，因为 形成单链</span><br><span class="line">组成强连通有向图，边最少n ，因为形成有向环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152218916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无向图将所有顶点的度相加=边数x2 ，因为每条边会多重复算一次，利用这个特性，求出度为2的点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152229507.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向图,求每个顶点最大的度--&gt;每个顶点最多与n-1个顶点相连--&gt;出边+入边--&gt;(n-1)*2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152235585.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152256350.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环任意去除一条边都是一颗生成树--&gt;共有n条边--&gt;有n条生成树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152313137.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在树中，每个顶点都有一条边指向，除了根节点，所以n-e=根结点数目</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152317313.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这道题比较难</span><br><span class="line">保证形成连通图的最少变数，7个顶点，前6个保证连通边数达到最大无法再增多，再多加1条连接剩下的顶点，7个就保证连通了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152329630.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无向图双向的，所以邻接矩阵沿对角线一定对称；由于这个矩阵不对成所以一定是有向图</span><br><span class="line">第i个顶点的度=矩阵中i行i列的1之和</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152347902.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Edge --&gt; E 边</span><br><span class="line">Vertex --&gt; V 顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161019171.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28条边用最少顶点充分利用n(n-1)=26--&gt;8个顶点--&gt;再额外+1孤立顶点--&gt;实现非连通--&gt;最少9顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161042675.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所有1集中在对角线往上</span><br><span class="line">- i&lt;j</span><br><span class="line">- i到j有边</span><br><span class="line"></span><br><span class="line">运用拓扑排序方式，对顶点号依次编号</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161111107.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161116342.png" alt="image.png"></p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历犯法</span><br><span class="line"></span><br><span class="line">为了防止出现图遍历的时候的死循环问题需要，将遍历过得结点进行标记，防止再次遍历</span><br><span class="line">于是</span><br><span class="line">1.设置一个与顶点数组相对应的标记数组(设为全局变量)，数组初始=0；</span><br><span class="line">2.遍历过后标记为1，visit[v]=1;</span><br><span class="line">3.然后ArcNode*q=G-&gt;adjList [v].first 找到第一条与该顶点相连的边</span><br><span class="line">4.找到第二条与该顶点相连的边，访问下一个顶点(往深处找)，先判断是否访问过</span><br><span class="line">5.如果没有访问过进行递归</span><br><span class="line">6.如果访问过就找与之相连的下一条边，直到与该顶点相连的边遍历完</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjV;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边(兄弟边)的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;        <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode,AdjList[MaxSize]   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">AdjList vertice;       <span class="comment">//顶点数组指针(也可以说顶点数组)</span></span><br><span class="line"><span class="type">int</span> n,e                <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639135.png" alt="image.png"></p><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历</span><br><span class="line">要点：</span><br><span class="line">1.找到与一个顶点相邻的所有顶点</span><br><span class="line">2.标记哪些顶点被访问过</span><br><span class="line">3.需要一个辅助队列，这里采用循环队列</span><br><span class="line"></span><br><span class="line">采用循环的队列作为辅助队列</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedeof <span class="type">int</span> maxSize</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G,<span class="type">int</span> v,<span class="type">int</span> visited[maxSize])</span>&#123;</span><br><span class="line">ArcNode *p;</span><br><span class="line"><span class="type">int</span> que[maxSize],front=<span class="number">0</span>,rear=<span class="number">0</span>;  <span class="comment">//辅助队列</span></span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">visit(v);                         <span class="comment">//访问出队顶点；</span></span><br><span class="line">vistted[v]=<span class="number">1</span>;</span><br><span class="line">rear = (rear+<span class="number">1</span>)%maxSize;  </span><br><span class="line">que[rear]=v;                      <span class="comment">//顶点入队,入队的其实是位置下标</span></span><br><span class="line"><span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">front = (front+<span class="number">1</span>)%maxSize;     <span class="comment">//出队一个顶点，赋值给j</span></span><br><span class="line">j=que[front];</span><br><span class="line">p=G-&gt;AdjList[j].first;         <span class="comment">//找到与这个顶点出去的边</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[p-&gt;adjV]==<span class="number">0</span>)&#123;   <span class="comment">//判断是否访问过</span></span><br><span class="line">visit(p-&gt;adjV);</span><br><span class="line">visited[p-&gt;adjV]==<span class="number">1</span>;</span><br><span class="line">rear=(rear+<span class="number">1</span>)%maxSize; </span><br><span class="line">que[rear]=p-&gt;adjV      <span class="comment">//入队</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;               <span class="comment">//寻找下一条边(找与之相连的下一个)</span></span><br><span class="line">&#125;                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640748.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640524.png" alt="image.png"></p><h2 id="最小生成树-Prim算法"><a href="#最小生成树-Prim算法" class="headerlink" title="最小生成树(Prim算法)"></a>最小生成树(Prim算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成树：由一个图按照某一种规则，导出里面包含的一颗树(就是由图所有顶点，与部分边，构成的一颗树，就是极小连通子图)</span><br><span class="line"></span><br><span class="line">最小生成树：构成的这颗生成树的所有分支的权值和最小(所以讨论的是带权图)</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.先确定一个根节点A0</span><br><span class="line">2.找到与根节点相邻的所有的边，选择权值最小的并入树中(如果产生环，则选择第二小的)，此时A0  A1两个结点</span><br><span class="line">3.继续，找到与A0 A1相邻的所有的边，3,2,7,8 --&gt;将权值为2的边并入树，此时结点A0 A1 A2</span><br><span class="line">4.重复...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640486.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641608.png" alt="image.png"></p><h2 id="最小生成树-Kruskal算法"><a href="#最小生成树-Kruskal算法" class="headerlink" title="最小生成树(Kruskal算法)"></a>最小生成树(Kruskal算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大致思想是</span><br><span class="line">1.将每条边都列举出来，按照权值从小到大排列</span><br><span class="line">2.从最小的边开始，如果边两边的顶点并未&quot;连通&quot;，则连通这条边</span><br><span class="line">3.如果两边顶点处于同一个&quot;并查集&quot;，即连通，则遍历下一条边</span><br><span class="line">4.直到所有顶点处于同一个&quot;并查集&quot;中，即生成了最小生产树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641841.png" alt="image.png"></p><h2 id="最短路径-DIjkstra"><a href="#最短路径-DIjkstra" class="headerlink" title="最短路径(DIjkstra)"></a>最短路径(DIjkstra)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">求某一个顶点(确定某一点)到其余各顶点之间的最短路径</span><br><span class="line"></span><br><span class="line">设置3个数组</span><br><span class="line">dist[] --&gt;树中，min[从起点经过新增顶点与上述顶点间的距离,原本直接距离] ，初始=无穷</span><br><span class="line">path[] --&gt; 表示，上述顶点的起始顶点 ,初始=-1</span><br><span class="line">set[] --&gt; 0表示未并入树中，1表示已在树中 ，初始=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641565.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新 ，&#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新，&#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><h2 id="最短路径-Floyd"><a href="#最短路径-Floyd" class="headerlink" title="最短路径(Floyd)"></a>最短路径(Floyd)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">求带权图中各顶点之间的最短路劲</span><br><span class="line"></span><br><span class="line">A矩阵：记录顶点到顶点的距离(一开始无中转点，无路径则为∞)</span><br><span class="line">path矩阵：记录顶点到顶点之间中转点(一开始无设为-1)</span><br><span class="line"></span><br><span class="line">接下来依次将中转点由V0~Vn遍历</span><br><span class="line">确定每一个中转点后，又在A距离矩阵遍历，比较加入中转点后与原距离的大小</span><br><span class="line">比如A(-1)[2][1] &gt; A(-1)[2][0] + A(-1)[0][1] 表示将0作为中转点，V2到V1的距离缩短了 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161335255.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三层循环，时间复杂度O(V^3)；空间复杂度O(V^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161351010.png" alt="image.png"></p><h2 id="最短路劲总结"><a href="#最短路劲总结" class="headerlink" title="最短路劲总结"></a>最短路劲总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161410881.png" alt="image.png"></p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不存在环路的有向图，也称DAG图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642453.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式，将重复部分，只保留一个(可以节省空间)，由两个指针指向同一个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642293.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642866.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式的构建</span><br><span class="line">1.将出现的元素罗列出来</span><br><span class="line">2.按照运算次序，按顺序加入运算符结点，并且将运算符号分层</span><br><span class="line">3.最后从最底层检查是否有重复部分，并合并</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643679.png" alt="image.png"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列是有向无环图（DAG）中所有顶点的一种线性排序，使得对于每一条有向边 &lt;u, v&gt;，顶点 u 在拓扑序列中都排在顶点 v 的前面。换句话说，拓扑序列可以看作是一个 DAG 中所有顶点的一种合法排序方式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AOV网</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643547.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例，下列拓扑排序总共有5种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序，实现的是，将AOV网中依次的输出具有传递性的活动(顶点),找到做事的先后顺序</span><br><span class="line"></span><br><span class="line">AOV网允许有多个入度为0的顶点活动</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.找到入度为0的顶点，先输出</span><br><span class="line">2.删除顶点，与顶点有关的边（出边，也就是将由该顶点指向的所有顶点入度-1）</span><br><span class="line">3.重复1 2 直到为空</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码实现需要定义两个数组，一个栈</span><br><span class="line">indegree[] 记录当前所有顶点的入度</span><br><span class="line">print[] 记录拓扑排好的的顶点序列</span><br><span class="line">Stack S 保存度为0的顶点(也可以用队列代替)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TopoSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化栈</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.n;i++)&#123; <span class="comment">//遍历找出所有入度为0的顶点</span></span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">push(S,i);      <span class="comment">//将入度为0的顶点进栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数目</span></span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Pop(S); <span class="comment">//栈顶元素出栈</span></span><br><span class="line">print[count]=i;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].first;p!=<span class="literal">NULL</span>;p=p-&gt;next)&#123;<span class="comment">//将所有由i指向的顶点入度-1</span></span><br><span class="line"><span class="type">int</span> v=p-&gt;adjV;</span><br><span class="line"><span class="keyword">if</span>(!(--indegree[v]))&#123;</span><br><span class="line">push(S,v); <span class="comment">//入度为0，入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//说明有回路，排序失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该算法。每一个顶点要被处理一次，每一条边也要遍历一次，所以时间复杂度O(|V|+|E|) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643741.png" alt="image.png"></p><h2 id="DFS实现逆拓扑排序"><a href="#DFS实现逆拓扑排序" class="headerlink" title="DFS实现逆拓扑排序"></a>DFS实现逆拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里和深度优先遍历几乎一样</span><br><span class="line">只是将Visit(v)放到最后</span><br><span class="line">实现了，只有递归结束之后访问本节点(在这之前已经先访问了递归里面的结点，也就是深处结点)</span><br><span class="line">这样就实现了逆拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643774.png" alt="image.png"></p><h2 id="DFS算法实现拓扑排序"><a href="#DFS算法实现拓扑排序" class="headerlink" title="DFS算法实现拓扑排序"></a>DFS算法实现拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1)假设结点u是结点v的祖先，则在调用DFS访问u的过程中，必然会在这个过程结束之</span><br><span class="line">前递归地对y调用DFS访问，即v的DFS函数结束时间先于u的DFS结束时间。从而</span><br><span class="line">可以考虑在DFS调用过程中设定一个时间标记，在DFS调用结束时，对各结点计时。因</span><br><span class="line">此，祖先的结束时间必然大于子孙的结束时间。</span><br><span class="line"></span><br><span class="line">2)若u是结点v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。</span><br><span class="line">3)若u和v没有关系，则u和v在拓扑序列的关系任意。</span><br><span class="line">从而按结束时间从大到小，可以得到一个拓扑序列。</span><br><span class="line"></span><br><span class="line">实际上和深度优先遍历算法完全相同，只不过加入了变量time</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> v,ALGraph *G,<span class="type">int</span> time,<span class="type">int</span> Time[])</span>&#123;</span><br><span class="line">vistit[v]=<span class="number">1</span>;</span><br><span class="line">ArcNOde *p=G-&gt;AdjList[v].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[q-&gt;AdjV]==<span class="number">0</span>)&#123;</span><br><span class="line">DFS(q-&gt;AdjV,G);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">time++;</span><br><span class="line">Time[v]=time;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后再按照time从多到少的顺序，输出，就得到了拓扑排序结果</span></span><br></pre></td></tr></table></figure><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图中所有路径长度=总工期的路径 ，都是关键路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOE网，边表示活动，顶点表示事件</span><br><span class="line"></span><br><span class="line">1.只有顶点事件发生后，各条边活动才能开始</span><br><span class="line">2.顶点的所有入边活动都结束时，顶点事件才能发生</span><br><span class="line">3.有些活动是能并行进行的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOE网只有1个入度为0的顶点，开始顶点(源点)，他表示整个工程的开始</span><br><span class="line">也只有1个出度为0的顶点，结束顶点(汇点)，他表示整个工程的结束</span><br><span class="line"></span><br><span class="line">从源点到汇点的所有路径中，具有最大路径长度(总权值)的路径称为关键路径，关键路径上的活动称为，关键活动</span><br><span class="line"></span><br><span class="line">在这里关键路径的总长度就是整个工程完成所需最短时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644443.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vk--&gt;顶点(事件)  ai--&gt;活动(边)</span><br><span class="line"></span><br><span class="line">1.事件vk的最早完成时间ve(k)</span><br><span class="line">2.事件vk的最晚完成时间vl(k)</span><br><span class="line">3.边ai的最早完成时间e(i)</span><br><span class="line">4.边ai的最晚完成时间l(i)</span><br><span class="line"></span><br><span class="line">规定将发生时间最长的路线定为汇点的 最晚发生时间=最早发生时间(如果不规定一下最晚发生时间，那么没有意义，因为，前面的事件可以一直拖下去永远不执行)</span><br><span class="line"></span><br><span class="line">可以通过逆拓扑排序先从后往前的倒推每个事件的最迟发生时间(由汇点来反推)</span><br><span class="line"></span><br><span class="line">关键活动是，活动最迟发生时间=活动最早发生时间 的活动</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644666.png" alt="image.png"></p><h2 id="课后习题1"><a href="#课后习题1" class="headerlink" title="课后习题1"></a>课后习题1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.以下叙述中，正确的是（A）。</span><br><span class="line">A.只要无向连通图中没有权值相同的边，则其最小生成树唯一</span><br><span class="line">B.只要无向图中有权值相同的边，则其最小生成树一定不唯一</span><br><span class="line">C.从n个顶，点的连通图中选取n-1条权值最小的边，即可构成最小生成树</span><br><span class="line">D.设连通图G含有n个顶点，则含有n个顶点、n-1条边的子图一定是G的生成树</span><br><span class="line"></span><br><span class="line">解析：选项A最小生成树的算法是基于贪心策略的，每次从事选取权值最小的，且满足条件的边，如果各边权值不同，则每次选择的新的顶点也是唯一的，因此最小生成树是唯一的</span><br><span class="line">选项B,若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。选项C,选取的一1条边可</span><br><span class="line">能构成回路。选项D,含有n个顶点、n-1条边的子图可能构成回路，也可能不连通。</span><br><span class="line"></span><br><span class="line">2.最短路径一定是简单路劲</span><br><span class="line"></span><br><span class="line">3.下面的（A）方法可以判断出一个有向图是否有环（回路）。</span><br><span class="line">I.深度优先遍历Ⅱ.拓扑排序Ⅱ.求最短路径V.求关键路径</span><br><span class="line">A.I、Ⅱ、IV</span><br><span class="line">B.I、II、V,</span><br><span class="line">C.:I、IⅡ、IⅢ</span><br><span class="line">D.全部可以</span><br><span class="line"></span><br><span class="line">解析：深度优先遍历，深度优先遍历是逐层遍历的,通过栈等数据结构可以记录已经访问过的顶点。一旦发现重复顶点,立即结束遍历,返回最终结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最小生成树不唯一的话，得到的最小生成树就可能相同也可能不同</span><br><span class="line">但是如果最小生成树唯一，那不同算法得到的就一定相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161206652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基础</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161210191.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先画出图</span><br><span class="line">2.根据图直接判断，因为是选择题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161413553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序结束条件时找到直至为空，如果有环，则无法找到拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161418914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161426088.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不能排成拓扑序列，说明有环，那么D正确</span><br><span class="line">强连通分量--&gt;就是顶点之间可以相互抵达，那么就是存在闭环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161444715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下列拓扑排序总共5种，理解什么是拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵 顶点指向方向 i-&gt;j 行-&gt;列  </span><br><span class="line">如果上三角矩阵：那么必定 编号小指向编号大</span><br><span class="line">如果下三角矩阵：那么必定 编号大指向编号小的</span><br><span class="line"></span><br><span class="line">而拓扑排序，必定是小编号指向大编号，那么体现在邻接矩阵就是上三角矩阵</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161456601.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图拓扑序列唯一 但是图却不止一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161503337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">关键路径手算</span><br><span class="line">1.画出图</span><br><span class="line">2.画表格，最早开始时间 ；最晚开始时间</span><br><span class="line">3.从前往后依次计算各个顶点最早开始时间(就是等顶点之前所有顶点完成的时间)</span><br><span class="line">4.之后再从后往前，求各个顶点的最晚开始时间(应该满足不影响工期，就是最后一个顶点的最早开始时间 21)</span><br><span class="line">5.找出最早、最晚开始时间相等的点组成关键路径</span><br><span class="line"></span><br><span class="line">关键路径的长度必然=整个工程完成的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161515079.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I ：加入只有一个路径，那么关键路径就是自己，怎么变都是一条关键路径</span><br><span class="line">II ：关键路径就是整个工程时间，没问题</span><br><span class="line">III：如果有多条关键路径，降低某一条不影响其他条</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161608871.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS深度优先遍历</span><br><span class="line">这样想，比如1这个结点最先入栈，在它后面的结点没有弹栈之前不会弹栈</span><br><span class="line">递归的思考，对于每个结点都是这样，于是就神奇的发现，实现了逆拓扑排序，只需要在弹栈之后再输出元素就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161635017.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新  &#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新 &#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩短工期问题，必须缩短所有关键路径共有的边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161806152.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例子，举最简单例子 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161809806.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列，边推进边删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161813650.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161854380.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">4...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162037259.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顶点的最早开始时间与最晚开始时间容易求</span><br><span class="line">需要注意的是，边的最早开始时间就是顶点的最早开始时间(顶点刚开始，就开启活动)</span><br><span class="line">但是，边的最晚开始时间却不是起始顶点的最晚开始时间(活动可能有剩余时间等待)，所以</span><br><span class="line">应该从 下一个顶点的最晚开始时间减去活动所需时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162102546.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图 DAG 表达式应用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162112044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">注意：如果存在多个入度=0的顶点，那么拓扑序列可能有多个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162135908.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间余量：就是不拖延工期前提，活动最多能拖延多久</span><br><span class="line">活动时间余量=结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162216094.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2)该图有多少个强连通分量？</span><br><span class="line">只有入度没有出度，或者只有出度没有入度的顶点，必然不可能和其他顶点连通，所以这种顶点自身就是一个强连通分量。通过不断去除已经找到的强连通分量进而更加清晰的寻找另外的强连通分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172253366.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">综合3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172318917.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明如何用DFS 实现拓扑排序?</span><br><span class="line">- 深度优先遍历，会将先经过的结点入栈，先入后出，一般用于实现逆拓扑排序</span><br><span class="line">- 如果反过来要实现逆拓扑排序，则需要定义一个全局变量time,标记当前结点的结束时间</span><br><span class="line">- 然后将顶点按时间从大到小排序，得到的的就是拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181137335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra最短路径算法能否给出一颗生产树？该树是否一定是最小生成树？</span><br><span class="line">- 能，但不一定是最下生成树。</span><br><span class="line"></span><br><span class="line">解答：Dijkstra最短路径算法能够给出一棵生成树，但该树不一定为最小生成树。虽然Dijkstra算法和Prim算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</span><br><span class="line"></span><br><span class="line">Dijkstra算法对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;Min[k]+G[k][j]);</span><br><span class="line">Min[j]=Min[k]+G[k][j];</span><br><span class="line"></span><br><span class="line">而Pim算法Q对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;G[k][j]);</span><br><span class="line">Min[j]=G[k][j]</span><br><span class="line"></span><br><span class="line">为此，可考虑以下的反例</span><br><span class="line">对于以下的带权连通无向图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181208563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181147863.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011年真题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181217437.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（2）.本质就是图结构体=顶点结构体+边结构体</span><br><span class="line">（3）.本质就是找出R1到各个路由器的最短路劲，然后按照从小到大的顺序排序，Dijkstra算发就是按照，先入较短路径的顶点，然后根据新入顶点找下一个较短路劲顶点，这样得到的顶点路劲必然是后面加入的顶点路劲更长</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232316553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.按照prim算法过程依次选出边即可</span><br><span class="line">（2）.题目只问一个问题——是否唯一？；答，唯一即可，无需多做解释</span><br><span class="line">（3）.题目只问满足什么条件时？；答一个充分条件即可。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232328694.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.&quot;所有可能&quot;，说明要列出所有，的最小生成树的情况</span><br><span class="line">（2）.写prim算法名称--&gt;奇怪怎么会有怎么简单的问题？</span><br><span class="line">（3）.TTL就是信息保留时间，当路径长度大于TTL时，信息销毁</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232343584.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储的图</span><br><span class="line">DFS遍历使用了栈--&gt;栈内存的顶点最多不超过顶点数n</span><br><span class="line">BFS使用了队列--&gt;队列内的顶点数，最多也不超过n</span><br><span class="line">那么DFS BFS空间复杂度都与n都有关,空间复杂度&#x27;不可避免&#x27;的O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241436702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无论是DFS还是BFS</span><br><span class="line">邻接矩阵都有nxn个空间需要依次遍历，所以时间复杂度是O(n^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241535428.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DFS遍历</span><br><span class="line">分析D选项</span><br><span class="line">从a作为开始结点a--&gt;e--&gt;d--&gt;f--&gt;c </span><br><span class="line">到c往下DFS发现边为NULL，执行到底不再递归弹栈,返回到c</span><br><span class="line">返回c，发现c的next为空，执行到底，退出栈</span><br><span class="line">返回f,发现..</span><br><span class="line">返回d,发现...</span><br><span class="line">返回e,发现e的next边与b相连，于是对b递归，访问b</span><br><span class="line">--&gt;最终顺序是a e d f c b</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241553960.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241544054.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错--&gt;至于通过报错判断是否有环是否可以利用还存在争议</span><br><span class="line">B.Dijikstra算法是求最短路劲，通过依次加入顶点，更新距离的操作与有没有环没有关系</span><br><span class="line">C.深度优先遍历算法.这里可以微调一下深度优先算法.将弹栈后的结点，清除器访问标记--&gt;</span><br><span class="line">这样做虽然会导致访问重复结点，但是我们的目的是判断是否有环，而不是遍历。所以有环的话，必然会在某一条深度递归中，压入已经存在栈内的顶点(重复顶点)，那么就可以判断有环存在。至于清除访问标记是因为该深度已经遍历，那么将节点释放相当于弹栈，以便判断下一条单条深度递归中的重复顶点。</span><br><span class="line">D.广度优先遍历,无法实现有向图是否有环的判断，因为，广度优先遍历无法判断图是否有环，因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242130768.png" alt="Uploading file...urh96"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于图的概念辨别题，主要是要理清楚图的概念</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242257386.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这道题目需要注意的点：</span><br><span class="line">1.对于写出深度优先生成树，不能根据给出的表，画出完整的图G后再进行深搜。因为给定的表隐含着遍历顺序，而你完整图中进行的遍历没有符合题目要求的顺序,因此，应该直接根据邻接表来深度搜索--&gt; 1--&gt;2--&gt;3--&gt;4--&gt;5</span><br><span class="line">2.对于写出广度优先生成树，同样的道理不能按照画出的完整图来遍历，原因依然是要按照题目中邻接表中隐含的顺序来进行推进--&gt;1 2 3 4 5 如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242335365.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242328392.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算法设计</span><br><span class="line">1.切入点：树的顶点=数的边+1</span><br><span class="line">2.步骤：初始化两个变量i j,分别存储顶点数目，边的数目；遍历顶点，没访问一个顶点i++,在访问与该点所有相连的边,每条边j++;最终边的数量统计了两次，因为一条边连接了两个顶点，所以最终统计i=j/2 + 1是否成立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252008877.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS如果不用递归，那么必须需要栈的数据结构来替代递归栈.</span><br><span class="line">邻接表采用深度优先遍历，从i开始--&gt;i入栈--&gt;遍历j--&gt;j入栈--&gt;跳转到j开头那一行--&gt;遍历k--&gt;k入栈--&gt;跳转到k的那一行--&gt;...--&gt;遍历到最深层--&gt;一次往回弹栈</span><br><span class="line">从过程中，入栈需要存入两种信息：</span><br><span class="line">1.该入栈结点的编号 </span><br><span class="line">2.该入栈顶点位于哪行的地几个位置(为了使得弹栈之后回到相对应的位置继续遍历) </span><br><span class="line">3.另外还需要，用一种数据结构存储已经遍历过的顶点，防止重复遍历</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252034320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用遍历算法判断邻接表方式存储的有向图中，是否存在顶点i到j的路径</span><br><span class="line">1.将i作为遍历的开始顶点</span><br><span class="line">2.采用任意遍历算法，遍历只要寻找到顶点j就说明存在从i到j的路径,返回true，否则返回false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252052716.png" alt="image.png"></p><h2 id="课后习题2"><a href="#课后习题2" class="headerlink" title="课后习题2"></a>课后习题2</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252202149.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完全图的定义：任意两个顶点之间都存在边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252206168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵:nxn</span><br><span class="line">无向图:矩阵中2e个1</span><br><span class="line">0个数=n^2-2e</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252208299.png" alt="Uploading file...p539r"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于邻接矩阵而言，&quot;行出列入&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252219197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图的邻接表的存储结构--&gt;左边一列，顶点结构体；右边的是由顶点引出的与顶点相连的所有边结构体。</span><br><span class="line"></span><br><span class="line">这题顶点v在边表中的出现次数，是指边表中存储的是边指向的下一个顶点(有向图)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271149779.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储无向图，由于无向图边是双向的，所以n(n-1)条边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271202239.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除有向图某个顶点v相关的所有边</span><br><span class="line">1.删除该顶点引出的所有一连串的边表结点，最多引出n-1条边 O(n) </span><br><span class="line">2.删除所有指向该顶点的所有边，由于无法判断起始点是哪一个，所以只能从头到尾遍历O(e)</span><br><span class="line"></span><br><span class="line">最终时间复杂度O(n+e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271210580.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十字链表是存储有向图</span><br><span class="line">邻接多重表是存储无向图</span><br><span class="line"></span><br><span class="line">推出十字链表和邻接多重表的目的是为了将某一条边的两个顶点都表示出来，以至于可以直接通过一条边找到两端的两个顶点，而不是只能从一个顶点出发</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271422325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271515927.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> numVertice,numEdge;</span><br><span class="line"><span class="type">char</span> Vertice[maxV];    <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> Edge[maxv][maxv];  <span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsExistEL</span><span class="params">(Mgraph G)</span>&#123;</span><br><span class="line"><span class="type">int</span> degree,count;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.numV;i++)&#123;</span><br><span class="line">degree =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j;j&lt;G.numV;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G.Edge[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">degree++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(degree%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">2</span>||count==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271544169.png" alt="image.png"></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><blockquote><p>基本概念<br><code>查找长度</code>：查找运算中，需要对比关键字的次数<br><code>平均查找长度</code>：（ASL  Average Search Length），所有查找过程中进行关键字比较次数的平均值</p></blockquote><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><hr><p>时间复杂度 无论如何优化，始终为<code>O(n)</code></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><hr><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041349757.png" alt="image.png"></p><ul><li>针对<code>有序的顺序表</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable T,ElemType key)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=T.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(T.data[mid]==key)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T.data[mid]&lt;key)&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//查找失败</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041428775.png" alt="image.png"><br><code>折半查找判定树</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041435628.png" alt="image.png"><br><code>折半查找判定树的性质</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- mid=(low+high)/2 采用的是向下取整方式</span><br><span class="line">- 结点数n为奇数，右子树结点数-左子树结点数=1</span><br><span class="line">- 结点数n为偶数，右子树结点数=左子树结点速</span><br><span class="line"></span><br><span class="line">- 折半查找判定树一定是平衡二叉树</span><br><span class="line">- 折半查找判定树，只有最下面一层不是满的，因此求树高h于完全二叉树公式一致</span><br><span class="line">- 失败结点：n+1个也就是查找成功结点的空链域数量</span><br><span class="line">- 每个元素所在层数表示查找次数，所以查找成功，失败的时间复杂度不会超过树高(树高不包括失败</span><br><span class="line">  结点)log2(n+1),时间复杂度O(log2n)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041446033.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041448619.png" alt="image.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树高不包含失败的结点(紫色的空节点)，因为查找失败的查找次数也就是查找到其父节点的查找次数(也就是失败结点的父节点的树高)，因为，当查找到树梢结点发现没找到就查找失败，那么查找是吧的次数也就是树梢结点的高度了</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041453663.png" alt="image.png"></li></ul><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：块内无序，块间有序,块内存放数据个数不同，索引中保存每个块的最大关键字和起始到末尾的地址</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041501254.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 考察选择，不要求代码</span><br><span class="line"></span><br><span class="line">索引表中保存的是每个区块中最大的关键字</span><br><span class="line"></span><br><span class="line">分块查找</span><br><span class="line">- 对分块的索引表采用顺序查找</span><br><span class="line"></span><br><span class="line">- 对分块的索引表采用折半查找</span><br><span class="line">分两种情况：</span><br><span class="line">1.查找元素正好是索引表的元素,例如30</span><br><span class="line">2.查找元素不是索引表的元素此时，折半查找，最终low&gt;high，low指向的就是目标元素</span><br><span class="line"> 所在区块</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041711226.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序查找方式</span><br><span class="line">ASL=查索引表的平均查找长度+查分块的平均查找长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041723622.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找方式</span><br><span class="line">ASl分析，不太重要，就不讨论了...</span><br></pre></td></tr></table></figure><h2 id="二叉查找-排序-树-BST"><a href="#二叉查找-排序-树-BST" class="headerlink" title="二叉查找(排序)树(BST)"></a>二叉查找(排序)树(BST)</h2><h3 id="查找-插入-构造树"><a href="#查找-插入-构造树" class="headerlink" title="查找-插入-构造树"></a><code>查找-插入-构造树</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">二叉查找(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-2">二叉查找(递归)</button></li><li class="tab"><button type="button" data-href="#test1-3">二叉排序树插入(递归)</button></li><li class="tab"><button type="button" data-href="#test1-4">二叉排序树插入(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-5">二叉排序树的建立</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;left,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&gt;T-&gt;key,key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若原二叉树为空，则直接插入结点，否则关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=key;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;left,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BST_Search</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T=T-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=k;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="type">int</span> str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">BST_Insert(T,str[i]); <span class="comment">//插入方法</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><code>查找ASL分析</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">查找成功ASL分析</button></li><li class="tab"><button type="button" data-href="#test1-2">查找失败ASL分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042035408.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042036128.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="二叉排序树删除"><a href="#二叉排序树删除" class="headerlink" title="二叉排序树删除"></a><code>二叉排序树删除</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">情况1-删叶节点</button></li><li class="tab"><button type="button" data-href="#test1-2">情况2-只有左或·右结点-</button></li><li class="tab"><button type="button" data-href="#test1-3">同时有左右结点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接删除，不影响排序树结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042039542.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也是可以直接删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042040203.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><code>有两种方式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将删除节点的右子树的最小节点替代删除节点</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042048914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将左子树的最大节点替代删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042049351.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a><code>回顾</code></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042051390.png" alt="image.png"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><hr><h3 id="平衡二叉树概念"><a href="#平衡二叉树概念" class="headerlink" title="平衡二叉树概念"></a>平衡二叉树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树(Balanced Binary Tree)，在二叉排序树基础上，树上任意结点的左子树与右子树高度只差不超过1</span><br><span class="line"></span><br><span class="line">平衡因子=左子树高度-右子树高度</span><br><span class="line"></span><br><span class="line">如果二叉树平衡，各个结点的平衡因子只能是0,-1,1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072211245.png" alt="image.png"></p><h3 id="平衡二叉树插入调整"><a href="#平衡二叉树插入调整" class="headerlink" title="平衡二叉树插入调整"></a>平衡二叉树插入调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树插入新结点如何保持平衡？</span><br><span class="line"></span><br><span class="line">只需调整引起不平衡的最小的那个子树，画圈的部分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072213624.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如何调整？</span><br><span class="line"></span><br><span class="line">插入导致不平衡分为四种情况：(A是最小不平衡子树)</span><br><span class="line">LL 在A的左孩子的左子树中插入导致不平衡</span><br><span class="line">RR 在A的右孩子的右子树中插入导致不平衡</span><br><span class="line">LR 在A的左孩子的右子树中插入导致不平衡</span><br><span class="line">RL 在A的右孩子的左子树中插入导致不平衡</span><br><span class="line"></span><br><span class="line">通过旋转来调整二叉树的失衡</span><br><span class="line">要找到最小的那颗失衡的二叉树调整</span><br></pre></td></tr></table></figure><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><code>LL右旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231082.png" alt="image.png"></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><code>RR左旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231424.png" alt="image.png"></p><p><code>LL&amp;RR代码思路</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072232020.png" alt="image.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><code>LR</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072238460.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072239049.png" alt="image.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><code>RL</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072241280.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072242585.png" alt="image.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072243530.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072250049.png" alt="image.png"></p><h3 id="平衡二叉树ASL分析"><a href="#平衡二叉树ASL分析" class="headerlink" title="平衡二叉树ASL分析"></a>平衡二叉树ASL分析</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072259228.png" alt="image.png"></p><h3 id="平衡二叉树删除调整"><a href="#平衡二叉树删除调整" class="headerlink" title="平衡二叉树删除调整"></a>平衡二叉树删除调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①删除结点(方法同“二叉排序树”)</span><br><span class="line">②一路向北找到最小不平衡子树，找不到就完结撒花</span><br><span class="line">③找最小不平衡子树下，“个头”最高的儿子、孙子</span><br><span class="line">④根据孙子的位置，调整平衡(LL/RR/LR/RL)</span><br><span class="line">⑤如果不平衡向上传导，继续②，对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081219106.png" alt="image.png"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><hr><h3 id="红黑树定义性质"><a href="#红黑树定义性质" class="headerlink" title="红黑树定义性质"></a>红黑树定义性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然平衡二叉树与红黑树，search、Insert、Delete操作时间复杂度都是O(log2(n)),但是平衡二叉树需要频繁调整数的形态；如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/RR/LR/RL调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081233506.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">红黑树特性：</span><br><span class="line">1.每个结点或是红或是黑色</span><br><span class="line">2.根节点一定是黑</span><br><span class="line">3.叶子结点均是黑(指的是失败结点，查找失败结点，也叫NULL结点)</span><br><span class="line">4.不存在两个相邻红结点(即红结点的父、孩子结点一定是黑)</span><br><span class="line">5.对于每个结点，从该结点到任一叶子结点的简单路劲，所含黑结点数量一致</span><br><span class="line"></span><br><span class="line">=&gt;1.红黑树从根节点到叶结点(NULL结点)的最长路径长度不大于最短路径的两倍</span><br><span class="line">  2.n个结点的红黑树高度h&lt;=2log2(n+1) --&gt; search时间复杂度O(log2(n))</span><br></pre></td></tr></table></figure><p><code>红黑树结点结构体</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> key;           <span class="comment">//保存得值</span></span><br><span class="line">RBnode* parent;    <span class="comment">//父节点指针</span></span><br><span class="line">RBnode* lChild;</span><br><span class="line">RBnode* rChild;</span><br><span class="line"><span class="type">int</span> color;         <span class="comment">//结点颜色，也可用0/1表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081253235.png" alt="image.png"></p><h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p><a href="[7.3_5_红黑树的插入_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=77&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081354530.png" alt="image.png"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="B树概念"><a href="#B树概念" class="headerlink" title="B树概念"></a>B树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">考察选择，不考察代码</span><br><span class="line"></span><br><span class="line">B树性质如下</span><br><span class="line"></span><br><span class="line">1.最少有1个关键字，也就最少有2个分叉;最多有4个关键字，最多就5个分叉</span><br><span class="line"></span><br><span class="line">如何保证查找效率？</span><br><span class="line">- m叉查找树中，规定除了根节点，任何结点都必须至少有[m/2向上取整]个分叉，即保证</span><br><span class="line">  除了根结点之外的结点至少有[m/2向上取整]-1个关键字</span><br><span class="line">- m叉查找树中，规定对于任何一个结点，其所有子树的高度都相同</span><br><span class="line">-- &gt;保证了上述两个条件的m叉查找树就是B树</span><br><span class="line"></span><br><span class="line">- B树,又称为多路平衡查找树</span><br><span class="line">- B树的阶，是B树中所有节点的分支数的最大值</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081519493.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301813773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081516407.png" alt="image.png"></p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B树的高度不包括叶子结点(失败结点)</span><br><span class="line">要使得n个结点的B树高度最小--&gt;尽可能的让结点里的关键字多，且分叉多--&gt;推导--&gt;</span><br><span class="line">m-1个关键字，m个分叉，则有(m-1)(1 + m + m^2 + m^3 +...+ m^h-1) = m^h - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301833168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要使得含有n个关键字的B树的高度最大--&gt;让每个结点包含的关键字尽可能的少，分叉尽可能的少--&gt;记k=[m/2向上取整]，--&gt;每个结点关键字(根节点可以只有1个关键字，其他结点都为k-1个结点)，分叉最少为k --&gt;如下表</span><br><span class="line"></span><br><span class="line">h层的m阶B树至少包含多少关键字--&gt;就是B树高度最高的情况--&gt;根据上面的推到求得</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301857073.png" alt="image.png"></p><h3 id="B树的插入和删除"><a href="#B树的插入和删除" class="headerlink" title="B树的插入和删除"></a>B树的插入和删除</h3><hr><p><a href="[7.4_2_B树的插入删除_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=80&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h2 id="课后习题-11"><a href="#课后习题-11" class="headerlink" title="课后习题"></a>课后习题</h2><hr><h3 id="顺序查找、折半查找、分块查找"><a href="#顺序查找、折半查找、分块查找" class="headerlink" title="顺序查找、折半查找、分块查找"></a>顺序查找、折半查找、分块查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序查找概念，从一端到另一端，适合链式存储结构和顺序存储结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271605230.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为查找的目标元素是任意的，对有序表而言，需要一次从头查找直到遇到mubiao,而对无序表而言依然需要从头查找直到遇到目标，所以，无论有序还是无序表，只要查找目标四任意的，那么查找平均时间都是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271615270.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均查找长度=∑（查找概率*查找长度）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271620424.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271627148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.字符型不能比较，所以没法做到有序，也就无法二分查找</span><br><span class="line">D.二分查找只能以顺序方式存贮</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271629499.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271635334.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">折半查找树一定是一颗平衡二叉树，因为查找的元素一定是中间的元素，那么就有左半部分与右半部分，也就是左右结点，最极端的情况也就是两端没有左或没有右，也就是说，左右子树的高度只差不会大于1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271644073.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找对应着一颗平衡二叉树，任意结点的左右子树高度只差不超过1，所以对应查找时间（=树高=查找次数=log2(n)）,但是二叉排序树，没有限制高度相差，所以二叉排序树可以单个高度很高，加入要查的目标元素就在这个很高的分支里面，那么查找次数就多。</span><br><span class="line">所以，折半查找和二叉排序树的查找时间性能上，时而相同时而不同，但是大部分是折半查找效率高，</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271649628.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">折半查找树是平衡二叉树</span><br><span class="line">但是不是所有平衡二叉树都满足折半查找树要求，折半查找树，左右子树都平均，最多相差一两个结点，但是平衡二叉树比如下图，右下有一大部分空缺。</span><br><span class="line">所以如果找折半查找树的高度，可以把其当成一颗完全二叉树来求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271703396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解一下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271716769.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空节点的个数就是查找失败的个数，但是查找失败所需次数(查找长度)不是失败结点的高度，而是查找到的最后一个结点的查找次数，也就是失败结点没有高度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271734741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分块查找，将数据分为若干块，块间有序是指按每块的最大值排序，块内无序，块内数据个数无需相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271749420.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据下面推到，块内最理想块长=根号n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271806326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最好情况：最理想分块 √n ;块内有序;块内快外都进行二分查找；</span><br><span class="line">在上述最好情况下，最多比较16次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271811217.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较5次最多</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271855161.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于A 500,200说明500向左走,左边的应该都比500小符合；200,450,说明200向右走，说明200右边应该比比200大且比500小,不符合；</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271859916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该题的算法本质就是顺序查找，而顺序查找如果要比折半查找比较次数更少，那只有x接近数组开头处</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271905335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.折半查找当结点个数为偶数时，要么统一选取左边结点为中间结点，要么统一选取右边结点为中间结点，看图B 末梢处，剩余两个结点，一边的选取了靠右的为中间结点，另一边选取了考左的为中间结点，不符合算法</span><br><span class="line">C.与B类似</span><br><span class="line">D.左子树4结点，右子树5结点，说明偶数结点数，统一选取考左的为中间结点，那么又因为，更小的子树的左子树为2，右子树为1，选取的又是靠右的，互相矛盾，所以不符合算法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271914099.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当个例题来看吧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272138000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k分查找成功时间复杂度--&gt;查找树的高度logk n + 1--&gt;查找成功次数最多logk n + 1时间复杂度O(logk n)</span><br><span class="line">查找不成功查找次数最多也为logk n + 1--&gt;时间复杂度也为O(logk n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272205598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">顺序查找查找成功7,15，23...8N-1 ---&gt;共n个--&gt;查找长度1+2+3+..+n</span><br><span class="line">二分查找查找成功</span><br><span class="line">第一层结点查找长度分别为2,3,4,5,..n+1</span><br><span class="line">第二层结点查找长度分别为2x3,2x4,2x5...2x(n+2)</span><br><span class="line">第三层.. 4x4,4x5,4x6...4x(n+3)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272220088.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSearch</span><span class="params">(SSTable ST,x,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;=end)&#123;</span><br><span class="line"><span class="type">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ST.data[mid]=x)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.data[mid]&lt;x)&#123;</span><br><span class="line">end = mid<span class="number">-1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">begin = mid+<span class="number">1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272249235.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_swap</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ST.data[i]!=x&amp;&amp;i&lt;ST.length)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=ST.length)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(ST.data[i],ST.data[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line">LinkList <span class="title function_">Search_swap</span><span class="params">(Linklist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next.data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(p=L;p-&gt;next-&gt;next.data!=x;p=p-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next=q-&gt;next-&gt;next;</span><br><span class="line">p-&gt;next-&gt;next=q;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272312095.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272350405.png" alt="image.png"></p><h3 id="平衡二叉树习题"><a href="#平衡二叉树习题" class="headerlink" title="平衡二叉树习题"></a>平衡二叉树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.查找失败则插入所查找的结点，查找失败说明找到结点的右边或左边已经无节点才导致失败</span><br><span class="line">那么，直接在空的位置上插入结点，并不会导致树的分裂和组合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282215672.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">完全二叉树才是二叉排序树的最理想情况</span><br><span class="line">完全二叉树求深度以满二叉树为模板</span><br><span class="line">，根据等比数列求和 --&gt; n=2^h -1 --&gt;这是n完全沾满第h层的时候</span><br><span class="line">但是第h层没有完全沾满时，数的高度同样是h,这样就需要对log2(n+1)向上取整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282251776.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据平衡二叉树，高度为h所需最少结点数的关系，解决此题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282321303.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树任意结点的左右子树高度只差不超过1</span><br><span class="line">H=1, n=1</span><br><span class="line">H=2, h左=1，h右=0 ; 1+1+0=2</span><br><span class="line">H=3, h左=2，h右=1 ; 1+2+1=4 --&gt;h左 根据前面H=2求得的n，h右 根据前面H=1求得的n</span><br><span class="line">...</span><br><span class="line">递推</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291911448.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树RL 型调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292125948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平衡因子均为1--&gt;用最少的结点构成高度最高的平衡二叉树</span><br><span class="line">与之前那题一模一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292137300.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全程用到RR的情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292146525.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292157774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292205741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.平衡二叉树的调整，需要调整的是插入后导致的最小的不平衡子树</span><br><span class="line">2.这题是RL型，RL是指，新插入的导致二叉树不平衡的结点是相对于最小不平衡子树的头号结点的位置，是先往右，再往左</span><br><span class="line">3.相对应的树的调整相当于打方向盘，从后往前考虑，先是往左偏了，就要右旋。接着考虑上层往右偏了，就要左旋</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292214226.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直到一个二叉排序树的先序遍历序列。--&gt;数字从小到大就是中序遍历序列--&gt;结合中序遍历序列和先序遍历序列，就能完整的画出一颗二叉排序树--&gt;在根据树来进行分析</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292226147.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈用于存放结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsOrderTree</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Push(S,T);</span><br><span class="line">BiTree Q;</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Q=Pop(S);</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift-&gt;data&lt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;lift);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right-&gt;data&gt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292251685.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树求指定结点所在的树的层次</span></span><br><span class="line"><span class="comment">//思路是，通过二叉排序树查找算法，查找指定结点，查找的次数就是结点所在层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BS_Search_high</span><span class="params">(BSTree T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">BSTree Q = T;</span><br><span class="line"><span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(Q-&gt;data&lt;x)&#123;</span><br><span class="line">Q=Q-&gt;left;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q=Q-&gt;right;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301546891.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个二叉树的平衡标记balance(1,表示平衡；0表示不平衡)</span></span><br><span class="line"><span class="comment">//h为二叉树的高度，</span></span><br><span class="line"><span class="comment">//如果树空，高度为0，如果树只有一个结点高度为1，</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Jude_AVL</span><span class="params">(BiTree T,<span class="type">int</span> &amp;balance,<span class="type">int</span> &amp;h)</span>&#123;</span><br><span class="line"><span class="type">int</span> bl=<span class="number">0</span>,br=<span class="number">0</span>,hl=<span class="number">0</span>,hr=<span class="number">0</span>;  <span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line"><span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">0</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lichild==<span class="literal">NULL</span>&amp;&amp;bt-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">1</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Judge_AVL(bt-&gt;lchild,bl,hl);  <span class="comment">//递归判断左子树</span></span><br><span class="line">Judge_AVL(bt-&gt;rchild,br,hr);  <span class="comment">//递归判断右子树</span></span><br><span class="line">h=(h1&gt;h2?h1:h2)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(h1-h2)&lt;<span class="number">2</span>)&#123;    <span class="comment">//若树的高度差的绝对值&lt;2,则看左右子树是否平衡</span></span><br><span class="line">balance=bl&amp;&amp;br;    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">balance=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301559886.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从大到小输出--&gt;中序遍历稍作修改</span><br><span class="line">2.输出的值不小于k，对中间结点输出的时候，做一个判断</span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_dechute</span><span class="params">(BSTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;right); <span class="comment">//先大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data&gt;=k)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;data);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301637025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这题思路是</span><br><span class="line">在每个结点里面保存，以当前结点为根的子树中总共有多少个结点</span><br><span class="line">假设这棵树的根节点是T</span><br><span class="line">一下几种情况：</span><br><span class="line">1.T-&gt;lchild==NULL </span><br><span class="line">- 若T-&gt;rchild非空且k=1,则T就是滴k小节点</span><br><span class="line">- 若T-&gt;rchild非空且k!=1,则第k小元素在T的右子树上</span><br><span class="line">2.T-&gt;lchild!==NULL</span><br><span class="line">- T-&gt;lchild-&gt;count=k-1,则T就是第k小元素</span><br><span class="line">- T-&gt;lchild-&gt;count&gt;k-1,则第k小元素必在左子树，继续到左子树中去找</span><br><span class="line">- T-&gt;lchild-&gt;count&lt;k-1,则第k小元素必在右子树，继续搜索右子树，寻</span><br><span class="line">   找第k-(T-&gt;lchild-&gt;count+1)小的元素</span><br><span class="line"></span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTree <span class="title function_">Search_Small</span><span class="params">(BSTree T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;T-&gt;count)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count==k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&gt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;lchild,k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&lt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k-(T-&gt;lchild-&gt;count+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301709526.png" alt="image.png"></p><h3 id="红黑树习题"><a href="#红黑树习题" class="headerlink" title="红黑树习题"></a>红黑树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟悉红黑树的性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291920684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D选项：根据两个性质解答</span><br><span class="line">1.红黑树对于每个结点，到叶子结点的任意一条路径上的黑结点的个数相同</span><br><span class="line">2.红结点不能与红结点相邻</span><br><span class="line">所以红黑树的单条从根结点到叶子结点的路径上的黑色结点个数是确定的设为x</span><br><span class="line">假设出发结点是black:</span><br><span class="line">- 高度最小的子树，全部位黑色结点，高度为 x-1</span><br><span class="line">- 高度最高的子树，黑色结点与红色结点相间出现</span><br><span class="line">- 子树原结点是black--&gt; x-1 + (x-2)=2x-3</span><br><span class="line">- 子树原结点是red --&gt; (x-1)+(x-1)=2x-2</span><br><span class="line">假设出发结点是red:</span><br><span class="line">- 高度最小子树，x</span><br><span class="line">- 高度最大子树，2x-1</span><br><span class="line">左右子树高度之比都小于2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291937703.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.红黑树是自平衡的树，但不是平衡二叉树</span><br><span class="line">B.红黑树所有结点都是黑色，那么它一定是满二叉树因为从根节点出发，到叶子结点，黑色结点数是一样的</span><br><span class="line">C.红色结点孩子结点可以全为黑</span><br><span class="line">D.一看就是错的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292029968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红黑树的插入操作</span><br><span class="line">1.插入的结点始终一致染成红色</span><br><span class="line">2.如果违反了不红红，则看叔叔的颜色</span><br><span class="line">3.黑叔，影响不向上传递，只需先按照平衡二叉树旋转，然后将旋转后的爷爷结点染黑</span><br><span class="line">4.红叔，影响向上传递，只需向先将爷爷结点染红，儿子染黑，然后爷爷结点作为新插入结点继续向上判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292043633.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292116716.png" alt="image.png"></p><h3 id="B树习题"><a href="#B树习题" class="headerlink" title="B树习题"></a>B树习题</h3><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">排序算法分为 交换类排序、插入类排序、选择类排序、归并类排序</span><br><span class="line">交换类排序</span><br><span class="line"></span><br><span class="line">冒泡排序</span><br><span class="line">初冒泡排序,一般靠选择题，考大题几率小</span><br><span class="line">快速排序</span><br><span class="line">更重要，考大题</span><br><span class="line"></span><br><span class="line">插入类排序</span><br><span class="line"></span><br><span class="line">直接插入</span><br><span class="line"></span><br><span class="line">折半插入</span><br><span class="line"></span><br><span class="line">希尔排序，以上三种插入算法，一般考选择题，考大题概率低</span><br><span class="line">选择排序</span><br><span class="line"></span><br><span class="line">简单选择排序</span><br><span class="line"></span><br><span class="line">堆排序(重要)</span><br><span class="line">很有可能考大题</span><br></pre></td></tr></table></figure><h2 id="课后习题-12"><a href="#课后习题-12" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于</span><br><span class="line">我们这里所提到的内部排序范畴，也不满足前面排序的定义。</span><br><span class="line"></span><br><span class="line">2.排序算法的稳定性是指? 经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">加入需要排序的数组是arr=[1,0,6,3,2,7,5]</span><br><span class="line">需要两个下标指针i、j</span><br><span class="line">初始时，只有第一个元素有序，那i从 1开始，j=i-1</span><br><span class="line"></span><br><span class="line">arr=[  1,  0,  6,  3,  2,  7,  5]</span><br><span class="line">       j   i</span><br><span class="line">先将arr[i]=temp存着</span><br><span class="line">如果arr[j] &gt; arr[i],arr[j]往后移一位，arr[j+1]=arr[j],j--;</span><br><span class="line"></span><br><span class="line">arr[  1,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1   </span><br><span class="line">      </span><br><span class="line">arr[j+1]=temp</span><br><span class="line"></span><br><span class="line">arr[  0,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1    </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(ElemType *str,<span class="type">int</span> n)</span>&#123; <span class="comment">//n为数组长度 </span></span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        temp=str[i];<span class="comment">//暂时存目标元素  </span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;str[j]&gt;temp)&#123;<span class="comment">//将比插入的数大的全部往后移一格  </span></span><br><span class="line">            str[j+<span class="number">1</span>]=str[j];  </span><br><span class="line">            j--;</span><br><span class="line">        &#125;  </span><br><span class="line">        str[j+<span class="number">1</span>]=temp;<span class="comment">//j来到了插入位置，将temp插入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，</span><br><span class="line">因而时间复杂度为O（n）.</span><br><span class="line">在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达</span><br><span class="line">到最大，总的移动次数也达到最大，总的时间复杂度为O（n^2）.</span><br><span class="line">平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为</span><br><span class="line">平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n^2/4。</span><br><span class="line">稳定性：</span><br><span class="line">由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置</span><br><span class="line">发生变化的情况，即直接插入排序是一个稳定的排序方法</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="课后习题-13"><a href="#课后习题-13" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在待排序的元素序列基本有序的前提下，效率最高的排序方法是（）。</span><br><span class="line">A.直接插入排序B.简单选择排序C.快速排序</span><br><span class="line">D.归并排序</span><br><span class="line"></span><br><span class="line">解析:待排序序列基本有序，只需比较n-1次时间复杂度O(n),达到效率最高</span><br></pre></td></tr></table></figure><h1 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从后往前(或从前往后)两两比较相邻元素的值，如果逆序，就交换，直到将最小元素，交换到最上层</span><br><span class="line">第1轮，比较n个元素，比较n-1次，找到最小的，放到第一位</span><br><span class="line">第2轮，比较n-1个元素，比较n-2次，找到剩余中最小，放到第二位</span><br><span class="line">...</span><br><span class="line">比较n-1轮</span><br><span class="line"></span><br><span class="line">n-1 + n-2 + ...+ 3 + 2 + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(ElemType arr[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="type">bool</span> flag;  <span class="comment">//用来标记是否发生了交换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环需要比较n-1次  </span></span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//内层循环  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);  </span><br><span class="line">                flag=<span class="literal">true</span>;<span class="comment">//有交换就返回true  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;<span class="comment">//如果这一趟没有比较，直接结束无须比较  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">最好情况：数组本身有序，那么比较第一轮比较了n-1次后，标记返回false，退出排序，O(n)</span><br><span class="line">最坏情况：O(n^2)</span><br><span class="line">平均：O(n^2)</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line">稳定性：由于i&gt;j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个顺序表</span><br><span class="line">以第一个数为基数，赋值给pviot存起来，此时，基数的位置看做为空</span><br><span class="line">定义两个指针i j</span><br><span class="line">i从左往右找比3大的数，i停止</span><br><span class="line">j从右往左找比3小的数，j停止</span><br><span class="line">然后i j 对应的数完成一次交换，i j 继续前进</span><br><span class="line">循环..直到ij相遇i==j</span><br><span class="line">arr[i]=pviot</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemTypeA[],intlow，inthigh）&#123; <span class="comment">//一趟划分</span></span></span><br><span class="line"><span class="params">ElemType pivot=A[<span class="number">1</span>ow]：<span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high）&#123; <span class="comment">//循环跳出条件</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high&amp;sA[high]&gt;=pivot)</span></span><br><span class="line">--high；</span><br><span class="line">A[low]=A[high]； <span class="comment">//将比框轴小的元素移动到左端</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;sA[low]&lt;=pivot)</span><br><span class="line">++<span class="number">1</span>ow；</span><br><span class="line">A[high]=A[low] <span class="comment">//将比框轴大的元素移动到右端</span></span><br><span class="line">&#125;</span><br><span class="line">A[low]=pivot <span class="comment">//框轴元素存放到最终位置</span></span><br><span class="line"><span class="keyword">return</span> low； <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序方法  </span></span><br><span class="line"><span class="type">void</span> quick_sort(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;<span class="comment">//low high用来限定分割的范围  </span></span><br><span class="line">        <span class="type">int</span> postion = partition(str, low, high);<span class="comment">//partition方法是核心方法，每一次分割的方法  </span></span><br><span class="line">        quick_sort(str, low, postion - <span class="number">1</span>);<span class="comment">//递归左边的数组  </span></span><br><span class="line">        quick_sort(str, postion + <span class="number">1</span>, high);<span class="comment">//递归数组右边  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645079.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度</span><br><span class="line">最好情况：每次分割都能平均分成两份则2^x=n; x=log2 n;每轮分割，所有子数组的比较总次数n-1次</span><br><span class="line">所以是(n-1)log2 n,O(n)=nlog2 n</span><br><span class="line">平均状态：接近最好情况O(n)=nlog2 n</span><br><span class="line">最差情况：如果数组本来就有序，那么每次都无法一次切一半，变成从1到n-1都要分割一次,每轮分割依</span><br><span class="line">旧比较n-1次，那么O(n)=n^2</span><br><span class="line">空间复杂度</span><br><span class="line">容量与递归的最大深度一致，最好情况log2 n ;最坏n-1</span><br><span class="line"></span><br><span class="line">稳定性：</span><br><span class="line">在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换</span><br><span class="line">到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。例如，表L=</span><br><span class="line">&#123;3,2,2&#125;,经过一趟排序后L=&#123;2,2,3&#125;,最终排序序列也是L=&#123;2,2,3&#125;,显然，2与2的相对次</span><br><span class="line">序已发生了变化。</span><br><span class="line"></span><br><span class="line">快速排序时内部排序算法中平均性能最优的一种算法</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组设置两个指针</span><br><span class="line">min j</span><br><span class="line">第一轮：</span><br><span class="line">min指向第1个数据，j指向min后一个,j移动寻找比min小的，然后min=j，j遍历到最后，最终交换arr[i]和arr[min]</span><br><span class="line"></span><br><span class="line">第二轮：</span><br><span class="line">min指向第2个数据，重复上述步骤</span><br><span class="line"></span><br><span class="line">...重复n-1趟</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;   <span class="comment">//一共进行n-1趟</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> min=i;        <span class="comment">//记录最小元素位置  </span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> j=i+l;j&lt;n;j++)      <span class="comment">//在A[i.n-1]中选择最小的元素</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (A[j]&lt;A(min])&#123;  </span></span><br><span class="line"><span class="params">min=j;              <span class="comment">//更新最小元素位置</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (min!=<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="params"> swap(A(i],A[min]);  <span class="comment">//封装的swap（）函数共移动元素3次</span></span></span><br><span class="line"><span class="params">&#125; </span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645595.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：第一轮比较n-1次 第二轮比较n-2次 ...最后一次比较1次</span><br><span class="line">n-1 + n-2 + n-3 +...+3 + 2 + 1=(n-1)n/2  所以是O(n^2)</span><br><span class="line">最好最坏都是O(n^2)</span><br><span class="line">稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同</span><br><span class="line">关键字元素的相对位置发生改变。例如，表L=&#123;2,2,1&#125;,经过一趟排序后L=&#123;1,2,2&#125;,最终排</span><br><span class="line">序序列也是L=&#123;1,2,2&#125;,显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳</span><br><span class="line">定的排序方法</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">引入大根堆的概念：</span><br><span class="line">对于一颗二叉树，任意结点的数值要比左右子树的所有结点的值都大</span><br><span class="line">这样一来，根节点成为了最大的结点</span><br><span class="line">既然大根堆的根节点最大，就不断调整为大根堆：</span><br><span class="line">对非叶子结点进行检测，判断这些非根节点是否大于左右</span><br><span class="line">非叶子结点也就是--&gt;叶子结点的父节点--&gt;i/2向下取整</span><br><span class="line"></span><br><span class="line">例如下面这个例子：</span><br><span class="line">想要调整为大根堆，从8/2=4号结点(非终端结点)开始调整,</span><br><span class="line">然后3号结点78,接着2号结点17,最后1号结点53</span><br><span class="line">这样从后往前调整--&gt;若元素互换破坏了下一级的堆--&gt;则采用相同的方法继续往下调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312317433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312340910.png" alt="image.png"></p><p>1.实现逻辑<br> <code>1.建立大根堆</code> :<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">建堆</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li><li>检查当前结点是否满足龈≥左、右若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(<code>小元素不断下坠</code>)</li><li>一般从<code>最底层的分支结点开始调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645508.png" alt="image.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=len/<span class="number">2</span>,i&gt;<span class="number">0</span>,i--)&#123;</span><br><span class="line">HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">A[<span class="number">0</span>]=A[k];</span><br><span class="line"><span class="keyword">for</span>(son;son&lt;=len;son*=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(son&lt;length&amp;&amp;A[son]&lt;A[son+<span class="number">1</span>])&#123; <span class="comment">//son&lt;len == son+1&lt;=len</span></span><br><span class="line">son++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(A[k]&lt;A[son])&#123;</span><br><span class="line">A[k]=A[son];</span><br><span class="line">k=son;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A[k]=A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646852.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p><code>2.交换堆顶元素与最后一个元素.并将小元素下坠,恢复成大根堆</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">排序过程</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(nlog2n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>交换顶部元素和末尾元素</li><li>小元素下坠</li><li>排除末尾最大元素，<code>len-1</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646651.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010950043.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010952356.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[A],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">BuildMaxHeap(A,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">swap(A[<span class="number">1</span>],A[i]);</span><br><span class="line">HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li>根节点最多才下坠<code>h-1</code>次，且没下坠一次最多比较2次，根结点最多比较2(h-1)次 时间复杂度 <code>O(h)</code></li><li>时间复杂度,其他结点<code>&lt;</code>根节点 , 假设每个都是 O(h),公有n个结点<code>O(nh)</code></li><li>h高度=log2n ，总时间复杂度<code>O(nh)=O(nlog2n)</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646722.png" alt="image.png"></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>2.算法稳定性</p><ul><li>堆排序<code>不稳定</code></li><li>假设只有<code>1、a1、a2</code>当左右子节点相同时a1=a2，会优先考虑左结点和根结点交换</li><li>排序时，交换根结点与最后结点，使得位序在前的a1跑到a2后面，—&gt;<code>1、a2、a1</code> 因此是不稳定的 </li></ul><h1 id="堆的插入和删除"><a href="#堆的插入和删除" class="headerlink" title="堆的插入和删除"></a>堆的插入和删除</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆的插入：</span><br><span class="line">1.插入的新元素放到表尾，最末尾的结点</span><br><span class="line">2.与父节点对比，对于小根堆而言，如果新元素比父结点更小，二者互换</span><br><span class="line">3.新元素一路上升,直至无法继续上升为止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011005919.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆的删除：</span><br><span class="line">1.被删除的元素空出来的位置，用堆底部的元素替代</span><br><span class="line">2.最后让该元素不断下坠，直至无法下坠</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011009010.png" alt="image.png"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><hr><h2 id="什么是归并？"><a href="#什么是归并？" class="headerlink" title="什么是归并？"></a>什么是归并？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">归并两个有序数组</span><br><span class="line">定义指针i指向有序数组1，指针j指向有序数组2,指针k指向要放入的数组</span><br><span class="line">对比i,j所指向的元素，选择更小的一个放入k中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011017728.png" alt="image.png"></p><h2 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4路归并，就是归并4个数组</span><br><span class="line">根据规律发现，m路归并，每次选出一个元素，最少需要比较关键字m-1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011022249.png" alt="image.png"></p><h2 id="单个归并代码实现"><a href="#单个归并代码实现" class="headerlink" title="单个归并代码实现"></a>单个归并代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge的时候，需要三个指针,i指向A的有序的前半段，j指向A有序的后半段，k指向放入的数组的当前位置</span><br><span class="line"></span><br><span class="line">1、将A[] 元素全部复制放到B[] ，i ,j分别对应low\mid+1起始位置，k=i.</span><br><span class="line"></span><br><span class="line">2、i j 先比较，小的放入A[k],i++,j不动，k++</span><br><span class="line"></span><br><span class="line">3、直到有剩余，i到头了，j还没到头;或者j到头了，i还没到头。while循环将剩余的全部放入,k随着++</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> mid)</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=low;k&lt;high;k++)&#123;</span><br><span class="line">B[k]=A[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]&lt;=B[j])&#123;</span><br><span class="line">A[k]=B[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">A[k]=B[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">A[k++]=B[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011030720.png" alt="image.png"></p><h2 id="归并排序完整代码"><a href="#归并排序完整代码" class="headerlink" title="归并排序完整代码"></a>归并排序完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;=high)&#123;</span><br><span class="line"><span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">MergeSort(A,low,mid);  <span class="comment">//不断递归的左右划分</span></span><br><span class="line">MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">Merge(A,low,mid,high); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011043727.png" alt="image.png"></p><h2 id="归并排序效率分析"><a href="#归并排序效率分析" class="headerlink" title="归并排序效率分析"></a>归并排序效率分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">递归调用栈的所占的空间不会超过log2 n 数量级；运用了额外的数组B空间O(n)</span><br><span class="line">相加O(log2 n)+O(n);舍去小的--&gt; O(n)</span><br><span class="line">时间复杂度：</span><br><span class="line">每一层归并时间复杂度O(n),共h=log2 n 层，时间复杂度O(nlog2 n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011048307.png" alt="image.png"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="基数排序算法"><a href="#基数排序算法" class="headerlink" title="基数排序算法"></a>基数排序算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">基数排序：</span><br><span class="line">递增排序：</span><br><span class="line">1.分别对一组数据根据他的的个位、十位、百位、分别先后进行排序</span><br><span class="line">2.其中个位为最次位关键字(对整体的值影响最小)，百为为最主要关键字(对值影响</span><br><span class="line">最大)</span><br><span class="line">3.先根据对权重最低的个位对数进行分配收集，然后在第一次排好的序列之上，再根</span><br><span class="line">据十位进行分配收集，最后是百位--&gt;最红会得到一个有序序列</span><br><span class="line">递减排序：</span><br><span class="line">步骤与递增相同，不过是先对高位进行分配收集，后对低位进行分配和收集</span><br><span class="line">注意：</span><br><span class="line">基数排序不是基于“比较”的排序算法，而是根据相同位数字的不同进行分类规整然后收集</span><br><span class="line">的过程，只是这个分类收集的顺序导致了最后的有序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011400022.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011351923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011404664.png" alt="image.png"></p><h2 id="基数排序算法效率分析"><a href="#基数排序算法效率分析" class="headerlink" title="基数排序算法效率分析"></a>基数排序算法效率分析</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">初始序列为一串链表，定义了一个链式队列的数组用来分配各个数字，由于数组里只是存</span><br><span class="line">放队头指针+队尾指针，实际所需的空间只有数组的10个空间，里面的队列是在原有链表</span><br><span class="line">序列的基础上修改指针指向得到，并没有消耗多余的空间。所以空间复杂度O(r)--&gt;r是</span><br><span class="line">数字可能出现的种类0~9</span><br><span class="line">时间复杂度：</span><br><span class="line">一趟分配n个O(n);一次收集扫描r个队列O(r) --&gt;因为只需将队列整个拆下来拼接</span><br><span class="line">总共分配收集3趟,设趟数为d</span><br><span class="line">时间复杂度 O(d(n+r))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011429831.png" alt="image.png"></p><h2 id="基数排序应用"><a href="#基数排序应用" class="headerlink" title="基数排序应用"></a>基数排序应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基数排序适用：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011433515.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011435864.png" alt="image.png"></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是外部排序？</span><br><span class="line">对磁盘(外存)中的数据进行排序，由于外存容量很大，但内存容量很小，要对外存中所有</span><br><span class="line">数据进行啊排序的话，内存放不下</span><br></pre></td></tr></table></figure><h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041049305.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041048131.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题目转化--&gt;4个结点的二叉树有多少种形状，然后可以将a b c d按照先序遍历填进二叉树里(填法唯一)</span><br><span class="line">(每种形状必定能按照一定顺序填 a b c d 使得先序遍历出来次序符合要求)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041051053.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为1入栈马上出栈，接着2入栈马上出栈，所以只看后面三个数的出栈序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041058998.png" alt="image.png"></p><h2 id="并查集-2022新增考点"><a href="#并查集-2022新增考点" class="headerlink" title="并查集(2022新增考点)"></a>并查集(2022新增考点)</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008040.png" alt="image.png"></p><p><code>Find查操作</code>：如何查到一个元素到底属于哪个集合？</p><ul><li>从指定元素出发，一路向北，找到根节点，判断根节点是否相同 <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008041.png" alt="image.png"></li></ul><p><code>Union并操作</code>：如何把两个集合合并为一个集合？</p><ul><li>让一棵树成为另一棵树的子树即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008042.png" alt="image.png"></li></ul><p><code>双亲表示法</code>：便于找到父节点(查)，便于合并两棵树(并)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008043.png" alt="image.png"></p><blockquote><p><code>代码实现</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Size 20</span></span><br><span class="line"><span class="type">int</span> UFSets[Size]; <span class="comment">//集合元素数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size;i++)&#123;</span><br><span class="line">S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008044.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find查操作，找到x所属集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">x=S[x]; <span class="comment">//找父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏：O(n)，树高=n,find时间复杂度与树高相关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//Union并操作，将两个集合合并为一个</span></span><br><span class="line"><span class="comment">void Union(int S[],int root1,int root2)&#123;</span></span><br><span class="line"><span class="comment">if(root2==root1)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">S[root2]=root1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//`Union优化`：小树合并到大树上(用树结点绝对值表示)，避免高度增加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> root1,<span class="type">int</span> root2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root2==root1)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S[root1]&gt;S[root2])&#123; </span><br><span class="line">S[root1] += S[root2];</span><br><span class="line">S[root2]=root1;  <span class="comment">//小树合并到大树</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">S[root2] += S[root1];</span><br><span class="line">S[root1] = root2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后，树高&lt;=log2n ,find最坏时间复杂度O(log2n)</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008045.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008046.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008047.png" alt="image.png"></p></blockquote><p><code>总结</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008048.png" alt="image.png"></p><p><code>find优化+Union优化</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008050.png" alt="image.png"></p><h2 id="课后习题-14"><a href="#课后习题-14" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">栏目2</button></li><li class="tab"><button type="button" data-href="#test1-3">栏目3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062010458.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;绪论&quot;&gt;&lt;a href=&quot;#绪论&quot; class=&quot;headerlink&quot; title=&quot;绪论&quot;&gt;&lt;/a&gt;绪论&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/im</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>高数</title>
    <link href="https://fqzs.netlify.app/undefined/95b2ede4.html"/>
    <id>https://fqzs.netlify.app/undefined/95b2ede4.html</id>
    <published>2023-04-04T22:36:00.000Z</published>
    <updated>2023-06-10T16:27:50.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础扫盲"><a href="#基础扫盲" class="headerlink" title="基础扫盲"></a>基础扫盲</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181104621.jpg" alt="ai绘画 动漫女孩 粉色长发 水手服 高清电脑壁纸_彼岸壁纸.jpg"></p><h2 id="偏导数存在-连续-可微-偏导数连续关系"><a href="#偏导数存在-连续-可微-偏导数连续关系" class="headerlink" title="偏导数存在-连续-可微-偏导数连续关系"></a>偏导数存在-连续-可微-偏导数连续关系</h2><details>  <summary>点击展开</summary>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续(x.y)</span><br><span class="line">一阶偏导数连续的意思是，该函数的图像是一条连续的线，无论从哪个方向接近某一点，偏导数的</span><br><span class="line">极限都存在且相等。也就是说，偏导数函数在每一点都满足连续性的定义。如果一个函数在某个区</span><br><span class="line">域内的所有点都有一阶连续偏导数，那么这个函数就是可微的(x、y方向的偏导数都连续)</span><br><span class="line">可微(x.y其他任意方向)</span><br><span class="line">是指曲面某一个点处存在一个切面，该点的各个方向的偏导数都存在(x、y和其他任意方向)</span><br><span class="line">偏导数存在(x.y)</span><br><span class="line">偏导数存在的意思是，一个多变量函数的偏导数，就是它关于其中一个变量的导数而保持其他变量</span><br><span class="line">恒定。也就是说，如果一个多元函数在某一点沿着某个方向的偏增量与该方向的增量之比当增量趋</span><br><span class="line">于零时的极限存在，那么这个极限值就是该函数在该点沿着该方向的偏导数(对于二元函数来说</span><br><span class="line">变量只有x.y那么要xy方向都存在偏导数，那么偏导数存在，要考虑两个变量)</span><br><span class="line">函数连续</span><br><span class="line">就是说二元函数所形成的的曲面是连续的没有断口，判断方法--&gt;该点函数值是否等于函数极限值</span><br><span class="line">等于就是连续</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">综上可以得到</span><br><span class="line"></span><br><span class="line">偏导数连续</span><br><span class="line">=&gt;可微</span><br><span class="line">=&gt;连续</span><br><span class="line">=&gt;偏导数存在</span><br></pre></td></tr></table></figure></details><div class="row">    <embed src="/pdf/基础扫盲题.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="三大核心计算"><a href="#三大核心计算" class="headerlink" title="三大核心计算"></a>三大核心计算</h1><h2 id="函数求极限"><a href="#函数求极限" class="headerlink" title="函数求极限"></a>函数求极限</h2><h3 id="无穷小的比较-泰勒公式-极限"><a href="#无穷小的比较-泰勒公式-极限" class="headerlink" title="无穷小的比较-泰勒公式-极限"></a>无穷小的比较-泰勒公式-极限</h3><div class="row">    <embed src="/pdf/无穷小的比较-泰勒公式-极限.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><div class="row">    <embed src="/pdf/习题.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="函数与求导"><a href="#函数与求导" class="headerlink" title="函数与求导"></a>函数与求导</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135693.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135205.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051139974.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051146278.png" alt="image.png"></p><h3 id="导数的几何意义"><a href="#导数的几何意义" class="headerlink" title="导数的几何意义"></a>导数的几何意义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051150223.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051229079.png" alt="image.png"></p><h3 id="各类函数求导"><a href="#各类函数求导" class="headerlink" title="各类函数求导"></a>各类函数求导</h3><h4 id="基本求导公式与四则运算"><a href="#基本求导公式与四则运算" class="headerlink" title="基本求导公式与四则运算"></a>基本求导公式与四则运算</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051700546.png" alt="image.png"></p><h4 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051701696.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708912.png" alt="image.png"></p><h4 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708838.png" alt="image.png"></p><h4 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051747241.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051757501.png" alt="image.png"></p><h4 id="反函数求导"><a href="#反函数求导" class="headerlink" title="反函数求导"></a>反函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051804246.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051810310.png" alt="image.png"></p><h4 id="高阶导数求导"><a href="#高阶导数求导" class="headerlink" title="高阶导数求导"></a>高阶导数求导</h4><h5 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821928.png" alt="image.png"></p><h5 id="莱布尼茨公式"><a href="#莱布尼茨公式" class="headerlink" title="莱布尼茨公式"></a>莱布尼茨公式</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821393.png" alt="image.png"></p><h5 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304052214444.png" alt="image.png"></p><h2 id="不定积分的计算"><a href="#不定积分的计算" class="headerlink" title="不定积分的计算"></a>不定积分的计算</h2><h3 id="四大积分方法"><a href="#四大积分方法" class="headerlink" title="四大积分方法"></a>四大积分方法</h3><hr><h4 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081717182.png" alt="image.png"></p><h4 id="第一类换元法-凑微分"><a href="#第一类换元法-凑微分" class="headerlink" title="第一类换元法(凑微分)"></a>第一类换元法(凑微分)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.两部分相乘，其中一项的导数是否与另外一项有关</span><br><span class="line">2.提到dx里面</span><br><span class="line">3.换元整体求积分</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081709362.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081727642.png" alt="image.png"></p><h4 id="第二类换元法-去根号"><a href="#第二类换元法-去根号" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根号下x是一次，整体换成t</span><br><span class="line">根号下x是二次，三角换元</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082024835.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082211375.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082333064.png" alt="image.png"></p><h4 id="第三类分部积分法"><a href="#第三类分部积分法" class="headerlink" title="第三类分部积分法"></a>第三类分部积分法</h4><hr><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091242072.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091447042.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091457248.png" alt="image.png"></p><h4 id="第四类有理函数积分"><a href="#第四类有理函数积分" class="headerlink" title="第四类有理函数积分"></a>第四类有理函数积分</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假分式：分子幂次比分母幂次高--&gt;一定可以写成`多项式+真分式`</span><br><span class="line">真分式：分子的幂次比分母低--&gt;例如 </span><br><span class="line">?/(1)(2) --&gt; a/(1) + b/(2)</span><br><span class="line">?/(1)(2)(3)--&gt;a/(1) + b/(2) + c/(3); </span><br><span class="line">?/(1)(2)^2 --&gt; a/(1) + b/(2) + c/(2)^2</span><br><span class="line">其中(1)(2)(3)都是x的一次多项式</span><br><span class="line">多项式的除法如下：</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091523975.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091533686.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091544726.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091550885.png" alt="image.png"></p><h3 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">奇数次凑微分</span><br><span class="line">偶数次降幂</span><br><span class="line">化为同倍角</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091623849.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091632455.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091637269.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091639418.png" alt="image.png"></p><h2 id="定积分的计算"><a href="#定积分的计算" class="headerlink" title="定积分的计算"></a>定积分的计算</h2><h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><h4 id="线性性质"><a href="#线性性质" class="headerlink" title="线性性质"></a>线性性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092231993.png" alt="image.png"></p><h4 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092232647.png" alt="image.png"></p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092239776.png" alt="image.png"></p><h3 id="定积分的计算-1"><a href="#定积分的计算-1" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><h4 id="牛顿莱布尼茨公式"><a href="#牛顿莱布尼茨公式" class="headerlink" title="牛顿莱布尼茨公式"></a>牛顿莱布尼茨公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101351992.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101357337.png" alt="image.png"></p><h4 id="定积分的换元法"><a href="#定积分的换元法" class="headerlink" title="定积分的换元法"></a>定积分的换元法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101404616.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101410502.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101413007.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101426085.png" alt="image.png"></p><h4 id="华里士公式"><a href="#华里士公式" class="headerlink" title="华里士公式"></a>华里士公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132472.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132831.png" alt="image.png"></p><h4 id="定积分的分部积分法"><a href="#定积分的分部积分法" class="headerlink" title="定积分的分部积分法"></a>定积分的分部积分法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038875.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038203.png" alt="image.png"></p><h4 id="区间在线公式"><a href="#区间在线公式" class="headerlink" title="区间在线公式"></a>区间在线公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102944.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102751.png" alt="image.png"></p><h2 id="变限积分与反常积分"><a href="#变限积分与反常积分" class="headerlink" title="变限积分与反常积分"></a>变限积分与反常积分</h2><h1 id="高数1-函数-极限-连续"><a href="#高数1-函数-极限-连续" class="headerlink" title="高数1-函数-极限-连续"></a>高数1-函数-极限-连续</h1><hr><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="8种求极限方法"><a href="#8种求极限方法" class="headerlink" title="8种求极限方法"></a>8种求极限方法</h3><h4 id="method1-基本极限求极限"><a href="#method1-基本极限求极限" class="headerlink" title="method1-基本极限求极限"></a>method1-基本极限求极限</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012219540.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012220359.png" alt="image.png"></p><h4 id="method2-等价无穷小求极限"><a href="#method2-等价无穷小求极限" class="headerlink" title="method2-等价无穷小求极限"></a>method2-等价无穷小求极限</h4><ul><li><code>等价无穷小</code>才能代换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221508.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221512.png" alt="image.png"></p><h4 id="method3-有理运算法则求极限"><a href="#method3-有理运算法则求极限" class="headerlink" title="method3-有理运算法则求极限"></a>method3-有理运算法则求极限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相加的极限=极限相加，前提是,两部分的极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222899.png" alt="image.png"></p><h4 id="method4-洛必达法则求极限"><a href="#method4-洛必达法则求极限" class="headerlink" title="method4-洛必达法则求极限"></a>method4-洛必达法则求极限</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222158.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222786.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222445.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：f(x) n阶可导，最多用洛必达到n-1阶</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012223174.png" alt="image.png"></p><h4 id="method5-泰勒公式求极限"><a href="#method5-泰勒公式求极限" class="headerlink" title="method5-泰勒公式求极限"></a>method5-泰勒公式求极限</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224169.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224130.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.传统方法</span><br><span class="line">2.各个击破</span><br><span class="line">3.代入选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224551.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，不能拆分成两部分，因为有理运算前提是两部分函数，极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225514.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225840.png" alt="image.png"></p><h4 id="method6-夹逼定理求极限"><a href="#method6-夹逼定理求极限" class="headerlink" title="method6-夹逼定理求极限"></a>method6-夹逼定理求极限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n项和的极限</span><br><span class="line">放缩法，分母放大，缩小，求一个范围</span><br><span class="line">然后用夹逼定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225906.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种形式开n方，放大时--&gt;全部换成最大项；缩小时--&gt;只保留最大项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226412.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226541.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如，根号里常数是2,可以写成1+1,最终还是可以舍去分成3段函数求最大</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226674.png" alt="image.png"></p><h4 id="method7-单调有界准则求极限"><a href="#method7-单调有界准则求极限" class="headerlink" title="method7-单调有界准则求极限"></a>method7-单调有界准则求极限</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226920.png" alt="image.png"></p><h4 id="定积分定义求极限"><a href="#定积分定义求极限" class="headerlink" title="定积分定义求极限"></a>定积分定义求极限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题用夹逼定则做不出来，基本思路是，看做求定积分，将函数平均划分为n部分，每部分1/n</span><br><span class="line">底x高</span><br><span class="line">看做f(x)求0~n的积分,主要是要抽提出f(x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226489.png" alt="image.png"></p><h3 id="无穷小量阶的比较"><a href="#无穷小量阶的比较" class="headerlink" title="无穷小量阶的比较"></a>无穷小量阶的比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">有理化--&gt;分母极限先求</span><br><span class="line">等价代换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227140.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法2.</span><br><span class="line">由于x-&gt;0, 两个根式都趋向于1</span><br><span class="line">构建f(x)=x^(1/2)的拉格朗日中值定理 x2&lt;ζ&lt;x1 </span><br><span class="line">f(x1)-f(x2)=f&#x27;(ζ)(x1-x2)</span><br><span class="line"></span><br><span class="line">方法3.</span><br><span class="line">等价代换</span><br><span class="line">1-cosx~x^2/2 --&gt; 1-(cosx)^α=(α/2)x^2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227233.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231623122.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231627897.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.构成等价代换</span><br><span class="line">方法2.拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012230880.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231913.png" alt="image.png"></p><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="连续性概念"><a href="#连续性概念" class="headerlink" title="连续性概念"></a>连续性概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续需要满足，该点极限=该点函数值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231169.png" alt="image.png"></p><h3 id="间断点定义及分类"><a href="#间断点定义及分类" class="headerlink" title="间断点定义及分类"></a>间断点定义及分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231532.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要有一个极限是无穷,就是无穷间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232300.png" alt="image.png"></p><h3 id="连续性的运算与性质"><a href="#连续性的运算与性质" class="headerlink" title="连续性的运算与性质"></a>连续性的运算与性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本初等函数是指最基本的函数：例如sinx cosx ...，在定义域内连续</span><br><span class="line"></span><br><span class="line">初等函数是指，最基本初等函数经过有限加减乘除运算后得到的例如√cosx-1 ,只在定义区间是定义域内连续的区间，所以只有存在连续区间，才能在区间内连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232062.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于f(x)是初等函数，所以，除x=0,1外处处连续</span><br><span class="line"></span><br><span class="line">x-&gt;0 左右极限没有区别 ，算出极限=-1 ，是第一类可去间断点</span><br><span class="line">x-&gt;1 左右极限不同 ，要分开讨论左右极限，左极限=0，右极限=1 ，是跳跃间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x^n，n趋于无穷，讨论4种情况：|x|&lt;1 、|x|&gt;1 、x=1、x=-1</span><br><span class="line">e^nx ,n趋于无穷，讨论3种情况：x&lt;0 、x&gt;0 、x=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233122.png" alt="image.png"></p><h1 id="高数2-导数-微分"><a href="#高数2-导数-微分" class="headerlink" title="高数2-导数-微分"></a>高数2-导数-微分</h1><h2 id="导数概念"><a href="#导数概念" class="headerlink" title="导数概念"></a>导数概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">导数：函数在哪一点的变化率</span><br><span class="line">导数定义是△x-&gt;0 的极限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该点左函数的极限值=该点函数值，所以左连续，可以直接求导</span><br><span class="line">该点右函数的极限值!=该点函数值，右不连续，右导数不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234982.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234642.png" alt="image.png"></p><h2 id="微分概念"><a href="#微分概念" class="headerlink" title="微分概念"></a>微分概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">微分：函数改变量的近似值，忽略了高阶无穷小</span><br><span class="line"></span><br><span class="line">eg.A△x--&gt;是一个关于x的线性函数--&gt;也称为线性主部分(微分)</span><br><span class="line"></span><br><span class="line">一元函数里面：可微等价于可导</span><br><span class="line">多元函数里面：可微=&gt;可导 ，可导不能推出可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234144.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235565.png" alt="image.png"></p><h2 id="导数几何意义"><a href="#导数几何意义" class="headerlink" title="导数几何意义"></a>导数几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可导=&gt;切线存在</span><br><span class="line">切线存在 不一定 可导 (切线斜率为∞，导数不存在)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235642.png" alt="image.png"></p><h2 id="微分几何意义"><a href="#微分几何意义" class="headerlink" title="微分几何意义"></a>微分几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">微分几何意义=切线上的增量dy=A△x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235182.png" alt="image.png"></p><h2 id="连续-可微-可导关系"><a href="#连续-可微-可导关系" class="headerlink" title="连续-可微-可导关系"></a>连续-可微-可导关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一元函数 </span><br><span class="line"></span><br><span class="line">可导：是指，f(x)在x0点处导数存在</span><br><span class="line">连续：f(x)在点x0处连续</span><br><span class="line"></span><br><span class="line">可微&lt;=&gt;可导 </span><br><span class="line">连续不一定可导(尖点)，所以连续不一定可微；</span><br><span class="line">可导/可微=&gt;连续 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)在x0的邻域内一阶可导，推不出，导函数在x0连续，也推不出，导函数在x0的极限存在</span><br><span class="line"></span><br><span class="line">所以总结：</span><br><span class="line">f(x)n阶可导 ,洛必达中中最多出现n-1阶导数</span><br><span class="line">f(x)n阶导数连续，洛必达可以出现n阶导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236777.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x趋于0的函数极限,与x=0的值毫无关系</span><br><span class="line">排除AB</span><br><span class="line">C:x=0处可导，说明函数在x=0处连续，既然连续，那么x=0处的极限存在即lim x-&gt;0 (f(x)/x)存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237415.png" alt="image.png"></p><h2 id="导数公式及求导法则"><a href="#导数公式及求导法则" class="headerlink" title="导数公式及求导法则"></a>导数公式及求导法则</h2><h3 id="基本初等函数求导公式"><a href="#基本初等函数求导公式" class="headerlink" title="基本初等函数求导公式"></a>基本初等函数求导公式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237303.png" alt="image.png"></p><h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237240.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">奇函数的导数是偶函数</span><br><span class="line">偶函数的导数是奇函数  </span><br><span class="line"></span><br><span class="line">周期函数的导数任然是周期函数</span><br><span class="line"></span><br><span class="line">运用了奇函数过(0,0)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237438.png" alt="image.png"></p><h3 id="隐函数求导法则"><a href="#隐函数求导法则" class="headerlink" title="隐函数求导法则"></a>隐函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238267.png" alt="image.png"></p><h3 id="反函数求导法则"><a href="#反函数求导法则" class="headerlink" title="反函数求导法则"></a>反函数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看到反函数，先写出原函数</span><br><span class="line">反函数对y求导数=原函数对x求导数的倒数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238483.png" alt="image.png"></p><h3 id="参数方程求导法则"><a href="#参数方程求导法则" class="headerlink" title="参数方程求导法则"></a>参数方程求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238001.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238200.png" alt="image.png"></p><h3 id="对数求导法则"><a href="#对数求导法则" class="headerlink" title="对数求导法则"></a>对数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两边ln</span><br><span class="line">两边求导。左边对y求，右边对x求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取对数，把连乘连除变成加减</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239343.png" alt="image.png"></p><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><h3 id="高阶导数定义"><a href="#高阶导数定义" class="headerlink" title="高阶导数定义"></a>高阶导数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n阶可导，那么就具有&lt;n阶的一切导数的存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239942.png" alt="image.png"></p><h3 id="常用高阶导数"><a href="#常用高阶导数" class="headerlink" title="常用高阶导数"></a>常用高阶导数</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239042.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240996.png" alt="image.png"></p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="导数定义应用"><a href="#导数定义应用" class="headerlink" title="导数定义应用"></a>导数定义应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种题，基本思路，认为凑成f(x)导数的定义式</span><br><span class="line"></span><br><span class="line">填空题，直接代入一个具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240723.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代入具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际要化为导数的定义式，转变化为求x=0的导数问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241229.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论：如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241771.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由定义式推出导数存在，要求左右极限都存在</span><br><span class="line">A.  h-&gt;+∞ ，1/h-&gt;0+  不行</span><br><span class="line">B.  n-&gt;∞，默认n-&gt;+∞,1/n-&gt;0+ ,不行</span><br><span class="line">C.  定义式求导数要求两个点,一定一动，两个点都动，不行</span><br><span class="line">D.  h-&gt;0，默认h-&gt;0+ &amp;&amp; h-&gt;0- ,可以</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241531.png" alt="image.png"></p><h3 id="复合-隐函-参数求导应用"><a href="#复合-隐函-参数求导应用" class="headerlink" title="复合-隐函-参数求导应用"></a>复合-隐函-参数求导应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要求二阶导数</span><br><span class="line">根据方程</span><br><span class="line">分别求出x=1时</span><br><span class="line">y=?</span><br><span class="line">y&#x27;=?</span><br><span class="line">最后</span><br><span class="line">y&#x27;&#x27;=?</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242620.png" alt="image.png"></p><h3 id="高阶导数应用"><a href="#高阶导数应用" class="headerlink" title="高阶导数应用"></a>高阶导数应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242698.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.高阶导数公式</span><br><span class="line">方法2.泰勒公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242415.png" alt="image.png"></p><h3 id="导数应用"><a href="#导数应用" class="headerlink" title="导数应用"></a>导数应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对方程求导</span><br><span class="line">求出y&#x27;-&gt;斜率</span><br><span class="line">继而求出切线方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242257.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243534.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243968.png" alt="image.png"></p><h1 id="高数3-微分中值定理及导数应用"><a href="#高数3-微分中值定理及导数应用" class="headerlink" title="高数3-微分中值定理及导数应用"></a>高数3-微分中值定理及导数应用</h1><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微分中值定理目的是为了</span><br><span class="line">建立函数与导数之间的关系</span><br></pre></td></tr></table></figure><ul><li><code>费马定理</code></li><li><code>罗尔定理</code></li><li><code>拉格朗日中值定理</code></li><li><code>柯西中值定理</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011611443.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实际上就是 x-&gt;0 处的泰勒展开</span><br><span class="line"></span><br><span class="line">建立了 函数 与 高阶导数 之间的关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612549.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由罗尔定理推导出拉格朗日中值定理和柯西中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252354448.jpg" alt="Screenshot_2023-05-24-20-47-07-55_769977972775e0c.jpg"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252355825.jpg" alt="Screenshot_2023-05-24-21-00-10-12_769977972775e0c.jpg"></p><h3 id="导数应用-1"><a href="#导数应用-1" class="headerlink" title="导数应用"></a>导数应用</h3><h4 id="函数极值"><a href="#函数极值" class="headerlink" title="函数极值"></a>函数极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">驻点：导数为0的点</span><br><span class="line">极值点不一定驻点 |x|</span><br><span class="line">驻点不一定是极值点 x^3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612417.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612620.png" alt="image.png"></p><h4 id="函数最值"><a href="#函数最值" class="headerlink" title="函数最值"></a>函数最值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">极值点是函数内部领域内的“凸点或尖点”，可以有多个，不一定是最大最小</span><br><span class="line">最值点，可以是某一个极值点，也可以是端点</span><br></pre></td></tr></table></figure><ul><li><code>连续函数f(x)</code>在（a,b）内有<code>多个极值点</code>，那么最值点要么是极值点，要么是端点</li><li><code>连续函数f(x)</code>在（a,b）内有`唯一极值点·，那么这个极值点就是(a,b)内的最大值或最小值点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求最值3部曲：</span><br><span class="line">- 求出函数f(x)的所有驻点、不可导点</span><br><span class="line">- 分别求出各自函数值</span><br><span class="line">- 比较函数值大小</span><br></pre></td></tr></table></figure><h4 id="函数凹凸性"><a href="#函数凹凸性" class="headerlink" title="函数凹凸性"></a>函数凹凸性</h4><ul><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&gt;0</code>,函数就是<code>凹的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&lt;0</code>,函数就是<code>凸的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)=0</code>,该点就是函数<code>拐点</code>，左右凹凸性变化</li></ul><h4 id="函数的渐近线"><a href="#函数的渐近线" class="headerlink" title="函数的渐近线"></a>函数的渐近线</h4><ul><li><code>水平渐近线</code></li><li><code>垂直渐进线</code></li><li><code>斜渐近线</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613369.png" alt="image.png"></li></ul><h4 id="弧微分与曲率"><a href="#弧微分与曲率" class="headerlink" title="弧微分与曲率"></a>弧微分与曲率</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613748.png" alt="image.png"></p><h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="求函数极值最值及确定函数凹向与拐点"><a href="#求函数极值最值及确定函数凹向与拐点" class="headerlink" title="求函数极值最值及确定函数凹向与拐点"></a>求函数极值最值及确定函数凹向与拐点</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613878.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613028.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这种分段函数，求导数和极值问题</span><br><span class="line"></span><br><span class="line">求f&#x27;(x)</span><br><span class="line">1.首先要判断断点处，导数是否存在(即左导数是否等于右导数)</span><br><span class="line">2.根据在断点处导数是否存在，再写f&#x27;(x)，以判断是否在断点处要写等号</span><br><span class="line"></span><br><span class="line">求f(x)极值</span><br><span class="line">3.极值点是驻点或不可导点，列出驻点、不可导点</span><br><span class="line">4.在不可导电需要判断函数是否连续(不能跳跃),连续就继续求，不连续就不属于极值点</span><br><span class="line">5.分别求出驻点、不可导点，根据f&#x27;(x)的正负形判断极大极小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614666.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614341.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数选取的重要性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614024.png" alt="image.png"></p><p><code>画图</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614910.png" alt="image.png"></p><h3 id="求渐近线"><a href="#求渐近线" class="headerlink" title="求渐近线"></a>求渐近线</h3><ul><li><code>ln(1+e^x)-x=ln[(1+e^x)/e^x]</code></li><li>或者<code>ln(1+e^x)-x=x+ln(e^-x + 1)-x</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614026.png" alt="image.png"></li></ul><p><code>去绝对值，分别讨论正负</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614805.png" alt="image.png"></p><h3 id="方程的根"><a href="#方程的根" class="headerlink" title="方程的根"></a>方程的根</h3><p><code>证明根的存在性</code></p><ul><li>罗尔定理：两端为零，之间至少存在一个导数为零</li><li>零点定理：左端右端一正一负，之间至少存在一个值为零<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615914.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615726.png" alt="image.png"></p><p><code>给定根数量，求范围</code></p><ul><li>画图<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615579.png" alt="image.png"></li></ul><h3 id="不等式证明"><a href="#不等式证明" class="headerlink" title="不等式证明"></a>不等式证明</h3><p><code>1.利用拉格朗日中值定理</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)=lnx</span><br><span class="line">至少存在一个ζ</span><br><span class="line">f(1+x)-f(1)=f&#x27;(ζ)(1+x-1)</span><br><span class="line">然后放大分母为1+x,--&gt;最小</span><br><span class="line">缩小分母--&gt;最大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615051.png" alt="image.png"></p><p><code>2.利用单调性证明不等式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616772.png" alt="image.png"></p><h3 id="中值定理的证明"><a href="#中值定理的证明" class="headerlink" title="中值定理的证明"></a>中值定理的证明</h3><p><code>两次罗尔定理</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616005.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616926.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011617692.png" alt="image.png"></p><h1 id="高数4-不定积分"><a href="#高数4-不定积分" class="headerlink" title="高数4-不定积分"></a>高数4-不定积分</h1><h2 id="内容概要-1"><a href="#内容概要-1" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="不定积分概念性质"><a href="#不定积分概念性质" class="headerlink" title="不定积分概念性质"></a>不定积分概念性质</h3><h4 id="原函数存在定理"><a href="#原函数存在定理" class="headerlink" title="原函数存在定理"></a><code>原函数存在定理</code></h4><ul><li>若f(x)<code>在区间I连续</code>，则f(x)在区间I上一定存在原函数(导函数连续，原函数必定连续)</li><li>若f(x)在区间I上<code>有第一类间断点</code>，则一定没有原函数</li><li>若f(x)在区间I上<code>有第二类间断点</code>，则可能有原函数(有原函数的导数不一定连续)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011039122.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数连续,所以有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011041496.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一类间断点(跳跃)，一定没有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011042885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二类间断点(震荡)，可能有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011047495.png" alt="image.png"></p><h4 id="不定积分性质"><a href="#不定积分性质" class="headerlink" title="不定积分性质"></a>不定积分性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011053012.png" alt="image.png"></p><h4 id="不定积分基本公式"><a href="#不定积分基本公式" class="headerlink" title="不定积分基本公式"></a>不定积分基本公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cscx=1/sinx</span><br><span class="line">secx=1/cosx</span><br><span class="line">cotx=1/tanx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141412806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011110068.png" alt="image.png"></p><h3 id="三大积分方法"><a href="#三大积分方法" class="headerlink" title="三大积分方法"></a>三大积分方法</h3><h4 id="第一类换元-凑微分"><a href="#第一类换元-凑微分" class="headerlink" title="第一类换元(凑微分)"></a>第一类换元(凑微分)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011121307.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011123543.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011130757.png" alt="image.png"></p><h4 id="第二类换元法-去根号-1"><a href="#第二类换元法-去根号-1" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011134848.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153689.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153143.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154683.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154305.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152947.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152136.png" alt="image.png"></p><h4 id="第三类分部积分"><a href="#第三类分部积分" class="headerlink" title="第三类分部积分"></a>第三类分部积分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">何时用？</span><br><span class="line">出现两类不同函数相乘</span><br><span class="line">如何用？</span><br><span class="line">Pn(x)代表多项式；如下，画圈的代表先凑进去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011156648.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238404.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011242946.png" alt="image.png"></p><h3 id="三类常见可积函数积分"><a href="#三类常见可积函数积分" class="headerlink" title="三类常见可积函数积分"></a>三类常见可积函数积分</h3><h4 id="可积函数概念"><a href="#可积函数概念" class="headerlink" title="可积函数概念"></a>可积函数概念</h4><p><code>可积函数</code>，是指积分可以用<code>初等函数</code>的<code>加减乘除表示</code>，下列是三种常见积不出的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011244308.png" alt="image.png"></p><h4 id="常见可积函数"><a href="#常见可积函数" class="headerlink" title="常见可积函数"></a>常见可积函数</h4><h5 id="有理函数积分"><a href="#有理函数积分" class="headerlink" title="有理函数积分"></a>有理函数积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有理函数积分都能积分出来</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011246229.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011247873.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011256885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回顾之前的有理函数积分方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011259165.png" alt="image.png"></p><h5 id="三角有理式积分-1"><a href="#三角有理式积分-1" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三角函数可以代换为有理函数，因为有理函数都能积分出来，所以三角函数一定能积分出来</span><br><span class="line"></span><br><span class="line">左三角函数积分有两类方法</span><br><span class="line">- 万能代换(万不得已不使用)</span><br><span class="line">- 三角变形、换元、分部</span><br><span class="line"></span><br><span class="line">总结的三个简单规律：</span><br><span class="line">下图R(-sinx,cosx)=-R(sinx,cosx)--&gt;意思是原函数用-sinx替换sinx，只需在函数前加-,这种一般换元cosx=u</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011302914.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011305711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332272.png" alt="image.png"></p><h5 id="简单无理式积分"><a href="#简单无理式积分" class="headerlink" title="简单无理式积分"></a>简单无理式积分</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353852.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353702.png" alt="image.png"></p><h2 id="不定积分常考题"><a href="#不定积分常考题" class="headerlink" title="不定积分常考题"></a>不定积分常考题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011452143.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分段函数，求原函数</span><br><span class="line">- 首先保证原函数F(x)连续(这样才能处处可导)--&gt;断点处，原函数要连续--&gt;趋于断点处左右原函数极限相等</span><br><span class="line">- 可以得到c1 c2关系--&gt; c2 = c1 + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011503967.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分段函数求原函数</span><br><span class="line">- f(x)处处有定义--&gt;原函数F(x)连续</span><br><span class="line">- 原函数要连续--&gt;满足断点处连续--&gt;左右极限相等</span><br><span class="line">- 得到c1 c2关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011509154.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011603033.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下方的</span><br><span class="line">有理函数积分，将分子 利用分母有的两种因子 凑成1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011623381.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两次分部积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011627054.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011634510.png" alt="image.png"></p><h1 id="高数5-定积分"><a href="#高数5-定积分" class="headerlink" title="高数5-定积分"></a>高数5-定积分</h1><h2 id="内容概要-2"><a href="#内容概要-2" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="定积分的概念"><a href="#定积分的概念" class="headerlink" title="定积分的概念"></a>定积分的概念</h3><h4 id="定积分定义"><a href="#定积分定义" class="headerlink" title="定积分定义"></a>定积分定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011722857.png" alt="image.png"></p><h4 id="定积分存在充分条件"><a href="#定积分存在充分条件" class="headerlink" title="定积分存在充分条件"></a>定积分存在充分条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定积分存在就是可积</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011728280.png" alt="image.png"></p><h4 id="定积分存在必要条件"><a href="#定积分存在必要条件" class="headerlink" title="定积分存在必要条件"></a>定积分存在必要条件</h4><p><code>可积</code>=&gt;<code>有界</code>(反过来不成立)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011731879.png" alt="image.png"></p><h4 id="定积分几何意义"><a href="#定积分几何意义" class="headerlink" title="定积分几何意义"></a>定积分几何意义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011733974.png" alt="image.png"></p><h3 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h3><h4 id="不等式性质-1"><a href="#不等式性质-1" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011736842.png" alt="image.png"></p><h4 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)的证明</span><br><span class="line">- f(x)在区间[a,b]连续，即导函数连续，必有原函数F(x)，存在F(a)-F(b)=F&#x27;(ζ)(a-b),拉格朗日中值定理</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011741252.png" alt="image.png"></p><h3 id="积分上限的函数"><a href="#积分上限的函数" class="headerlink" title="积分上限的函数"></a>积分上限的函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于第二个定理</span><br><span class="line">若f(x)是奇函数，那么0到x对f(t)dt积分是偶函数，积分下限可以是任意常数，相当于偶函数+常数</span><br><span class="line">但是对于f(x)是偶函数，积分下限只能是0，因为奇函数+常数 就不是奇函数了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012252269.png" alt="image.png"></p><h3 id="定积分的计算-2"><a href="#定积分的计算-2" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012304896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012306157.png" alt="image.png"></p><h2 id="常考题型-1"><a href="#常考题型-1" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="定积分定义、几何性质应用"><a href="#定积分定义、几何性质应用" class="headerlink" title="定积分定义、几何性质应用"></a>定积分定义、几何性质应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这类题型</span><br><span class="line">- 提取1/n</span><br><span class="line">- 写成定积分形式求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021020359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021022319.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021026083.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021028407.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.常规根据上下限，算出面积</span><br><span class="line">解法2(快速).根据定积分奇偶性，根据图像,被积函数是奇函数，所以原函数是偶函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021036825.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021042331.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.f&#x27;&#x27;(x)&gt;0 ,函数凹的，根据定积分性质</span><br><span class="line">解法2.排除法，找一个满足题目要求的函数，代入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021050490.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分中值定理+微分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021421295.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021422494.png" alt="image.png"></p><h3 id="定积分的计算-3"><a href="#定积分的计算-3" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+点火公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021425241.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+几何意义</span><br><span class="line">常用的几种圆的积分形式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021428611.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用公式∫0-&gt;π xf(sinx) dx = π/2 ∫0-&gt;π f(sinx) dx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021433961.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021443943.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021445163.png" alt="image.png"></p><h3 id="变上限积分"><a href="#变上限积分" class="headerlink" title="变上限积分"></a>变上限积分</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021510612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521763.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021509396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于上下限有x的，且被积分函数含有x的因式因子，首先将x当成常数，将x提出到外面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521474.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意x&gt;=0,∫-1-&gt;x  包括了-1-&gt;0 要分两段计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021542735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021554116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021613968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解法2.利用积分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021610552.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021606709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021614121.png" alt="image.png"></p><h1 id="高数5-反常积分"><a href="#高数5-反常积分" class="headerlink" title="高数5-反常积分"></a>高数5-反常积分</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021617496.png" alt="image.png"></p><h2 id="内容概要-3"><a href="#内容概要-3" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="无穷区间上的反常积分"><a href="#无穷区间上的反常积分" class="headerlink" title="无穷区间上的反常积分"></a>无穷区间上的反常积分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021640001.png" alt="image.png"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021647869.png" alt="image.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找合适的p函数，p的取值，可以是，分母x的幂次-分子x的幂次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021657042.png" alt="image.png"></p><h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022201133.png" alt="image.png"></p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论中：画蓝线的为无界点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022207691.png" alt="image.png"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分上下限都是无界点，需要分别算--&gt;拆成两部分0-&gt;1/2 和1/2-&gt;1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022208858.png" alt="image.png"></p><h2 id="常考题型-2"><a href="#常考题型-2" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="反常积分敛散性"><a href="#反常积分敛散性" class="headerlink" title="反常积分敛散性"></a>反常积分敛散性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126385.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126832.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含无穷区间，和无界点，需要拆成两部分分别计算</span><br><span class="line">0-&gt;1      此时，主要看0点(无界点)，(1+x)^b-&gt;1 ,,所以p积分指数取a  </span><br><span class="line">1-&gt;无穷   此时,主要看无穷区间，1+x--&gt;x ,所以p积分指数取a+b   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031134500.png" alt="image.png"></p><h3 id="反常积分计算"><a href="#反常积分计算" class="headerlink" title="反常积分计算"></a>反常积分计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031156742.png" alt="image.png"></p><h1 id="高数6-定积分应用"><a href="#高数6-定积分应用" class="headerlink" title="高数6-定积分应用"></a>高数6-定积分应用</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031157707.png" alt="image.png"></p><h2 id="内容概要-4"><a href="#内容概要-4" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="几何应用"><a href="#几何应用" class="headerlink" title="几何应用"></a>几何应用</h3><h4 id="平面图形面积"><a href="#平面图形面积" class="headerlink" title="平面图形面积"></a>平面图形面积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本质上还是二重积分，利用二重积分更加容易</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031327184.png" alt="image.png"></p><h4 id="旋转体体积"><a href="#旋转体体积" class="headerlink" title="旋转体体积"></a>旋转体体积</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031344267.png" alt="image.png"></p><h4 id="曲线弧长"><a href="#曲线弧长" class="headerlink" title="曲线弧长"></a>曲线弧长</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031345840.png" alt="image.png"></p><h2 id="常考题型-3"><a href="#常考题型-3" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="几何应用-1"><a href="#几何应用-1" class="headerlink" title="几何应用"></a>几何应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用二重积分，先对x求积分，再对y求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031355804.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031401556.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427671.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427969.png" alt="image.png"></p><h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031500543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031459946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031508079.png" alt="image.png"></p><h1 id="高数7-常微分方程"><a href="#高数7-常微分方程" class="headerlink" title="高数7-常微分方程"></a>高数7-常微分方程</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031510341.png" alt="image.png"></p><h2 id="内容概要-5"><a href="#内容概要-5" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="常微分方程概念"><a href="#常微分方程概念" class="headerlink" title="常微分方程概念"></a>常微分方程概念</h3><hr><p><code>微分方程</code>：含有未知数导数的方程称为微分方程<br><code>微分方程的阶</code>：含有的未知数导数的最高阶导数的阶数<br><code>微分方程的解</code>：例如微分方程<code>y&#39;&#39;=e^x</code>，那么解可以是<code>y=e^x ，e^x + c1x , e^x + c1x + c2</code><br><code>微分方程的通解</code>：上面<code>y=e^x + c1x + c2</code>就是<code>y&#39;&#39;=e^x</code>的通解<br><code>微分方程的特解</code>：<code>y=e^x , e^x + c1x</code>都是特解<br><code>积分曲线</code>：微分方程的解对应的那条曲线就是微分方程的积分曲线</p><h3 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h3><hr><h4 id="可分离变量微分方程"><a href="#可分离变量微分方程" class="headerlink" title="可分离变量微分方程"></a>可分离变量微分方程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以将dx,dy分别移到两边，然后求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031657268.png" alt="image.png"></p><h4 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031703516.png" alt="image.png"></p><h4 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031751173.png" alt="image.png"></p><h4 id="伯努利方程及全微分方程"><a href="#伯努利方程及全微分方程" class="headerlink" title="伯努利方程及全微分方程"></a>伯努利方程及全微分方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031759927.png" alt="image.png"></p><h3 id="可降阶方程"><a href="#可降阶方程" class="headerlink" title="可降阶方程"></a>可降阶方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最简单</span><br><span class="line">2.基本思路，将y&#x27;替换为P,转换为一阶微分方程计算</span><br><span class="line">3.令y&#x27;=P，则y&#x27;&#x27;=(dP/dy)*P   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031811741.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031815908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031823129.png" alt="image.png"></p><h3 id="高阶线性微分方程"><a href="#高阶线性微分方程" class="headerlink" title="高阶线性微分方程"></a>高阶线性微分方程</h3><h4 id="变系数线性微分方程"><a href="#变系数线性微分方程" class="headerlink" title="变系数线性微分方程"></a>变系数线性微分方程</h4><hr><p><code>齐次线性微分方程</code><br><code>非齐次线性微分方程</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时还停留在理论层面，实际问题不好求特解</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031857961.png" alt="image.png"></p><h4 id="常系数齐次线性微分方程"><a href="#常系数齐次线性微分方程" class="headerlink" title="常系数齐次线性微分方程"></a>常系数齐次线性微分方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与线性齐次微分方程对比不同点，实际上就是，y导数的系数是常数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031901716.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031905608.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031905608.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031925959.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031926834.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三阶，三解，单独拆开看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031944218.png" alt="image.png"></p><h4 id="常系数非齐次线性微分方程"><a href="#常系数非齐次线性微分方程" class="headerlink" title="常系数非齐次线性微分方程"></a>常系数非齐次线性微分方程</h4><hr><p>非齐次线性方程的解=<code>齐次通解</code>+<code>非齐次特解</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找特解</span><br><span class="line">1.k值看 λ 是几重根</span><br><span class="line">2.k值看 α+iβ 是几重根</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032048454.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.确定非齐次项类型</span><br><span class="line">2.根据特征方程特征根，得出齐次方程的通解</span><br><span class="line">3.设出合适非齐次特解，根据非齐次项得知 λ ,再根据λ比较特征方程的根，看是几重根,本题λ=0 != r,所以</span><br><span class="line">  k=0</span><br><span class="line">4.将假设的y*带回方程，求出系数</span><br><span class="line">5.非齐次线性方程的解=`齐次通解`+`非齐次特解`</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032101045.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032109778.png" alt="image.png"></p><h4 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D^2--&gt;r^2</span><br><span class="line">D--&gt;r</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032114735.png" alt="image.png"></p><h2 id="常考题型-4"><a href="#常考题型-4" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="方程求解"><a href="#方程求解" class="headerlink" title="方程求解"></a>方程求解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的齐次方程求解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131818514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131914887.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判别类型：二阶(导数是二阶导数)  线性  常系数 齐次 微分方程 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131903867.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二阶 非齐次 线性 微分方程</span><br><span class="line">非其次项分为两种类型，因为非齐次线性微分方程的解具有叠加性</span><br><span class="line">所以可以分别设两种解，然后分别求出，再相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132117987.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二阶齐次线性微分方程,选取对应方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132132649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先判断(1/2)e^2x 只能是齐次的通解，因为如果是非齐次特解，那么代入方程得不到ce^x</span><br><span class="line">2.然后判断xe^x，是非齐次的特解，因为如果是齐次通解，由于是xe^x形式，原齐次特征方程特征根必然是二重根，且为1，但是之前已经知道一个齐次通解--&gt;其中一个根可知=2,；矛盾，所以必然是非齐次特解</span><br><span class="line">3.不难判断最后一个是齐次通解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132147848.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经典例题，多看看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132213446.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由二阶微分方程可知--&gt;y二阶可导--&gt;洛必达可以洛到一阶导数--&gt;2x/y&#x27;(0)--&gt;还是0/0型--&gt;由二阶微分方程可知y&#x27; y e^3x都连续，所以y&#x27;&#x27;也连续--&gt;所以可以洛到二阶导数--&gt;2/y&#x27;&#x27;(0)--&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132221621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f括号里的变量和d后面的变量相同，就无所谓是t还是t/3。变量前面的d表示你对该变量求导。所以f(t)dt和f(t/3)dt是等价的表达式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132308460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">综合性，很强</span><br><span class="line">1.令x-t=u，便于求导</span><br><span class="line">2.第二步处理，分开进行求导</span><br><span class="line">3.最终得到一阶线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132321419.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.分析微分方程类型，二阶微分方程，但是没有y，不属于高阶类型，降阶，令y&#x27;=p,则y&#x27;&#x27;=p&#x27;</span><br><span class="line">2.得到xp&#x27;-p+2=0;--&gt;线性微分方程，带对应公式</span><br><span class="line">3.这一步关键，积分过程中x&gt;0,所得y通解x&gt;0,所以不能直接代入y(0),因为是连续函数，应该取极限</span><br><span class="line">得到C2=0，</span><br><span class="line">4.旋转体体积积分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141104530.png" alt="image.png"></p><h1 id="高数8-多元函数微分学"><a href="#高数8-多元函数微分学" class="headerlink" title="高数8-多元函数微分学"></a>高数8-多元函数微分学</h1><h2 id="重极限-连续-偏导数-全微分"><a href="#重极限-连续-偏导数-全微分" class="headerlink" title="重极限-连续-偏导数-全微分"></a>重极限-连续-偏导数-全微分</h2><h3 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">证明该极限不存在</span><br><span class="line">1.假设y=kx;</span><br><span class="line">2.代入原式，得到极限=k/1+k^2</span><br><span class="line">3.由于极限随k变化而变化，所以极限不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181231264.png" alt="image.png"></p><h3 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与一元函数性质类似</span><br><span class="line">多元函数不考察间断点及其分类，因为过于复杂</span><br><span class="line">多元主要考察用定义判断，分段函数，在分界点上的连续性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181237219.png" alt="image.png"></p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数用的是偏增量</span><br><span class="line">偏导数本质上就是一元函数导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247801.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数几何意义</span><br><span class="line">偏x导数 : 作过y=y0垂直于xy平面的平面，与空间曲面上交于一曲线，这条曲线沿x轴方向的导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247505.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果函数在D内连续，混合偏导数与偏导次序无关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181254091.png" alt="image.png"></p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义法-判断二元函数是否可微？</span><br><span class="line">1.首先判断x、y的偏导数是否都存在，如果有1个不存在，肯定不可微</span><br><span class="line">2.两个偏导数存在，接着根据全微分定义，看O(ρ)是否是ρ的高阶无穷小，如果不是就不可微</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181401379.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">充分条件-判断是否可微?</span><br><span class="line">两个偏导数在(x0,y0)处连续，则函数在(x0,y0)一定可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181405682.png" alt="image.png"></p><h3 id="连续-可偏导-可微关系"><a href="#连续-可偏导-可微关系" class="headerlink" title="连续-可偏导-可微关系"></a>连续-可偏导-可微关系</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181424194.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数存在(x、y方向偏导存在、可偏导)--&gt;可能会有缺失,所以可能不连续，可微更推不出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181451922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续(四面八方不存在空缺)--&gt;面上可能有尖点，不存在切平面，也可能不存在切线</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181441922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微--&gt;某点有切平面(一定连续、可导)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181440267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续--&gt;等级最高</span><br></pre></td></tr></table></figure><h3 id="常考题型-5"><a href="#常考题型-5" class="headerlink" title="常考题型"></a>常考题型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断在点(0,0)连不连续： 求x-&gt;0,y-&gt;0 时，函数的极限。该极限之前求过，不存在，所以不连续</span><br><span class="line">2.判断在点(0,0)处偏导数存不存在，用定义式，先求偏x，令y=0代入，发现分子恒=0，分母趋近与0却不等于0，所以极限=0.偏x导数存在；接着求p偏y，令x=0...</span><br><span class="line">3.最后得出不连续，偏导存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181746558.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181754311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种填空题，一眼令f(x,y)=2x-y+2, dz=Adx+Bdy</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181824197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.直接法</span><br><span class="line">题目对x偏导数&gt;0 ,说明z随x增大而增大;偏y&lt;0,随y增大而减小</span><br><span class="line"></span><br><span class="line">2.特殊方程法</span><br><span class="line">根据题目要求，设一个函数，代入数值求证</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181859413.png" alt="image.png"></p><h4 id="四个经典反例"><a href="#四个经典反例" class="headerlink" title="四个经典反例"></a>四个经典反例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续，但不可导</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181842665.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可导但不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181843326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可导但不可微例子</span><br><span class="line"></span><br><span class="line">1.先判断可不可微，两部曲--a.判断两个偏导存不存在 b.求(△z-A△x-B△y)/(△x^2 +△y^2)^1/2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181841705.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微但偏导数不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181854359.png" alt="image.png"></p><h2 id="多元函数微分法"><a href="#多元函数微分法" class="headerlink" title="多元函数微分法"></a>多元函数微分法</h2><h3 id="复合函数微分法"><a href="#复合函数微分法" class="headerlink" title="复合函数微分法"></a>复合函数微分法</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192118819.png" alt="image.png"></p><h3 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如何判断谁是谁的函数？</span><br><span class="line">F&#x27;z(x0,y0,z0)!=0 ==&gt; 说明z是x、y的函数 =&gt;z=f(x,y)</span><br><span class="line">同理如果F&#x27;x(x0,y0,z0) != 0 ==&gt; 说明x是y、z的函数 ==&gt;x=f(y,z)</span><br><span class="line"></span><br><span class="line">2.由方程F(x,y,z)=0 确定的隐函数z=z(x,y)</span><br><span class="line">a.该函数在点P(x0,y0,z0)的某一领域内有连续偏导数</span><br><span class="line">b.F(x0,y0,z0)=0</span><br><span class="line">c.Fz&#x27;(x0,y0,z0)!=0</span><br><span class="line">==&gt;则方程F(x,y,z)=0,在点P(x0,y0,z0)的某一邻域可</span><br><span class="line">   唯一确定一个具有连续偏导数的函数 z=z(x,y)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192133986.png" alt="image.png"></p><h3 id="常考题型-6"><a href="#常考题型-6" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="复合函数偏导数与全微分"><a href="#复合函数偏导数与全微分" class="headerlink" title="复合函数偏导数与全微分"></a>复合函数偏导数与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.直接导两次</span><br><span class="line">方法2.先导一次，然后将y=2代入--&gt;只剩下x的函数--&gt;求x=0时的导数--&gt;运用导数定义</span><br><span class="line">      --&gt;求x=0处导数--&gt; f(x)-f(0)/x-0 --&gt; 求极限=4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192147510.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.换元</span><br><span class="line">考到了微分的有理运算法则</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192210116.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192220636.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∂z/∂x = (∂z/∂u)*(∂u/∂/x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数z=f(u,v)</span><br><span class="line">fu&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f1&#x27; </span><br><span class="line">fv&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f2&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192245416.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192300736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f12&#x27;=f21&#x27;本质是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192317760.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种求具体某一点的二阶偏导数</span><br><span class="line">可以先求出一阶偏x导数之后，代入x的值</span><br><span class="line">然后继续求偏y，不影响，更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192329042.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.多元复合求偏导</span><br><span class="line">2.微分方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336916.png" alt="image.png"></p><h4 id="隐函数偏导与全微分"><a href="#隐函数偏导与全微分" class="headerlink" title="隐函数偏导与全微分"></a>隐函数偏导与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1.微分形式不变性</span><br><span class="line"></span><br><span class="line">两边dK=dM ,看做两个新函数，x,y,z为变量</span><br><span class="line">同时求全微分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201615692.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br><span class="line">利用全微分定义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201627288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">隐函数求偏微分三种方法应用</span><br><span class="line">1.两边对x求导</span><br><span class="line">2.代隐函数偏导数公式</span><br><span class="line">3.两边求全微分(微分形式不变性)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201637250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252222727.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例13.</span><br><span class="line">方法1.使用隐函数偏导数公式。写成F(x,y,z)=0的形式--&gt;代偏导公式--&gt;再利用全微分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246104.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.利用微分形式不变，对两边求微分，求出dz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246977.png" alt="image.png"></p><h2 id="多元函数的极值与最值"><a href="#多元函数的极值与最值" class="headerlink" title="多元函数的极值与最值"></a>多元函数的极值与最值</h2><hr><h3 id="无约束极值"><a href="#无约束极值" class="headerlink" title="无约束极值"></a>无约束极值</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252310840.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对于二元函数,极值不一定是驻点，驻点不一定是极值</span><br><span class="line">驻点推不出极值，典例xy</span><br><span class="line">极值推不出驻点，典例|x|+|y|</span><br><span class="line"></span><br><span class="line">极值点有三种可能</span><br><span class="line">1.驻点</span><br><span class="line">2.fx&#x27;与fy&#x27;都不存在的点</span><br><span class="line">3.fx=0,且fy不存在;或fy=0且fx不存在的点</span><br><span class="line"></span><br><span class="line">一般只考察第一种可能</span><br><span class="line">--&gt;如何判断驻点是极大值还是极小值还是有没有极值</span><br><span class="line">--&gt;下面这个公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252311524.png" alt="image.png"></p><h3 id="有条件极值与拉格朗日数乘法"><a href="#有条件极值与拉格朗日数乘法" class="headerlink" title="有条件极值与拉格朗日数乘法"></a>有条件极值与拉格朗日数乘法</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">条件极值概念，在某一个约束条件下，函数的极值。</span><br><span class="line"></span><br><span class="line">例如下面这幅图，φ(x,y)=0的条件--&gt;得到一条曲线--&gt;在这条曲线对应的x,y范围内求f(x,y)的极值，这种极值被称为条件极值。</span><br><span class="line"></span><br><span class="line">如何求条件极值？</span><br><span class="line">--&gt;将f(x,y)与φ(x,y)两个函数写成非条件极值的形式</span><br><span class="line">--&gt;F(x,y,λ)分别对x,y,λ求偏导=0，</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br><span class="line"></span><br><span class="line">如果有两个约束条件呢？</span><br><span class="line">--&gt;那就假设四个变量的函数F(x,y,λ,Φ)</span><br><span class="line">--&gt;分别对四个变求偏导数，分别都等于0</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252334882.png" alt="image.png"></p><h3 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261155130.png" alt="image.png"></p><h3 id="常考题型-7"><a href="#常考题型-7" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="求极值"><a href="#求极值" class="headerlink" title="求极值"></a>求极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">根据题目可知全微分dz=xdx+ydy --&gt; fx&#x27;=x ;fy&#x27;=y --&gt; 代入点(0,0) --&gt; 两个偏导数都为0，是驻点(满足了极值点必要条件) --&gt; 接着求二阶偏导数，利用公式AC-B^2 ,判断时极小值还是极大值</span><br><span class="line"></span><br><span class="line">方法2.偏积分(找函数本身)</span><br><span class="line">方法3.凑微分(找函数本身)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261206463.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261222061.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261227562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261239426.png" alt="image.png"></p><h4 id="求最大最小值"><a href="#求最大最小值" class="headerlink" title="求最大最小值"></a>求最大最小值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不考条件极值而考条件最值？</span><br><span class="line">因为求得了驻点，我们无法判断时极大还是极小值。而一个问题如果存在最大值，那么驻点必是最值，所以可以根据最值必存在，推出该驻点是最大还是最小值</span><br><span class="line"></span><br><span class="line">根据条件约束--&gt;写出拉格朗日数乘法--&gt;求出所有可能极值点--&gt;再根据题目隐含意思推出该极值点大概是极大值还是极小值(注意这里没有公式可以得知是极大值还是极小值)。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261248743.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br><span class="line"></span><br><span class="line">像这种全微分为dz=2xdx - 2ydy --&gt;全微分存在说明可微--&gt;fx&#x27;=2x ;fy&#x27;=2y --&gt;驻点只有(0,0),是唯一驻点--&gt;可微说明函数光滑，接着驻点唯一，说明驻点要么是最大值或最小值或单调的水平过渡点。--&gt;意味着二元函数要么是单调的或凸的或凹的--&gt;这些情况都只需要我们求出边界上的极值点与驻点一比较就能得出最大值，最小值</span><br><span class="line"></span><br><span class="line">有两种方法：</span><br><span class="line">方法1.得出驻点之后，根据约束条件函数，将x或y代换，转变为一元函数化条件为无条件，在求边界最值。</span><br><span class="line">方法2.得出驻点之后，构造拉格朗日数乘法，求出边界极值</span><br><span class="line">方法3.参数方程，化条件为无条件，出现这种椭圆的可以转化为参数方程</span><br><span class="line"></span><br><span class="line">最终在与驻点函数值比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301211.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305262253388.png" alt="image.png"></p><h1 id="高数9-二重积分"><a href="#高数9-二重积分" class="headerlink" title="高数9-二重积分"></a>高数9-二重积分</h1><h2 id="二重积分的概念和性质"><a href="#二重积分的概念和性质" class="headerlink" title="二重积分的概念和性质"></a>二重积分的概念和性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二重积分几何意义：区域D内，以函数为顶的，这个圆柱体的体积</span><br><span class="line">二重积分的性质：不等式性质、中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282116780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282118635.png" alt="image.png"></p><h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><h3 id="利用直角坐标计算"><a href="#利用直角坐标计算" class="headerlink" title="利用直角坐标计算"></a>利用直角坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149154.png" alt="image.png"></p><h3 id="利用极坐标计算"><a href="#利用极坐标计算" class="headerlink" title="利用极坐标计算"></a>利用极坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149068.png" alt="image.png"></p><h4 id="适合极坐标计算的二重积分特征"><a href="#适合极坐标计算的二重积分特征" class="headerlink" title="适合极坐标计算的二重积分特征"></a>适合极坐标计算的二重积分特征</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282134528.png" alt="image.png"></p><h3 id="利用对称性奇偶性计算"><a href="#利用对称性奇偶性计算" class="headerlink" title="利用对称性奇偶性计算"></a>利用对称性奇偶性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.如果积分区域关于y轴对称</span><br><span class="line">- f(x,y)为关于x是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于x是奇函数--&gt; 积分就等于0</span><br><span class="line">2.如果积分区域关于x轴对称</span><br><span class="line">- f(x,y)为关于y是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于y是奇函数--&gt; 积分就等于0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282145694.png" alt="image.png"></p><h3 id="利用变量对称性计算"><a href="#利用变量对称性计算" class="headerlink" title="利用变量对称性计算"></a>利用变量对称性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量对称性也称轮换对称性</span><br><span class="line">积分区域关于y=x对称就有如下性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282204438.png" alt="image.png"></p><h3 id="常考题型-8"><a href="#常考题型-8" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="累次积分交换次序或计算"><a href="#累次积分交换次序或计算" class="headerlink" title="累次积分交换次序或计算"></a>累次积分交换次序或计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据积分上下限，画出积分区域</span><br><span class="line">2.根据积分区域重新定限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282210754.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302117455.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">极坐标转化为直角坐标--&gt;画域</span><br><span class="line">右边对ρ积分下限=0 ;对ρ积分上限=cosx;</span><br><span class="line">ρcosθ=0 --&gt; x=0 --&gt;积分区域在x=0上方</span><br><span class="line">ρ^2=x^2+y^2=ρcosθ=x --&gt; 积分区域在x^2+y^2=x的下方</span><br><span class="line">--&gt;最终就是如图所示的半圆区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302126758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题是将直角坐标转化为极坐标</span><br><span class="line">对y=0 --&gt; ρsinθ =0 --&gt; ρ=0</span><br><span class="line">y=(2x-x^2)^0.5 --&gt; y^2=2x-x^2 --&gt; ρ=2cosθ</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302143241.png" alt="image.png"></p><h4 id="二重积分的计算-1"><a href="#二重积分的计算-1" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用轮换对称性质+奇偶对称性</span><br><span class="line">1.积分区域(圆)关于y=x对称</span><br><span class="line">2.因为y是关于y轴的奇函数，积分区域关于y，所以对称积分为0</span><br><span class="line">3.轮换对称，对x^2积分=对y^2积分=1/2(x^2+y^2)积分 --&gt;转换成极坐标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302208501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域--&gt;划分为关于y轴对称的区域+关于x轴对称的区域</span><br><span class="line">2.对xy积分，x是关于x轴的奇函数，y是关于y轴的奇函数--&gt;所以两个部分积分区域积分=0</span><br><span class="line">3.对cosxsiny积分，siny是关于y轴的奇函数，cosx是关于x轴的偶函数--&gt;所以关于x轴对称积分区域=0；只剩下关于y轴对称的积分区域的积分</span><br><span class="line">4.就如A选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302217243.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域,积分区域关于y轴对称</span><br><span class="line">2.将被积函数拆开--&gt;x^2 + 2x + 1 ,其中2x是关于x轴的奇函数,积分区域有时关于y轴对称,</span><br><span class="line">  2x积分=0</span><br><span class="line">3.剩下x^2 + 1,关于x轴的偶函数--&gt;由于积分区域是圆--&gt;化成极坐标好做一点</span><br><span class="line">4.最后点火公式带走</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302233155.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据区域判断被积函数绝对值正负</span><br><span class="line">1.画出的积分区域是一个正方形</span><br><span class="line">2.被积函数有绝对值，所以要讨论函数的正负性</span><br><span class="line">3.发现被积函数是一个圆，小于圆时为负，入D1区域;大于该圆的部分为正，如D2区域</span><br><span class="line">4.于是分开两个区域讨论,圆内的区域，被积函数为负，圆外的积分区域，被积函数为正</span><br><span class="line">5.其中D1部分区域的积分用极坐标，D2部分积分化为正方形区域-圆的区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302253981.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302311344.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302314653.png" alt="image.png"></p><h1 id="高数10-无穷级数"><a href="#高数10-无穷级数" class="headerlink" title="高数10-无穷级数"></a>高数10-无穷级数</h1><h2 id="常数项级数"><a href="#常数项级数" class="headerlink" title="常数项级数"></a>常数项级数</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061714753.png" alt="image.png"></p><h3 id="级数概念"><a href="#级数概念" class="headerlink" title="级数概念"></a>级数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是无穷多个常数项相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720100.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720954.png" alt="image.png"></p><h3 id="级数的性质"><a href="#级数的性质" class="headerlink" title="级数的性质"></a>级数的性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.若一个级数收敛，则其每一项相都乘以常数k,这个级数任然收敛</span><br><span class="line"></span><br><span class="line">2.两个级数收敛，相加相减之后任然收敛，收敛于他们各自极限的和或差</span><br><span class="line"></span><br><span class="line">3.去掉或加上改变有限项不影响级数的敛散性--&gt;也就是说只有后面无穷多项会影响敛散性</span><br><span class="line"></span><br><span class="line">4.收敛级数加括号任然收敛，但是加括号收敛无法推出原级数收敛</span><br><span class="line"></span><br><span class="line">5.如果一个级数收敛--&gt;它的第n项(n趋于无穷)，一定趋近于0</span><br><span class="line">  但是通项趋近于0，不能得到级数收敛(例如∑1/n)</span><br><span class="line">  通项不趋近于0，一定发散</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061730770.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061742981.png" alt="image.png"></p><h3 id="级数的审敛准则"><a href="#级数的审敛准则" class="headerlink" title="级数的审敛准则"></a>级数的审敛准则</h3><h4 id="正项级数"><a href="#正项级数" class="headerlink" title="正项级数"></a>正项级数</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.比较判别法</span><br><span class="line">2.比较法的极限形式</span><br><span class="line">3.比值法</span><br><span class="line">4.根值法</span><br><span class="line">5.积分判别法</span><br><span class="line"></span><br><span class="line">5不常用，1，2,3,4做题比较常用</span><br><span class="line"></span><br><span class="line">1,2 适用范围广 但不方便(因为要找别的函数比较)</span><br><span class="line">3,4 适用范围窄 但方便比较(直接和自己比较)</span><br><span class="line"></span><br><span class="line">通常做题先用3,4 然后做不出再用1,2</span><br><span class="line"></span><br><span class="line">出现a^n 、n! 、n^n --&gt;使用3,4</span><br><span class="line">出现n^p 、ln n 使用1,2</span><br><span class="line"></span><br><span class="line">正项级数与负项级数本质一样，只不过多个负号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061800727.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061801216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802574.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802116.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061816942.png" alt="image.png"></p><h4 id="交错级数"><a href="#交错级数" class="headerlink" title="交错级数"></a>交错级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交错级数--&gt;正负项交替出现，有规律的级数</span><br><span class="line">莱布尼兹准则：</span><br><span class="line">1.若Un单调减小，且趋近于无穷是Un趋近于0，--&gt; 交错级数收敛</span><br><span class="line">2.但是反过来，交错级数收敛无法推出，Un递减</span><br><span class="line">为什么交错级数，Un递减，且Un趋近于0才能推出交错级数收敛？</span><br><span class="line">因为如果Un递减，但不趋向于0而如果是趋向于1，那么级数会在-1 1之间摇摆不可能收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061902443.png" alt="image.png"></p><h4 id="任意项级数"><a href="#任意项级数" class="headerlink" title="任意项级数"></a>任意项级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任意项级数--&gt;有正项有负项，正负项没有规律，正负项都是无穷项</span><br><span class="line">- 既然没有规律，那应该怎么判定是否收敛呢？</span><br><span class="line">- 引入绝对收敛和条件收敛：</span><br><span class="line">1.绝对收敛: 当级数的绝对值收敛那么原级数一定收敛，称原级数绝对收敛</span><br><span class="line">2.条件收敛：如果原级数是收敛的，但是他的绝对值是发散的，那么是条件收敛</span><br><span class="line">- 基本结论： </span><br><span class="line">- 绝对收敛的级数一定是收敛的</span><br><span class="line">- 条件收敛的级数，它的正项构成的级数发散，负向构成的级数也发散</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061917627.png" alt="image.png"></p><h2 id="常考题型-9"><a href="#常考题型-9" class="headerlink" title="常考题型"></a>常考题型</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062156822.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062217881.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062226142.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A.bn收敛 举反例bn=(-1)^n/√n ; an=(-1)^n/√n =&gt;相乘-调和级数1/n 发散</span><br><span class="line"></span><br><span class="line">B.举反例bn=1/n ;an=1/n =&gt; 相乘1/n^2 收敛</span><br><span class="line"></span><br><span class="line">C.</span><br><span class="line">首先</span><br><span class="line">∑|bn| 收敛 =&gt; |bn|-&gt;0 =&gt; |bn|&lt;1 =&gt; |bn|&gt;bn^2 大收则小收</span><br><span class="line">然后</span><br><span class="line">an-&gt;0 =&gt; |an|&lt;1 =&gt; a^2&lt;1 =&gt; an^2bn^2&lt;bn^2  </span><br><span class="line"></span><br><span class="line">D.举反例，与上面反例类似</span><br><span class="line"></span><br><span class="line">总结：常用结论--&gt; |bn|收敛=&gt; bn^2收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062230522.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062257669.png" alt="image.png"></p><h2 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102219380.png" alt="image.png"></p><h3 id="幂级数的收敛半径、收敛区间、收敛域"><a href="#幂级数的收敛半径、收敛区间、收敛域" class="headerlink" title="幂级数的收敛半径、收敛区间、收敛域"></a>幂级数的收敛半径、收敛区间、收敛域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不直接讨论改幂级数是收敛还是发散？</span><br><span class="line">因为幂级数∑an*x^n, 当x=1时，他就是一个常数项级数 a1,a2,a3,a4...an</span><br><span class="line">当x=2,就是一个另外一个常数项级数2a1,4a2,8a3,...</span><br><span class="line">--&gt;因为x是变化的，所以只能讨论x取什么时，级数的敛散性--&gt;也就是讨论收敛半径、区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102220953.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定理1(阿贝尔定理)：</span><br><span class="line">(1) x=x0(x0!=0),时收敛，则当|x|&lt;|x0|时,幂级数就是绝对收敛的</span><br><span class="line">(2) x=x0,时发散，则|x|&gt;|x0|时，幂级数发散</span><br><span class="line"></span><br><span class="line">定理2.</span><br><span class="line">幂级数的收敛性有且仅有一下三种可能</span><br><span class="line">(1).要么R上都收敛</span><br><span class="line">(2).要么只在x=0收敛</span><br><span class="line">(3).要么只在一个半径内收敛</span><br><span class="line">注意：如果幂级数在点x=x0出条件收敛，则点x0必为幂级数收敛区间(-R,R)上的一端点</span><br><span class="line"></span><br><span class="line">定理3.lim an+1/an = ρ，则收敛半径R=1/ρ </span><br><span class="line">因为假如R=1/2，那么x=1/3时，是收敛的，级数∑an*(1/3)^n --&gt; 比值法</span><br><span class="line">设bn+1=an+1*(1/3)^n+1 ，bn=an*(1/3)^n  ;bn+1/bn= (1/3)an+1/an=2/3&lt;1,收敛成</span><br><span class="line">立</span><br><span class="line">定理4.如果lim|an|^(1/n)=ρ，则收敛半径R=1/ρ</span><br><span class="line">--&gt;根值法证明</span><br><span class="line"></span><br><span class="line">概念：</span><br><span class="line">收敛半径:R </span><br><span class="line">收敛区间:(-R,R) --&gt;区间都是是开的区间</span><br><span class="line">收敛域：需要确定端点x=-R,x=R，处是否收敛，确定区间闭合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102237267.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102244221.png" alt="image.png"></p><h3 id="幂级数的性质"><a href="#幂级数的性质" class="headerlink" title="幂级数的性质"></a>幂级数的性质</h3><hr><h4 id="有理运算性质"><a href="#有理运算性质" class="headerlink" title="有理运算性质"></a>有理运算性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当幂级数A,收敛半径R1!,幂级数B收敛半径R2,R1!=R2,时</span><br><span class="line">令R=min&#123;R1,R2&#125;,当x∈(-R,R)</span><br><span class="line">1.幂级数加减法后新的幂级数的收敛半径=R</span><br><span class="line">2.乘除法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102317028.png" alt="image.png"></p><h4 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">幂级数的收敛半径为R,和函数S(x)有一下性质</span><br><span class="line">1.连续性：&lt;收敛域内&gt;</span><br><span class="line">和函数S(x)在收敛域内连续</span><br><span class="line"></span><br><span class="line">2.可导性：(任意阶可导) &lt;收敛区间内&gt;</span><br><span class="line">和函数S(x)在(-R,R)上可导，且逐项可导，半径不变</span><br><span class="line">例如S&#x27;(x)=(∑an*x^n)&#x27;=∑(an*x^n)&#x27;=∑n*an*x^n-1 --&gt;任然是幂级数，收敛半径任</span><br><span class="line">然与an有关，ρ=lim an+1/an, R=1/ρ不变 --&gt;所以是任意阶可导(可一直导下去)</span><br><span class="line">3.可积分性：&lt;收敛域内&gt;</span><br><span class="line">可导性逆过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102330711.png" alt="image.png"></p><h3 id="函数的幂级数的展开"><a href="#函数的幂级数的展开" class="headerlink" title="函数的幂级数的展开"></a>函数的幂级数的展开</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110004937.png" alt="image.png"></p><h4 id="几个常用的展开"><a href="#几个常用的展开" class="headerlink" title="几个常用的展开"></a>几个常用的展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110005861.png" alt="image.png"></p><h4 id="函数展开为幂级数的方法"><a href="#函数展开为幂级数的方法" class="headerlink" title="函数展开为幂级数的方法"></a>函数展开为幂级数的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110006907.png" alt="image.png"></p><h3 id="常考题型-10"><a href="#常考题型-10" class="headerlink" title="常考题型"></a>常考题型</h3><hr><h4 id="求收敛半径、收敛区间、收敛域"><a href="#求收敛半径、收敛区间、收敛域" class="headerlink" title="求收敛半径、收敛区间、收敛域"></a>求收敛半径、收敛区间、收敛域</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两种方法：</span><br><span class="line">其中要注意lim  =1   、  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110019509.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础扫盲&quot;&gt;&lt;a href=&quot;#基础扫盲&quot; class=&quot;headerlink&quot; title=&quot;基础扫盲&quot;&gt;&lt;/a&gt;基础扫盲&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture</summary>
      
    
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/categories/%E9%AB%98%E6%95%B0/"/>
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
</feed>
