<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风起之时</title>
  
  
  <link href="https://fqzs.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://fqzs.netlify.app/"/>
  <updated>2023-08-09T15:04:27.633Z</updated>
  <id>https://fqzs.netlify.app/</id>
  
  <author>
    <name>风起之时</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高数严选题</title>
    <link href="https://fqzs.netlify.app/undefined/c037e1e7.html"/>
    <id>https://fqzs.netlify.app/undefined/c037e1e7.html</id>
    <published>2023-07-20T10:44:00.000Z</published>
    <updated>2023-08-09T15:04:27.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png" alt="image.png"></p><h1 id="1-函数极限连续"><a href="#1-函数极限连续" class="headerlink" title="1.函数极限连续"></a>1.函数极限连续</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>开区间连续，两端点单侧极限存在，是函数有界的充分条件，而不是必要条件</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201100161.png" alt="image.png"></p><p><em>相乘的极限存在，不想代表，各自都有极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201114713.png" alt="image.png"></p><p><em>利用夹逼定理，单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201121973.png" alt="image.png"></p><p><em>极限要求趋向于0，但不等于0，没有说明φ(x)不等于0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201126863.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201131884.png" alt="image.png"></p><p><em>1.注意加减关系不能直接等价代换，等价代换实质上是一种精度不太高的泰勒展开(低阶展开)，当f(x)与g(x)存在加减关系时，例如这题是相加关系，如果f(x)与g(x)的低阶无穷小相互抵消(limf(x)/g(x)=-1),那么就需要比较高阶的无穷小；但是等价代换就没有高阶项，所以精度丢失- - -&gt;</em><br><em>2.拆成两项极限求和的前提是—&gt;两项极限都存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201145234.png" alt="image.png"></p><p><em>确定变上限积分函数，无穷小的阶数—&gt;N(M+1)原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201358107.png" alt="image.png"></p><p><em>1.当a=2,arctanx-sin2x可以分别等价代换，为什么？不是说加减不能等价代换吗？ —&gt;等价代换实质就是一次低阶泰勒展开，当展开之后，最低阶的无穷小两者不相等时，意味着相减，不会消去这个低阶无穷小，就不需要比较高阶无穷小，那么就可以直接等价代换 ；arctanx-sin2x ~ x-2x</em></p><p><em>2.当a=1时，arctanx-sinx不能分别等价为x-x，因为低阶无穷小项，互相消去，需要比较高阶无穷小，但是arctanx的泰勒展开不熟悉，只能通过arctanx-x~-1/3 x³  ,sinx-x~ -1/6 x³  ;</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201404411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201415098.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201424934.png" alt="image.png"></p><p><em>极限x-&gt;1不需要讨论1+,1-，因为极限保号性；同理x-&gt; -1; 但是x-&gt;0,时，考虑0+,0-,因为两侧正负不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201429124.png" alt="image.png"></p><p><em>最关键的还是，幂指函数指数化 来处理幂指函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201454848.png" alt="image.png"></p><p><em>考察了基本极限x^n ,e^nx</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201505101.png" alt="image.png"></p></blockquote><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>对于这种分母中含有两根号相减的，—&gt;1.是有理化  2.是拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201511419.png" alt="image.png"></p><p><em>考察知识点很综合<br>1.导数几何意义<br>2.基本极限求极限1^∞型<br>3.洛必达法则<br>4.变上限积分求导<br>5.导数的定义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201528282.png" alt="image.png"></p><p><em>ln(x+√1+x²) ~ x</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201543906.png" alt="image.png"></p><p><em>1.利用到了ln(x+√1+x²) ~ x,判断时1^∞型<br>2.写基本极限标准型lim (1+a(x))^β(x) =e^ a(x)β(x)</em><br><em>3.利用等价代换(1+a(x))^β(x) -1 ~ a(x)β(x) </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201549785.png" alt="image.png"></p><p><em>1.n项连乘 直接夹逼不出来，化为对数<br>2.关键再利用基本常用不等式<br>3.再夹逼</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201602526.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201607237.png" alt="image.png"></p></blockquote><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>0/0型</em><br><em>1)洛必达法则<br>2)等价无穷小代换<br>3)泰勒公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201614121.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201620034.png" alt="image.png"></p><p><em>1.第一眼看，我想用1^∞型极限，但是这里不能拆开求极限因为，右半部分的极限不存在，所以不能1^∞极限直接做<br>2.正确的做法是将幂指函数，化为指数，然后将整个分子，e^x -1 ~ x等价代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201708362.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201735817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201754350.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201801518.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201900306.png" alt="image.png"><br><em>用到拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201903837.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201909167.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915159.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915846.png" alt="image.png"></p><p><em>1.自平方项，前n项和，公式要记住<br>2.到底是选择夹逼，还是定积分定义，看每一项变化的那个地方，看是占大头(同量级，选择定积分定义)，还是小头(变化对分母整体量影响不大，用夹逼)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201920638.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201925221.png" alt="image.png"></p><p><em>分子变化部分相对于主体是次量级，用夹逼；分母变化部分相对于主体是同量级，用定积分定义</em><br><em>对分子放大—&gt;所有项分子=n+1/n;  缩小—&gt;所有项分子=n+1</em><br><em>对分母提出1/n，可爱因子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201932498.png" alt="image.png"></p><p><em>经典的找间断点，和类型题目</em><br><em>在求间断点的极限时，是否要分开考虑左右极限，是根据，左右会不会对函数正负性有影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201938018.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201944583.png" alt="image.png"></p><p><em>极限存在一般根据极限存在准则：<br>1.夹逼定理<br>2.单调有界准则<br>该题只需要证明极限存在，只需单调有界就可证明极限存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202046598.png" alt="image.png"></p><p><em>1.先看递推式函数是否单调增<br>2.函数单调增说明数列有单调性，再根据x1,x2判断数列单调增还是减<br>3.假设极限=A，根据递推式代入A求出A<br>5.再证明有界且界限=A</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202055627.png" alt="image.png"></p><p><em>1.先看递推式函数，是否单调增,如果单调减则数列没有单调性<br>2.接着没有单调性则，直接证明xn-√2的极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202103715.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202114022.png" alt="image.png"></p><p><em>零点定理—证明区间两端点异号，则区间内必有一点=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202123672.png" alt="image.png"></p><p><em>介值定理—函数值介于最大与最小之间，必有一点,f(β)=该值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202128724.png" alt="image.png"></p></blockquote><h1 id="2-一元函数微分"><a href="#2-一元函数微分" class="headerlink" title="2.一元函数微分"></a>2.一元函数微分</h1><h2 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>既要趋近于0，又要同时趋近0+,0-，才能判定该点导数存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231415896.png" alt="image.png"></p><p><em>考察连续的概念、导数的概念、导函数连续的概念</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231422649.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231431041.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231509976.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231525936.png" alt="image.png"></p><p><em>1.拆开求导。2.求得导数等于0的点，用二阶导数判定是极小还是极大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231553956.png" alt="image.png"></p><p><em>求得二阶导数=0，继续代入求三阶导数，看二阶导数是否单调，如果单调，那么该点就是拐点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231627232.png" alt="image.png"></p><p><em>求斜或水平渐近线，直接将原式改写，为y=ax+b形式，利用x-&gt;∞极限求出a,b</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231643077.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231648475.png" alt="image.png"></p></blockquote><h2 id="填空题-2"><a href="#填空题-2" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>不能用洛必达，没有一阶可导条件，并且数列不是函数，不连续</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231657600.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231701991.png" alt="image.png"></p><p><em>利用链导法，而不是将所有表达式求出来，再求导，那样太麻烦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231726425.png" alt="image.png"></p><p><em>反函数的导数，注意反函数是对y求导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231735491.png" alt="image.png"></p><p><em>高阶导数具体点导数—用泰勒展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232115462.png" alt="image.png"></p><p><em>求高阶导数—总结规律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232114368.png" alt="image.png"></p><p><em>根据罗尔定律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232121848.png" alt="image.png"></p><p><em>解一元三次方程=0，一般方法，凑1,2,3,4…整数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232146981.png" alt="image.png"></p></blockquote><h2 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232220253.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241057847.png" alt="image.png"></p><p><em>1.积分上限用变量代换<br>2.定积分定义求0点导数<br>3.求x-&gt;0，导数极限看是否=0点导数<br>4.运用到了积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241123900.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141774.png" alt="image.png"></p><p><em>这种参数方程求积分问题，要注意变换积分上下限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241347626.png" alt="image.png"></p><p><em>单中值—微分中值定理证明题，主要是微分中值定理的构造</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241611635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241626811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241829186.png" alt="image.png"></p><p><em>运用柯西定理、拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241854086.png" alt="image.png"></p><p><em>双中值—两中值点没有要求不同<br>分开两部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242018794.png" alt="image.png"></p><p><em>双中值—要求中值点不同<br>1.先将【0,1】段用c分开，假设存在一点c，使得…</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242027225.png" alt="image.png"></p><p><em>证明中值，含有高阶导数—泰勒展开，在给出信息最多的那一点展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242131657.png" alt="Uploading file...swyug"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242134232.png" alt="image.png"></p></blockquote><h1 id="3-一元函数积分学"><a href="#3-一元函数积分学" class="headerlink" title="3.一元函数积分学"></a>3.一元函数积分学</h1><h2 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>原函数是否存在判定<br>1.函数连续，一定存在原函数<br>2.函数有第一类间断点，就一定没有原函数（证明：通过原函数的定义或者导函数的介值定理，F(X)在a,b可导，则其导数在[a，b]内不会有第一类间断。）<br>3.有第二类间断点，可能有原函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242146129.png" alt="image.png"></p><p><em>直接判断导函数是否连续，如果有第一类间断点，那么原函数必定不可导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242237240.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251023049.png" alt="image.png"></p><p><em>积分区域相同，比较被积函数，被积函数大，积分就大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251028390.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251033971.png" alt="image.png"></p><p><em>旋转体体积问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251046107.png" alt="image.png"></p></blockquote><h2 id="填空题-3"><a href="#填空题-3" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>简单有理函数积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251137183.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251151287.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251249954.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251433037.png" alt="image.png"></p><p><em>对称区间，奇偶性判断</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251449741.png" alt="image.png"></p><p><em>1.取根号，要注意加绝对值，分区间计算<br>2.善用结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251458855.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251631501.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251642326.png" alt="image.png"></p><p><em>1.利用定积分定义，转化为定积分的计算<br>2.利用几何意义，想象为，一个半圆的面积的积分，直接求面积<br>3.也可以将x=sint，左变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251651125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251707587.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251718611.png" alt="image.png"></p><p><em>多项式分数，根式里面一次，一般变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251906680.png" alt="image.png"></p><p><em>根式含有平方项，三角代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251907971.png" alt="image.png"></p><p><em>边界曲线，用极坐标给出，求面积的问题<br>可以直接套公式，<br>任然还有问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251922342.png" alt="image.png"><br><em>对比着看</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261610407.png" alt="image.png"></p><p><em>运用弧长积分公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251926365.png" alt="image.png"></p><p><em>通过分部积分法，将f(x)写成导数计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252055735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252126968.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252153239.png" alt="image.png"></p></blockquote><h2 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261042264.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261116190.png" alt="image.png"></p><p><em>积分中值定理+介值定理+两次罗尔定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261131711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261205973.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261235506.png" alt="image.png"></p><p><em>方法1.利用介值定理，介于最大最小值之间</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261329751.png" alt="image.png"><br><em>方法2.利用构造辅助函数，常规方法，然后再说明有两个点，辅助函数值相等(罗尔定理)，就证明等式成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261334817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261400953.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261417494.png" alt="image.png"></p><p><em>难题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261443061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261446496.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261506664.png" alt="image.png"></p><p><em>长条中质心的积分计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261509020.png" alt="image.png"></p><p><em>典型，积分求旋转体体积</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261604721.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261607358.png" alt="image.png"></p></blockquote><h1 id="4-常微分方程"><a href="#4-常微分方程" class="headerlink" title="4.常微分方程"></a>4.常微分方程</h1><h2 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292225471.png" alt="image.png"></p><blockquote><p><em>直到三阶常系数齐次线性微分方程的特解，直接从特解中看出特征根，然后根据特征根写出特征方程，即可</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292150830.png" alt="image.png"></p><p><em>非齐次解具有叠加性，可以拆开分析</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292154652.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292200338.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292214416.png" alt="image.png"></p></blockquote><h2 id="填空题-4"><a href="#填空题-4" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301428202.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301530231.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301545683.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301551914.png" alt="image.png"></p><h2 id="解答题-3"><a href="#解答题-3" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>1.三个线性无关特解，两两相减=通解<br>2.然后通过消去系数得到最终方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301634920.png" alt="image.png"></p><p><em>不属于已知的类型，通过x,y对调,令y’ =1/x’,化为x为函数，y为自变量的函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301638682.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301713823.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916345.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302054499.png" alt="image.png"></p><p><em>通过导数定义，构建微分方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302136747.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307310953433.png" alt="image.png"></p><p><em>微分方程与全微分结合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311007885.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311033425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311047528.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311409647.png" alt="image.png"></p></blockquote><h1 id="5-二重积分"><a href="#5-二重积分" class="headerlink" title="5.二重积分"></a>5.二重积分</h1><h2 id="选择题-3"><a href="#选择题-3" class="headerlink" title="选择题"></a>选择题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311421096.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311647617.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311656049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311710142.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311713317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311750227.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311754610.png" alt="image.png"></p><p><em>二重积分是一个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311805140.png" alt="image.png"></p><p><em>区域相同，比较被积函数大小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311808151.png" alt="image.png"></p><p><em>轮换对称性、奇偶性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311816485.png" alt="image.png"></p><p><em>经典</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311824085.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311827837.png" alt="image.png"></p><p><em>累次积分对t求导<br>1.通过转换积分次序，使得只有外层积分保留t<br>2.将外层0~t积分对应微分的变量，在内层用t替换</em><br><em>例1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312059190.png" alt="image.png"><br><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011156555.png" alt="image.png"><br><em>例3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011228116.png" alt="image.png"></p></blockquote><h2 id="填空题-5"><a href="#填空题-5" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312129808.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312156656.png" alt="image.png"></p><p><em>拆开、奇偶性、轮换对称性、极坐标法<br>太妙了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312207638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011058407.png" alt="image.png"></p><p><em>此时极坐标方便—&gt;换位直角坐标，然后(x-1)关于(1,0)点的奇函数，利用奇偶性；最后计算简单</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011107023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222340.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222036.png" alt="image.png"></p></blockquote><h2 id="解答题-4"><a href="#解答题-4" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>数列n项和，转化为定积分定义，最终得到一个累次积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011224321.png" alt="image.png"></p><p><em>题目给的积分不好积分，就交换积分次序<br>1.先画域<br>2.重新确定积分次序，就可以简便积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011402509.png" alt="image.png"></p><p><em>该题很有规律，不要硬算，算不出来</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417984.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417329.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011438457.png" alt="image.png"></p><p><em>没想到的，极坐标不好用，换成极坐标</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011518588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529261.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529642.png" alt="image.png"></p><p><em>利用奇偶性、对称性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011538891.png" alt="image.png"></p><p><em>圆形不再原点的，通过平移，使得圆心在原点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011636328.png" alt="image.png"></p><p><em>注意奇函数乘偶函数=奇函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012100835.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012128361.png" alt="image.png"></p><p><em>积分的绝对值&lt;=绝对值的积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012138798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012151775.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012150173.png" alt="image.png"></p></blockquote><h1 id="6-多元函数微分学"><a href="#6-多元函数微分学" class="headerlink" title="6.多元函数微分学"></a>6.多元函数微分学</h1><h2 id="选择题-4"><a href="#选择题-4" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>求偏导数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021328671.png" alt="image.png"></p><p><em>D.正确<br>从x方向趋向于x0,的极限，而y0固定的，相当于一个一元函数从x方向的一元函数，由于x方向的偏导数存在=a, 再根据一元函数可导必定连续，说明该函数极限就等于函数值f(x0,y0) ;同理y方向趋向于y0极限也存在也等于f(x0,y0)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021336253.png" alt="image.png"></p><p><em>1.首先证明偏导数存不存在(用定义法)<br>2.判断出两个偏导数都存在，接着通过可微判断式，判断是否等于0<br>3.最终式子如下，利用y=kx（其中一个方向趋向于y0）,看极限手否与趋向的方向无关(也就是如果极限与k有关，那么极限就不存在)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021351399.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021420120.png" alt="image.png"></p><p><em>偏x方向导数&gt;0,所以延x方向是增加的，同理延y方向减小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021422359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021430141.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021507965.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021520285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021527756.png" alt="image.png"></p><p><em>极限保号性，既然当x-&gt;0,y-&gt;0时 f(x,y)&gt;0, 且f(0,0)=0,所以f(0,0)就是极小值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021532707.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031454924.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031502939.png" alt="image.png"></p><blockquote><p><em>AC-B^2 &lt;0 所以内部无极值点，那么由于这是一个有界区域，所以最值位于边界上的点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031505371.png" alt="image.png"></p></blockquote><h2 id="填空题-6"><a href="#填空题-6" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031537091.png" alt="image.png"></p><p><em>知道偏导，求函数本身—&gt;偏积分法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031542061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031600766.png" alt="image.png"></p><p>*公式法，将x,y,z看做独立的变量，而不用再将z看做x,y的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031607224.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031654172.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031721585.png" alt="image.png"></p></blockquote><h2 id="解答题-5"><a href="#解答题-5" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031728679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031736577.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032041935.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032100874.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032321526.png" alt="image.png"></p><p><em>AC-B^2=0，不能确定是否有极值，需要通过定义判定<br>1.极值的定义是，一个极小区域内无论函数从哪个方向趋向于极值点，函数值都是要么都同号，不会有正负都出现的情况</em><br><em>2.所以分别从y=x方向与y=-x方向趋向于(0,0)点，发现两个方向趋向于该点，一个方向值为+，一个方向为-，就说明该点不是极值点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041021953.png" alt="image.png"></p><p><em>我做错了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041154395.png" alt="image.png"></p><p><em>数形结合，起始就是求z坐标绝对值的最大值，由于|z|不好求，所以改为求z^2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041507215.png" alt="image.png"></p><p><em>1.利用齐次方程，有非零解时，系数行列式=0的特点<br>2.求长半轴与短半轴长度之比，实际就是求椭球距离原点最长最短距离之比</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041515026.png" alt="image.png"></p><p><em>把证明不等式的问题，转化为证明一个条件下，最大最小值的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041519753.png" alt="image.png"></p></blockquote><h1 id="7-无穷级数"><a href="#7-无穷级数" class="headerlink" title="7-无穷级数"></a>7-无穷级数</h1><h2 id="选择题-5"><a href="#选择题-5" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061036658.png" alt="image.png"></p><p><em>(1)好理解<br>(2)采用比值法，需要取极限，而不是单单相除，例如(1/n+1) / (1/n) &lt;1 但是取极限就是=1，而1/n级数是发散的<br>(3)比值法，前提是两个都是正项级数<br>(4)  0&lt;=bn-an&lt;=cn-an ; $\sum<em>{n=1}^{\infty}a_n$ 与$\sum</em>{n=1}^{\infty}c<em>n$都收敛，所以$\sum</em>{n=1}^{\infty}c_n-a_n$ 收敛<br>大收则小收，bn-an也收敛，因为bn = (bn-an)+an,两个收敛相加依然收敛，故bn收敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061054853.png" alt="image.png"></p><p><em>关键：级数与函数有关，函数连续，想到函数必定有界，设M</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061135473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061209429.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061211017.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061348192.png" alt="image.png"></p><p><em>A. an-&gt;0,所以anbn&lt;bn ,大收则小收，但是不确定bn是正项级数还是有负的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061354692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061415331.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061416527.png" alt="image.png"></p></blockquote><h2 id="填空题-7"><a href="#填空题-7" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122547.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122923.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072200181.png" alt="image.png"></p><p>*级数$\sum<em>{n=1}^{\infty}a_n$ 是等价于 $\sum</em>{n=1}^{\infty}\frac{1}{ln n}$,是发散的，<br>原级数$\sum<em>{n=1}^{\infty}\frac{(-1)^na_n}{n}(x+1)^n$ 看做是$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$逐项求导，收敛半径不变。<br>$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$将x=0代入，是$\sum</em>{n=1}^{\infty}(-1)^na_n$条件收敛<br>又因为幂级数条件收敛的点只可能发生在收敛区间端点，所以0是区间一个端点，所以收敛半径=1；收敛区间（-2,0）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072207881.png" alt="image.png"></p><p><em>我的方法是直接代入，x=3,-3(根据直觉)，发现x=-3时条件收敛，那么x=-3一定是收敛区间端点，接着就能找出收敛域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308080950111.png" alt="image.png"></p></blockquote><h2 id="解答题-6"><a href="#解答题-6" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>考察对各类级数敛散性判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081000284.png" alt="image.png"></p><p><em>x的范围一定要写，原公式-1&lt;x&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081018049.png" alt="image.png"></p><p><em>像是arctan，的幂级数展开，一般是求导，展开，再积分<br>积分是要变上限积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081039482.png" alt="image.png"></p><p><em>省略二次求导，再积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081122483.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081144158.png" alt="image.png"></p><p><em>这种题，和函数的导四次，回到原来的和函数，建立微分方程，求解<br>【注意通解中含有4个变量，需要四个函数值，0! =1,所以y(0)=1,y’(0)=0….】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130847.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130620.png" alt="image.png"></p><p><em>求常数项级数的求和，借助幂级数，写成常用的展开的形式，再代入x=1（这题来说代入x=1,恢复原来式子）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081236378.png" alt="image.png"></p><p><em>这种微分方程不好解，那只能代入方程，将x化为同次幂，关注其常数项系数=0，就能找出幂级数系数的关系式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081342834.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081343735.png" alt="image.png"></p><p><em>与上面一样的做法，将x化为同次幂，找幂级数系数的关系</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081350959.png" alt="image.png"></p><p><em>S’(x)，和函数的导数，这个导数幂级数要从n=1开始，因为n=0的项是常数a0,求导之后没了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081407634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452179.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452832.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504136.png" alt="image.png"></p><p><em>运用到了柯西积分不等式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081513995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081512357.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081532609.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081533525.png" alt="image.png"></p><p><em>傅里叶级数展开的系数问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081547512.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-函数极限连续&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/categories/%E9%AB%98%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线代</title>
    <link href="https://fqzs.netlify.app/undefined/43e039bd.html"/>
    <id>https://fqzs.netlify.app/undefined/43e039bd.html</id>
    <published>2023-06-30T12:24:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png" alt="image.png"></p><h1 id="01-行列式的定义与性质"><a href="#01-行列式的定义与性质" class="headerlink" title="01-行列式的定义与性质"></a>01-行列式的定义与性质</h1><h2 id="行列式背景"><a href="#行列式背景" class="headerlink" title="行列式背景"></a>行列式背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于一个二元方程组，每次都要求解就特别麻烦。</span><br><span class="line">为了更加快速的找到方程的解，人们寻找规律，发现解的通式如下</span><br><span class="line">但是通式难以记忆，所以将这种计算规律用行列式表示，规定行列式计算方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301231233.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301500559.png" alt="image.png"></p><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论:一个排列中任意的两个元素对换，排列的奇偶性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301509795.png" alt="image.png"></p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行列式是一个数</span><br><span class="line">行列式计算方法是：</span><br><span class="line">1.取数相乘: 取n个不同行不同列的数 相乘 --&gt; 所以n!种取法，就有n!项</span><br><span class="line">2.冠以符号: 每一项(n个数相乘),将里面的元素，按列排好，然后数 列序号的逆序数τ，</span><br><span class="line">-(1)^τ</span><br><span class="line">3.全部相加: 将所有项n!项相加   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301521315.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按照行列式定义，因为行列式的每一项都是有不同行不同列的n个数相乘</span><br><span class="line">假如取1行1列的数--&gt;x</span><br><span class="line">那么画个十字线，十字线上的数都不能再取</span><br><span class="line">题目要求行列式结果中x^3的系数</span><br><span class="line"></span><br><span class="line">排除法:</span><br><span class="line">假如先取1，画十字线，发现其他行最多只能取到两个x，构不成x^3</span><br><span class="line">假如先取2，同理不行</span><br><span class="line">所以只能取x或x+3</span><br><span class="line"> 取x+3,只有一种情况，可行</span><br><span class="line"> 取x,第二行只能取x,第三行只能取x,第四行只能取x，那么x^4不符合。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301535080.png" alt="image.png"></p><blockquote><p>重要的特殊行列式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt="image.png"></p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a><em>转置</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301557471.png" alt="image.png"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><em>交换</em></h3><p><strong>交换一行实际上是对每一项的逆序数发生改变，导致全部项的正负性改变</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301600178.png" alt="image.png"></p><h3 id="倍乘"><a href="#倍乘" class="headerlink" title="倍乘"></a><em>倍乘</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301619501.png" alt="image.png"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a><em>拆分</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301620199.png" alt="image.png"></p><blockquote><p><em>倍加</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301623438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301627820.png" alt="image.png"></p><hr><h1 id="02-行列式的计算与代数余子式"><a href="#02-行列式的计算与代数余子式" class="headerlink" title="02-行列式的计算与代数余子式"></a>02-行列式的计算与代数余子式</h1><h2 id="分块矩阵的行列式计算"><a href="#分块矩阵的行列式计算" class="headerlink" title="分块矩阵的行列式计算"></a>分块矩阵的行列式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301645404.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301654171.png" alt="image.png"></p><h2 id="行列式按行-列-展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h2><h3 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">余子式M 是特殊的情况，恰好第一行第一个数不是0,该行其余都是0,行列式的值=a11xM11。</span><br><span class="line">代数余子式A是讨论,不是特殊情况时，要考虑符号问题。</span><br><span class="line">就是不断的交换将aij逐行逐列的移到第一个的位置(交换一次改变一次正负号),aij列需要j次</span><br><span class="line">交换，行需要i次交换。所以符号-(1)^i+j x Mij = Aij </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301724746.png" alt="image.png"></p><blockquote><p><em>“么”型通法，按横展开</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301750483.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302120137.png" alt="Uploading file...havyy"></p><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302138234.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302217822.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302141433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302143275.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302148080.png" alt="image.png"></p><h2 id="范德门行列式"><a href="#范德门行列式" class="headerlink" title="范德门行列式"></a>范德门行列式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像这种第一行(或列)是1，第二行(列)是x1,x2..xn;第三行(列)是x1^2,x2^2..xn^2;...第n行(列)是...</span><br><span class="line">这种形式的就是范德蒙行列式，它的值有如下规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302222870.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.加边法</span><br><span class="line">与范德蒙行列式相似的，可以加边使其成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302228111.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.提公因子</span><br><span class="line">每一行提一个公因子，使得第一列的全为1，成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302230815.png" alt="image.png"></p><hr><h1 id="03矩阵及其运算"><a href="#03矩阵及其运算" class="headerlink" title="03矩阵及其运算"></a>03矩阵及其运算</h1><h2 id="矩阵及分块的概念"><a href="#矩阵及分块的概念" class="headerlink" title="矩阵及分块的概念"></a>矩阵及分块的概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矩阵的提出主要源自于数学中的三个问题:</span><br><span class="line">1.线性变换:用于表示未知数的变换关系</span><br><span class="line">2.线性方程组:用于表示方程组各个未知数的系数</span><br><span class="line">3.二次型:方便表示二次型，x^2,y^2,xy,出现的个数</span><br></pre></td></tr></table></figure><blockquote><p><em>数表来源</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302253439.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302255227.png" alt="image.png"></p><blockquote><p><em>特殊矩阵及分块矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302314484.png" alt="image.png"></p><h2 id="矩阵及分块矩阵的计算"><a href="#矩阵及分块矩阵的计算" class="headerlink" title="矩阵及分块矩阵的计算"></a>矩阵及分块矩阵的计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">矩阵加减法要求</span><br><span class="line">1.同型矩阵，m,n相同</span><br><span class="line">2.对应每个元素相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302321222.png" alt="image.png"></p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302346561.png" alt="image.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵乘法，实质是将由x-&gt;y的线性变换通过y-&gt;z的变化 转到x-&gt;z的线性变换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302349135.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011521217.png" alt="image.png"></p><hr><blockquote><p><em>对角矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011524350.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011527225.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵练习</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排列与组合区别在于，组合不要求内部顺序，所以要除以顺序个数</span><br><span class="line"></span><br><span class="line">将A矩阵拆分为--&gt; 单位E矩阵 + “坍缩矩阵”B </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011532335.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011534905.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011535161.png" alt="image.png"></p><blockquote><p><em>成比例矩阵的幂</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每行成比例的矩阵，可以写为如下</span><br><span class="line">成比例矩阵n次幂就可以拆为如下</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011559846.png" alt="image.png"></p><blockquote><p><em>与伴随矩阵相乘</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AxA* --&gt; 乘错行导致只有对应行的与其对应的代数余子式相乘结果才为|A|--&gt;也就是只有对角线上是|A| </span><br><span class="line"></span><br><span class="line">为什么代数余子式，乘错行会=0？ </span><br><span class="line">因为,乘错行，可以看做求一个具有两行相元素的行列式的值--&gt;两行相同元素的行列式=0</span><br><span class="line"></span><br><span class="line">为什么两行相同元素的行列式值是0?</span><br><span class="line">因为，利用交换一次行,矩阵正负性改变,两行相同交换后不变，但正负性改变，那么只能是0</span><br><span class="line"></span><br><span class="line">为什么交换两行元素，矩阵正负性要改变?</span><br><span class="line">因为，交换两行之后，导致每一项列排序发生一次交换--&gt;逆序数奇偶性变化--&gt;正负性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011615201.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011741250.png" alt="image.png"></p><hr><h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011730342.png" alt="image.png"></p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743537.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743180.png" alt="image.png"></p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵定义"><a href="#逆矩阵定义" class="headerlink" title="逆矩阵定义"></a><em>逆矩阵定义</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011859511.png" alt="image.png"></p><h3 id="逆矩阵充要条件"><a href="#逆矩阵充要条件" class="headerlink" title="逆矩阵充要条件"></a><em>逆矩阵充要条件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011901315.png" alt="image.png"></p><blockquote><p><em>原矩阵行列式=0 =&gt;伴随矩阵行列式=0</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011907635.png" alt="image.png"></p><blockquote><p><em>求二阶矩阵的逆矩阵方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011939266.png" alt="image.png"></p><blockquote><p><em>分块矩阵求逆矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011948103.png" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012256386.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求可对角化的矩阵的幂--&gt;先将矩阵写为下列形式，然后相乘，中间可以相互抵消为E(单位矩阵)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012257657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012300822.png" alt="image.png"></p><h2 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012305438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012312191.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012314168.png" alt="image.png"></p><hr><h1 id="04初等变换与初等矩阵"><a href="#04初等变换与初等矩阵" class="headerlink" title="04初等变换与初等矩阵"></a>04初等变换与初等矩阵</h1><h2 id="初等变换、矩阵的行阶梯、行最简、标准形"><a href="#初等变换、矩阵的行阶梯、行最简、标准形" class="headerlink" title="初等变换、矩阵的行阶梯、行最简、标准形"></a>初等变换、矩阵的行阶梯、行最简、标准形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">化为行阶梯型矩阵--&gt;自上而下化简</span><br><span class="line">化为最简型矩阵--&gt;自下而上化简</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012324531.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">矩阵A只进行行变换到B,称A与B 行等价</span><br><span class="line">矩阵A只进行列变换到B,称A与B 列等价</span><br><span class="line">如果即行又列，称A与B 等价 </span><br><span class="line"></span><br><span class="line">不管行等价，列等价，等价 --&gt;其秩都相等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012335843.png" alt="image.png"></p><h2 id="初等矩阵的定义性质"><a href="#初等矩阵的定义性质" class="headerlink" title="初等矩阵的定义性质"></a>初等矩阵的定义性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初等矩阵可以传递三种操作:</span><br><span class="line">1.交换: 左行右列 Eij --&gt;交换第i、j行(列)</span><br><span class="line">2.倍乘: 左行右列 Ei(k) --&gt; 第i行(列) 乘k倍</span><br><span class="line">3.倍加: 左行由列 Eij(k) --&gt; (左)将第i行加上j行的k倍;(右)将第j列加上第i行的k倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012358129.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307020005020.png" alt="image.png"></p><h2 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031442490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031446780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031452285.png" alt="image.png"></p><h2 id="可逆矩阵都可初等变换化为单位阵"><a href="#可逆矩阵都可初等变换化为单位阵" class="headerlink" title="可逆矩阵都可初等变换化为单位阵"></a>可逆矩阵都可初等变换化为单位阵</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031514917.png" alt="image.png"></p><h2 id="初等变换求逆矩阵-解可逆矩阵方程"><a href="#初等变换求逆矩阵-解可逆矩阵方程" class="headerlink" title="初等变换求逆矩阵-解可逆矩阵方程"></a>初等变换求逆矩阵-解可逆矩阵方程</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031520619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.A逆在左，行变换，所以可逆矩阵方程A,B要行摆放</span><br><span class="line">2.A逆在右，列变换，所以可逆矩阵方程A,B要列摆放</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031537723.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031547781.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031553549.png" alt="image.png"></p><hr><h1 id="05-矩阵的秩与线性方程组"><a href="#05-矩阵的秩与线性方程组" class="headerlink" title="05-矩阵的秩与线性方程组"></a>05-矩阵的秩与线性方程组</h1><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="矩阵的秩的定义"><a href="#矩阵的秩的定义" class="headerlink" title="矩阵的秩的定义"></a>矩阵的秩的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初等变换不会改变秩的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031709329.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031717376.png" alt="image.png"></p><h3 id="行阶形求秩"><a href="#行阶形求秩" class="headerlink" title="行阶形求秩"></a>行阶形求秩</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031713196.png" alt="image.png"></p><h3 id="秩的结论"><a href="#秩的结论" class="headerlink" title="秩的结论"></a>秩的结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.矩阵的秩不会超过行数也不会超过列数，因为逆矩阵的秩就是阶梯个数，阶梯怎么画都不会   超过行和列</span><br><span class="line">2.转置矩阵的秩不变很好理解</span><br><span class="line">3.等价的矩阵秩一定相等--&gt;等价的矩阵实际就是在一个矩阵基础上经过若干初等变换得到的   两个矩阵，初等变换不会影响秩的大小</span><br><span class="line">4.P,Q可逆--&gt;P,Q是若干初等矩阵的乘积--&gt;相当于对A经过若干初等行变换+列变换--&gt;秩不变</span><br><span class="line">5.(A,B)矩阵的秩R(A,B)min/max --&gt; A,B都化为标准型之后，看斜对角线</span><br><span class="line">6.矩阵相加的秩，化标准型理解</span><br><span class="line">7.矩阵相乘的秩，化标准型理解(特殊:矩阵与其转置矩阵相乘，秩不变)</span><br><span class="line">8.两矩阵相乘为0矩阵--&gt;标准型中1刚好错开，那么R(A)+R(B)&lt;=n</span><br><span class="line">9....</span><br><span class="line">10....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031725785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031745903.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031749579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031751055.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031755979.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.R(Amxn) =n --&gt;列满秩 ;所以A的标准型是上面E,下面O ; --&gt; 标准型左边乘以可逆矩阵P(等效为若干初等变换) 得到A --&gt; A标准型=PA ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031800370.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031819833.png" alt="image.png"></p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><h3 id="解的判定"><a href="#解的判定" class="headerlink" title="解的判定"></a>解的判定</h3><blockquote><p><em>齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031839448.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031838230.png" alt="image.png"></p><hr><blockquote><p><em>非齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031850780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031852539.png" alt="image.png"></p><h3 id="具体方程组的求解"><a href="#具体方程组的求解" class="headerlink" title="具体方程组的求解"></a>具体方程组的求解</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031859530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031900387.png" alt="image.png"></p><h1 id="06-向量组的线性相关性"><a href="#06-向量组的线性相关性" class="headerlink" title="06-向量组的线性相关性"></a>06-向量组的线性相关性</h1><h2 id="向量及向量空间"><a href="#向量及向量空间" class="headerlink" title="向量及向量空间"></a>向量及向量空间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;01-行列式的定义与性质&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="线代" scheme="https://fqzs.netlify.app/categories/%E7%BA%BF%E4%BB%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>百度网盘不限速下载</title>
    <link href="https://fqzs.netlify.app/undefined/d1267184.html"/>
    <id>https://fqzs.netlify.app/undefined/d1267184.html</id>
    <published>2023-06-18T11:35:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png" alt="image_2022-11-16_11-48-14.png"></p><h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181136945.png" alt="image.png"></p><h2 id="打开解析网站"><a href="#打开解析网站" class="headerlink" title="打开解析网站"></a>打开解析网站</h2><p><a href="https://pan.qsbaidu.com/">点击跳转解析网站</a>（<a href="https://pan.qsbaidu.com/）。">https://pan.qsbaidu.com/）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181139806.png" alt="image.png"></p><p>点击解析分享链接后跳转该界面，点击下载按钮。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181141184.png" alt="image.png"></p><p>之后跳转该界面，推荐使用NDM下载器下载。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181142387.png" alt="image.png"></p><h2 id="NDM下载及配置"><a href="#NDM下载及配置" class="headerlink" title="NDM下载及配置"></a>NDM下载及配置</h2><p>1.官网<a href="http://www.neatdownloadmanager.com/index.php/en/">下载链接</a>（<a href="http://www.neatdownloadmanager.com/index.php/en/）">http://www.neatdownloadmanager.com/index.php/en/）</a></p><ol><li>初次使用要先配置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181147528.png" alt="image.png"></li></ol><p>3.复制上述用户代理名，打开NDM点击设置，将用户代理名填入默认用户代理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181148592.png" alt="image.png"></p><p>4.配置好后，点击新建，将之前的下载链接复制粘贴下载即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181150249.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png&quot; alt=&quot;image_2022-11-16_11-48-14.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="百度网盘" scheme="https://fqzs.netlify.app/categories/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title>栈为什么从高地址往低地址分配内存</title>
    <link href="https://fqzs.netlify.app/undefined/e44ea15d.html"/>
    <id>https://fqzs.netlify.app/undefined/e44ea15d.html</id>
    <published>2023-06-14T23:19:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png" alt="image.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？</p><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>程序计数器(<code>Program Counter</code>，简称<code>PC</code>)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。</p><p>因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；</p><p>heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142320352.png" alt="image.png"></p><hr><h2 id="栈由高地址向低地址扩展的优点"><a href="#栈由高地址向低地址扩展的优点" class="headerlink" title="栈由高地址向低地址扩展的优点"></a>栈由高地址向低地址扩展的优点</h2><p><code>stack</code>从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142351623.png" alt="image.png"></p><p>并且<strong>这样设计可以使得堆和栈能够充分利用空闲的地址空间。</strong>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化</p><hr><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：x86，MIPS</li><li>主流2：自由选择：Arm（但个别指令仅支持向低）</li><li>罕见：向高地址扩展：PA-RISC，操作系统Multics</li><li>非主流：System z，栈是个链表[2]</li></ul><hr><h2 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h2><p><strong>1.栈内内存是连续分配</strong></p><pre><code>因位栈空间内存分配连续，如果给一个数组或对象分配内存，栈会优先选择还没有分配的最小的内存地址给数组，数组中的地址是从低地址到高地址依次分配。所以数组的第一个元素的起始地址就是给数组分配的最低地址</code></pre><p><strong>2.栈的栈顶指针ESP默认指向栈顶</strong></p><pre><code>对数组的访问一般都是对一个数组的起始地址进行操作，也就是说我们需要的是数组的起始地址-&gt;也就是低地址，由于栈顶指针默认指向的是栈顶元素，那么只能是栈顶指针指向低地址值--&gt;这样便于对数组的访问。如果栈还是采用从低地址到高地址的扩展，那么就不会默认指向数组的起始地址(数组指针)，不便于访问。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>LaTaX语言</title>
    <link href="https://fqzs.netlify.app/undefined/31c326ac.html"/>
    <id>https://fqzs.netlify.app/undefined/31c326ac.html</id>
    <published>2023-06-12T16:19:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png" alt="image.png"></p><p><code>1.求和表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;n=0&#125;^&#123;\infty&#125;n$$</span><br><span class="line"></span><br><span class="line">其中，\sum表示求和符号，n表示要累加的变量，0表示起始索引，\infty表示末尾索引。所以，上述表达式表示了从0开始到正无穷的所有整数之和。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}n</script><hr><p><code>2.积分表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\int_&#123;-\pi&#125;^&#123;\pi&#125;f(x)dx$$</span><br><span class="line"></span><br><span class="line">其中，$\int$ 表示积分符号，$f(x)$ 表示要积分的函数，$dx$ 表示积分的变量（即积分变量），$-\pi$ 和 $\pi$ 分别表示积分的下限和上限。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(x)dx</script><hr><p><code>3.分式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;a&#125;&#123;b&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$a$ 表示分子，$b$ 表示分母。它表示了 $a$ 与 $b$ 之间的比率关系，也可以理解为 $a$ 中包含了 $b$ 的多少倍。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\frac{a}{b}</script><hr><p><code>4.下标</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$a_i$$</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$$x_&#123;i,j&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$i$ 和 $j$ 是变量的下标，它们用于表示该变量的某个特定元素。在第一个例子中，$a$ 中的 $i$ 表示 $a$ 数组中的第 $i$ 个元素；在第二个例子中，$x$ 中的 $i$ 和 $j$ 分别表示一个二维数组 $x$ 中的第 $i$ 行第 $j$ 列的元素。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">a_i</script><script type="math/tex; mode=display">x_{i,j}</script><hr><p><code>5.向量</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$\vec&#123;v&#125;$ 表示向量，“$$\begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$” 表示以列的形式表示的向量，$v_1$、$v_2$、$\ldots$、$v_n$ 是向量中的元素。如果向量是一个二维向量，那么它还可以写成如下形式：</span><br><span class="line"></span><br><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; x \\ y \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$x$ 和 $y$ 分别是二维向量 $\vec&#123;v&#125;$ 的 $x$ 和 $y$ 分量</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n\end{pmatrix}</script><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}</script><hr><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号``，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\&#123; \&#125;</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum<em>{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A</em>{k<em>0}A</em>{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li><li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li><li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.求和表达式&lt;/code&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="LaTax" scheme="https://fqzs.netlify.app/categories/LaTax/"/>
    
    
  </entry>
  
  <entry>
    <title>多地址指令实际访存次数</title>
    <link href="https://fqzs.netlify.app/undefined/7566551b.html"/>
    <id>https://fqzs.netlify.app/undefined/7566551b.html</id>
    <published>2023-06-10T10:44:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png" alt="image.png"></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>english</title>
    <link href="https://fqzs.netlify.app/undefined/2c830200.html"/>
    <id>https://fqzs.netlify.app/undefined/2c830200.html</id>
    <published>2023-06-08T11:44:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png" alt="image.png"></p><h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a><strong>定语</strong></h2><p><em>hypocritical虚伪的、spectacle壮观的场面、intense激烈的、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a><strong>状语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a><strong>同位语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a><strong>插入语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p><h1 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conmence 毕业典礼、开始</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162327530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162328895.png" alt="image.png"></p><h2 id="句子之间的连接方式"><a href="#句子之间的连接方式" class="headerlink" title="句子之间的连接方式"></a>句子之间的连接方式</h2><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162329883.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162349412.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306170009789.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162352377.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162354284.png" alt="image.png"></p><h3 id="主从复合句"><a href="#主从复合句" class="headerlink" title="主从复合句"></a>主从复合句</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207495.png" alt="image.png"></p><h4 id="状语从句-副词性从句"><a href="#状语从句-副词性从句" class="headerlink" title="状语从句(副词性从句)"></a>状语从句(副词性从句)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207245.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181217682.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.It doesn&#x27;t feel like a human or democratic relationship,even if both sides</span><br><span class="line">benefit.</span><br><span class="line">即使双方都受益，也不是人与人之间平等的关系</span><br><span class="line"></span><br><span class="line">2.As the cost to everyone else has become clearer,politicians have begun to</span><br><span class="line">clamp down.</span><br><span class="line">因为每个人所承受的代价变得显而易见了，政客们已经开始施压了</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181225896.png" alt="image.png"></p><h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><h5 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">That the seas are being over fished has been known for years--&gt;主语从句</span><br><span class="line"></span><br><span class="line">--&gt;一般会改写为形式主语--&gt; it has been knows for years that...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181304536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181305134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181306845.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181312445.png" alt="image.png"></p><h5 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181441584.png" alt="image.png"></p><h5 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181444199.png" alt="image.png"></p><h5 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181449900.png" alt="image.png"></p><h5 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181601408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181608655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181612050.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181613273.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181619664.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181620104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181625756.png" alt="image.png"></p><h1 id="层次化阅读和主干隔离"><a href="#层次化阅读和主干隔离" class="headerlink" title="层次化阅读和主干隔离"></a>层次化阅读和主干隔离</h1><h2 id="层次化阅读法"><a href="#层次化阅读法" class="headerlink" title="层次化阅读法"></a>层次化阅读法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052224384.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042239593.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042240478.png" alt="image.png"></p><p><em>substance 物质  、clinical nutirtion 临床营养学 、utilize 利用 、distinct 明显的、essential 必要的 、agent 介质、constituent 组成部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042245516.png" alt="image.png"></p><h2 id="主干隔离法"><a href="#主干隔离法" class="headerlink" title="主干隔离法"></a>主干隔离法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052225973.png" alt="image.png"></p><blockquote><p><em>将主语与谓语连在一起读，中间部分调整语序</em></p></blockquote><p>*artisans 工匠、artists 艺术家、machanic 技工、establishment 机构、组织</p><p>The notion - 这个观念、这个想法</p><p>that learning should have in it an element of inspired play - 观念认为学习应该融入受启发的游戏元素</p><p>would seem - 似乎</p><p>to the greater part of the academic establishment - 对大部分有学术性的机构或组织(如学校、大学等)</p><p>merely silly - 只是一个愚蠢的想法*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052227844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052229938.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052236404.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052237748.png" alt="image.png"></p><h1 id="非谓语动词和独立主格结构"><a href="#非谓语动词和独立主格结构" class="headerlink" title="非谓语动词和独立主格结构"></a>非谓语动词和独立主格结构</h1><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060933764.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060942180.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060946157.png" alt="image.png"></p><h2 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h2><p><em>带有主语的非谓语动词</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060953217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060956043.png" alt="image.png"><br><em>Media 媒体 、epidemic 流行病、cigarette 香烟、liken 比作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061003195.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061007239.png" alt="image.png"></p><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061012037.png" alt="image.png"></p><blockquote><p><em>部分倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061019182.png" alt="image.png"></p><blockquote><p><em>完全倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061023671.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061046014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061049074.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061050328.png" alt="image.png"></p><h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061056945.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061107064.png" alt="image.png"></p><p><em>individual 个体 、maximaize 最大化、profits利润、coupled with 以及(相等于and)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061121649.png" alt="image.png"></p><h1 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061131321.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061130607.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061140766.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061141718.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061142254.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061148829.png" alt="image.png"></p><h1 id="实战解析"><a href="#实战解析" class="headerlink" title="实战解析"></a>实战解析</h1><p><em>cognitive认知 、caregiver看护者</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061158889.png" alt="image.png"></p><p><em>imposter 冒牌者   、file(ing) cabinet  文件柜、 fraught 充满 、reconcile 调和、和解 、<br>designate 指定、指派(职务)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071032339.png" alt="image.png"></p><p><em>overwhelming 巨大到无法应付的。指某事物之多、之严重以至于无法有效应对。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071556623.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071614505.png" alt="image.png"></p><p><em>Come to a halt的含义是停止;停顿下来。<br>它表示某物停止了运动或工作。强调运动或行为的终止。<br>例句:<br>The car came to a sudden halt.<br>那辆车突然停了下来 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071621176.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071625167.png" alt="image.png"></p><p><em>quantum computers 量子计算机 、crack 破解、encryption加密</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071639372.png" alt="image.png"></p><p><em>mutually 互相、composed of 由..组成  、composed 镇定的，有条理的、simulate模拟<br>interactions 相互影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071727387.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071728023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071804873.png" alt="image.png"></p><hr><blockquote><p>!!!</p></blockquote><p>proportion 的意思是:</p><p>比例,部分,成比例</p><ol><li>proportion 指在整体中所占的百分比或比例。例如:</li></ol><ul><li><p>What proportion of your income do you spend on rent? 你的收入中有多大比例用于支付房租?</p></li><li><p>Only a small proportion of applicants are admitted to this school. 只有一小部分申请者能被这所学校录取。</p></li></ul><ol><li>proportion 也可以表示一个量与另一个量之间的比较关系,指成比例。例如:</li></ol><ul><li><p>Mix the ingredients in the proper proportion. 按正确的比例混合这些材料。</p></li><li><p>The model was built in exact proportion to the original building. 这个模型按原建筑的精确比例建造的。</p></li></ul><ol><li>proportion 还可以指大小、范围或重要性的程度。例如:</li></ol><ul><li><p>The cost overrun was of massive proportion. 造价超支的规模巨大。</p></li><li><p>An issue of such proportion requires careful thought. 这么重大的问题需要慎重考虑。</p></li></ul><p><strong>literacy 的意思是:</strong></p><p>识字能力,读写能力</p><p>literacy 指一个人阅读和写作的基本能力,特别是在 mother tongue(母语)中的读写能力。</p><p>一些关于literacy的例子:</p><ul><li><p>Improving literacy is a priority, as it helps break the cycle of poverty. 提高识字率是优先事项,这有助于打破贫困循环。</p></li><li><p>The government has launched a campaign to boost literacy among adults. 政府启动了一个运动来提高成人的读写能力。</p></li><li><p>Children’s literacy skills develop through reading books and stories. 儿童的读写能力通过读书和故事得到发展。</p></li><li><p>Digital literacy is increasingly important in the internet age. 在互联网时代,数字读写能力越来越重要。</p></li><li><p>Functional literacy refers to the basic skills needed to function in society. 功能性识字能力是指一个人在社会中基本需求的读写能力。</p></li></ul><p><em>institution 机构、制度、组织  ， soild 坚固的、扎实的、牢固的，souvenir 纪念品<br>quill 鹅毛笔</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091525945.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>fitigue 的意思是疲劳,疲惫。</p><p>它是一个来自法语的英语词汇,常见的用法有:</p><ol><li><p>身体上的疲劳,疲惫 例句:After a long run, I felt fatigue in my legs. 长时间跑步后,我腿感到了疲劳。</p></li><li><p>精神上的疲惫 例句:Mental fatigue built up after hours of study. 坐了几个小时后精神上感到了疲惫。</p></li><li><p>金属疲劳 例句:The metal wing suffered fatigue after many flights. 金属机翼在多次飞行后出现了金属疲劳。</p></li><li><p>造成疲劳的因素或过程 例句:Sleep deprivation leads to increased fatigue. 睡眠不足会导致疲劳加剧。</p></li></ol><p>poll 有以下几层常见意思:</p><ol><li>民意调查;选举投票</li></ol><p>例句:The latest polls show he has a slim lead over his opponent. 最新民调显示他比对手略占优势。</p><ol><li>票数;票汇总</li></ol><p>例句:After the polls closed, vote counting began immediately. 在投票结束后,票票汇总工作立即开始。</p><ol><li>投票站;选区</li></ol><p>例句:There were long lines at the polls this morning. 今天早晨投票站前有长长的队伍。</p><ol><li>票选,投票</li></ol><p>例句:About 60% of voters polled today. 大约有60%的选民今天参与了投票。</p><ol><li>统计,调查</li></ol><p>例句:Let’s take a poll of everyone’s opinion on this matter. 让我们统计一下每个人对这个问题的看法。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152210940.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217622.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217842.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>acknowledge 的意思是:</p><ol><li>承认,认可</li></ol><p>例句:He acknowledged that he had made a mistake. 他承认了自己犯了一个错误。</p><ol><li>感谢,表达谢意</li></ol><p>例句:I acknowledge all the staff for their hard work. 我对全体员工的辛勤工作表示感谢。</p><ol><li>回复,对…作出响应</li></ol><p>例句:She acknowledged my email with a quick reply. 她很快回复了我的电子邮件。</p><ol><li>收到,收悉</li></ol><p>例句:Please acknowledge receipt of this document. 收到此文件请回执。</p><p><em>cut adrift 被抛弃、sector行业，领域、self-critical自我批判、landlord房东</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152225925.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>dynamic 的常见意思有:</p><ol><li>动态的,不断变化的</li></ol><p>例句:a dynamic economy 动态变化的经济</p><ol><li>积极有活力的</li></ol><p>例句:a dynamic young leader 一个精力充沛的年轻领导者</p><ol><li>(音量)强弱变化的</li></ol><p>例句:the dynamic range of the music 音乐的动态范围</p><ol><li>(力学术语)动力学的</li></ol><p>例句:dynamic equilibrium 动态平衡</p><ol><li>动力的,与动力相关的</li></ol><p>例句:a dynamic microphone 动力麦克风</p><p>所以,dynamic的意思是“动态的、变化的”,强调不断变化和活力,与“static”相对。可以广泛地应用于许多领域</p><p><em>publishing industry出版行业</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161009103.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>casino 是赌场的意思。</p><p>例句:</p><ol><li><p>There are many large casinos in Las Vegas. 拉斯维加斯有许多大型赌场。</p></li><li><p>He lost a lot of money gambling in the casino. 他在赌场赌博损失了很多钱。</p></li><li><p>The new casino brought in tourism revenue for the city. 新的赌场为这座城市带来了旅游收入。</p></li><li><p>She always plays blackjack when she visits casinos. 她每次去赌场都会玩二十一点。</p></li><li><p>The casino was open 24 hours and full of slot machines. 这个赌场24小时营业,里面满是老虎机。</p></li></ol><p>综上所述,casino 代表赌场这个场所,里面有各种赌博游戏,例如扑克、轮盘、老虎机等。赌场主要为赌博提供场所,通常还有酒店、餐厅、商场等设施和娱乐活动。</p><hr><p>gambling 的意思是赌博、赌钱。</p><p>常见的词义包括:</p><ol><li><p>赌博活动 例句:Gambling is illegal in some countries. 在一些国家赌博是非法的。</p></li><li><p>赌钱 例句:Many people lose a lot of money through gambling. 很多人通过赌博损失了大量金钱。</p></li><li><p>冒险 例句:Changing jobs now would be a gamble. 现在换工作将是一次冒险。</p></li><li><p>对…抱有希望 例句:I’m gambling that the weather will be nice tomorrow. 我抱着明天天气会好的希望。</p></li><li><p>孜孜不倦地追求 例句:He is gambling for fame and reputation. 他孜孜不倦地追求名誉和声望。</p></li></ol><p>综上所述,gambling 意思是赌博、赌钱,通常涉及金钱的风险投机。延伸意思是冒险以及抱有希望。</p><hr><p>coasting on 意思是“依靠,利用(之前的成就或努力)”。</p><p>这是一个常见的英语习语,意思是指一个人或组织停止努力,而是依靠或利用过去的成就和努力来维持当前的状态或成功。</p><p>例句:</p><ol><li><p>After the company’s initial success, the CEO has just been coasting on its reputation rather than innovating. 在公司最初成功之后,CEO一直依靠其声誉,而不是创新。</p></li><li><p>The actor admitted to coasting on his previous roles and hasn’t taken up new challenges lately. 这位演员承认自己近期沿用老角色,没有接受新挑战。</p></li><li><p>The professor seems to be coasting on her book’s popularity rather than producing new research. 这位教授似乎依靠她书籍的畅销,而不是进一步研究。</p></li><li><p>Successful entrepreneurs cannot afford to coast on past achievements. 成功的企业家不能依赖过去的成就。</p></li></ol><p>综上所述,coasting on 意味着依靠过去努力的成果,而不是继续付出努力。通常有负面的含义,意味着一个人或组织变得自满和懒惰。</p><hr><p>pan out 是一个英语习语,意思是“结果变成,发展成”。</p><p>例句:</p><ol><li><p>His business idea didn’t pan out as he had hoped. 他的商业想法结果没有如他所愿。</p></li><li><p>We’re still waiting to see how this new project pans out. 我们仍在观望这个新项目的发展。</p></li><li><p>I don’t think this relationship is going to pan out after all. 我认为这段关系结果不会太理想。</p></li><li><p>If their date pans out, they might start a relationship. 如果他们的约会进展顺利,他们可能会开始一段关系。</p></li><li><p>His career as a musician never really panned out. 他作为音乐家的职业生涯结果并不成功。</p></li></ol><p>综上所述,pan out 意思是经过发展或等待结果后,事情的结果最后如何,是否成功或达到预期。也可以表示事情最终结果的好坏。</p><p><em>enormous revenues 意思是“巨大的收入”或“极高的营收”、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161019158.png" alt="image.png"><br><em>big advance 巨额预付金、preexisting先前存在的、frenzy狂热、疯狂失控</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161025712.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>contexts 是名词,复数形式,主要有以下几层含义:</p><ol><li>文章或谈话中的语言环境,提供理解词语或行为的额外信息。<br>例句:You can’t understand what he meant without looking at the wider context of the conversation. 如果不考虑谈话的更广泛语境,你就无法理解他的意思。</li><li>事件或行为发生的背景情况。<br>例句:In the context of high unemployment, the policy makes sense. 在高失业率的背景下,这项政策有意义。</li><li>程序运行或操作的环境。<br>例句:This function behaves differently depending on the software context. 这个功能的运行取决于软件环境的不同而有区别。</li><li>论证或思考的前提条件或框架。<br>例句:Examine the problem in the context of the limitations we face. 在我们面临的限制条件下审视这个问题。</li></ol><hr><p>constraining 的意思是“限制的、约束的”。它来源于动词constrain,意为“限制、抑制”。</p><p>constraining 作为形容词,常用于以下场合:</p><ol><li>限制行为或活动的规则或条件。</li></ol><p>例句:The new policy imposes constraining regulations on business. 新政策对企业施加了限制性规定。</p><ol><li>限制思维或创造力的框架或因素。</li></ol><p>例句:We need to think outside constraining traditional paradigms. 我们需要跳出限制思维的传统模式。</p><ol><li>限制行动或发展的不利环境或因素。</li></ol><p>例句:Poverty is a constraining factor that traps people in disadvantage. 贫穷是一个制约因素,让人们无法摆脱劣势。</p><ol><li>紧缚的、禁锢的衣物或配饰。</li></ol><p>例句:She refused to wear constraining clothes that restricted her movement. 她拒绝穿会限制行动的紧身衣服。</p><hr><p>pertaining 的意思是“关于”,“与…有关”。它是一个正式用语,通常用于描述某人或某事与特定主题、事件或情况有关。</p><p>例句:</p><ol><li><p>All documents pertaining to the legal case must be submitted to the court. 所有与此法律案件有关的文件都必须提交给法院。</p></li><li><p>The police asked questions pertaining to the accident. 警察问了一些关于这起事故的问题。</p></li><li><p>The manager sent a memo pertaining to the new company policy. 经理发了一则与新公司政策相关的备忘录。</p></li><li><p>The museum has a collection of artifacts pertaining to ancient Egypt. 博物馆有一个关于古埃及的藏品收集。</p></li><li><p>I need some advice pertaining to filing my taxes this year. 我需要一些建议,关于今年报税的事宜。</p></li></ol><hr><p>labor 的意思是“劳动,劳力”。它是一个常用词,主要有以下几层含义:</p><ol><li>工作,尤其是体力劳动。</li></ol><p>例句:Farming is hard labor. 农活是体力劳动。</p><ol><li>工人阶级,劳动者。</li></ol><p>例句:The new policy protects the rights of labor. 这项新政策保护劳动者的权益。</p><ol><li>分娩的努力和痛苦,即生产过程。</li></ol><p>例句:The mother was in labor for 10 hours. 这位母亲经历了10小时的分娩过程。</p><ol><li>工作结果,劳动成果。</li></ol><p>例句:The Pyramids are an amazing labor of ancient Egyptians. 金字塔是古埃及人惊人的劳动成果。</p><ol><li>具有特定功能的工作或任务。</li></ol><p>例句:Every part has its own labor in the workings of a machine. 在机器运转中,每个部件都有其特定的功能。</p><p><em>curtail 削弱、缩短、限制、 seek 寻找、pursue追求、 oppressive压迫的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161034961.png" alt="image.png"></p><p><em>vaccine 疫苗、corporate regulation企业监管、 labor劳工、劳动力、civil民事的、公民的 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161043329.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>extract 的意思是“提取;摘录”,是个常用词,主要有以下几层含义:</p><ol><li>从某物中提取或分离出某个成分、物质等。</li></ol><p>例句:extract oil from coal 从煤中提取油</p><ol><li>摘录,选取某文献中的段落或内容。</li></ol><p>例句:extract key passages from the book 从书中摘录主要段落</p><ol><li>获取、套取(信息等)。</li></ol><p>例句:extract a confession from him 从他那里套取口供</p><ol><li>引出,推断出(结论等)。</li></ol><p>例句:extract meaning from the data 从数据中推断出意义</p><ol><li>移去,拔出(牙齿等)。</li></ol><p>例句:The dentist extracted two teeth. 牙医拔除了两颗牙。</p><p>所以,extract 的基本意思是从某物中提取出某部分或物质;也可以指获取一些隐藏或不容易觉察的信息。</p><hr><p>vantage</p><ol><li>有利条件,优势。</li></ol><p>例句:a good vantage point to watch birds 观察鸟类的有利位置</p><ol><li>视野,视力范围。</li></ol><p>例句:Beyond my vantage, I could see the lake. 在我的视野范围之外,我可以看到湖泊。</p><ol><li>预见,预知。</li></ol><p>例句:He plans with vantage for the future. 他预见未来做计划。</p><ol><li>利益,好处。</li></ol><p>例句:I have no personal vantage in this. 这对我没有任何个人利益。</p><hr><p><em>scramble 的基本意思是匆忙或火急火燎的样子、crucial至关重要的、fossil fuels化石燃料、 tear up 撕碎的弄破的、plants植物、工厂、设备、 rural农村的、urban城市的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161330773.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331524.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>dwell 停留、居住、 atmosphere大气、气氛、环境、plain平坦的、平淡的、 dull迟钝的、无聊的·、 version版本 、notification通知、通告、storm风暴</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422007.png" alt="image.png"><br>￼<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422229.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>critics 评论家、 stand as is 保持原样、penguin企鹅</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432549.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432535.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>reframe 的意思是“重新塑造,重构”,reframe 是由前缀 re- (再次)和 frame(框架)组合而成的词。</p><p>reframe 作为动词,主要有以下含义:</p><ol><li>重新组织,调整结构或框架。</li></ol><p>例句:We need to reframe our business strategy. 我们需要重新组织我们的商业战略。</p><ol><li>以新的观点或角度重新审视。</li></ol><p>例句:Let’s reframe this issue in a more positive light. 让我们以更正面的视角来重新审视这个问题。</p><ol><li>重新描绘,重述。</li></ol><p>例句:He reframed his experiences more constructively. 他以更建设的方式重述了他的经历。</p><ol><li>调整态度,换种思维方式。</li></ol><p>例句:Reframing problems as opportunities. 将问题重塑为机遇。</p><p>所以,reframe 意思是把事情放在一个新的框架或视角中进行重新思考,以产生新的结构、见解或态度。</p><hr><p>spectrum 的意思是“范围, 光谱”。主要有以下几层含义:</p><ol><li>范围,系列,一系列邻接的事物。</li></ol><p>例句:There is a wide spectrum of opinions on the issue. 这个问题有广泛的观点范围。</p><ol><li>光谱,按波长顺序排列的电磁波颜色范围。</li></ol><p>例句:Sunlight contains all the wavelengths of the visible light spectrum. 阳光包含了可见光谱中所有的波长。</p><ol><li>分类,按顺序或级别排列的系统。</li></ol><p>例句:the whole political spectrum from left to right 政治光谱上的全部派别</p><ol><li>范围,多种选择或可能性。</li></ol><p>例句:We offer a spectrum of investment options. 我们提供一系列投资选择。</p><ol><li>范畴,领域。</li></ol><p>例句:The issue falls outside the spectrum of this committee. 这个问题超出了委员会的范畴。</p><p><em>beaming面带灿烂笑容、scrolling 滚动、浏览</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161442818.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>physician 的意思是“医生”,尤其是指正式的医学执业医师。</p><p>一些关键点:</p><ol><li><p>physician 指经过长时间医学训练和执业资格认证的医生。</p></li><li><p>它与 doctor 的含义基本相同,但physician 表示更专业和正式的医生身份。</p></li><li><p>physician 通常需要接受8年以上的医学院教育和临床实习。</p></li><li><p>主治医生(attending physician)和内科医生(physician)是两种常见的physician。</p></li><li><p>physician可以自主开业,也可以在医院、诊所、学术机构等工作。</p></li><li><p>与physician对应的是医疗助理职业,如护士、技师等。</p></li><li><p>按专业领域又可细分为儿科医生、外科医生、心理医生等。</p></li><li><p>口语中更常用doctor,但是正式场合仍使用physician。</p></li></ol><p>所以,physician指经过系统医学训练和考核,获得医生资格并执业的医疗专业人士。是医疗保健领域的核心职业之一。</p><hr><p>procedures 的意思是“程序;步骤”,表示完成某项工作或任务所需遵循的一系列步骤或流程。</p><p>些关键点:</p><ol><li><p>procedure 强调按照规定的顺序和方法来进行。</p></li><li><p>医疗程序(medical procedures)指进行疾病治疗或身体检查的标准步骤。</p></li><li><p>行政程序(administrative procedures)指在政府、公司或组织内部的官方工作流程。</p></li><li><p>程序也可以是规范某项活动的准则或方针。</p></li><li><p>程序的目的是提高工作效率、减少错误。</p></li><li><p>遵守程序意味着按照特定顺序执行每一步。</p></li><li><p>程序可能需要书面文档,以方便培训和规范操作。</p></li><li><p>如果情况失控,也可主动终止程序。</p></li><li><p>相比过程(process),程序更加规范化和固定化</p></li></ol><hr><p>strain 的意思有以下几个:</p><ol><li>拉、绷紧</li></ol><p>例句:Strain the rope tightly. 把绳子用力拉紧。</p><ol><li>扭伤;拉伤</li></ol><p>例句:I strained my back lifting those heavy boxes. 我搬动那些重箱子时扭伤了背。</p><ol><li>过度使用;损伤</li></ol><p>例句:Don’t strain your eyes watching TV in the dark. 别在暗处看电视伤眼睛。</p><ol><li>压力;负荷过重</li></ol><p>例句:The recent difficulties have put a strain on their relationship. 近来的困难给他们的关系造成了压力。</p><ol><li>过滤;过滤掉</li></ol><p>例句:Strain the noodles and run them under cold water.过滤面条并在冷水下冲洗。</p><ol><li>费力;竭力</li></ol><p>例句:She strained to hear what they were saying. 她竭力去听他们在说什么。</p><ol><li>(微生物的)菌株</li></ol><p><em>physicians 执业医师、procedures程序步骤、squeeze积压、挤出、incentivize激励</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161454669.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>are only as good as  ..的好坏取决于..  、precisely精确地· 正是、 metabolism新陈代谢<br>commerical 商业的、贸易的、盈利性质的  、variables变量   、dizzying令人头晕目眩的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161530860.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161541216.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>critical 的意思有以下几个方面:</p><ol><li>批评的;批判的</li></ol><p>例句:She has a very critical attitude toward modern art. 她对现代艺术持非常批判的态度。</p><ol><li>关键的;决定性的</li></ol><p>例句:Proper hydration is critical for athletes. 适当的水化对运动员来说非常关键。</p><ol><li>危急的;危重的</li></ol><p>例句:The patient’s condition was listed as critical after the accident. 事故后,病人的情况被列为危重。</p><ol><li>批评;批评意见</li></ol><p>例句:The film received excellent critical reviews. 这部电影获得了极好的评价。</p><ol><li>关键时刻;危急关头</li></ol><p>例句:We made it through the critical moment.我们挺过了最危急的时刻。</p><ol><li>临界;最高点</li></ol><p>例句:The reactor was close to its critical temperature.反应堆的温度接近临界点。</p><p>综上所述,critical 既可形容事物的重要性,也可表示对事物的批判分析,或描述达到极限的状态</p><hr><p>slash 的常见意思有:</p><ol><li>削减;打折</li></ol><p>例句:The store slashed prices for its end-of-season sale. 商店为季末销售大幅削减了价格。</p><ol><li>砍;割</li></ol><p>例句: He slashed through the vines with his machete. 他用大砍刀砍开藤蔓.</p><ol><li>猛砍;乱砍</li></ol><p>例句: The maniac slashed the victim repeatedly with a knife. 那个疯子用刀猛砍受害者。</p><ol><li>斜线</li></ol><p>例句: Write the date using slashes: mm/dd/yy. 用斜线表示日期:月/日/年。</p><ol><li>(在计算机字段中用于表示)一种选择或替代</li></ol><p>例句: Choose A/B/C. 选择A/B/C。</p><ol><li>(音乐样式)迷幻摇滚</li></ol><p>例句: Guns N’ Roses started as an LA slash metal band. 枪与玫瑰乐队最初是洛杉矶的卷舌摇滚乐队。</p><p>综上所述,slash 的意思与切、砍、削减、选择等相关,可以作为动词或名词使用。</p><hr><p>drilling 有以下几层含义:</p><ol><li><p>钻孔 - Drilling a hole into the wall to hang a picture. 为了挂画在墙上钻孔。</p></li><li><p>练习 - Repeatedly drilling math problems to memorize formulas. 重复训练数学题以记住公式。</p></li><li><p>军事训练 - Soldiers drilling every morning on the parade ground. 士兵每天早晨在操场进行军事训练。</p></li><li><p>疾行 - Drilling through the crowded sidewalk. 穿过拥挤的人行道疾行。</p></li><li><p>严格训斥 - The coach kept drilling the players on minor mistakes. 教练一直严厉指责球员的小错误。</p></li><li><p>开采;钻探 - An oil company is drilling for petroleum in the ocean. 石油公司在海洋钻探石油。</p></li><li><p>牙科钻孔 - The dentist will be drilling several cavities today. 今天牙医要钻几个蛀牙。</p></li></ol><p>所以,drilling 的基本意思是通过钻孔或重复性训练来获得或加强某项技能。</p><hr><p><em>methane甲烷  、 emissions排放、 drilling 钻探、maintained保持维持、dramatically显著的</em>、<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161551101.png" alt="image.png"></p><p><em>A risks B —&gt;A有可能导致B</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162306630.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>rage 的常见意思有:</p><ol><li>激怒;狂怒</li></ol><p>例句:Seeing the mess, he flew into a rage. 看到一团糟,他暴怒起来。</p><ol><li>激烈的情感;狂暴</li></ol><p>例句:a poem full of rage and passion 一首充满激愤与激情的诗歌</p><ol><li>风靡;盛行</li></ol><p>例句:A new dance craze is all the rage right now. 一个新的舞蹈热潮现在正风靡一时。</p><ol><li>激烈的争论或斗争</li></ol><p>例句:a philosophical rage 在哲学上的激烈争论</p><ol><li>精力旺盛;热情</li></ol><p>例句:Quitting smoking has filled me with a rage to live. 戒烟让我热情高涨,对生活充满了激情。</p><ol><li>暴力;激烈</li></ol><p>例句:the rage of war 战争的暴力</p><ol><li>(疾病的)流行</li></ol><p>例句:a flu rage 流感的流行</p><p>综上所述,rage 表示强烈愤怒或热情,也可指某事物的风靡或某情绪的强烈爆发。</p><hr><blockquote><p>!!!</p></blockquote><p><em>strategy战略、策略； uncovered揭露，揭示、confession坦白、忏悔、认罪</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171222257.png" alt="image.png"></p><p><em>protest抗议、抗议活动；sin罪行，罪恶；proactive积极主动地&lt;-反-&gt;passive消极的；<br>reputation名誉，声誉；massive大规模的，大量的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171327987.png" alt="image.png"></p><p><em>approach方法；statement声明</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171329142.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>consolidation 的意思是“巩固,加强”。它的常见含义有:</p><ol><li>巩固,加强已获得的地位或者优势。</li></ol><p>例句:The company is seeking to consolidate its dominant position in the market. 该公司正寻求巩固其在市场的主导地位。</p><ol><li>合并,将多个事物整合在一起。</li></ol><p>例句:There was a wave of consolidation among major banks. 主要银行进行了一波合并潮。</p><ol><li>使更加稳固、坚实。</li></ol><p>例句:The new evidence helped consolidate the argument. 新的证据帮助加强了这个论点。</p><ol><li>统一,整合(权力、资源等)。</li></ol><p>例句:The king consolidated his rule over the empire. 国王统一了他对帝国的统治。</p><ol><li>使(知识等)牢固。</li></ol><p>例句:We need to consolidate what we learned in class today. 我们需要巩固今天课堂上学到的知识。</p><ol><li>合并(财务账目等)。</li></ol><p>例句:All the subsidiaries report to HQ for financial consolidation. 所有子公司汇报给总部进行财务合并。</p><hr><p><em>trade-off 取舍、权衡 ；consolidation合并，加强；instance实例，情况</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171333756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171338448.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171343874.png" alt="image.png"></p><p><em>appropriate恰当的，适当的； collective集体的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171345209.png" alt="image.png"></p><hr><p>quo 的常见意思有:</p><ol><li>status quo</li></ol><p>这个词组表示“现状,原状”。</p><p>例句:We cannot continue with the status quo. We need changes. 我们不能维持现状。我们需要改变。</p><ol><li>pro quo</li></ol><p>这个词组表示“交换,回报”。</p><p>例句:Quid pro quo refers to an exchange of goods or services. Quid pro quo 指商品或服务的交换。</p><hr><p><em>is anything but simple不是容易的；pre-pandemic前疫情的  </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171348681.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>episode 的常见意思有:</p><ol><li>事件,故事的一个章节或阶段</li></ol><p>例句:The latest episode of the drama was very moving. 这部电视剧的最新一集非常动人。</p><ol><li>一段经历,一个阶段</li></ol><p>例句:That was an unfortunate episode in my life. 那是我一生中一段不幸的经历。</p><ol><li>发作,发病</li></ol><p>例句:The patient had a sudden episode of chest pain. 这个病人突然胸痛发作。</p><ol><li>一集电视节目</li></ol><p>例句:I missed the first episode of this TV series. 我错过了这个电视剧的第一集。</p><ol><li>情节中的一个片段</li></ol><p>例句:There are several funny episodes in the movie. 这部电影有几个搞笑的片段。</p><ol><li>事件,事变</li></ol><p>例句:The bombing was just one episode in the long conflict. 这次轰炸只是长期冲突中的一个事件。</p><p>所以,episode 指故事、事件发展中的一个阶段或段落,也可以指电视节目中的一集、或病人的一场发作。</p><hr><p>count 的常见意思有:</p><ol><li>计算;数数</li></ol><p>例句:Let me count the coins in my pocket. 让我数数口袋里的硬币。</p><ol><li>计数;计数值</li></ol><p>例句:What was the final count of votes? 最后的投票计数是多少?</p><ol><li>计数单位;数目</li></ol><p>例句:A vast count of stars are visible in the night sky. 夜空中可见无数的星星。</p><ol><li>重要;有影响力</li></ol><p>例句:Your opinion counts. 你的观点很重要。</p><ol><li>认为;视为</li></ol><p>例句:She counted him as one of her closest friends. 她视他为自己最亲密的朋友之一。</p><ol><li>依靠;信赖</li></ol><p>例句:You can always count on him for help. 对于寻求帮助你总能依靠他。</p><ol><li>控诉;指控</li></ol><p>例句:He was accused on five counts of fraud. 他被控五项诈骗罪。</p><ol><li>回数;节拍</li></ol><p>例句:The dancer kept perfect count throughout the performance. 舞者在整场表演中拍子始终正确。</p><hr><p><em>privileged有特权的；implicitly隐含的，默认的；class阶级；administration行政部门，政府机构；rescue营救，解救，脱困；uninsured没有保险的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171402709.png" alt="image.png"></p><p><em>crisis危机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171411443.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>just as significantly同样重要的是；industry行业； precedent先例</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171425766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171429332.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>contrast with与…形成对比 ；stark明显的，极端，荒凉;  elementary基础性的；element 元素，成分，要素</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171450834.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171458497.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>systematically 的意思是“有系统地”,是个副词。其含义是:</p><ol><li>按照系统或方法进行</li></ol><p>例句:We need to systematically analyze all the data. 我们需要系统地分析所有数据。</p><ol><li>有条理地,有步骤地</li></ol><p>例句:He systematically went through all the possible solutions. 他有条不紊地检查了所有可能的解决方案。</p><ol><li>有计划地,有组织地</li></ol><p>例句: The manager systematically arranged all the tasks. 经理有组织地安排了所有任务。</p><ol><li>从根本上,彻底地</li></ol><p>例句: We must systematically change how things are done. 我们必须从根本上改变做事的方式。</p><ol><li>不断重复地,习以为常地</li></ol><p>例句: She was systematically abused by her partner. 她不断遭到伴侣的虐待。</p><p>综上,systematically 意思是按照预定的系统、计划或方法进行,做事有条理和组织,而不是碎片化和随意进行。</p><hr><p><em>bias偏见,偏心，倾斜；pernicious有害的，具有负面破坏性的；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171503468.png" alt="image.png"></p><p><em>strikes 击中，罢工，罢课；health care 医疗保健；pension退休金，养老金<br>median中位数，中线，中间值；household家庭，户，住户</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171558168.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>endure忍受；agency机构；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171614940.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>essence 的意思是:</p><ol><li>本质;实质;真谛<br>例句:The essence of his argument is that we need to focus on education. 他论点的真谛是我们需要关注教育。</li><li>精华;精髓;灵魂<br>例句:She has captured the essence of the book in her summary. 她在摘要中抓住了这本书的精髓。</li><li>(植物、化学品等的)香精;香料;香气<br>例句:This perfume contains floral essences. 这种香水含有花香精华。</li></ol><p>essential 的意思是:</p><ol><li>基本的;本质的;必不可少的<br>例句:Water is essential to human life. 水对人类生命至关重要。</li><li>不可或缺的;必需的<br>例句:An engineer needs an essential understanding of math. 工程师需要必不可少的数学知识。</li><li>香精;香精油</li></ol><hr><p><em>race种族；admission 接纳，录取；essential基本的，本质的；recrut招聘，征招 ；surrogates替代品；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171638065.png" alt="image.png"></p><h1 id="阅读强化"><a href="#阅读强化" class="headerlink" title="阅读强化"></a>阅读强化</h1><h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p><em><code>词汇体现观点</code></em></p><p><em>词汇体现观点、态度<br>stand in favor of sth 支持某事<br>Unfavorable 不支持<br>Lame 跛脚的<br>Ignore 忽视<br>Ignorant 无知的<br>sustainable 可持续的  sustain持续，连续不断<br>alleviate 缓解<br>aggravate 恶化<br>Lost 失去</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181112122.png" alt="image.png"><br><em>the Federal Court 联邦法院 、annually每年的、 is overturned 被推翻、<br>the supreme court 最高法院、 profit利润</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181117962.png" alt="image.png"></p><hr><p><em><code>如何寻找文章的中心对象？</code></em></p><p><em>题目一定是围绕中心对象展开—&gt;所以，找题目中心对象</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181126215.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181127934.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>rail 铁路、fare票价，车票、nationalizaion 国有化、revenue收入、ever-rising</em><br><em>ever-rising 在句子中的意思是“不断上升的;持续增长的”。它由ever和rising两个词组成。<br>ever 有“永远地”的意思。<br>rising 的现在分词形式,有“上升的;增长的”的意思。<br>将ever和rising组合起来,ever-rising就是一个复合形容词,表示某人或某事“不断上升;持续增长”的状态或趋势。</em><br><em>inflation膨胀、通货膨胀</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181145002.png" alt="image.png"></p><p>*collapse 的常见意思有:</p><ol><li>崩溃,倒塌<br>例句:The old building collapsed after the earthquake.<br>这座老房子在地震后倒塌了。</li><li>衰竭,崩溃<br>例句:The company is in danger of financial collapse.<br>这家公司有财务崩溃的危险。</li><li>折叠,收拢<br>例句:The chair can collapse for easy storage.<br>这把椅子可以折叠起来以便储存。</li><li>体力衰竭<br>例句:The runner collapsed from exhaustion midway through the race.<br>这位运动员在比赛中途由于体力透支而倒下。</li><li>瓦解,分崩离析<br>例句:The alliance between the two countries collapsed.<br>两个国家之间的联盟已瓦解。<br>综上所述,collapse 表示由于各种原因导致的崩溃、倒塌或瓦解的状态。*</li></ol><p><em>commuter 乘务员、compensation补偿，赔偿</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181149134.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>townsfolk 城市里的居民、 imitate模仿、tourism旅游业、Cadtle城堡</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181204822.png" alt="image.png"></p><h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p><em>discrimination歧视、condemn谴责、insidious隐藏的，潜在的、alphabetism字母表主义、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181347279.png" alt="image.png"></p><p>overlooked 的意思是“忽视,疏忽”。它是动词 overlook 的过去分词和过去式。<br>下面几个例句可以帮助理解它的意思:</p><ol><li>The teacher overlooked several mistakes in my essay.<br>老师在我的文章中忽视了几处错误。</li><li>Sorry, I overlooked your text message yesterday.<br>不好意思,我昨天忽略了你的短信。</li><li>The security guard overlooked the suspicious person entering the building.<br>安保人员疏忽了那个可疑人物进入大楼。</li><li>Her contributions were often overlooked by her colleagues.<br>她的贡献常常被同事们忽视。</li><li>In his haste, he overlooked a few important details.<br>他匆忙中忽略了几个重要细节。</li><li>The producer apologized for having overlooked the young actor’s talent.<br>制片人为忽视了那位年轻演员的天赋而道歉。<br>综上所述,overlooked 表示注意力不集中导致未注意或忽略某事物、某人的状态或行为,常与动词忽视、疏忽、未注意等意思相对应。</li></ol><p><em>conspicuous 明显的，引人注目的 、prejudice偏见，成见</em></p><p><strong>出现illustrate，is mentioned等等都是举例说明，不是对中心对象的说明 </strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181352977.png" alt="image.png"></p><p><em>subtle微妙的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181357709.png" alt="image.png"></p><p><em>ill-treated虐待</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181401359.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>is comparable to相当于…  、legitimate合法的、正当的、<br>illegal, illegitimate不合法的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181421451.png" alt="image.png"></p><p><em>is quoted to被引用来说明…  、Constitution宪法、interpretation解释，阐释<br>alter 改变，更改 、implement执行、实施、实现、violate违反规则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181426235.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p>diminishing 的意思是“逐渐减少的”,是动词diminish的进行时和过去分词形式。<br>下面几个例句可以帮助理解diminishing的意思:</p><ol><li>The diminishing food supplies posed a threat to the shipwrecked sailors.<br>不断减少的食物供应给那些遇难船员带来了威胁。</li><li>There has been a diminishing number of wildlife in the area due to habitat loss.<br>由于栖息地丧失,该地区的野生动物数量在不断减少。</li><li>His diminishing eyesight made it difficult for him to read.<br>他逐渐衰弱的视力使阅读变得艰难。</li><li>The diminishing sunlight signaled the coming of winter.<br>阳光逐渐减弱,标志着冬季的到来。</li><li>She felt a diminishing desire to socialize with friends.<br>她感到社交的欲望在不断减退。<br>综上所述,diminishing 指 etwas在不断减少或缩小,表示从更多到更少的过程或趋势。与increase, enhance等词义相反。</li></ol><p><em>asset资产财产 、deminish逐渐减少</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181434016.png" alt="image.png"></p><p><em>evade 逃避 、peer同龄人、reform改革、misinterpreted曲解、neglect忽略，忽视 、skepticism怀疑态度、怀疑主义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181435621.png" alt="image.png"></p><h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><blockquote><p><em>细节题，注意词，细节</em></p></blockquote><p><em>partly 部分地、construction建设，构建、transparancy透明度、公开性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192245188.png" alt="image.png"></p><hr><blockquote><p><em>态度题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192251461.png" alt="image.png"></p><blockquote><p><em>例证题</em></p></blockquote><p><em>Toyota Motor 丰田汽车 、demonstrate展示，证明</em></p><p><em>limbic 的意思是“边缘的,边界的”,来源于解剖学术语,常用来形容脑内负责情绪和记忆的结构区域。<br>limbic system 边缘系统,指大脑内边缘部位的一组核团和神经纤维,控制情感反应和本能行为。<br>limbic cortex 边缘皮层,大脑边缘区域的组织。<br>limbic lobe 边缘小叶,位于大脑半球内侧的一部分,与情绪和记忆相关。<br>limbic brain 边缘脑,主管情感反应和本能的脑区。<br>综上所述,limbic 在解剖学上专门用来指代大脑内与情绪和本能相关的结构,因为这些结构位于大脑的边缘区域。它与理性思考和认知判断相对,更多与情感和直觉相关。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192253419.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192258586.png" alt="image.png"></p><blockquote><p><em>词汇题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211010386.png" alt="image.png"></p><blockquote><p><em>推理题</em></p></blockquote><p><em>当题目中没有给出定位信息的时候，，需要主动定位，70%来自段落首句</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211014882.png" alt="image.png"></p><p><em>search agent 搜索代理程序或者搜索机器人、negotiate谈判、磋商</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211024090.png" alt="image.png"></p><blockquote><p><em>主题题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211032732.png" alt="image.png"></p><h2 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h2><blockquote><p><em>比对</em></p></blockquote><p><em>选项和答案来源比对,先根据题目细节定位到句子，再根据名词一定会重现，动词替换原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211036300.png" alt="image.png"></p><p><em>关于定位和比对的专项训练—细节题的定位和比对</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211039422.png" alt="image.png"></p><p><em>sustained 的意思是“持续的,不间断的”,是动词sustain的过去式和过去分词。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211043870.png" alt="image.png"></p><p><em>levy ,tax 税、 impose强制施加，征收税、platform站台，月台、apply primarily主要适用于… 、multinational跨国的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211051386.png" alt="image.png"></p><p><em>出现两个名词，可能要考虑两个名词需要用相近的次替换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211104367.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;五大基本句型&quot;&gt;&lt;a href=&quot;#五</summary>
      
    
    
    
    <category term="english" scheme="https://fqzs.netlify.app/categories/english/"/>
    
    
  </entry>
  
  <entry>
    <title>acdemic_gpt添加slack-Claude模型</title>
    <link href="https://fqzs.netlify.app/undefined/6ca9ded9.html"/>
    <id>https://fqzs.netlify.app/undefined/6ca9ded9.html</id>
    <published>2023-06-07T23:16:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png" alt="image.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p><p><code>3.ppt生成promt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">帮我制作一篇内容关于这篇文章的PPT，要求如下： </span><br><span class="line">第一、一定要使用中文。 </span><br><span class="line">第二、页面形式有3种，封面、目录、列表。 </span><br><span class="line">第三、目录页要列出内容大纲。 </span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页内容使用“=====列表=====”作为开头。 </span><br><span class="line">第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 </span><br><span class="line">第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 </span><br><span class="line">第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 </span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。 </span><br><span class="line">第九、请用代码块回复你生成的内容。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://fqzs.netlify.app/undefined/e255a10a.html"/>
    <id>https://fqzs.netlify.app/undefined/e255a10a.html</id>
    <published>2023-06-03T17:23:00.000Z</published>
    <updated>2023-08-09T15:04:27.633Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" alt="image.png"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被服务的</span><br><span class="line">关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资源有限同时发</span><br><span class="line">消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主要指</span><br><span class="line">下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上与服务端进</span><br><span class="line">    行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服务端又</span><br><span class="line">是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境当中，下载的</span><br><span class="line">主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一</span><br><span class="line">       点点交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电</span><br><span class="line">话(释放链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，</span><br><span class="line"> 然后再由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段</span><br><span class="line"> 的占用链路，不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机</span><br><span class="line">  发出报文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入</span><br><span class="line">10bit信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间</span><br><span class="line">被称为排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被</span><br><span class="line">称为处理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步</span><br><span class="line">  (SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载</span><br><span class="line">app，网络断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用</span><br><span class="line">  户数据报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返</span><br><span class="line">回确认信息后，才会发送下一段内容；如果没有接收到确认信息，那</span><br><span class="line">么会一直发送当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无</span><br><span class="line">需确认这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速</span><br><span class="line">度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发</span><br><span class="line">消息，qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进</span><br><span class="line">行区分，例如请qq的消息端口号是1，接收方端口号1的进程(qq)接</span><br><span class="line">收该条消息；微信端口号2，接收方端口号2的进程(微信)接受该条消</span><br><span class="line">息</span><br><span class="line">5.拥塞控制</span><br><span class="line">       - 传输层协议</span><br><span class="line">       1.TCP</span><br><span class="line">       2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服</span><br><span class="line">   务，网络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则</span><br><span class="line">进行对分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制</span><br><span class="line">校验)</span><br><span class="line">4.拥塞控制：是一种全局的调控，与流量控制不同(只是控制收发方的流量速</span><br><span class="line">度)，而拥塞控制，是对所有线路可能产生的拥塞进行控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里</span><br><span class="line">开始，到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和</span><br><span class="line">解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制：发送方速度过快或过慢，可以减慢或加速发送速度</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合</span><br><span class="line">都可在链路上传输</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基础知识1"><a href="#数据通信基础知识1" class="headerlink" title="数据通信基础知识1"></a>数据通信基础知识1</h3><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>单、半、全三种通信方式</em></p></blockquote><p><em>单工通信：一条单向的信道(一条信道同一时刻要么接收，要么发送)<br>半双工通信：两条单向的信道<br>全双工通信：两条双向的信道(一条信道同一时刻，可以同时发送和接收)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>串行与并行传输方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261729820.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输通信方式</em></p></blockquote><p><em>同步传输：传输数据是连续传输<br>异步传输：数据间间断断，传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261735457.png" alt="image.png"></p><h3 id="数据通信基础知识2"><a href="#数据通信基础知识2" class="headerlink" title="数据通信基础知识2"></a>数据通信基础知识2</h3><blockquote><p><em>码元</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261959550.png" alt="image.png"></p><blockquote><p><em>速率、波特</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001158.png" alt="image.png"></p><blockquote><p><em>带宽</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001622.png" alt="image.png"></p><h3 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h3><blockquote><p><em>奈氏准则</em></p></blockquote><ul><li><em>是在理想低通(无噪声、带宽受到限制)条件下，避免 <strong>码间串扰</strong>  确定的极限的码元的传输速率=2W Baud，所以极限 信息传输速率=2W ×n  （n是码元bit数，就是n进制码元）</em></li><li><em>W 表示带宽，单位Hz</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262100499.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262104722.png" alt="image.png"></p><blockquote><p><em>香农定理</em></p></blockquote><ul><li><em>是在带宽受限，且有噪声的信道中，规定的在该噪声条件下的，不影响码元判断的，极限数据传输速率</em></li><li><em>S/N是信噪比，常常用作10log10(S/N) 来进行转换，从而将单位记作dB,就是定义了一个转换数值的公式 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262108690.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262114311.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262115670.png" alt="image.png"></p><blockquote><p><em>香农和奈氏</em></p></blockquote><ul><li><em>奈氏准则：关注的是无噪声条件下，不会造成码间串扰的极限 数据传输速率</em></li><li><em>香农定理：关注的是在当前噪声条件下，不会导致数据码元判断失真的 数据极限传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262120589.png" alt="image.png"></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a><em>基带信号与宽带信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262222235.png" alt="image.png"></p><h4 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a><em>编码与调制</em></h4><p><em>将数据 编码 /调制 —&gt;信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262223896.png" alt="image.png"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a><em>数字数据编码为数字信号</em></h4><blockquote><p><em>非归零编码</em></p></blockquote><p><em>缺点是，需要额外的信道，传输时钟周期信号，告诉多久发一个bit信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271044394.png" alt="image.png"></p><blockquote><p><em>归零编码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262237642.png" alt="image.png"></p><blockquote><p><em>反向不归零编码</em></p></blockquote><ul><li><em>缺点是，对于发送全1的信号，无法判断，有多少个1，因为，高低电平都有可能是1</em></li><li><em>还有就是，缺点在全1，的时候，会出现长条，没有时钟周期，就无法得知发送了，多少个1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262234072.png" alt="image.png"></li></ul><blockquote><p><em>曼彻斯特编码</em></p></blockquote><ul><li><em>1bit数据，就是1码元，被调制成两段电平，所以数据传输速率只有调制速率的1/2</em></li><li><em>每个码元中间，有一次跳变，可以实现同步，可通过中间跳变反应时钟信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271051270.png" alt="image.png"></li></ul><blockquote><p><em>差分曼彻斯特编码</em></p></blockquote><ul><li><em>每个码元中间都有一次跳变，可以实现同步</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271059163.png" alt="image.png"></li></ul><blockquote><p><em>4B/5B编码</em></p></blockquote><ul><li><em>编码效率80%</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271101120.png" alt="image.png"></li></ul><h4 id="数字数据调制成模拟信号"><a href="#数字数据调制成模拟信号" class="headerlink" title="数字数据调制成模拟信号"></a><em>数字数据调制成模拟信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271105446.png" alt="image.png"></p><ul><li><em>采样频率要达到信号最高频率的2倍以上，以保证，可以在每一个最高频的信号峰之内都可以采样到2个信息，得到波峰图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271112992.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271114621.png" alt="image.png"></p><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271138465.png" alt="image.png"></p><blockquote><p><em>1.电路交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271319318.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320037.png" alt="image.png"></p><blockquote><p><em>2.报文交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320009.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320369.png" alt="image.png"></p><blockquote><p><em>3.分组交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321465.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321976.png" alt="image.png"></p><blockquote><p><em>数据交换方式的选择</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271324239.png" alt="image.png"></p><blockquote><p><em>3.1.分组交换—数据报方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271325439.png" alt="image.png"></p><p><em>无连接服务，就是事先不为分组确定传输路径，传输路径全靠路由选择</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326584.png" alt="image.png"></p><blockquote><p><em>3.2分组交换—虚电路方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326838.png" alt="image.png"></p><p><em>连接服务，就是事先要确定分组的传输路径，提前建立连接，然后再按照这个路径输送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327331.png" alt="image.png"></p><blockquote><p><em>虚电路与数据报方式的区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327057.png" alt="image.png"></p><h2 id="传输介质-信道"><a href="#传输介质-信道" class="headerlink" title="传输介质(信道)"></a>传输介质(信道)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271453976.png" alt="image.png"></p><ul><li><em>传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。</em></li><li><em>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了 电 气 特 性，因此能够识别所传送的比特流</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271431578.png" alt="image.png"></li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a><em>导向性传输介质</em></h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a><em>双绞线</em></h4><p><em>电流方向相反的铜线，绞合一起，磁感线相互抵消，减少相邻导线的电磁干扰</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271436145.png" alt="image.png"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><em>同轴电缆</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271440754.png" alt="image.png"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><em>光纤</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443295.png" alt="image.png"></p><blockquote><p><em>单模光纤和双模光纤</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271447411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443816.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271448705.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449288.png" alt="image.png"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a><em>非导向性传输介质</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449201.png" alt="image.png"></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><blockquote><p><em>中继器</em></p></blockquote><ul><li><em>中继器是对数字信号的再生(整形)</em></li><li><em>中继器是连接两个网段的桥梁，以助于数字信号的再生</em></li><li><em>中继器，只负责将数据发送到另一网段，不管数据中是否有错误</em></li><li><em>中继器两端可以连接相同传输介质，也可以不同传输介质</em></li><li><em>中继器两端网段一定要是统一协议</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271612539.png" alt="image.png"></p><blockquote><p><em>集线器</em></p></blockquote><p><em>集线器，可以连接多台主机，平分带宽，共享数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271616925.png" alt="image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="链路层的功能"><a href="#链路层的功能" class="headerlink" title="链路层的功能"></a>链路层的功能</h2><blockquote><p><em>数据链路层基本概念</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271636246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271637260.png" alt="image.png"></p><blockquote><p><em>功能概述</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639722.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639736.png" alt="image.png"></p><h3 id="封装成帧-amp-透明传输"><a href="#封装成帧-amp-透明传输" class="headerlink" title="封装成帧&amp;透明传输"></a><em>封装成帧&amp;透明传输</em></h3><blockquote><p><em>封装成帧</em></p></blockquote><p><em>在一段数据添加首部、尾部构成一个帧，接收端就能收到bit流后，能识别帧的开始和结束</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271708120.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271711174.png" alt="image.png"></p><blockquote><p><em>透明传输</em></p></blockquote><p><em>就是传输数据的bit组合不会影响，到帧开始和结束的判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271714311.png" alt="image.png"></p><blockquote><p><em>四种组帧的方法</em></p></blockquote><p><strong><em>1.字符计数法</em></strong></p><ul><li><em>帧的开始字符记录的是该帧的字符数(包括自己)</em></li><li><p><em>缺点是，当前面的字符出错，往后的全部会出错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271716399.png" alt="image.png"><br><strong><em>2.字符填充法</em></strong></p></li><li><p><em>传送文本，由于文本字符对应的ASCII码不会出现的bit组合充当帧头，帧尾，中间数据部分不会产生边界判定错误</em></p></li><li><em>如果传送的帧，由二进制程序，或图像等等非ASCII编码文本文件，数据内容有可能出现帧头，帧尾bit组合，导致中间穿插,帧边界判定错误</em></li><li><em>通过对数据部分 字节填充ESC转义字节 ，—&gt;使得特殊字符意义失效，实现干扰的解决</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271720950.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271724181.png" alt="image.png"></p><p><strong><em>3.零比特填充法</em></strong></p><p><em>以01111110 作为帧头和帧尾，发送端先将数据扫描，将所有连续的5个1 后都插入0，这样就不会出现6个1 ，再封装成帧；接收端，再逆过程去掉0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271726553.png" alt="image.png"></p><p><strong><em>4.违规编码法</em></strong></p><p><em>曼彻斯特编码中不会出现的状态(高-高/低-低)来表示帧头，帧尾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271729961.png" alt="image.png"></p><h3 id="差错控制—检错编码"><a href="#差错控制—检错编码" class="headerlink" title="差错控制—检错编码"></a><em>差错控制—检错编码</em></h3><blockquote><p><em>差错从何而来？</em></p></blockquote><ul><li><em>差错来源：随机噪声（线路本身电气特性产生）、冲击噪声（外界短暂原因）</em></li><li><p><em>差错：位错；帧错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271901773.png" alt="image.png"></p></li><li><p><em>链路层编码与物理层编码调制不同：链路层编码是用于<strong>一组比特</strong>，判断传输过程是否出现出错。物理层编码调制针对<strong>单个比特</strong>，解决的是传输过程中 比特同步的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271903232.png" alt="image.png"></p></li></ul><blockquote><p><em>差错控制—检错编码—奇偶校验码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271910981.png" alt="image.png"></p><blockquote><p><em>差错控制—检错编码—CRC循环冗余码</em></p></blockquote><p><em>接收结果作 余数为0，就无差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271911773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271912297.png" alt="image.png"></p><h3 id="差错控制—纠错编码"><a href="#差错控制—纠错编码" class="headerlink" title="差错控制—纠错编码"></a><em>差错控制—纠错编码</em></h3><blockquote><p><em>海明距离</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272215926.png" alt="image.png"></p><blockquote><p><em>海明码纠错步骤</em></p></blockquote><p><strong><em>1.确定校验码位数r</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217701.png" alt="image.png"></p><p><strong><em>2.确定校验码和数据的位置</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217078.png" alt="image.png"></p><p><strong><em>3.求出校验码的值</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272220510.png" alt="image.png"></p><p><strong><em>4.检错并纠错</em></strong><br><em>方式1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272228839.png" alt="image.png"></p><ul><li><em>先每个校验码对应一个大圆，分别填入器其校验码序号</em></li><li><em>交集部分，填入校验码负责校验的一组序号中重叠的序号数据</em></li><li><em>最中间是三个校验码负责的重叠序号</em></li><li><em>2号校验码负责的没有出错，1,4号出错，所以3，6,7，排除，只剩下5</em></li></ul><p><em>方式2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272242979.png" alt="image.png"></p><blockquote><p><em>海明码纠错演示</em></p></blockquote><p><strong><em>1．传输的数据：1101</em></strong></p><p><strong><em>2．校验位计算公式：</em></strong></p><p>2^k &gt;= k+n+1,n为数据位在本例中计算的k为3；</p><p>用P1,P2,P3,表示校验位，其中</p><p>P1,的位数2^0,P2,的位数2^1,P3,的位数2^2</p><p>则：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>1+2</th><th>4</th><th>1+4</th><th>2+4</th><th>1+2+4</th></tr></thead><tbody><tr><td>位数的二进制</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td></tr><tr><td>位数</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>数据位</td><td></td><td></td><td>1</td><td></td><td>1</td><td>0</td><td>1</td></tr><tr><td>校验位</td><td>P1,</td><td>P2,</td><td></td><td>P3</td><td></td><td></td></tr></tbody></table></div><p><strong><em>3.分组：</em></strong></p><div class="table-container"><table><thead><tr><th>校验位</th><th>位数分组</th></tr></thead><tbody><tr><td>P1,</td><td>1,3,5,7</td></tr><tr><td>P2,</td><td>2,3,6,7</td></tr><tr><td>P3</td><td>4,5,6,7</td></tr></tbody></table></div><p><strong><em>4.计算校验位值(异或运算)</em></strong></p><p>P1^1^1^1=0,得P1=1</p><p>P2^1^0^1=0,得P2=0</p><p>P3^1^0^1=0,得P3=0</p><p>最终传输的数据位：10101<code>0</code>1</p><p><strong><em>5,检验</em></strong><br>     如果接收端收到的是10101<code>1</code>1<br>     还是按照刚才的分组进行计算P1,P2P3每个分组的异或值，为零则无错，为1则有错。<br>     P1组 1^1^1^1=0<br>     P2组 0^1^1^1=1<br>     P3组 0^1^1^1=1</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a><em>流量控制与可靠传输机制</em></h3><p><em>可靠传输的意思是数据发送端发送什么数据，数据接收放就接收到什么数据，没有出现分组丢失、差错、重复、乱序等情况。</em></p><h4 id="流量控制与可靠传输的方法"><a href="#流量控制与可靠传输的方法" class="headerlink" title="流量控制与可靠传输的方法"></a><em>流量控制与可靠传输的方法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281155434.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157464.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157841.png" alt="image.png"></p><ul><li><em>停止-等待协议  ，发送窗口=1，接收窗口=1</em></li><li><em>后退N帧协议（GBN）发送窗口&gt;1,接收窗口=1</em></li><li><em>选择重传协议（SR）发送窗口&gt;1,接收窗口&gt;1</em></li></ul><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p><em>为什么要有停止等待协议？</em></p></blockquote><ul><li><em>为了解决流量控制的问题：互相的停止等待，使得不会传输太多的数据</em></li><li><em>为了解决可靠传输的问题：互相停止等待，接收确认帧，能保证能发现差错，以及处理差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281348782.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—无差错情况</em></p></blockquote><ul><li><em>ACK i 是接收方收到第 i 号帧之后，返回给发送方的确认帧</em></li><li><em>每次发送一个数据帧就停止等待，所以只需要1bit来对帧进行编号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352535.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—有差错情况</em></p></blockquote><p><strong><em>1.数据帧丢失或检测到帧出错</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352337.png" alt="image.png"></p><ul><li><em>超时计时器，当没有在设定时间内收到确认帧，发送方就重发一次</em></li><li><em>超时计时器设置的设定时间，要并RTT(往返传播时延)高一点，因为还有发送时延</em></li><li><em>发完一个帧之后，要保留这个帧的副本，用来重发</em></li><li><em>数据帧和确认帧必须编号，以确定确认帧确定的是哪一个数据帧</em></li></ul><p><strong><em>2.ACK丢失</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356757.png" alt="image.png"></p><p><strong><em>3.ACK迟到</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356868.png" alt="image.png"></p><blockquote><p><em>信道利用率</em></p></blockquote><ul><li><em>信道利用率就是发送方在一个发送周期内，有效的发送数据所需时间(发送时延)，占整个发送周期的比率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281403631.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281404211.png" alt="image.png"></p><blockquote><p><em>梳理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281406220.png" alt="image.png"></p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><h6 id="后退N帧协议GBN"><a href="#后退N帧协议GBN" class="headerlink" title="后退N帧协议GBN"></a><em>后退N帧协议GBN</em></h6><blockquote><p><em>停等协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281646729.png" alt="image.png"></p><blockquote><p><em>后退N帧协议中的滑动窗口</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281541947.png" alt="image.png"></p><blockquote><p><em>GBN发送方要响应的三件事</em></p></blockquote><ul><li><em>窗口已满是指，当前窗口的数据，在没有收到确认帧之前，不能往前移动，此时的状态就是窗口已满</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281539613.png" alt="image.png"></li></ul><blockquote><p><em>GBN接收方要做的事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281651074.png" alt="image.png"></p><blockquote><p><em>运行中的GBN</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281536912.png" alt="image.png"></p><blockquote><p><em>滑动窗口长度</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281559974.png" alt="image.png"></p><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281532640.png" alt="image.png"></p><ul><li><em>1000个窗口，所以发送方同时可以发1000个帧，每个帧1000个字节<br>所以一次右1000x1000x8 bit数据，<strong>受到信道带宽限制，所以发送延时=<br>1000x1000x8b/100Mb/s =80ms</strong></em></li><li><em>只有受到受到1号帧的确认帧，发送框才会开始移动一个，所以，<strong>在没有受到第一个确认帧之前，发送方不会发送新的数据</strong></em></li><li><em>所以计算，受到确认帧的时间=2x50ms + 1000x8b/100Mb/s =100.08ms &gt;80ms ,所以，信道会有20ms没有新数据推入，空闲，有100.08-80ms=20ms无输入，所以<strong>实际平均数据传输率=1000x1000x8b/100.08ms=80Mb/s</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281518658.png" alt="image.png"></li></ul><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281543131.png" alt="image.png"></p><h6 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a><em>选择重传协议SR</em></h6><blockquote><p><em>后退N帧协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281647073.png" alt="image.png"></p><blockquote><p><em>选择重传协议中的滑动窗口</em></p></blockquote><ul><li><em>发送窗口黄色部分是未被确认的帧，绿色部分是发送之后，收的确认帧的帧</em></li><li><em>接收窗口，紫色部分是收到的帧，灰色部分是<strong>希望收到</strong>的帧，发现，接收窗口可以在没有收到希望收到的帧前，接收其他序号的帧，这里不同于GBN协议，GBN协议在没有收到希望收到的帧之前，对其他发送过来的帧会全部丢弃</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281652798.png" alt="image.png"></li></ul><blockquote><p><em>SR 发送方必须响应的三件事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281659010.png" alt="image.png"></p><blockquote><p><em>SR接收方要做的事</em></p></blockquote><ul><li><em>接收窗口只有当接收到窗口下届的帧，才会将接收窗口往前移动，移动到最小的未接收的帧，并将接收到的这批帧，交付给网络层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705434.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705718.png" alt="image.png"></p><blockquote><p><em>运行中的SR</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281708817.png" alt="image.png"></p><blockquote><p><em>SR滑动窗口长度</em></p></blockquote><ul><li><em>发送窗口=接收窗口（防止溢出）</em></li><li><em>窗口长度=2^(n-1),n为帧的个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281711388.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281714834.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281713327.png" alt="image.png"></p><h3 id="信道划分介质访问控制-MAC协议"><a href="#信道划分介质访问控制-MAC协议" class="headerlink" title="信道划分介质访问控制(MAC协议)"></a><em>信道划分介质访问控制(MAC协议)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942630.png" alt="image.png"></p><ul><li><em>当一个对讲机讲话，其他对讲机就不能够进行讲话，否则会信号冲突</em></li><li><em>广播式链路，如何实现，两对节点之间通信不会互相干扰，就需要介质访问控制来实现</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942457.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291141124.png" alt="image.png"></p><h4 id="静态划分信道-信道划分介质访问控制"><a href="#静态划分信道-信道划分介质访问控制" class="headerlink" title="静态划分信道(信道划分介质访问控制)"></a><em>静态划分信道(信道划分介质访问控制)</em></h4><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a><em>频分多路复用FDM</em></h5><ul><li><em>不同用户同一时间占用不同的带宽(频率资源)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282109872.png" alt="image.png"></li></ul><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a><em>时分多路复用TDM</em></h5><ul><li><p><em>缺点是每个用户在每一个帧中占用固定的时隙，导致其他用户空闲时，不传送数据时，时隙被浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282111844.png" alt="image.png"></p></li><li><p><em>改进后的统一时分复用STDM,就解决了上面的问题，铜国集中器，将不同用户的数据，按照进入的先后，排列使得每一个STDM帧都排满</em></p></li><li><em>所以STDM帧的每个用户的时隙，不是固定的，是按照需要动态分配的时隙</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282112256.png" alt="image.png"></li></ul><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a><em>波分多路复用WDM</em></h5><ul><li><em>实际上就是光的频分多路复用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282115560.png" alt="image.png"></li></ul><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a><em>码分多路复用CDM</em></h5><ul><li><em>不太理解</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282116386.png" alt="image.png"></li></ul><h4 id="动态分配信道-随机访问介质访问控制"><a href="#动态分配信道-随机访问介质访问控制" class="headerlink" title="动态分配信道(随机访问介质访问控制)"></a><em>动态分配信道(随机访问介质访问控制)</em></h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><em>ALOHA协议</em></h5><blockquote><p><em>纯ALOHA协议</em></p></blockquote><ul><li><em>这里帧用T0表示，T0是一个帧从的 发送时间+传播时间 这所有过程，所耗费的时间，所以是在时间坐标上表示帧</em></li><li><em>ALOHA协议想发就发，多个站点，可以在任何时刻，发送数据帧，只是，如果有两个数据帧产生，时间重叠，那么就发生冲突，接收方会检测到差错，不返回确认，如此发送方就会等待一个随机的时刻再次发送数据帧</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282134246.png" alt="image.png"></li></ul><blockquote><p><em>时隙ALOHA协议</em></p></blockquote><ul><li><em>把时间分为若干相同的时间片段，所有用户只允许在<strong>开始时刻</strong>且 <strong>同步</strong>接入网络信道，这样所有用户拥有一个统一的时间划分，都只能在时间片开始时刻发送数据，若发生冲突，则等到下一个时间片开始时刻发送,大大降低了数据冲突问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282138877.png" alt="image.png"></li></ul><h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a><em>CSMA协议</em></h5><p><strong><em>载波监听多路访问协议</em></strong></p><ul><li><em>CS ：载波监听，每一个站发送数据前先检测总线上是否有其他计算机发送数据</em></li><li><em>当信道空闲：发送完整帧(具体发送看CSMA类型)</em></li><li><em>当信道忙：则等待一个随机时间再监听</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290953369.png" alt="image.png"></li></ul><blockquote><p><em>1-坚持CSMA</em></p></blockquote><ul><li><em>空闲直接传输，不等待；忙则一直监听，直到空闲马上传输</em></li><li><em>不是都是空闲的时候再传输吗？为什么会出现冲突？</em></li><li><em>因为，当有两个以上站，同时在等候监听时，由于信息在两台站之间有传播时延，即使是信道上已经存在数据传输，任然检测不出，所以就当做信道空闲，也把数据传输上去，这样就导致数据碰撞，造成冲突</em></li><li><em>优点：只要空闲就发送，媒体利用率最高</em></li><li><em>缺点：冲突概率高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290956924.png" alt="image.png"></li></ul><blockquote><p><em>非坚持CSMA</em></p></blockquote><ul><li><em>空闲则直接传输，不等待；忙则放弃监听，随机时间后再监听</em></li><li><em>优点：减少了当台站，同时监听到空闲直接发送数据，产生冲突的可能</em></li><li><em>缺点：媒体空闲无法迅速被利用起来，利用率低</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291000848.png" alt="image.png"></li></ul><blockquote><p><em>p-坚持CSMA</em></p></blockquote><ul><li><em>空闲时，概率p直接发送，概率1-p等待下一个时间槽传输。</em></li><li><em>忙则持续监听，直到信道空闲</em></li><li><em>冲突则等待下一个时间槽监听</em></li><li><em>优点：即减少了冲突发生，有能减少空间时间的浪费</em></li><li><em>缺点：冲突后还是会把数据帧发送完，造成浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291004905.png" alt="image.png"></li><li><strong><em>正确使用以上策略可以在一定程度上减少碰撞的发生，但无法彻底解决碰撞问题。</em></strong></li></ul><blockquote><p><em>比对</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291009309.png" alt="image.png"></p><h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><em>CSMA/CD协议</em></h5><blockquote><p><strong><em>强化CSMA协议，推出CSMA/CD协议</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034112.png" alt="image.png"></p><p><strong><em>载波监听多点接入/碰撞检测协议</em></strong></p><ul><li><em>CSMA/CD适用于半双工网络(也就是<strong>有线以太网</strong>)—就是不能一方发送还没发送完，另一方就发送，这样会造成数据在路上的碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034904.png" alt="image.png"></li></ul><blockquote><p><em>为什么先听后发会产生冲突</em></p></blockquote><ul><li><em>为什么先听后发还会产生冲突？</em></li><li><em>因为电磁波在总线上有传播时延，B暂时没有检测到A发送过来的数据</em></li><li><em>以A为基准，对于A来说，A检测到发生碰撞的最长时间=2τ</em></li><li><em>所以当发送数据之后过了2τ还没接受到碰撞，说明这次传输，不会产生碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291053463.png" alt="image.png"></li></ul><blockquote><p><em>如何确定碰撞后重传时机</em></p></blockquote><ul><li><em>碰撞之后如何重传，以及重传几次，通过以下方式**</em>截断二进制指数规避法<em>**</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291055125.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291057356.png" alt="image.png"></li></ul><blockquote><p><em>最小帧长</em></p></blockquote><ul><li><em>当检测到碰撞之后，应当立即停止继续发送帧，但是如果检测到碰撞之前就将帧发送完毕，就显得有些尴尬</em></li><li><em>为了避免检测到碰撞之前，就将帧发完，应该设置一个最小的帧长度，保证2τ(最大检测到碰撞时间)之内不会将帧传输完</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103100.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103689.png" alt="image.png"></p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><em>CSMA/CA协议</em></h5><blockquote><p><em>为什么要有CSMA/CA协议</em></p></blockquote><ul><li><em>无线局域网中无法辺全面的检测碰撞</em></li><li><em>并且当多台站点A,C检测到信道空闲，会同时向终端B发送数据帧，就会导致冲突</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134454.png" alt="image.png"></li></ul><blockquote><p><em>CSMA/CA协议工作原理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291133228.png" alt="image.png"></p><blockquote><p><em>CSMA/CA与CSMA/CD区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134135.png" alt="image.png"></p><h4 id="动态分配信道-轮询访问介质访问控制"><a href="#动态分配信道-轮询访问介质访问控制" class="headerlink" title="动态分配信道(轮询访问介质访问控制)"></a><em>动态分配信道(轮询访问介质访问控制)</em></h4><ul><li><strong><em>结合了静态划分信道的优点，不会产生冲突；又结合了随机访问协议的优点发送时能独占信道，占全部带宽</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291220580.png" alt="image.png"></li></ul><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><em>轮询协议</em></h5><ul><li><em>主节点，挨个轮流询问（实际就是以数据帧形式）下面的主机是否要发送数据</em></li><li><em>主节点故障，就无法询问，所有结点就无法传输数据—称为单点故障</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291214203.png" alt="image.png"></li></ul><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><em>令牌传递协议</em></h5><ul><li><em>令牌就是特殊格式的MAC协议控制帧，不包含任何信息</em></li><li><em>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291218760.png" alt="image.png"></li></ul><h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a><em>局域网基本概念和体系结构</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291600023.png" alt="image.png"></p><p><strong><em>决定局域网主要要素</em></strong></p><ul><li><em>网络拓扑</em></li><li><em>传输介质</em></li><li><em>介质访问控制方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291548371.png" alt="image.png"></li></ul><blockquote><p><em>局域网拓扑结构</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291550233.png" alt="image.png"></p><blockquote><p><em>局域网传输介质</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551105.png" alt="image.png"></p><blockquote><p><em>局域网介质访问控制方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551614.png" alt="image.png"></p><blockquote><p><em>局域网的分类</em></p></blockquote><p><em>以太网。是目前应用最广泛的局域网，逻辑拓扑是总线型，物理拓扑是星型。使用的是CSMA/CD 协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291554255.png" alt="image.png"></p><blockquote><p><em>IEEE 802标准</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291556090.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291555065.png" alt="image.png"></p><blockquote><p><em>LLC子层和MAC子层</em></p></blockquote><p><em>IEEE 802标准将局域网的数据链路层划分为：逻辑链路层LLC子层，和介质访问控制MAC子层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291559577.png" alt="image.png"></p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><em>以太网</em></h3><blockquote><p><em>以太网概述</em></p></blockquote><ul><li><em>以太网有两个标准，DIX Ethernet V2 和IEEE 802.3 ;两种标准的帧格式只有1点点的不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291654999.png" alt="image.png"></li></ul><blockquote><p><em>以太网提供无连接、不可靠服务</em></p></blockquote><ul><li><em>无连接：发送方接受方，之间通信前，不提前确立信道，无握手</em></li><li><em>不可靠：是指，不管接受数据帧是否乱序、差错、丢失</em></li><li><em>无差别接收：是指，在接收数据不会有意外，来什么收什么</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291655881.png" alt="image.png"></li></ul><blockquote><p><em>以太网传输介质与拓扑结构</em></p></blockquote><ul><li><em>现在以太网都是逻辑上总线型，物理上星型</em></li><li><em>传输介质采用双绞线+集线器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291658840.png" alt="image.png"></li></ul><blockquote><p><em>10BASE-T以太网</em></p></blockquote><ul><li><em>BASE 表示传输基带信号，也就是数字信号</em></li><li><em>T表示采用双绞线</em></li><li><em>采用曼彻斯特编码</em></li><li><em>采用CSMA/CD介质访问控制</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291700140.png" alt="image.png"></li></ul><blockquote><p><em>适配器与MAC地址</em></p></blockquote><ul><li><em>通信适配器，实现计算机与外界局域网的连接，也称网络接口板，或网卡NIC</em></li><li><em>现在计算机都嵌入了适配器，就无须单独使用网卡了</em></li><li><em>适配器上装有处理器和存储器(RAM,ROM)，ROM上存储了计算机硬件(网卡)地址MAC地址</em></li><li><em>MAC地址全球唯一，换网卡，MAC地址改变</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291704298.png" alt="image.png"></li></ul><blockquote><p><em>以太网MAC帧—V2格式</em></p></blockquote><ul><li>*为什么有帧开始定界符 ，却没有帧结尾定界符呢？</li><li><em>因为以太网编码采用的是曼彻斯特编码，一个bit内就有一个跳变，当这种形式消失，就说明帧结束，然后只需要往前推4bit就能找到数据位置</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291717806.png" alt="image.png"></li></ul><blockquote><p><em>高速以太网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292033086.png" alt="image.png"></p><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><em>无线局域网</em></h3><blockquote><p><em>802.11的MAC帧头格式</em></p></blockquote><ul><li><em>基站AP(也称无线接入点), 是主机通过连接无线网络连入有线网络（以太网）的设备</em></li><li><em>以下的场景：A 想要与B通信，由于距离太远，A要先通过无线网络将数据发送给Ap1,然后Ap1发送给AP2，最后由Ap2将数据发送给B</em></li><li><em>接收端—AP2的MAC地址 ；发送端—AP1的MAC地址；目的地址—B的MAC地址；源地址—A的MAC地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292038208.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292052190.png" alt="image.png"></p><blockquote><p><em>无线局域网的分类</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292053304.png" alt="image.png"></p><p><strong><em>1.有固定基础设施无线局域网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292055469.png" alt="image.png"></p><ul><li><em>一个基本服务集BSS内，的主机可以相互之间直接通过基站发送数据</em></li><li><em>不同基本服务集之间要进行远距离通信，需要借助基站与基站之间的互相通信来实现，称作“漫游”</em></li><li><em>wifi名称—就是服务集标识符</em></li></ul><p><strong><em>2.无固定基础设施无线局域网的自组织网络</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292101049.png" alt="image.png"></p><h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a><em>虚拟局域网VLAN</em></h3><blockquote><p><em>为什么提出虚拟局域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041734284.png" alt="image.png"></p><blockquote><p><em>VLAN基本概念</em></p></blockquote><ul><li><strong><em>就是将局域网内的设备，划分为不同的逻辑工作组，这种域与物理位置无关</em></strong></li><li><em>一个逻辑工作组，就是一个子网，一个广播域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041735592.png" alt="image.png"></li></ul><blockquote><p><em>VLAN实现</em></p></blockquote><ul><li><em>将一个交换机下的局域网，逻辑上划分为两个虚拟的不同的局域网，同时其他交换机下的也可以划分为同样的两个分组，这样相同的分组之间就是一个可以互相通信的虚拟局域网，而不同分组之间就不能互相通信</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041738107.png" alt="image.png"></li><li><em>按照交换机上的端口划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041740977.png" alt="image.png"></p><ul><li><em>按照接入的主机MAC地址划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041743116.png" alt="image.png"></p><ul><li><em>假如A要往E发送数据，A主机会先准备一个普通以太网帧，帧送往交换机，交换机会往帧上贴一个标签(标注VLAN1)，发往交换机2，然后交换机2会根据标签，知道这是发往虚拟局域网VLAN1的然后再根据一些其他标志，判断发往E </em></li></ul><blockquote><p><em>VLAN进行数据交换时，帧的格式变化</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041752990.png" alt="image.png"></p><blockquote><p><em>练习</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041753776.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041756089.png" alt="image.png"></p><h2 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a><em>广域网及相关协议</em></h2><blockquote><p><em>什么是广域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041719233.png" alt="image.png"></p><blockquote><p><em>PPP协议</em></p></blockquote><p><strong><em>PPP点对点协议，广域网使用的链路层协议，只支持全双工链路，用于用户使用拨号电话接入因特网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041721607.png" alt="image.png"></p><blockquote><p><em>PPP协议应该满足的要求/无需满足的要求</em></p></blockquote><ul><li><em>同步线路是逐个bit发送数据，异步线路是逐个字节或字符发送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726956.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726276.png" alt="image.png"></p><blockquote><p><em>PPP协议的是哪个组成部分</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727339.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727950.png" alt="image.png"></p><blockquote><p><em>PPP协议的帧格式</em></p></blockquote><ul><li><em>PPP协议的帧格式，最小单位是字节，所以是面向字节的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041731402.png" alt="image.png"></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><em>基本概念</em></h3><h4 id="网段"><a href="#网段" class="headerlink" title="网段"></a><em>网段</em></h4><ul><li><em>网段计算机网络中使用同一物理层设备，能够直接通讯的那一部分，同一个网段，会有冲突域，同一时间只能有一台设备占用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042038496.png" alt="image.png"><h4 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a><em>冲突域与广播域</em></h4></li></ul><p><strong><em>1.冲突域：</em></strong></p><ul><li><em>在以太网  中，如果某个CSMA/CD网络上的两台计算机在同时通信时<strong>会发生冲突</strong>，那么这个CSMA/CD网络就是一个<strong>冲突域</strong>（collision domain)。如果以太网中各个网段以<strong>集线器</strong>连接，因为不能避免冲突，所以它们仍然是一个冲突域</em></li><li><em>冲突域就是连接在<strong>同一导线</strong>上的所有工作站的集合，或者说<strong>是同一物理网段</strong>上所有节点的集合，或以太网上竞争<strong>同一带宽</strong>的节点集合.</em></li><li><em>集线器是一个标准的共享式设备，也就是<strong>同一时刻只有一个端口下联的设备可以发送数据。正常工作时，集线器随机选出某一端口设备并让它独占全部带宽与集线器上联设备（如交换机、路由器等）进行通信</strong>。因此，集线器设备的所有端口即形成了一个冲突域。</em></li><li><em>为了有效避免冲突，局域网中使用<strong>交换机</strong>（Switch）来分割冲突域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042041995.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042042138.png" alt="image.png"></p><p><strong><em>2.广播域：</em></strong></p><ul><li><em>广播是一种信息的<strong>传播方式</strong>，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>(Broadcast Domain)。</em></li></ul><p><strong><em>3.两者区别</em></strong></p><ul><li><em>冲突域是基于物理层</em></li><li><p><em>广播域是基于数据链路层</em></p></li><li><p><em>冲突域：竞争同一带宽的节点的集合</em></p></li><li><em>广播域：接收同样广播消息的节点的集合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042020764.png" alt="image.png"></li></ul><blockquote><p><em>练习加深了解</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042120355.png" alt="image.png"></p><h3 id="链路层的设备"><a href="#链路层的设备" class="headerlink" title="链路层的设备"></a><em>链路层的设备</em></h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a><em>网桥</em></h4><ul><li><em>网桥有左右两个端口，分别分割两个冲突域</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042049108.png" alt="image.png"></p><blockquote><p><em>透明网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045169.png" alt="image.png"></p><blockquote><p><em>源路由网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045552.png" alt="image.png"></p><blockquote><p><em>网桥的自学习功能</em></p></blockquote><ul><li><em>网桥只有左右两个端口，分别标记位1,2号</em></li><li><em>网桥自学习是指，网桥转发表一开始是空的，当A-&gt;B发送信息时，A会向所有主机发送，当经过第一个网桥时，由于网桥转发表没有对A的记录，所以当数据帧经过该网桥时，就会在转发表记录  A对应1端口位置；同时由于没有对B的记录，无法选择转发，所以只能一股脑转发出去，右边的网桥也经过一样的过程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042101488.png" alt="image.png"></li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><em>交换机</em></h4><blockquote><p><em>多接口网桥—交换机</em></p></blockquote><ul><li><em>集线器，也是多接口，集线器，会将每台计算机原有100MB/s带宽，平均为每台只有25MB/s ,同时会有冲突域，一台集线器下的计算机只能同时有一台发送数据，传输速率大大降低</em></li><li><em>交换机，就是一个多接口的网桥，可以隔绝冲突域，一台交换机下的每条信道都能占满带宽(独占媒体带宽)，维持原有的100MB/s,同时一台交换机之内的所有计算机都可以同时传输数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042110168.png" alt="image.png"></li></ul><blockquote><p><em>以太网交换机的两种交换方式</em></p></blockquote><ul><li><em>直通式交换机</em></li><li><em>存储转发式交换机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042121848.png" alt="image.png"></li></ul><blockquote><p><em>交换机的自学习功能</em></p></blockquote><ul><li><em>与网桥的自学习功能类似，只是多了几个端口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042114758.png" alt="image.png"></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051043362.png" alt="image.png"></p><p><strong><em>1.网络层功能</em></strong></p><ul><li><em>路由选择分组转发</em></li><li><em>异构网络互联</em></li><li><em>拥塞控制：全局性的概念，是因为整个网络负载过重造成拥塞；而流量控制只是，发送方发送过快导致接收方接收不过来，所以需要流量控制</em></li></ul><p><strong><em>2.拥塞控制方法</em></strong></p><ul><li><em>WAY1开环控制：静态方法</em></li><li><em>WAY2闭环控制：动态方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051053599.png" alt="image.png"><h2 id="SDN基本概念"><a href="#SDN基本概念" class="headerlink" title="SDN基本概念"></a><em>SDN基本概念</em></h2></li></ul><blockquote><p><em>考察概念，主要是选择题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051308929.png" alt="image.png"></p><p><strong><em>1.网络层的关键功能</em></strong></p><ul><li><em>转发：将分组从路由器的输入端口，转发到合适的输出端口【局部的功能】【数据平面的部分】</em></li><li><em>路由：使用路由算法决定分组从发送主机到目标接收主机的路径【全局的功能】【控制平面的部分】</em></li></ul><p><strong><em>2.网络层：数据平面、控制平面</em></strong><br><code>数据平面：</code> </p><ul><li><em>路由器本地动作</em></li><li><em>根据路由表，将分组从输入端口转发到合适的输出端口【路由表和转发表是控制平面的路由选择协议实体算出来的】</em></li></ul><p><code>控制平面：</code></p><ul><li><em>网络范围内的逻辑</em></li><li><em>决定数据报从源到目标主机的端到端路径</em></li><li><em>2个控制平面方法：传统方法、SDN方法(software-define-networking)</em><ul><li><em>传统方法：运行在每一台路由器本地中</em></li><li><em>SDN方法：在远程服务器中实现</em></li></ul></li></ul><p><strong><em>3.控制平面两个方法</em></strong></p><blockquote><p><em>传统方式—每路由控制平面</em></p></blockquote><ul><li><em>传统方式下，每个路由器，即实现了控制平面功能，又实现了数据平面功能</em></li><li><em>每台路由器中的路由选择算法与其他路由器中的路由选择算法相互通信, <strong>计算出路由表和转发表</strong></em></li><li><em>这种方式使得路由器的控制平面与数据平面相互紧紧耦合，带来的问题是，改变路由运行逻辑变得非常困难</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051337186.png" alt="image.png"></li></ul><blockquote><p><em>SDN方式—集中逻辑的控制平面</em></p></blockquote><ul><li><em>将控制平面从路由器物理上剥离开，在远程服务器中集中实现。在远程控制器中计算和分发转发表，以提供给每台路由器</em></li><li><em>计算、转发、远程控制器，是由软件实现，所以是集中式，可编程的</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051345318.png" alt="image.png"></p><p><strong><em>4.SDN方式控制平面的组成</em></strong><br><em>远程控制器中包括：</em></p><ul><li><em>SDN控制器</em></li><li><em>网络控制应用程序</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051351391.png" alt="image.png"></li></ul><p><strong><em>5.SDN控制器的三个层次</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051357037.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051359025.png" alt="image.png"></p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a><em>IP数据报</em></h2><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a><em>IP数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071000263.png" alt="image.png"></p><ul><li><p><em>网络层的传输单位是数据报，，网络层主要用到的协议是IP协议，IP协议的数据报格式如下</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071001404.png" alt="image.png"></p></li><li><p><em>首部长度4bit,从 0011~1111(5~15)，单位是4B，也就是首部长度最小5x4B=20B,最大15x4B=60B</em></p></li><li><em>协议部分，字段值不同，代表不同数据部分协议【注意是数据部分协议，网络层之上的协议】【TCP协议：面向连接服务，字段值6；UDP：不面向连接服务，字段值17】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071013525.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071017094.png" alt="image.png"></p><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a><em>IP数据报分片</em></h3><blockquote><p><em>为什么要分片？</em></p></blockquote><ul><li><em>数据链路层是对IP数据报进行封装成帧，但是帧有最大传输单元MTU，如果IP数据报/分组，大于MTU,怎么办？</em><br><em>所以需要对IP数据报进行<strong>分片</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071038656.png" alt="image.png"></li></ul><blockquote><p><em>数据报分片例子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034403.png" alt="image.png"></p></blockquote><ul><li><em>最大数据报片&lt;=1420B </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034753.png" alt="image.png"></li></ul><h2 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a><em>IPV4地址</em></h2><ul><li><em>一个路由器会连接很多个主机，一个主机对应路由器一个接口(有线或无线接口)，每个接口都会分配一个唯一的ip地址</em></li><li><em>ip地址都是32bit的标识符，采用点分十进制，每一个字节，用点隔开，并且<br>每个字节的数字都是用十进制表示</em></li><li><em>IP 地址包括两部分：网络 ID（网络地址） + 主机 ID（主机地址）<br>网络 ID 用于不同网络寻址； 主机 ID 用于局域网内通讯</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071522558.png" alt="image.png"></li></ul><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a><em>IP地址的分类</em></h3><p><em>根据 IP 地址(二进制下)前缀数字的不同情况，划分为 A,B,C,D,E 5个类别，如下图  （本文我们主要介绍 A,B,C 三类）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt="image.png"></p><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a><em>A类地址</em></h4><p>*1. 第 1 字节为网络地址，其他 3 字节为主机地址，第 1 个字节第一位固定为0    2. 网络号范围： 1.0.0.0 - 126.0.0.0<br>3.包含私有地址和保留地址</p><pre><code>1. 私有网络号：10 （局域网中使用的网络地址）（网段1个）2. 保留地址：127.X.X.X</code></pre><p>4.主机数量：千万台*</p><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a><em>B类地址</em></h4><p>*1.第 1.2 字节为网络地址，其他为主机地址，第 1 个字节前两位固定为 10<br>2.网络号范围：128.0.0.0 - 191.255.0.0<br>3.包含私有地址和保留地址</p><pre><code>- 私有网络号：172.16—172.31 （网段16个）- 保留地址：169.254.X.X （IP 地址为自动获取，且无可用 DHCP 服务时，分                   配该地址）- 广播地址：191.255.255.255</code></pre><p>4.主机数量：最大 65534 台*</p><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a><em>C类地址</em></h4><p>*1. 第 1.2.3 字节为网络地址，第 4 字节为主机地址，第 1 个字节前三位固定110<br>2.网络号范围：192.0.0.0—223.255.255.0<br>3.包含私有地址和保留地址</p><pre><code>- 私有网络号 ：192.168.0~192.168.255 网段共255个</code></pre><p>4.主机数量：最大 254 台*</p><p><code>*网段个数，代表某类ip地址网络号有几种分法*</code></p><h4 id="特殊ip地址"><a href="#特殊ip地址" class="headerlink" title="特殊ip地址"></a><em>特殊ip地址</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630383.png" alt="image.png"></p><ul><li><em>A类可用的网络号：1~126</em></li><li><em>B类可用的网络号：128.1~191.255</em></li><li><em>C类可用的网络号：192.0.1~223.255.255</em></li><li><em>主机号要减去全0，全1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630367.png" alt="image.png"></li></ul><h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a><em>网络地址转换</em></h2><blockquote><p><em>内网ip,不能直接与外网通信</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="image.png"></p><blockquote><p><em>NAT转换</em></p></blockquote><ul><li><em>需要通过NAT转换，将内网ip（专用网/私有ip地址）以及端口号，通过路由器 按照NAT转换表 转换为路由器的公网ip地址和端口号，才能与外部通信</em></li><li><em>NAT路由器一般只有1个公网ip，所以内网的主机公用一个公网ip</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071707488.png" alt="image.png"></li></ul><blockquote><p><em>什么时候需要NAT转发？什么时候不需要？</em></p></blockquote><ul><li><em>当申请的网络号是公网网络号，那么其下的ip都是公网ip，就不需要再对其NAT转换</em></li><li><em>当使用的都是专用网络，内网网络号，那么其下的都是私有ip，也就需要保证，路由器拥有至少一个公网ip，通过NAT转换与外部通信</em></li></ul><h2 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a><em>子网划分与子网掩码</em></h2><blockquote><p><em>什么是子网？</em></p></blockquote><p><strong><em>子网或子网络是大型网络内的较小网络。子网划分使网络路由更加高效。</em></strong></p><blockquote><p><em>为什么要划分子网？</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">详细概述：</span><br><span class="line">首先，先明白网络广播的基本概念，本网段向本网络的所有节点发送数据包，所有节点都会收到，但往往只有一个节点是需要这个数据包的，因此广播的过程会很浪费的占用一部分网络资源。因此划分子网的一个最为重要意义就在于减少网络广播所带来的负面影响，提高性能的整体性能。因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户数少了，当然所占用的资源也就少了。</span><br><span class="line"></span><br><span class="line">其次，这节省了IP地址的资源。这看似于前面介绍的连接主机数减少相矛盾，其实这要看具体的情况来定。对本省规模较大网络（200个用户以上），划分子网后，可用的IP地址数减少了。但如果是那些小型的企业网络来哦说，划分子网后又可以节省大量的IP地址资源。比如现在学校有四个机房，每个机房25台电脑，如果直接分配四个C类地址字段，每个机房一个。虽然这样做理论上没有错，但实际上你一共浪费了（254-25）*4=916个IP地址（全0全1不取,故256-2=254）。如果公用网络都这样分配IP地址，那么IP地址资源早就枯竭了。</span><br><span class="line"></span><br><span class="line">另外，不同的子网之间是不能直接通信的，需要借助路由器或网关。而且网络规模小了是相对较安全的，比如财政部门。而且较小的网络也比较容易部署特定的安全政策，而网络规模大了这些政策可能会影响到其他普通用户的工作。还有一个优点就是便于维护，当某个网点要查找故障的时候，网络规模小了，更容易查找到错误网络。</span><br><span class="line"></span><br><span class="line">需要注意的一点就是，划分子网也是有一些弊端的，一方面就是：可连接的主机数减少，这对于网络规模小的网点没有影响，但如果网络规模大，他们就必须划分为多个子网，如果它们需要进行频繁的通信的话就需要总是借助路由器或网关，会影响工作效率。另一方面就是：各个相对对立的网点，主机号0和1是不能取的，需要留给网络地址和广播地址。因此每多一个子网，就必须浪费两个IP地址（当然，这问题不大。）。</span><br><span class="line">总结：划分子网并不适用于所有网络，对于各部门间工作相对独立的企业或行业来说，划分子网还是可取的。而对于那些IP资源本来就不是很够，各部门间的联系又非常紧密的则最好不划分子网。</span><br></pre></td></tr></table></figure><blockquote><p><em>什么是子网掩码？</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071832869.png" alt="image.png"></p><blockquote><p><em>子网划分</em></p><ul><li><em>采用B类ip地址，该申请的网络号为145.13</em></li><li><em>由于</em></li><li><em>内部再划分子网，其中一个子网网络地址为145.13.3</em></li><li><em>这个子网里有多台主机，(子网网络地址+主机号)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071821362.png" alt="image.png"></li></ul></blockquote><ul><li><em>子网的划分实际上就是将<code>二级ip地址</code>,将原本主机号，借用若干位，作为子网号—&gt;<code>三级ip地址</code></em></li><li><em>在两级IP地址两个字段的基础上新增一个<code>子网号字段</code></em></li><li><em>划分子网纯属是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg.  对外表现ip为141.14.72.24【这是一个B类ip地址，网络地址为141.14.0.0,后面是主机号】</span><br><span class="line"></span><br><span class="line">假如子网掩码是：</span><br><span class="line">255.255.192.0</span><br><span class="line">11111111 11111111 11000000 00000000</span><br><span class="line">可以看出，该子网是借用了2bit作为子网号，后面14bit才是主机号 </span><br><span class="line"></span><br><span class="line">141.14.72.24</span><br><span class="line">10001101 00001110 01001000 00011000</span><br><span class="line">与子网掩码相与，得到的子网网络地址就是：</span><br><span class="line">141.14.64.0</span><br><span class="line">10001101 00001110 01000000 00000000</span><br><span class="line">主机号是子网号后面14bit：</span><br><span class="line">2072</span><br><span class="line">001000 00011000</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071834346.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071846600.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072115836.png" alt="image.png"></p><h2 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h2><p>CIDR（Classless Inter-Domain Routing）无分类域间路由选择</p><p>划分子网在一定程度上缓解了因特网发展中遇到的困难，但其仅仅是对分类编址方式的改进，A、B、C类IP网络号都为8的倍数，其划分不够精细，存在很大程度的浪费，基于此，无分类编址方式CIDR应运而生。</p><h3 id="分类编址的问题"><a href="#分类编址的问题" class="headerlink" title="分类编址的问题"></a>分类编址的问题</h3><p>1992年因特网面临三个必须尽早解决的问题</p><ol><li>B类地址在1992年分配了近一半，眼看很快就将全部分配完毕</li><li>因特网主干网上的路由表中的项目数急剧增长（由几千个增长至几万个）</li><li>整个IPV4的地址空间最终将全部耗尽，在2011年2越3日，IANA宣布IPV4地址已经耗尽了</li></ol><p>IETF研究采用无分类编址的方法来解决前两个问题，其认为第三个问题属于更加长远的问题，因此专门成立IPV6工作组负责研究新版本IP协议的问题</p><h3 id="CIDR最主要的两个特点"><a href="#CIDR最主要的两个特点" class="headerlink" title="CIDR最主要的两个特点"></a>CIDR最主要的两个特点</h3><ul><li><strong>CIDR消除了传统的A类、B类和C类地址及划分子网的概念</strong>，因此可以更加有效地分配IPv4的地址空间，并且在新的IPv6使用前容许因特网的规模继续增长</li></ul><blockquote><p>CIDR把32位的IP地址划分为两个部分，前面的部分是网络前缀，用来指明网络，后面的部分则用来指明主机，其与分类编址最大的不同，便是网络前缀不局限于8的倍数。因此CIDR使IP地址从三级编址（使用子网掩码）又回到两级地址，但这已经是无分类的两级编址。CIDR在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。<br>IP地址 :: = {&lt;网络前缀&gt;，&lt;主机号&gt;}</p></blockquote><ul><li><strong>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”</strong>。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（最小地址）和终止地址（最大地址），以及地址块中的地址数。</li></ul><blockquote><p>例如，已知IP地址为128.14.35.7/20是某CIDR地址块中的一个地址，现在把它写成二进制形式，其中前20位是网络前缀，而后面的12位是主机号：<br>128.14.35.7/20 = <strong>10000000 00001110 0010</strong>0011 00000111<br>这个地址块的最小地址为：<strong>10000000 00001110 0010</strong>0000 00000000<br>这个地址块的最大地址为：<strong>10000000 00001110 0010</strong>1111 11111111</p></blockquote><h3 id="CIDR的地址掩码"><a href="#CIDR的地址掩码" class="headerlink" title="CIDR的地址掩码"></a>CIDR的地址掩码</h3><p>为了更方便地进行路由选择，CIDR使用32位的地址掩码（address mask）。地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR不使用子网了，但由于目前一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码</p><blockquote><p>例如，/20地址块的地址掩码是：11111111 11111111 11110000 00000000（20个连续的1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数</p></blockquote><h3 id="CIDR不划分子网的理解"><a href="#CIDR不划分子网的理解" class="headerlink" title="CIDR不划分子网的理解"></a>CIDR不划分子网的理解</h3><p>另外，“CIDR不使用子网”，是指<strong>CIDR中并没有在32位地址中指明若干位作为子网字段。但分配到一个CIDR地址块的单位</strong>仍然可以在本单位内根据需要划分出一些子网。<strong>这些子网也都只有一个网络前缀和一个主机地址号，但子网的网络前缀比整个单位的网络前缀要长一些</strong></p><blockquote><p>例如，某单位分配到地址块/20，就可以继续划分为8个子网（即需要从主机号中借用3位来划分子网）。这时，每一个子网的网络前缀就变成23位（原来的20位加上主机号借来的3位），比该单位的网络前缀多了3位</p></blockquote><h3 id="路由聚合的概念"><a href="#路由聚合的概念" class="headerlink" title="路由聚合的概念"></a>路由聚合的概念</h3><p>由于一个CIDR地址块有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合（Route aggregation）,它使得路由表中的一个项目可以表示原来传统分类网络地址的很多个路由。路由聚合也称为构成超网（supernettig）</p><blockquote><p>如果没有采用CIDR，则在1994年和1995年，因特网一个路由器就回超过7万个项目，而使用了CIDR以后，在1996年一个路由表的项目数菜只有3万多个。路由聚合有利于减少路由器之间的路由选择信息交换，提高整个网络性能</p></blockquote><p><img src="https://s1.ax1x.com/2018/11/19/FpQmUx.jpg#shadow" alt=""></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><h4 id="最长前缀匹配的概念"><a href="#最长前缀匹配的概念" class="headerlink" title="最长前缀匹配的概念"></a>最长前缀匹配的概念</h4><p>在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要做相应的改变。这时，每个项目由<br><strong>“网络前缀”  和  下一跳地址</strong>组成。但是在<strong>查找路由表时可能得到不止一个匹配结果</strong>。这样就带来一个问题：我们应当从这些匹配的结果中选择哪一条路由呢？</p><p>正确的答案是：<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫作最长前缀匹配（longest-prefix matching）,这时因为网络前缀越长，其地址块就越小（因为主机位数越少），因而路由就越具体。最长前缀匹配又称为<strong>最佳匹配或最长匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg.路由器接收到一个分组R0,它的目的ip地址是132.19.237.5</span><br><span class="line">路由器路由表包含5个目的网络号分别是</span><br><span class="line">132.0.0.0/8   </span><br><span class="line">【前8位是网络前缀，地址掩码11111111 000000000 00000000 00000000】 </span><br><span class="line">132.0.0.0/11</span><br><span class="line">【前11位是网络前缀，地址掩码11111111 11100000 00000000 00000000】</span><br><span class="line">132.19.232.0/22</span><br><span class="line">【前22位是网络前缀，地址掩码11111111 11111111 11111100 00000000】</span><br><span class="line">0.0.0.0/0</span><br><span class="line">【这是默认路由，所有目的网络都不匹配的时候走这里】</span><br><span class="line"></span><br><span class="line">目的ip地址是132.19.237.5</span><br><span class="line">10000100 00010011 11101001 00000101</span><br><span class="line">与上述子网掩码与运算后，匹配的网络地址是</span><br><span class="line">132.0.0.0/8  和 132.0.0.0/11</span><br><span class="line">但是按照最长路由前缀匹配，应该选择走132.0.0.0/11这个网络</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081951285.png" alt="image.png"></p><h4 id="依据地址位置划分地址快"><a href="#依据地址位置划分地址快" class="headerlink" title="依据地址位置划分地址快"></a>依据地址位置划分地址快</h4><p>如果IP地址的分配从一开始就采用CIDR，那么我们可以按网络所在的地理位置来分配地址块，这样就可以大大减少路由表中的项目数</p><blockquote><p>例如，可以将世界划分为四大地区，每一个地区分配一个CIDR地址块：<br>地址块194/7(194.0.0.0至195.255.255.255)分配给欧洲<br>地址块198/7(198.0.0.0至199.255.255.255)分配给北美洲<br>地址块200/7(200.0.0.0至201.255.255.255)分配给中美洲和南美洲<br>地址块202/7(202.0.0.0至203.255.255.255)分配给亚洲和太平洋地区</p></blockquote><p>上面一个地址块包含约3200万个地址($2^{32}-7$)。这种分配方法使得IP地址与地理位置关联，它的好处是可以大大压缩路由表中的项目数。例如从中国发往北美的数据报（不管它是地址块198/7中的哪一个地址）都先送到美国的一个路由器，因此在路由表中使用一个项目就行了。<br>  但是，在使用CIDR之前，因特网的地址管理机构并没有按照地理位置来分配IP，现在要把已分配的IP地址回收再重新分配是十分困难的事情，因为这牵涉很多正在工作的主机必须改变其IP地址。<strong>所以基于地址位置划分地址块仅仅停留在想法</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p>完成主机或路由器IP地址到MAC地址的映射，解决下一跳走哪的问题</p><blockquote><p><strong>*由于实际网络链路中，传送数据帧时，必须使用MAC地址</strong>，<br>例如：在一个局域网内，所有设备使用同一套链路，主机A想要向同一个网段下的主机B,在数据链路上发送数据帧，肯定需要在帧头加上源MAC地址和目的MAC地址，但是如果主机A不知道主机B的目的MAC地址怎么办？这就需要先检查<strong>ARP高速缓存</strong>，检查是否有主机B的IP地址与MAC地址的映射，如果有，则直接将主机B的MAC地址封装上数据帧，放到链路上传输；如果没有，那么就需要使用ARP协议，主机A向局域网内所有设备广播ARP请求的分组，<strong>同一局域网内所有主机收到该请求</strong>，当主机B收到这个请求分组，发现目的IP就是自己的IP地址，就会向主机A 单播返回一个 带有IP和MAC地址的分组，A得到B的响应，立刻将主机B的ip和MAC地址的映射项写入ARP缓存（<strong>10-20min更新一次</strong>），然后主机A就能向帧头加上目的MAC地址放到链路上传送了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082116250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082127346.png" alt="image.png"></p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt="image.png"></p><h3 id="主机如何获取ip地址？"><a href="#主机如何获取ip地址？" class="headerlink" title="主机如何获取ip地址？"></a><strong><em>主机如何获取ip地址？</em></strong></h3><ul><li><em>动态分配</em></li><li><em>静态分配</em></li></ul><h3 id="什么是动态分配DHCP协议？"><a href="#什么是动态分配DHCP协议？" class="headerlink" title="什么是动态分配DHCP协议？"></a><strong><em>什么是动态分配DHCP协议？</em></strong></h3><p><strong><em>DHCP协议是应用层协议</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091011931.png" alt="image.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt=""></p><h3 id="什么是ICMP"><a href="#什么是ICMP" class="headerlink" title="什么是ICMP?"></a><em>什么是ICMP?</em></h3><p>ICMP，全称是 Internet Control Message Protocol，即互联网控制报文协议，所谓控制，就是通过下发指令来感知和控制网络环境，所以它一定是配合一个无法感知网络环境的协议来工作的，这个协议就是 IP(包括 IPv4 和 IPv6)。</p><p>所以，ICMP 通常被认为是 IP 协议的一部分，它封装在 IP 层中，使用 IP 协议进行传输。因此，严格来说，<strong><em>ICMP 既不是一个网络层协议，也不是一个传输层协议，而是介于两者之间的一个协议。</em></strong></p><p>它的主要功能是传输网络诊断信息，信息主要包括两类：</p><ul><li>一类是 查询类报文 ：主要用于信息的查询和采集，比如采集传输路径上的每个路由器都是谁，本次传输的报文是否达到目的地等等。</li><li>另一类是 差错诊断类报文 ：主要用于诊断网络故障，比如传输报文被丢弃的原因是什么等等。</li></ul><h3 id="为什么需要ICMP？"><a href="#为什么需要ICMP？" class="headerlink" title="为什么需要ICMP？"></a><em>为什么需要ICMP？</em></h3><p>我们都知道，<strong><em>IP 协议是一个不可靠协议</em></strong>，如果 IP 包在传输过程中出现错误，比如 checksum 对不上，拥塞，超时等等，那么 IP 包是会直接被丢弃的，之后也不会有进一步的努力来修正。</p><p>这是 IP 协议的一个设计准则决定的，也就是 best effort，尽力而为，这样的好处是让 IP 协议尽量保持简单的形态，只负责有效率的数据传输，而更多的质量控制交给高层的协议去处理(比如 TCP)。</p><p>但高层能提供质量控制的协议毕竟在少数，所以就需要在下层有协议来辅助 IP 完成必要的网络质量管理。ICMP 协议自然就被提出来了。</p><p>通过 ICMP 协议，当 IP 包发生错误的时候，上层发送 IP 包的主机或路由器并不知道下层发生了错误，这个时候，下层的主机或路由器就可以通过发送 ICMP 包，将错误信息汇报给上层，从而让上层的主机或路由器进行调整。</p><p>不过需要注意的是，<strong><em>ICMP 仅仅只能提供某些特定类型的错误信息汇报，并不能帮助 IP 协议成为可靠的协议</em></strong>。它能做的事还是有限，但用于基本的网络质量管理是足够了。</p><h3 id="ICMP应用场景"><a href="#ICMP应用场景" class="headerlink" title="ICMP应用场景"></a><em>ICMP应用场景</em></h3><h4 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a><strong>错误报告</strong></h4><p>ICMP 错误消息报告网络错误，例如目的地不可达、超时或分段问题。这些消息对于具有无连接通信模型的用户数据报协议 (UDP) 尤其重要。</p><p>UDP 不提供可靠、有序的数据包传输。发送 UDP 数据包时，数据包可能会丢失，也可能在传送时出现校验和错误等故障。如果发生这种情况，接收方会将 ICMP 错误报告消息发回给发送方，以通知该问题。</p><h4 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a><strong>诊断</strong></h4><p>您可以使用 ICMP 进行网络诊断。它最常用于 <strong><em>ping 和 traceroute</em></strong> 命令。</p><ul><li><p><strong><em>ping 命令通过向目标设备发送 ICMP 回显请求数据包来测试网络设备的可访问性</em></strong>。如果设备可以访问，则会返回 ICMP 回显回复。它可以可靠地检查网络延迟并确保设备可用。</p></li><li><p><strong><em>traceroute 命令跟踪数据包从源到目的地所采用的路径</em></strong>。为此，该命令将回显请求和回显回复消息发送到预定目的地。</p></li></ul><blockquote><p>例如：回显请求包含一个生存时间 (TTL) 值，数据包每通过一个路由器，该值就会减 1。当数据包到达 TTL 为零的路由器时，路由器会向源端发送一条 ICMP 消息。该消息包含有关数据包所采用路由的信息。Traceroute 会显示数据包的确切路径，可以为您提供网络性能详情。</p></blockquote><h3 id="ICMP报文格式长啥样？"><a href="#ICMP报文格式长啥样？" class="headerlink" title="ICMP报文格式长啥样？"></a><em>ICMP报文格式长啥样？</em></h3><ul><li><em>【注意区分，报文数数据部分，报文在网络层封装成数据报】</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091035923.png" alt="image.png"></p><p>如下图所示，ICMP 报文是被封装在 IP 数据报中传输的。</p><p>IP 报头中的 Protocol 字段为 1 即表示该报文携带的是 ICMP 报文。(此处只是为了说明问题，因此 IP 报头是简化了的)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091057587.png" alt="image.png"></p><p>进一步看，ICMP 报头为 4 个字节：</p><ul><li>类型 type：占 1 个字节，表示较大范围类型分类的 ICMP 报文</li><li>代码 code：占 1 个字节，表示较小范围类型分类的 ICMP 报文(type的细分)</li><li>校验和 checksum：占 2 个字节，ICMP checksum 的计算方法类似于 IP checksum，但是不同的是 IP 只校验头部，ICMP 校验头部+数据部分</li></ul><p>后面紧接的 ICMP 数据部分，根据前面的类型和代码字段的不同，具有不同的内容。</p><h3 id="ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】"><a href="#ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】" class="headerlink" title="ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】"></a><em>ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】</em></h3><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a><em>ICMP差错报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091033395.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091104579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091105405.png" alt="image.png"></p><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a><em>ICMP询问报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091106410.png" alt="image.png"></p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="为什么需要IPV6？"><a href="#为什么需要IPV6？" class="headerlink" title="为什么需要IPV6？"></a><em>为什么需要IPV6？</em></h3><p><em>IPv4地址采用32比特标识，理论上能够提供的地址数量是43亿（由于地址分配的原因，实际可使用的数量不到43亿）。另外，IPv4地址的分配也很不均衡：美国占全球地址空间的一半左右，而欧洲则相对匮乏；亚太地区则更加匮乏。与此同时，移动IP和宽带技术的发展需要更多的IP地址。目前IPv4地址已经消耗殆尽。针对IPv4的地址短缺问题，也曾先后出现过几种解决方案。比较有代表性的是无类别域间路由CIDR（Classless Inter-Domain Routing）和网络地址转换NAT（Network Address Translator）。但是CIDR和NAT都有各自的弊端和不能解决的问题，由此推动了IPv6的发展。</em></p><p><strong><em>IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</em></strong></p><h3 id="IPV6地址表示方法"><a href="#IPV6地址表示方法" class="headerlink" title="IPV6地址表示方法"></a><em>IPV6地址表示方法</em></h3><ol><li><p><em>IPv6地址总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。例如：FC00:0000:130F:0000:0000:09C0:876A:130B，这是IPv6地址的首选格式。</em></p></li><li><p><em>为了书写方便，IPv6还提供了<strong>压缩格式</strong>，以上述IPv6地址为例，具体压缩规则为：</em></p><ul><li><em>每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876A:130B</em></li><li><em>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，所以上述地址又可以进一步简写为：FC00:0:130F::9C0:876A:130B。</em></li><li><em>需要注意的是，<strong>在一个IPv6地址中只能使用一次双冒号“::”</strong>，否则当计算机将压缩后的地址恢复成128位时，无法确定每个“::”代表0的个数</em></li></ul></li></ol><h3 id="IP数据报格式-1"><a href="#IP数据报格式-1" class="headerlink" title="IP数据报格式"></a><em>IP数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091306357.png" alt="image.png"></p><h3 id="IPV6与IPV4对比"><a href="#IPV6与IPV4对比" class="headerlink" title="IPV6与IPV4对比"></a><em>IPV6与IPV4对比</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091307625.png" alt="image.png"></p><h3 id="IPV4向IPV6过渡"><a href="#IPV4向IPV6过渡" class="headerlink" title="IPV4向IPV6过渡"></a><em>IPV4向IPV6过渡</em></h3><ul><li><strong>*双栈技术</strong>：主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。*</li></ul><blockquote><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p></blockquote><ul><li><strong>*隧道技术</strong>：在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。*</li></ul><blockquote><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091308688.png" alt="image.png"></p><h2 id="路由算法与路由选择协议概述"><a href="#路由算法与路由选择协议概述" class="headerlink" title="路由算法与路由选择协议概述"></a><em>路由算法与路由选择协议概述</em></h2><blockquote><p><em>路由算法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062114988.png" alt="image.png"></p><blockquote><p><em>路由算法分类</em></p></blockquote><ul><li><em>静态路由算法（非自适应路由算法）：管理员手动配置路由信息</em></li><li><em>动态路由算法（自适应路由算法）：路由器彼此交换信息，自行优化路由表</em><ul><li><em>全局性算法：链路状态路由算法OSPF</em><br>  <em>所有路由器掌握完整的网络拓扑和链路费用</em></li><li><em>分散性算法：距离向量路由算法RIP</em><br>  <em>路由器只掌握物理相连的邻居及链路费用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062115290.png" alt="image.png"></li></ul></li></ul><blockquote><p><em>分层次的路由选择协议</em></p></blockquote><ul><li><strong>*路由选择协议需要分层次</strong><br>1.因为因特网规模大 2.因为许多单位不想让外界知道自己的路由选择协议<em></em>所以就分为多个自治系统AS，并且将不同自治系统可以使用不同协议<em></em>一个AS内使用的RIP、OSPF协议；AS与AS之间使用的BGP协议*</li><li><strong>*自治系统AS</strong>：<br>是单一的技术管理下的一组路由器（这些路由器使用一种AS内部的路由选择协议）；互联网是一个由网络组成的网络。它由成千上万个被称为“自治系统”（autonomous system，AS）的更小网络组成。这些网络中的每一个实际上就是由单一组织运行的一个大型路由器池。如果我们继续将 BGP 比作互联网的邮政服务，那么自治系统就相当于各邮政分局。一个城镇可能有数百个邮箱，但邮箱中的所有邮件都必须先经过本地邮政分局，然后再运送到另一个目的地。自治系统中的内部路由器就好比邮箱。它们将出站流量路由到自治系统，然后使用 BGP 路由将这些流量传输到其目的地。*</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062122986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062126920.png" alt="image.png"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a><em>RIP协议及距离向量算法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835341.png" alt="image.png"></p><h4 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a><em>RIP协议报文格式</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议，使用UDP传输数据</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091945467.png" alt="image.png"></p><h4 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a><em>什么是RIP协议？</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议</strong>，是一种<strong>分布式的基于距离向量的路由选择协议</strong>适用于与比较小的网络</em></p></blockquote><p><em>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</em><br><em>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></em></p><p><em>路由表有三项：目的网络、距离、下一条路由器</em></p><ul><li><strong>*目的网络</strong>：通过该路由器能够到达的网络*</li><li><strong>*距离</strong>：该路由器到达目的网络的最佳距离（跳数）*</li><li><strong>*下一跳路由器</strong>：如果要走这样的最佳距离，需要走过的下一跳路由器<em></em>【直接交付，是指目的网络和该路由器直接相连的】*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091606961.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091718131.png" alt="image.png"></p><h4 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点"></a><em>RIP协议的特点</em></h4><ol><li><em>仅和<strong>相邻路由器</strong>交换信息。</em></li><li><em>交换的信息是当前本路由器所知道的全部信息，即<strong>自己的路由表。</strong></em></li><li><em>按固定的时间间隔交换路由信息，例如，<strong>每隔 30 秒</strong>。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息（当链路有变化，就不等30s了，比如某个网段不存在了，会立刻告诉。）</em></li></ol><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a><em>距离向量算法</em></h4><p><em>在RIP协议相邻路由器互相交换路由表之后，如何处理，才能得到到达某一个网络的最短距离？这就是距离向量算法所解决的问题</em></p><ol><li><em>修改相邻路由器发来的RIP报文中 <strong>所有表项。</strong><br> 对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离” 字段 +1。</em></li><li><em>对修改后的RIP报文中的每一个项目，进行以下步骤：</em><br> <em>（1）R1路由表中若没有Net3，则把该项目填入R1路由表</em><br> <em>（2）R1路由表中若有Net3，则查看下一跳路由器地址：</em><ul><li><em>若下一跳是X，则用收到的项目替换源路由表中的项目；</em></li><li><em>若下一跳不是X， 原来距离比从X走的距离远则更新，否则不作处理。</em></li></ul></li><li><em>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</em></li><li><em>返回</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091734766.png" alt="image.png"></li></ol><blockquote><p><em>距离向量算法例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091737534.png" alt="image.png"></p><p><strong><em>解析：</em></strong><br><em>来自B的向量为（5，0，8，12，6，2）；<br>其数字分别对应路由器C通过B 到达(A，B，C，D，E，F) 路由器的距离，<br>由于还有C到B的延迟6,所以每个分量还需要+6；其他的同理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091738922.png" alt="image.png"></p><h4 id="好消息穿的快，坏消息传的慢"><a href="#好消息穿的快，坏消息传的慢" class="headerlink" title="好消息穿的快，坏消息传的慢"></a><em>好消息穿的快，坏消息传的慢</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835185.png" alt="image.png"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><em>OSPF协议及链路状态算法</em></h3><h4 id="OSPF分组格式"><a href="#OSPF分组格式" class="headerlink" title="OSPF分组格式"></a><em>OSPF分组格式</em></h4><blockquote><p><em>注意：OSPF协议是<strong>网络层协议，使用IP数据爆传输数据</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091941328.png" alt="image.png"></p><h4 id="为什么会有OSPF协议？"><a href="#为什么会有OSPF协议？" class="headerlink" title="为什么会有OSPF协议？"></a><em>为什么会有OSPF协议？</em></h4><p><em>开放式最短路径优先OSPF（Open Shortest Path First）协议是IETF定义的一种<strong>基于链路状态的内部网关路由协议</strong>。</em></p><p><em>为什么会出现OSPF？:因为<strong>RIP是一种基于距离矢量算法的路由协议</strong>，存在着</em></p><ul><li><strong>收敛慢；</strong></li><li><strong>易产生路由环路；</strong></li><li><strong>可扩展性差，最大只能支持15跳。</strong></li></ul><p><em>OSPF的出现很好地解决了上述3个问题</em></p><h4 id="OSPF协议的特点"><a href="#OSPF协议的特点" class="headerlink" title="OSPF协议的特点"></a><em>OSPF协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091934529.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935354.png" alt="image.png"></p><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a><em>链路状态路由算法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935933.png" alt="image.png"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a><em>BGP协议</em></h3><h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a><em>BGP协议报文格式</em></h4><blockquote><p><em>注意：BGP协议是<strong>应用层协议，使用TCP传送</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091948118.png" alt="image.png"></p><h4 id="什么是BGP协议？"><a href="#什么是BGP协议？" class="headerlink" title="什么是BGP协议？"></a><em>什么是BGP协议？</em></h4><p><em>边界网关协议 (BGP) 就是互联网的邮政服务。当有人把一封信投进邮筒时，邮政服务就会处理这封邮件，并选择一条快速、高效的路线将这封信投递给收件人。同样地，当有人通过互联网提交数据时，BGP 负责寻找数据能传播的所有可用路径，并选择最佳的路由，这通常意味着在自治系统之间跳跃。</em></p><h4 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a><em>BGP协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092009810.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092010645.png" alt="image.png"></p><h4 id="BGP协议交换信息过程"><a href="#BGP协议交换信息过程" class="headerlink" title="BGP协议交换信息过程"></a><em>BGP协议交换信息过程</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011121.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011023.png" alt="image.png"></p><h4 id="BGP协议四种报文"><a href="#BGP协议四种报文" class="headerlink" title="BGP协议四种报文"></a><em>BGP协议四种报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092012373.png" alt="image.png"></p><h3 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a><em>三种路由协议的比较</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013263.png" alt="image.png"></p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a><em>IP组播</em></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>字扩展与多模块存储器区别</title>
    <link href="https://fqzs.netlify.app/undefined/a9bcdbf2.html"/>
    <id>https://fqzs.netlify.app/undefined/a9bcdbf2.html</id>
    <published>2023-06-01T22:23:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于一个存储器的一部分，也就是说拥有同一个读写周期。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg&quot; alt=&quot;星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哪些方法可以判断一个有向图是否有环</title>
    <link href="https://fqzs.netlify.app/undefined/d30215e4.html"/>
    <id>https://fqzs.netlify.app/undefined/d30215e4.html</id>
    <published>2023-05-24T22:03:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg&quot; alt=&quot;房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>模4补码与模2补码</title>
    <link href="https://fqzs.netlify.app/undefined/f711f08b.html"/>
    <id>https://fqzs.netlify.app/undefined/f711f08b.html</id>
    <published>2023-05-22T22:13:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg&quot; alt=&quot;女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码、模与运算</title>
    <link href="https://fqzs.netlify.app/undefined/b988fae0.html"/>
    <id>https://fqzs.netlify.app/undefined/b988fae0.html</id>
    <published>2023-05-22T16:32:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg&quot; alt=&quot;晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码的移位</title>
    <link href="https://fqzs.netlify.app/undefined/fe859f5c.html"/>
    <id>https://fqzs.netlify.app/undefined/fe859f5c.html</id>
    <published>2023-05-21T22:55:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对补码左移运算&lt;/code&gt;&lt;br&gt;书里介绍的</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="补码" scheme="https://fqzs.netlify.app/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://fqzs.netlify.app/undefined/8d4b7ae1.html"/>
    <id>https://fqzs.netlify.app/undefined/8d4b7ae1.html</id>
    <published>2023-05-08T20:07:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg" alt="白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期=主频周期=节拍：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 </span><br><span class="line">  入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF-Overflow-Flag"><a href="#OF-Overflow-Flag" class="headerlink" title="OF:Overflow Flag"></a>OF:Overflow Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">1011 + 1001 = 1 0100 --&gt; 只有符号位进位 溢出</span><br><span class="line">0100 + 0100 =   1000 --&gt; 只有次高位进位 溢出</span><br><span class="line">1111 + 1100 = 1 1011 --&gt; 符号位和次高位都进位，不溢出</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF-Sign-Flag"><a href="#SF-Sign-Flag" class="headerlink" title="SF: Sign Flag"></a>SF: Sign Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF-Zero-Flag"><a href="#ZF-Zero-Flag" class="headerlink" title="ZF: Zero Flag"></a>ZF: Zero Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF-Carry-Flag"><a href="#CF-Carry-Flag" class="headerlink" title="CF: Carry Flag"></a>CF: Carry Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 进位/借位标志位，表示无符号数的加减法是否发生了进位或借位</span><br><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B</span><br><span class="line">               电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那就需</span><br><span class="line"> 要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10条字选</span><br><span class="line"> 线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内全部</span><br><span class="line">      刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期变为</span><br><span class="line">  1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功耗低</span><br><span class="line">  价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache-缓存"><a href="#Cache-缓存" class="headerlink" title="Cache(缓存)"></a>Cache(缓存)</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><p><em>思考一个问题？如何确定将主存中的数据搬到Cache中后，数据在Cache中的存放位置？这就需要一个具体的映射方式来确定，一个主存地址中的数据在Cache中的存储位置</em></p><p><strong>*地址映射</strong>：地址映射是一种规则，它指明了把主存地址空间映射到Cache地址空间所用的规则，即把存放在主存中的程序按照某种规则装入Cache。，由Cache的块数比主存块数少得多，因此需要加入主存字块标记和字块内地址*</p><p><strong>*地址变换</strong>：地址变换是一个过程，它是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始</span><br><span class="line">都为0)如果不加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位</span><br><span class="line">表示块号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要</span><br><span class="line">6bit位表示--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221529841.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一快的副本。</em></li><li><em>字块内地址：由于Cachei块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit位就对应表示Cache中的块号</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221530376.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一块的副本。</em></li><li><em>Cache:字块地址：指明存放在Cache中的哪个Cache块。</em></li><li><em>字块内地址：由于Cache块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221531760.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中那一块的副本。</em></li><li><em>组地址：指明存放在Cache中的哪个Cache块的组。</em></li><li><em>字块内地址：由于Cche块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></li></ul><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">- 当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><ul><li><em>有效位：1bit 用于判断该数据是否有效</em></li><li><em>脏位：1bit 用于标记Cache中数据是否被修改过</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块</span><br><span class="line">中，因此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主</span><br><span class="line">存块大小相等)因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑页号对应，所以出现了一个映射表，存储</span><br><span class="line">块号与页号的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;10 转换地址 000001(操作码) 10(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺序编</span><br><span class="line"> 址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表示SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br><span class="line">&gt;快表TLB ,相当于主存与外存之间的&quot;Cache&quot;用于存放外存中页表的副本</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h3 id="高速缓冲存储器-Cache-习题"><a href="#高速缓冲存储器-Cache-习题" class="headerlink" title="高速缓冲存储器(Cache)习题"></a>高速缓冲存储器(Cache)习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221203457.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221209136.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221219813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221351133.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221353099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221455353.png" alt="image.png"></p><p>*128KB/16B = 8K(块)=2^13(块)，组相连映射，每组8块，所以2^13/8=2^10(组)，—&gt;10bit表示Cache内组号</p><p>主存地址1234567H —&gt;说明主存地址共4x7=28位，28-10-4=14(主存字块标记位数)*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221542461.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221604202.png" alt="image.png"></p><p><em>逻辑地址与物理地址区别就是页号不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221642813.png" alt="image.png"></p><p><em>Cache容量计算：数据部分+控制部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221650066.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222021823.png" alt="image.png"></p><p><em>没有告诉主存地址位数,只知道地址号数<br>通过逻辑右移·取余数得到低位部分数<br>就可得如组号是多少了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221659922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221710825.png" alt="image.png"></p><p><em>Cache一次缺失，就需要将一个主存块替换进Cache里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221701004.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221705615.png" alt="image.png"></p><p><em>1.做这题第一眼，忽略了写命中也要算进去<br>2.这里k=1000刚好是4的倍数，，因为一个块16B,可以存4个数组元素，所以替换到Cache中的数组都可以访问到不会遗漏，所以可以根据每8次缺失1次算<br>3.当k=10,时，只能访问到a[9],剩余替换到Cache块中的a[10],a[11]不会访问到，所以要按实际情况计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222004782.png" alt="image.png"></p><p>*时间局部性：一条指令一旦被执行，在不久的将来可能会再次执行<br>典型代表：循环指令</p><p>空间局部性：一旦一个存储单元被访问，那么它附近的存储单元也很快被访问典型代表：数组，顺序指令*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222013840.png" alt="image.png"></p><p><em>比较器的作用：用于判断需要取的数据是否在Cache中已存在<br>1.由于一次存取只能存取一个数据，故一次存取先根据主存地址中的Cache组号，确定数据所在Cache组（一组8个Cache块）<br>2.在根据主存地址标志位tag(用于确定对应的主存块号)，通过比较器将目的tag位，与该组中所有Cache块中存储的数据的tag位进行比对，如果匹配成功，说明Cache命中<br>3.所以比较器是用在确定组号之后，比较组内所有块的tag位，所以组内有8块，就需要8个比较器，tag位有20位，比较器位数就需要20位</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222036946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222048277.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222054958.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222059557.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222116123.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222121516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222132157.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154250.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154018.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222153389.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222208624.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217240.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222219607.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217728.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231216744.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231307226.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231314918.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231319447.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231321170.png" alt="image.png"><br><em>本题要点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231323044.png" alt="image.png"></p><p><em>(1)(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231339697.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231340569.png" alt="image.png"><br><em>(4)</em><br>*修改页面，是指改完主存中的内容后，再将主存中修改的内容写到辅存(外存)</p><p>Cache直写，是一并将修改写入Cache和主存，就是全写法，通过写缓冲实现*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231343247.png" alt="image.png"></p><p><em>LRU标记位需要3bit,用于标记各个块被访问的先后顺序，由于每个分组内只有8个块，先后顺序无非1~8，所以3bit位标记先后顺序即可</em><br><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231353841.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406025.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406198.png" alt="image.png"></p></blockquote><h3 id="虚拟存储器-1"><a href="#虚拟存储器-1" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码 </span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr><h3 id="汇编语言的考试要求"><a href="#汇编语言的考试要求" class="headerlink" title="汇编语言的考试要求"></a>汇编语言的考试要求</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111601729.png" alt="image.png"></p><h3 id="X86汇编语言基础"><a href="#X86汇编语言基础" class="headerlink" title="X86汇编语言基础"></a>X86汇编语言基础</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是X86?</span><br><span class="line">1978年Intel公司生产了一块CPU芯片代号8086，</span><br><span class="line">之后就出现了80286、80386等一系列86结尾的型号的CPU，都兼容之前的CPU，能够将程序</span><br><span class="line">移植到新的CPU执行。因此X86汇编语言指令，是指能够被这一系列CPU处理的汇编语言指</span><br><span class="line">令</span><br></pre></td></tr></table></figure><hr><h4 id="以mov指令为例"><a href="#以mov指令为例" class="headerlink" title="以mov指令为例"></a>以mov指令为例</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111617341.png" alt="image.png"><br>s-&gt;source-&gt;源操作数<br>d-&gt;destination-&gt;目标操作数<br><code>mov d , s</code>-&gt;将源操作数s复制到目的操作数d所指的位置</p><p>mov指令常用格式有一下几种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111619250.png" alt="image.png"><br>其中当指明的是内存地址的时候，通过dword ptr(双字)、word ptr(单字)、byte ptr(字节)<br>来指明需要读写的长度</p><hr><h4 id="X86CPU有哪些寄存器"><a href="#X86CPU有哪些寄存器" class="headerlink" title="X86CPU有哪些寄存器"></a>X86CPU有哪些寄存器</h4><ul><li>X 结尾：通用寄存器</li><li>I 结尾 ：变址寄存器</li><li>P结尾：堆栈寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111633315.png" alt="image.png"></li></ul><ul><li>寄存器都以E开头，E-&gt;Extenden=32bit，</li><li>对于通用寄存器而言如果指向使用低位的16bit，那么可将E 去掉</li><li>变地址寄存器和堆栈寄存器都不能去掉E ,只能固定使用32bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111638172.png" alt="image.png"></p><hr><h4 id="源、目的-操作数书写格式"><a href="#源、目的-操作数书写格式" class="headerlink" title="源、目的 操作数书写格式"></a>源、目的 操作数书写格式</h4><ul><li>[寄存器] 是指寄存器里所存的地址所指向的数据，相当于寄存器间接寻址</li><li>[地址/寄存器] 前没有指明读学长度时，默认32bit</li><li>[af996-12 h]-&gt;最后h表示16进制，这样写是指地址af886往前偏移12位地址所指数据</li><li>[abx +8]-&gt;是指该寄存器内地址往后+8的主存地址所指向的数据<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111642835.png" alt="image.png"></li></ul><hr><h4 id="常见的算数运算指令"><a href="#常见的算数运算指令" class="headerlink" title="常见的算数运算指令"></a>常见的算数运算指令</h4><ul><li>乘法 mul d,s -&gt; 表示无符号数d * s,乘积存入d</li><li>乘法 imul d,s -&gt; 表示有符号数d * s,乘积存入d</li><li>除法 div s -&gt;无符号数除法，被除数会提前存放在edx:eax中<br>  -&gt;edx:eax表示两个寄存器拼接将被除数从原来的32bit扩展为64bit ;<br>  -&gt;商存入eax,余数存入edx中</li><li>除法 idiv s -&gt;有符号数除法，被除数会提前存放在edx:eax中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111737632.png" alt="image.png"></li></ul><hr><h4 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111750543.png" alt="image.png"></p><hr><h4 id="s、d操作数"><a href="#s、d操作数" class="headerlink" title="s、d操作数"></a>s、d操作数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于X86系统，指令后面的两个操作数不允许两个都来自主存&lt;mem&gt;</span><br><span class="line">2.并且，目的操作数d 不能是常数&lt;con&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172215148.png" alt="image.png"></p><hr><h4 id="AT-amp-T格式指令与Intel格式指令区别"><a href="#AT-amp-T格式指令与Intel格式指令区别" class="headerlink" title="AT&amp;T格式指令与Intel格式指令区别"></a>AT&amp;T格式指令与Intel格式指令区别</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111800835.png" alt="image.png"></p><ul><li>基址+变址 <em> 比例因子+偏移量<br>用于结构体数组内信息的寻址<br>基地址-&gt;寻找数组起始地址<br>变址 </em> 比例因子-&gt;寻找目标元素在数组内的位置<br>偏移量-&gt;寻找目标信息在该元素内的具体位置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111806568.png" alt="Uploading file...npg0j"></li></ul><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><hr><h4 id="jmp指令与cmp指令"><a href="#jmp指令与cmp指令" class="headerlink" title="jmp指令与cmp指令"></a>jmp指令与cmp指令</h4><p><strong>1.程序中选择分支结构</strong></p><ul><li>程序计数器PC又被称为IP寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112305940.png" alt="image.png"></li></ul><hr><p><strong>2.无条件跳转指令—Jmp</strong></p><p>执行该条指令PC会无条件跳转到某个主存地址，执行那个地址的指令</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317121.png" alt="image.png"></p><p>无条件跳转指令格式 -&gt; jmp &lt;地址&gt; </p><ul><li>jmp 128 -&gt;跳转到地址128</li><li>jmp eax -&gt; 地址来自于寄存器</li><li>jmp [999] -&gt;地址来自于主存地址999中存的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317178.png" alt="image.png"></li></ul><hr><p><strong>3.jmp跳转标记位格式</strong></p><pre><code>因为写程序的时候，例如if-else分支语句的时候，通过条件判断决定跳转执行那一条程序语句，这样就有一个问题，如果都采用上面的三种jmp跳转指令--需要先知道需要跳转的程序的主存地址(jmp 116)，这样写死了地址，很不灵活，一旦程序的主存地址一改变，原有的jmp指令就会跳转错误位置，所以就可以通过对需要跳转的语句做标记NEXT ,通过jmp NEXT 的跳转方式实现跳转</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112330386.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112332972.png" alt="image.png"></p><hr><p><strong>4.条件转移指令-jxxx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112334438.png" alt="image.png"></p><p>通常使用条件跳转指令前，需要使用cmp指令。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336192.png" alt="image.png"></p><p>所以cmp指令经常和条件跳转指令搭配使用。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336184.png" alt="image.png"></p><hr><p><strong>5.cmp指令的底层原理</strong></p><p>本质上就是对a,b两个操作数镜像减法运算a-b,并生成了OF、ZF、CF、SF四个标志位信息<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112339041.png" alt="image.png"></p><p>ALU 每进行一次运算的标志位都会自动存入<br>PSW程序状态字寄存器中(Intel称它为“标志寄存器FR”)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112341179.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340390.png" alt="image.png"></p><p>jxxx指令，就是根据cmp指令得到的标志位，来判断是否= &lt;  &gt; ！=<br>进而决定进行跳转<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112345836.png" alt="image.png"></p><hr><h4 id="条件转移指令jmp实现循环"><a href="#条件转移指令jmp实现循环" class="headerlink" title="条件转移指令jmp实现循环"></a>条件转移指令jmp实现循环</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142216499.png" alt="image.png"></p><hr><h4 id="loop指令实现循环"><a href="#loop指令实现循环" class="headerlink" title="loop指令实现循环"></a>loop指令实现循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 指令：</span><br><span class="line">- 格式loop Looltop  // ecx-- ,若ecx!=0,跳转到Looptop</span><br><span class="line">- 只能用ecx作为循环计数器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142229529.png" alt="image.png"></p><hr><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><h4 id="call、leave、ret指令"><a href="#call、leave、ret指令" class="headerlink" title="call、leave、ret指令"></a>call、leave、ret指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call、leave、ret指令实现函数调用：</span><br><span class="line">call 指令 作用：</span><br><span class="line">1.将IP旧址压栈保存(保存在当前函数的栈帧顶部)</span><br><span class="line">2.设置新的IP值，无条件转移到被调用函数的第一条指令</span><br><span class="line">leave 指令 作用：</span><br><span class="line">1.将现在的函数的栈帧撤销，相当于将该函数弹栈</span><br><span class="line">ret 指令 作用：</span><br><span class="line">1.弹栈后，从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP原有的值指向回原来位</span><br><span class="line">置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142240959.png" alt="image.png"></p><hr><h4 id="如何访问栈帧里的数据？"><a href="#如何访问栈帧里的数据？" class="headerlink" title="如何访问栈帧里的数据？"></a>如何访问栈帧里的数据？</h4><h5 id="访问栈帧数据Push和Pop指令"><a href="#访问栈帧数据Push和Pop指令" class="headerlink" title="访问栈帧数据Push和Pop指令"></a>访问栈帧数据Push和Pop指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ebp和esp：</span><br><span class="line">ebp指向当前栈帧的底部，esp指向当前栈帧的顶部，两者标记了当前栈帧的一个范围</span><br><span class="line">ebp、esp存的是地址不是数据值，ebp和esp只是一个指针</span><br><span class="line"></span><br><span class="line">Push、Pop指令实现入栈出栈操作操作，X86默认以4字节为单位：</span><br><span class="line">格式:</span><br><span class="line">Push ?  //先让esp-4，在将数据压入</span><br><span class="line">Push eax   #将寄存器eax的值压栈</span><br><span class="line">Push 985   #将立即数985压入栈中</span><br><span class="line">Push [ebp+8] #将主存地址[ebp+8]的数据压栈</span><br><span class="line">(所谓压栈是指将esp里保存的地址，所指向的数据的值修改,然后esp-4)</span><br><span class="line">Pop ?  //栈顶元素出栈并写入&lt;寄存器/主存地址&gt;，在esp+4</span><br><span class="line">Pop eax   # 将栈顶元素出栈，写入寄存器eax</span><br><span class="line">Pop [ebp+8] # 将栈顶元素出栈，并写入主存地址[ebp+8]</span><br><span class="line">(所谓出栈是指,将esp保存的地址所指向的值写入?,然后esp+4)</span><br><span class="line">问题： </span><br><span class="line">这样访问栈帧数据不灵活，因为每次Push都只能往esp+4的位置Push(压入数据)</span><br><span class="line">每次Pop也只能一次弹出一个栈顶元素，并写入一个栈顶栈顶元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151025134.png" alt="image.png"></p><hr><h5 id="访问栈帧数据mov指令"><a href="#访问栈帧数据mov指令" class="headerlink" title="访问栈帧数据mov指令"></a>访问栈帧数据mov指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以直接对esp进行加减运算：</span><br><span class="line">可以使用减法/加法，即sub/add修改栈顶指针esp的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151046206.png" alt="image.png"></p><hr><h4 id="如何切换栈帧？"><a href="#如何切换栈帧？" class="headerlink" title="如何切换栈帧？"></a>如何切换栈帧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.先执行call指令：</span><br><span class="line">1.将当前IP(取出call之后自动指向下一条)值，相当于 Push IP</span><br><span class="line">2.将IP设置为被调用函数的第一条指令地址, 相当于jmp add</span><br><span class="line"></span><br><span class="line">2.进入目标函数后：&lt;保存上一个函数的栈帧，并设置当前函数栈帧&gt;</span><br><span class="line">1.Push ebp --&gt;将前一个函数的栈底地址保存入栈(先esp+4,然后将ebp值压入)</span><br><span class="line">2.mov ebp esp --&gt; 将esp的地址值复制给ebp,使ebp指向另一个函数的栈底地址</span><br><span class="line"> ==&gt; 1+2等价于enter指令</span><br><span class="line"> </span><br><span class="line">3.一系列逻辑处理</span><br><span class="line"></span><br><span class="line">4.恢复上一层函数的栈帧：</span><br><span class="line">1.mov esp ebp --&gt; 让esp指向当前函数栈底</span><br><span class="line">2.Pop ebp --&gt; 将栈顶元素出栈，并写入ebp(ebp重新指回上一个函数基底)</span><br><span class="line"> ==&gt; 等价于leave指令</span><br><span class="line">5.ret指令：</span><br><span class="line">从栈顶找到返回的地址(原来基础上继续执行)，出栈并将值写到IP寄存器中，使其继续执</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><code>调用函数</code></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151109099.png" alt="image.png"></p><p><code>函数返回</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151130458.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151214922.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151105535.png" alt="image.png"></p><hr><h4 id="如何传递参数和返回值？"><a href="#如何传递参数和返回值？" class="headerlink" title="如何传递参数和返回值？"></a>如何传递参数和返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈帧最底部(基址)一定是上一层栈帧的基址</span><br><span class="line"></span><br><span class="line">栈帧的最顶部，一定是IP的返回地址(当前栈帧除外)</span><br><span class="line"></span><br><span class="line">栈帧结构，分为以下几块区域，每块区域内同时越靠前定义的就越靠近栈顶:</span><br><span class="line">1.局部变量区域</span><br><span class="line"></span><br><span class="line">2.未使用区域</span><br><span class="line">为什么会有未使用区域？</span><br><span class="line">因为gcc编译器会将每个栈帧大小设置为16B的整数倍(当前函数栈帧除外)</span><br><span class="line">当局部变量和调用参数没有填满栈帧时，就会空出未使用的部分</span><br><span class="line">3.调用参数区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172225143.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172137430.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数，返回值</span><br><span class="line">传低参数：在call指令前，将调用参数写入栈帧顶部区域</span><br><span class="line">接收返回值：在执行ret指令前将函数返回值写入eax寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172234781.png" alt="image.png"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CISC: Complex Instruction Set Computer(复杂指令集)</span><br><span class="line">- 通过一条指令完成复杂的基本功能，所以，它的指令往往是变长的</span><br><span class="line">- 变长，这也决定了它的指令执行效率低，因为需要花时间判断该指令的长度</span><br><span class="line">- 像是前面提到的乘法指令 000100 0000000110 只通过乘法指令就可以进行访存，所以</span><br><span class="line">  CISC指令对指令的访存权限没有限制</span><br><span class="line">- 由于随着CISC指令变得越来越复杂，很难用一个专门的电路硬件来实现，所以&quot;存储程</span><br><span class="line">  序&quot;，就是事先将几条组合指令存储在某个地方，比如要实现矩阵的乘法--&gt;可以通过</span><br><span class="line">  矩阵的加法、减法;整数加法、减法、乘法，5个比较通用的电路之间配合使用来实现复</span><br><span class="line">  杂的矩阵乘法</span><br><span class="line">RISC: Reduced Instruction Set Computer(精简指令集)</span><br><span class="line">- 一条指令只完成一个基本动作，一条指令一个电路</span><br><span class="line">- 由于电路设计简单功耗更低，所以主要用于移动设备:手机、平板等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172336854.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSIC:</span><br><span class="line">1.寄存器数量少，因为可以访存的指令没有限制，可以直接从主存中存取，不会过多的占</span><br><span class="line">  用寄存器的数量</span><br><span class="line">2.难以用优化编译生成高效的目标代码程序，因为，CISC本身就是一个复杂体，又胖又无</span><br><span class="line"> 法切割重组，决定了其效率的上限很低</span><br><span class="line"></span><br><span class="line">RISC:</span><br><span class="line">1.寄存器数量多，因为，可以访存的指令只有Load/Stroe，所以进行计算等操作的时候，</span><br><span class="line">  只能通过寄存器来存放数据，最后再通过Load/Stroe指令来进行写入或删除</span><br><span class="line">2.指令精简，可以很大程度上重组功能，生成更高效的代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172340404.png" alt="image.png"></p><h1 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041138990.png" alt="image.png"></p><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a><em>CPU的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032012738.png" alt="image.png"></p><h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a><em>运算器和控制器的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032026718.png" alt="image.png"></p><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a><em>运算器的基本结构</em></h3><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个寄存器与ALU之间都有专门的单独的数据通路--&gt;称为专用数据通路</span><br><span class="line">下图所示，所有寄存器与ALU都直接相连，但是我们不需要同时有这么多寄存器同时输入数据</span><br><span class="line">以下有两种解决办法:1.多路选择器;2.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032116421.png" alt="image.png"></p><blockquote><p><em>多路选择器</em></p></blockquote><p><em>使用多路选择器根据控制信号选择一路输出</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032113430.png" alt="image.png"></p><blockquote><p><em>三态门</em></p></blockquote><p>计算机里面<strong>1 0</strong> 分别表示 <strong>是  非</strong> 两种逻辑，但是还不够，因此引入了一种新的状态——<strong>高阻态</strong>(相当于电阻无穷大，断路状态)。</p><p>三态：高电平、低电平、高阻态。</p><p>三态门主要与总线连接，因为总线在同一时间内只能对一个设备有效。<br>通常在数据总线上连接有<strong>多个器件</strong>。同一时刻只能有一个设备选通，用于数据传输；其他设备处于高阻态(断开)。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032142905.png" alt="image.png"></p><p>EN使能信号：<br>    EN是<strong>0信号</strong>表示数据从A-&gt;B ;<strong>1信号</strong>表示数据从B-&gt;A；当EN使能信号无效时(没有产生信号)处于高阻态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032148055.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032150494.png" alt="image.png"></p><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将所有寄存器的输入端和输出端都连接到一条公用的通路上(CPU内部总线)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032203518.png" alt="image.png"></p><p><strong>引入暂存寄存器</strong><br><em>从这开始内部总线就只能同时有一个输入信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032207030.png" alt="image.png"></p><p><strong>为了避免输入信号还没稳定的时候就发出输出信号，在ALU后面再引入一个暂存寄存器+一个三态门</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当输入信号稳定前，期间产生的输出信号被存放在暂存器中(此时三态门没有导通);</span><br><span class="line">当输入信号稳定之后，(三态门接通)最终产生的输出信号才传输到CPU内部总线</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032209466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032216449.png" alt="image.png"></p><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032229276.png" alt="image.png"></p><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041129708.png" alt="image.png"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041136632.png" alt="image.png"></p><hr><h2 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><strong>CPU从主存中每取出并执行一条指令所需的全部时间</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041154511.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041200018.png" alt="image.png"></p><h3 id="数据流-微操作-有效信号"><a href="#数据流-微操作-有效信号" class="headerlink" title="数据流(微操作+有效信号)"></a>数据流(微操作+有效信号)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041429770.png" alt="image.png"><br><strong>注意书写数据流的时候需要写出——&gt; 微操作 + 有效控制信号</strong></p><hr><blockquote><p><em>指令周期的数据流向-取指周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041216231.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-间址周期</em></p></blockquote><p><strong>Ad(MDR) -&gt; MAR</strong> 中Ad 表示的是将MDR数据(取得的指令)中的<code>地址码部分</code>放入MAR中<br><strong>Ad(IR) -&gt; MAR</strong> 中Ad表示的也是将IR数据(取得的指令)中的<code>地址码部分</code>放到MAR中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041238584.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-执行周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041412833.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-中断周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041428150.png" alt="image.png"></p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041435747.png" alt="image.png"></p><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041434691.png" alt="image.png"></p><h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据通路的基本结构有:</span><br><span class="line">1.CPU内部单总线方式</span><br><span class="line">所有CPU部件连接一根内部总线，同时只能一组部件数据交换(一个发出，一个接收)</span><br><span class="line">2.CPU内部多总线方式</span><br><span class="line">为了解决同时只能有一组部件进行数据交换，所以提出CPU内部多总线，所有部件与这些</span><br><span class="line">多根总线都有连接，同时可以支持n组部件数据交换(n是总线根数)</span><br><span class="line">3.专用数据通路方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041936960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041935158.png" alt="image.png"></p><h3 id="数据通路-CPU内部单总线方式"><a href="#数据通路-CPU内部单总线方式" class="headerlink" title="数据通路-CPU内部单总线方式"></a>数据通路-CPU内部单总线方式</h3><blockquote><p><em>完成一次加法运算，完整的数据通路(单总线方式)</em></p></blockquote><p>由于这是单总线方式，一次只能有一组部件传输数据(例如 (ACC)-&gt;Bus-&gt;ALU  实现ACC和ALU之间的 <strong>被加数</strong>传输，<strong>加数</strong>只能先通过MDR-&gt;Bus-&gt;Y 存放在暂存寄存器中)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042005863.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>取指周期过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042040431.png" alt="image.png"></p><p>间址周期过程(省略微操作)：<br>    1.R0out  ,MARin 控制信号有效 -&gt;R0内间接地址传送到MAR<br>    2.MemR ,MARout ,MDRinE 控制信号有效 -&gt; 根据间接地址得到的直接地址EA存入MDR<br>    3.MDRout ,MARin 控制信号有效 -&gt;EA传给MAR<br>    4.MARout ,MemR ,MDRinE 控制信号有效 -&gt; 根据EA找到的操作数()存入MDR<br>    5.MDRout ,Yin 控制信号有效 -&gt; 将目的操作数((R0))放入暂存寄存器Y中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137539.png" alt="image.png"></p><p>执行周期过程(省略微操作):<br>    1.R1out , ALUin ,CU向ALU发送加法操作信号, 控制信号有效 -&gt;将源操作数送入ALU运算(Y寄存器同时会将之前暂存的目的操作数通过专用数据通路送往ALU)<br>    2.Zout ,MDRin 控制信号有效 -&gt; 将计算结果送入MDR寄存器<br>    3.MemW ,MDRoutE ,MARout -&gt; MDR将计算结果送到主存，MAR目的操作数地址传给主存，主存根据MAR中已经存在的目的操作数的有效地址，将结果写回到目的操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137717.png" alt="image.png"></p><h3 id="数据通路-专用数据通路方式"><a href="#数据通路-专用数据通路方式" class="headerlink" title="数据通路-专用数据通路方式"></a>数据通路-专用数据通路方式</h3><blockquote><p><em>专用数据通路-取指周期</em></p></blockquote><p>取指周期数据流向:<br>    <em>1</em>. (PC)-&gt;MAR                 C0有效<br>    <em>2</em>. (MAR) -&gt;主存             C1有效<br>    <em>3</em>. 1-&gt;R                          控制单元向主存发送读命令<br>    <em>4</em>.  M(MAR) -&gt; MDR      C2有效<br>    <em>5.</em>  (MAR) -&gt; IR              C3有效<br>    <em>6.</em>  (PC)+1-&gt;PC<br>    <em>7.</em>  Op(IR) -&gt;CU             C4有效【Op是操作码，Ad是地址码；将操作码传给CU分析】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042219807.png" alt="image.png"></p><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="硬布线控制器（组合逻辑控制器）"><a href="#硬布线控制器（组合逻辑控制器）" class="headerlink" title="硬布线控制器（组合逻辑控制器）"></a>硬布线控制器（组合逻辑控制器）</h3><h4 id="什么是硬布线控制器？"><a href="#什么是硬布线控制器？" class="headerlink" title="什么是硬布线控制器？"></a><em>什么是硬布线控制器？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070922995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070924177.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070930551.png" alt="image.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a><em>硬布线控制器的设计</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070934082.png" alt="image.png"></p><blockquote><p><em>1.分析每个阶段的微操作序列</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070935646.png" alt="image.png"></p><p><em>2.选择CPU的控制方式</em><br><strong>这里采用同步控制方式(定长机器周期)—&gt;一个周期安排3个节拍</strong></p><p><em>3.安排微操作时序</em></p><p><strong>取指周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070943155.png" alt="image.png"><br><strong>间址周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070946256.png" alt="image.png"><br><strong>执行周期</strong><br><em>访存指令STA 、ADD 、LDA<br>非访存指令<br>转移指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070945614.png" alt="image.png"></p><p><em>4.电路设计</em><br><strong>a.列出操作时间表</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951515.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952398.png" alt="image.png"><br><strong>b.写出微操作命令的最简表达式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070948343.png" alt="image.png"><br><strong>c.画出逻辑图</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951629.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062351469.png" alt="image.png"></p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><h4 id="什么是微程序控制器？"><a href="#什么是微程序控制器？" class="headerlink" title="什么是微程序控制器？"></a>什么是微程序控制器？</h4><blockquote><p><em>为了方便修改和扩展，提出了微程序控制器</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071919688.png" alt="image.png"></p><ul><li>微命令是控制部件向执行部件发出的控制信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CPU内的控制器包含:CU IR PC</span><br><span class="line">CU控制单元用于实现微指令的执行</span><br><span class="line">1.由于CM内存储了多种指令 的 微程序,所以“微地址形成部件”需要根据IR内具体</span><br><span class="line">的指令的操作码，判断该指令对应CM内哪个微程序，以获得其&quot;起始微地址&quot;</span><br><span class="line">  (改正一下表述:所谓微程序既可以说是一条完整指令，包括取指周期、间址周</span><br><span class="line">  期、执行周期、中断周期的所有微指令的总和;也可以说单独的某个周期的微程</span><br><span class="line">  序，例如:取指周期微程序，这里“微地址形成部件，的作用是在根据IR中的操作</span><br><span class="line">  码特征，分析执行周期的微程序的微指令首地址，而不是取指周期微指令首地址</span><br><span class="line">  因为取指周期是通用的它的地址可以由执行周期中最末尾的微指令的下地址指</span><br><span class="line">  明，而执行周期的微指令不是通用的，所以需要单独通过“微地址形成部件”，来</span><br><span class="line">  获得首地址)</span><br><span class="line">2.再根据&quot;顺序逻辑&quot; 中&quot;标志&quot;信息判断下一步要执行微指令的存放地址(一般标志</span><br><span class="line">信息是根据指令地址码(IR中的地址码)的特征，判断是否要进行间址周期，无需间</span><br><span class="line">接寻址就跳过间址周期微指令;如果要间接寻址,那么按照“CMDR中的下地址”顺序执</span><br><span class="line">行下去)</span><br><span class="line">3.CMAR接收来自经过顺序逻辑处理后的“起始微地址”</span><br><span class="line">4.CMAR 将地址(微指令地址)送入地址译码器，找到地址对应的微指令在CM中的位</span><br><span class="line">置</span><br><span class="line">5.CM(控制存储器)根据位置取出该条微指令(操作控制+下地址) ,送到CMDR</span><br><span class="line">6.CMDR将微指令的操作控制信息 传至CPU内部和系统总线的控制信号</span><br><span class="line">7.CMDR 将下一条(相邻的)微指令地址传给顺序逻辑(顺序逻辑会根据之前获得的标</span><br><span class="line">志+CLK信息，如果当前执行到了间址周期微指令，会根据标志信息，判断是否跳过)</span><br><span class="line">8.重复这一循环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071924474.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071950460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个微程序包括一条指令的所有周期的微指令，所以一条指令的取指周期微程序+执行周期微程序，其实是一个微程序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071958856.png" alt="image.png"></p><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092240574.png" alt="image.png"></p><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><blockquote><p><em>水平型微指令、垂直型微指令、混合型微指令</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092245360.png" alt="image.png"></p><h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><blockquote><p><em>编码方式</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微指令编码主要方式分为3种</span><br><span class="line">直接编码: </span><br><span class="line">n个微命令-&gt;需要分别对应n个bit信号位</span><br><span class="line">字段直接编码: </span><br><span class="line">采用译码器，将控制字段分段,比如3bit为1段,能产生2^3种不同信号,</span><br><span class="line">这样就能用更少bit存储控制信号。</span><br><span class="line">这样实现，相同字段内的控制信息无法并行进行--&gt;所以互斥信号放在同一字段</span><br><span class="line">字段间接编码:</span><br><span class="line">译码器上加一层译码器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101035576.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101037705.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101047396.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><em>互斥的放在同一段内，控制字段，需要表示的状态数，需要预留一个全0,表示无操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101046382.png" alt="image.png"></p><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><blockquote><p><em>方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101050533.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101053029.png" alt="image.png"></p><h5 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h5><blockquote><p><em>微程序控制单元的设计</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141414952.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141419465.png" alt="image.png"></p><p><em>微程序设计的分类</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141420731.png" alt="image.png"></p><p><em>硬布线与微程序的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421167.png" alt="image.png"></p><p><em>微程序控制器回顾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421854.png" alt="image.png"></p></blockquote><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141625402.png" alt="image.png"></p><h3 id="指令流水线基本概念性能指标"><a href="#指令流水线基本概念性能指标" class="headerlink" title="指令流水线基本概念性能指标"></a>指令流水线基本概念性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141515119.png" alt="image.png"></p><h4 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a><em>指令流水的定义</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141632815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141501856.png" alt="image.png"></p></blockquote><h4 id="流水线表示方法"><a href="#流水线表示方法" class="headerlink" title="流水线表示方法"></a><em>流水线表示方法</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141500715.png" alt="image.png"></p></blockquote><h4 id="流水线的性能指标-—吞吐率、加速比、效率"><a href="#流水线的性能指标-—吞吐率、加速比、效率" class="headerlink" title="流水线的性能指标 —吞吐率、加速比、效率"></a><em>流水线的性能指标</em> —<strong>吞吐率、加速比、效率</strong></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513423.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513840.png" alt="image.png"></p></blockquote><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">完成一条指令，常分为五个阶段:</span><br><span class="line">IF(取指阶段)、ID(译码段)、EX(执行段)、M(访存)、WB(写回)</span><br><span class="line"></span><br><span class="line">由于每个功能段需要消耗时间不一致，为了统一方便指令流水线，以最长耗时为准这里就设为100ns</span><br><span class="line"></span><br><span class="line">同时就需要在每个功能段后面加一个缓冲寄存器--&gt;锁存器</span><br><span class="line">目的是为了保证执行更快的阶段，将数据存放，处于缓冲等待的状态，以维持统一</span><br><span class="line"></span><br><span class="line">Instruction Cache(指令Cache)--也就是Cache中存放指令的区域</span><br><span class="line">取指一般都是在指令Cache中取指</span><br><span class="line"></span><br><span class="line">Data Cache(数据Cache)--也就是Cache数据区域</span><br><span class="line">M访存，当Cache命中的情况下，直接访问数据Cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142119460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考试中常见的指令有五类(RSIC精简指令集)</span><br><span class="line">运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142127965.png" alt="image.png"></p><h4 id="各类指令的执行过程"><a href="#各类指令的执行过程" class="headerlink" title="各类指令的执行过程"></a>各类指令的执行过程</h4><h5 id="运算类指令执行过程"><a href="#运算类指令执行过程" class="headerlink" title="运算类指令执行过程"></a>运算类指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142135940.png" alt="image.png"></p><h5 id="LOAD指令执行过程"><a href="#LOAD指令执行过程" class="headerlink" title="LOAD指令执行过程"></a>LOAD指令执行过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD--取数指令，RSIC指令集中唯二可以访存的指令,作用是从主存取数到寄存器中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142144944.png" alt="image.png"></p><h5 id="STORE指令执行过程"><a href="#STORE指令执行过程" class="headerlink" title="STORE指令执行过程"></a>STORE指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142150614.png" alt="image.png"></p><h5 id="条件转移指令执行过程"><a href="#条件转移指令执行过程" class="headerlink" title="条件转移指令执行过程"></a>条件转移指令执行过程</h5><p><strong>WrPC逻辑上既不属于M段，也不属于WB段，只是因为WrPC所需要的功能部件与这5个阶段的功能部件是“相互独立的”，所以可以看做一个独立的阶段，可以自由安排</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142157041.png" alt="image.png"></p><h5 id="无条件转移指令执行过程"><a href="#无条件转移指令执行过程" class="headerlink" title="无条件转移指令执行过程"></a>无条件转移指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142205108.png" alt="image.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207049.png" alt="image.png"></p><h3 id="指令流水线的影响因素"><a href="#指令流水线的影响因素" class="headerlink" title="指令流水线的影响因素"></a>指令流水线的影响因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142243130.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142245235.png" alt="image.png"></p><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p><em>这里三地址指令的顺序搞错了，顺序应该是OP R1 R2 R3  —&gt; (R1)OP(R2)—&gt;R3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142254264.png" alt="image.png"></p><blockquote><p><em>硬件阻塞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142257185.png" alt="image.png"><br><em>NOP空操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142256095.png" alt="image.png"><br><em>数据旁路技术</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142308675.png" alt="image.png"></p></blockquote><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><em>由于指令会提前预取，如果到时候需要进行条件转移，那么之前预取的指令就不会执行，浪费导致阻塞</em><br><em>解决办法就是尽早的判别是否需要跳转</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151112357.png" alt="image.png"></p><h3 id="指令流水线分类"><a href="#指令流水线分类" class="headerlink" title="指令流水线分类"></a>指令流水线分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151115488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151120957.png" alt="image.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151125637.png" alt="image.png"></p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127336.png" alt="image.png"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127292.png" alt="image.png"></p><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151153767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151258121.png" alt="new.png"></p><blockquote><p><em>SISD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453525.png" alt="image.png"></p><p><em>SIMD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453930.png" alt="image.png"></p><p><em>MIMD</em></p><p><strong>共享存储多处理器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454475.png" alt="image.png"><br><strong>多计算机系统</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454095.png" alt="image.png"></p><p><em>向量处理器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151455393.png" alt="image.png"></p></blockquote><h2 id="硬件多线程的基本概念"><a href="#硬件多线程的基本概念" class="headerlink" title="硬件多线程的基本概念"></a>硬件多线程的基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504162.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504522.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151505623.png" alt="image.png"></p><h2 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h2><h3 id="CPU的功能与结构习题"><a href="#CPU的功能与结构习题" class="headerlink" title="CPU的功能与结构习题"></a>CPU的功能与结构习题</h3><blockquote><p><em>PSW属于运算器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161825605.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161834865.png" alt="image.png"></p><p><em>指令寄存器就是IR</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161835516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161844725.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161846997.png" alt="image.png"></p><p><em>CPU中寄存器分为用户可见，和不可见</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161847536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161853622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161854165.png" alt="image.png"></p><p><em>存储字长—假如内存按照字节寻址，则内存中一个地址对应1byte,存储字长就是1byte</em><br><em>机器字长—CPU一次性能处理的数据的最大位数，往往等于运算器中寄存器的位数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161856909.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162105859.png" alt="image.png"></p><p><em>地址译码器属于主存，是将地址信号翻译成存储器的选通信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162111498.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162129014.png" alt="image.png"></p><p><em>如果指令字按字边界对齐，那么可以按一个机器字(这里是32bit=4B)，占一个地址。所以，本来按字节编址需要32位，那么按字编址，就只需30位</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162132028.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162201928.png" alt="image.png"></p></blockquote><h3 id="指令执行过程习题"><a href="#指令执行过程习题" class="headerlink" title="指令执行过程习题"></a>指令执行过程习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162204207.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162208016.png" alt="image.png"></p><p><em>需要存取的指令地址信息，追根究底来自于PC</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162215113.png" alt="image.png"></p><p><em>机器周期—取决于访存时间—&gt;存取周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172057737.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172103654.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172106455.png" alt="image.png"></p><p><em>1.取指操作是控制器固有的功能，不需要操作码控制</em><br><em>2.指令有长有短，当指令过长占两个存储字长时，就需要两次访存</em><br><em>3.中断周期，是在当前指令执行完之后才出现</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172110895.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172113362.png" alt="image.png"></p><p><em>冯诺依曼计算机—&gt;同时存储指令和数据，并且统一编址</em><br><em>那吗如何区分取得的二进制串是数据还是指令呢？</em><br><em>1.首先先规定一个指令入口地址，这个地址存放的必定是指令</em><br><em>2.从入口地址取指令，然后根据指令周期的阶段，当进行到执行周期，取的<br>一定是数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172122269.png" alt="image.png"></p><p><em>开中断是指 允许中断</em><br><em>取完空操作指令，PC照样会+1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172154839.png" alt="image.png"></p><p><em>中断周期的前一个周期—&gt;执行周期</em><br><em>中断周期的后一个周期—&gt;下一条指令的取指周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172159620.png" alt="image.png"></p></blockquote><h3 id="数据通路的功能和基本概念习题"><a href="#数据通路的功能和基本概念习题" class="headerlink" title="数据通路的功能和基本概念习题"></a>数据通路的功能和基本概念习题</h3><blockquote><p><em>数据通路是指数据不同功能部件之间传送的路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172205638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172227023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172232124.png" alt="image.png"></p><p><em>CPU内部单总线结构—由于只有一条数据总线，所以切换时钟周期T(节拍时)<br>就需要先释放上一个时钟周期里面微操作所占用的数据通路，才能开始下一个微操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181557135.png" alt="image.png"></p><p><em>举例：一整个完整管道系统(管道+阀门) ，就是一个数据通路(电路+部件)<br>水管就是电路，阀门就是部件(不能存储，是时序逻辑元件)</em><br><em>部件 分为 组合逻辑元件(不能存储，也称操作元件) 和 时序逻辑元件(能存储，也称状态元件)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181603679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181612657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181621484.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181630451.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181631386.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181716181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181719840.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181720622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182056692.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182057675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182058005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182102014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182117697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182112370.png" alt="image.png"></p><p><em>1.该指令，是变址寻址, X是变址寄存器XR ,D是形式地址，所以有效地址是(X)+D,那么，得到有效地址只有1个，也就意味着操作数只有一个，所以是隐含了一个操作数在ACC里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182129217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182147615.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182151182.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182158118.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191121774.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191123723.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191124619.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191128718.png" alt="image.png"></p><p><em>答题要爽快</em><br><em>1.题中M(MAR)-&gt;MDR ,外部总线数据输入到MDR控制信号MDRinE ,图中没有给出，可以不写<br>2.IR，FR(状态字寄存器)都与CU输入端相连<br>3.rd,目的寄存器，rs，源寄存器<br>4.题中声明了数据送到MDR需要5个时钟周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146369.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146756.png" alt="image.png"></p></blockquote><h3 id="控制器的功能和工作原理-1"><a href="#控制器的功能和工作原理-1" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191433576.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191444240.png" alt="image.png"></p><p><em>1.缩短微指令长度，自然可以减少从CM中取指的次数，加快速度</em><br><em>2.增大控制存储器CM容量，会增加对CPU占用率，所以应该是减少CM容量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191447484.png" alt="image.png"></p><p><em>1.控制存储器CM是用的ROM芯片，只读存储器，非易失性存储器，里面的微指令是出厂就设定好的</em><br><em>2.主存是用的DRAM芯片，易失性存储器，关机数据就清空</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191454136.png" alt="image.png"></p><p><em>访存延迟比电路延迟大很多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191502908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191504073.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191550336.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191556007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191627070.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191628996.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191633814.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191636725.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191923360.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191928517.png" alt="image.png"></p><p><em>对于汇编语言程序员可见的寄存器，即是在汇编语言中能出现的寄存器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191930184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191936535.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191952494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191958740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192104787.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192107103.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192115047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192116029.png" alt="image.png"></p></blockquote><h3 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192120189.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192123119.png" alt="image.png"></p></blockquote><h3 id="指令流水线习题"><a href="#指令流水线习题" class="headerlink" title="指令流水线习题"></a>指令流水线习题</h3><blockquote><p><em>流水CPU—时间并行技术<br>RSIC采用的一定是流水CPU，部分CSIC也采用流水CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202134527.png" alt="image.png"></p><p><em>超标量流水线—空间换时间，配置多个相同功能部件，同时处理相同任务</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202140283.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202147772.png" alt="image.png"></p><p><em>m段流水线稳定时，是指，第一条指令完全从头到尾执行完，之后，每隔一个时钟周期，都会有一条指令执行结束，这样的状态就是稳定状态<br>稳定状态平均下来，一个时钟周期，完成一条任务,CPU吞吐能力(单位时间内流水线完成的任务数量)=1条/T ; 等效于m个并行部件CPU吞吐能力</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211139928.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211150637.png" alt="image.png"><br><em>度为4，表示处理机能并行处理4条指令(超标量流水技术)，那么处理20条指令，相当于普通流水线处理20/4=5条指令，过程与上面一致</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211153372.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211200981.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211444035.png" alt="image.png"></p><p><em>1.加入空操作，可以解决所有类型的指令流水线影响因素(结构、数据、控制)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211450269.png" alt="image.png"></p><p><em>数据相关流水线冲突有:<br>RAW(写后读冲突)：在前一条指令还没有写回数据，后面就开始读取该数据<br>WAR(读后写冲突)：在前一条指令对数据还没有开始读，后一条指令就开始写<br>WAW(写后写冲突)：后续指令比前面的指令先进行写数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211512534.png" alt="image.png"></p><p><em>要实现流水线必须将每个功能段时间取为一样长,且按照最长的功能段为标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211513312.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211529027.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211532867.png" alt="image.png"></p><p><em>动态调度技术，就是将能够并行执行，不会造成数据冲突的指令安排调度在同一个周期内完成</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211540142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211603920.png" alt="image.png"></p><p><em>流水段寄存器延时—指令功能段与段(部件与部件)之间需要通过将之前的数据放到寄存器里，传递给后面的功能段(部件)，这里存在一些时间延迟，所以考虑CPU时钟周期，不仅要以最长时间为标准，还需要加上寄存器延时</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211606983.png" alt="image.png"></p><p><em>1.单周期CPU—指令周期不细化分为取指、间址、执行、等等周期，理想状态1个时钟周期就可执行一条指令<br>2.多周期CPU—指令周期细分为取指、间址、执行、中断等多个机器周期，每个机器周期都需要多个时钟周期<br>3.基本流水线—理想状态下，稳定后，隔1个时钟周期就能完成一条指令<br>4.超标量流水线—理想状态下，稳定后，隔一个时钟周期，能完成多条指令，CPI&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211617413.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211635734.png" alt="image.png"></p><p><em>画出流水线时空图、非流水线时空图、指令周期流程图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211700005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211644593.png" alt="image.png"></p><p><em>画出流水线功能段结构图、指令执行过程流水线的时空图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211658332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211659606.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211942581.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211944729.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211948548.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211951115.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212046439.png" alt="image.png"></p><p><em>（1）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212115428.png" alt="image.png"><br><em>（2）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212123922.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212120953.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212127310.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212150355.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159175.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159029.png" alt="image.png"><br><em>（3）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212206954.png" alt="image.png"></p></blockquote><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151633335.png" alt="image.png"></p><h2 id="总线的概念与分类"><a href="#总线的概念与分类" class="headerlink" title="总线的概念与分类"></a>总线的概念与分类</h2><h3 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151634177.png" alt="image.png"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151641836.png" alt="image.png"></p><h4 id="按数据传输格式"><a href="#按数据传输格式" class="headerlink" title="按数据传输格式"></a>按数据传输格式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151644599.png" alt="image.png"></p><h4 id="按总线功能"><a href="#按总线功能" class="headerlink" title="按总线功能"></a>按总线功能</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151646654.png" alt="image.png"></p><blockquote><p><em>重点介绍系统总线- 单总线结构</em></p><p><em>1.单总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151655545.png" alt="image.png"><br><em>2.双总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151701271.png" alt="image.png"></p><p><em>3.三总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151821115.png" alt="image.png"></p><p><em>4.四总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151822640.png" alt="image.png"></p></blockquote><h4 id="按时序控制方式"><a href="#按时序控制方式" class="headerlink" title="按时序控制方式"></a>按时序控制方式</h4><blockquote><p><em>略</em></p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151648934.png" alt="image.png"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p>&gt;<br><em>1.总线的传输周期（总线周期）<br>2.总线时钟周期<br>3.总线的工作频率<br>4.总线的时钟频率<br>5.总线宽度<br>6.总线带宽<br>7.总线复用<br>8.信号线数</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151833607.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834590.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834082.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151838059.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151844178.png" alt="image.png"></p><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg&quot; alt=&quot;白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Telegram</title>
    <link href="https://fqzs.netlify.app/undefined/fd45428c.html"/>
    <id>https://fqzs.netlify.app/undefined/fd45428c.html</id>
    <published>2023-04-28T18:47:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用bot&quot;&gt;&lt;a href=&quot;#常用bot&quot; class=&quot;headerlink&quot; title=&quot;常用bot&quot;&gt;&lt;/a&gt;常用bot&lt;/h1&gt;&lt;p&gt;&lt;code&gt;@SMS24.me&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plainte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python安装</title>
    <link href="https://fqzs.netlify.app/undefined/ae5c380e.html"/>
    <id>https://fqzs.netlify.app/undefined/ae5c380e.html</id>
    <published>2023-04-14T18:11:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg" alt="绘梨衣壁纸_彼岸壁纸.jpg"></p><h1 id="配置python"><a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><hr><ul><li><code>下载好python环境，将文件夹配置到环境变量当中</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355861.png" alt="image.png"></li></ul><ul><li><code>CMD输入python查看版本信息，若显示说明配置成功</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355755.png" alt="image.png"></li></ul><ul><li><code>若不显示，打开CMD窗口，where python查看python安装位置 path查看环境变量配置</code></li><li><code>不显示，而是打开微软商店，需要将变量中的python移到Microsoft上方,或者删除Microsoft环境变量</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355535.png" alt="image.png"></li></ul><h1 id="添加pip"><a href="#添加pip" class="headerlink" title="添加pip"></a>添加pip</h1><hr><p><strong>pip</strong>是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包</p><ul><li>将图中<code>\python311\Script</code>配置到环境变量当中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355943.png" alt="image.png"></li></ul><ul><li><code>查看配置是否成功</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure></li></ul><h1 id="最便捷方式"><a href="#最便捷方式" class="headerlink" title="最便捷方式"></a>最便捷方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装python后，install前勾选pip to path</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg&quot; alt=&quot;绘梨衣壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置python&quot;&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://fqzs.netlify.app/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CMD命令</title>
    <link href="https://fqzs.netlify.app/undefined/3e5cd712.html"/>
    <id>https://fqzs.netlify.app/undefined/3e5cd712.html</id>
    <published>2023-04-12T23:12:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg" alt="可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="调出远程桌面控制"><a href="#调出远程桌面控制" class="headerlink" title="调出远程桌面控制"></a>调出远程桌面控制</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><p><code>输入ip地址</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352256.png" alt="image.png"></p><h1 id="查看连接过的wifi密码"><a href="#查看连接过的wifi密码" class="headerlink" title="查看连接过的wifi密码"></a>查看连接过的wifi密码</h1><hr><p><code>1.查看历史所有wifi</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure></p><p><code>2.查看指定wifi的密码</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile name=&quot;wifi名&quot; key=clear</span><br></pre></td></tr></table></figure></p><h1 id="查询本机当前ip地址"><a href="#查询本机当前ip地址" class="headerlink" title="查询本机当前ip地址"></a>查询本机当前ip地址</h1><hr><ul><li><code>查看当前局域网ip和其他信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353460.png" alt="image.png"></li></ul><ul><li><code>查看更详细信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353598.png" alt="image.png"></li></ul><ul><li><code>查看当前外网地址</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L ip.tool.lu</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353405.png" alt="image.png"></li></ul><h1 id="ping检测ip地址或服务器网络情况"><a href="#ping检测ip地址或服务器网络情况" class="headerlink" title="ping检测ip地址或服务器网络情况"></a>ping检测ip地址或服务器网络情况</h1><hr><ul><li><code>短暂监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353128.png" alt="image.png"></li></ul><ul><li><code>持续监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名) -t</span><br></pre></td></tr></table></figure></li></ul><h1 id="调出资源监测器"><a href="#调出资源监测器" class="headerlink" title="调出资源监测器"></a>调出资源监测器</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfmon.msc</span><br></pre></td></tr></table></figure><p><code>监测磁盘、网络、CPUz占用率</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353676.png" alt="image.png"></p><h1 id="查看电脑当前所有用户"><a href="#查看电脑当前所有用户" class="headerlink" title="查看电脑当前所有用户"></a>查看电脑当前所有用户</h1><hr><p><code>查看用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354885.png" alt="image.png"></p><p><code>删除用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user 名字 /del</span><br></pre></td></tr></table></figure></p><h1 id="修复丢失或损坏的系统文件"><a href="#修复丢失或损坏的系统文件" class="headerlink" title="修复丢失或损坏的系统文件"></a>修复丢失或损坏的系统文件</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具可以允许用户扫描所有受保护的系统文件，并且检查系统文件的完整性，然后恢复Windows损坏的系统文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg&quot; alt=&quot;可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="cmd" scheme="https://fqzs.netlify.app/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>C语言(三)</title>
    <link href="https://fqzs.netlify.app/undefined/1db5c403.html"/>
    <id>https://fqzs.netlify.app/undefined/1db5c403.html</id>
    <published>2023-04-10T21:42:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg" alt="北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jpg"></p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="补码解析"><a href="#补码解析" class="headerlink" title="补码解析"></a>补码解析</h2><hr><ul><li><code>补码</code>：计算机只能加法运算<code>2+(-5)</code>,所以需要补码，补码大小是<code>原码取反+1</code></li><li><p><code>原码</code>：补码取反+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0101     //5的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5    fffffffb </span><br></pre></td></tr></table></figure><p><code>由于X8架构采用的是小端存储</code>：低字节在前(低地址)，高字节在后(高地址) —&gt; <code>fbffffff</code></p></li><li><p><code>补码原码相加</code>：对应位置相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010     //2的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5 </span><br><span class="line"></span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1101     //补码 -3 =2+(-5)  --&gt;依次相加</span><br></pre></td></tr></table></figure></li><li><p>对于有符号数，最高位为1，就是负数</p></li></ul><h2 id="整型不同类型"><a href="#整型不同类型" class="headerlink" title="整型不同类型"></a>整型不同类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">整型类型</th><th style="text-align:center">符号</th><th style="text-align:center">字节</th><th style="text-align:center">整型数范围</th></tr></thead><tbody><tr><td style="text-align:left">基本整型</td><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31~(2^31-1)</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15~(2^15-1)</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:center">long</td><td style="text-align:center">(32位)4;(64位)8</td><td style="text-align:center">-2^31~(2^31-1)或-2^63~(-2^63-1)</td></tr><tr><td style="text-align:left">无符号整型</td><td style="text-align:center">unsigned int</td><td style="text-align:center">4</td><td style="text-align:center">0~2^32-1</td></tr><tr><td style="text-align:left">无符号短整型</td><td style="text-align:center">unsigned short</td><td style="text-align:center">2</td><td style="text-align:center">0~2^16-1</td></tr><tr><td style="text-align:left">无符号长整型</td><td style="text-align:center">unsigned long</td><td style="text-align:center">(32位)4;(62位)8</td><td style="text-align:center">0~(2^32-1)或0~(-2^64-1)</td></tr></tbody></table></div><ul><li><code>有符号数</code>：最高位只表示正负，不代表大小</li><li><code>无符号数</code>：最高位代表大小，不表示正负</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short最小数字：</span><br><span class="line">1000 0000 0000 0000  //补码 -32768 </span><br><span class="line">1000 0000 0000 0000  //原码  32768</span><br></pre></td></tr></table></figure><h2 id="溢出解析"><a href="#溢出解析" class="headerlink" title="溢出解析"></a>溢出解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">32767</span>;   <span class="comment">//01111 1111 1111 1111     32767</span></span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);  <span class="comment">//10000 0000 0000 0000    -32768 </span></span><br><span class="line"><span class="comment">//解决办法是用更大的空间存储</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=a+<span class="number">1</span>;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304111919441.png" alt="image.png"></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><h3 id="浮点数IEE754标准解析"><a href="#浮点数IEE754标准解析" class="headerlink" title="浮点数IEE754标准解析"></a>浮点数IEE754标准解析</h3><hr><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>格式</th><th>SEEEEEEE</th><th>EMMMMMMM</th><th>MMMMMMMM</th><th>MMMMMMMM</th></tr></thead><tbody><tr><td>二进制</td><td>01000000</td><td>10010000</td><td>00000000</td><td>00000000</td></tr><tr><td>十六进制</td><td>40</td><td>90</td><td>00</td><td>00</td></tr></tbody></table></div><ul><li><code>S</code>：符号位1表示正，0表示负</li><li><code>E</code>：指数部分，(指数部分的值规定只能是1到254，不能是全0，全1)，指数部分运算前都要减去127(这是EEE-754的规定)，因为还要表示负指数。这里的<code>10000001</code>转换为十进制数为129,129-127=2，即实际指数部分为2.<code>表示小数部分小数点往后移两位</code></li><li><code>M</code>：小数部分 <code>0010000 00000000 00000000</code> 左边默认省略了一个1，应该是<code>1.0010000 00000000 00000000(二进制数)</code></li></ul><blockquote><p>分析上面浮点数<br>S=0，表示正数<br>E=2^0+2^7-127=129-127=2,表示小数点向后移动两位<br>M=<code>0010000 00000000</code> ，前面默认有个1，<code>1.0010000 00000000 00000000</code><br>因为E，M小数点向后移动两位，<code>100.10000 00000000 00000000</code> =2^2 + 2^-1 =4.5</p></blockquote><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><hr><ul><li>浮点型变量分为单精度（float）型、双精度（double）型</li><li>float的数值范围：<code>2^-126~2^127</code>(因为指数部分值1~254，再减去127，得到的-126~127，也就是二进制位数小数点后126位，到小数点前127位)</li><li>float的精度：<code>6~7位</code></li><li>double数值范围：<code>2^-1022~2^1023</code></li><li>double的精度：<code>15~16位</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们赋给a的值为1.23456789e10,加20后，应该得到的值为1.234567892e10,</span><br><span class="line">但b输出结果却是b=12345678848.000000,变得更小了。我们将这种现象称为精度丢失，因</span><br><span class="line">为float型数据能够表示的有效数字为7位，最多只保证1.234567e10的正确性，要使结果正确，</span><br><span class="line">就需要把a和b均改为double型，因为double可以表示的精度为15~16位。</span><br></pre></td></tr></table></figure><code>int 溢出 可以考虑改用double存储</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg&quot; alt=&quot;北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jp</summary>
      
    
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git远程仓库</title>
    <link href="https://fqzs.netlify.app/undefined/3f8bae1e.html"/>
    <id>https://fqzs.netlify.app/undefined/3f8bae1e.html</id>
    <published>2023-04-09T18:20:00.000Z</published>
    <updated>2023-08-09T15:04:27.629Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg" alt="Uploading file...0i2ar"></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>当安装Git后首先要做的事情是设置用户名称和emailt地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息</p><ul><li><code>git config --global user.name &quot;itcast&quot;</code></li><li><code>git config --global user.email &quot;hello@iteast.cn&quot;</code></li></ul><p>查看用户信息</p><ul><li><code>git config --global user.name</code></li><li><code>git config --global user.email</code></li></ul><h1 id="获取本地仓库及其基础操作指令"><a href="#获取本地仓库及其基础操作指令" class="headerlink" title="获取本地仓库及其基础操作指令"></a>获取本地仓库及其基础操作指令</h1><ul><li>初始化仓库文件夹：<code>git init</code></li><li><code>git status</code>：查看的修改的状态（暂存区、工作区）</li><li><code>git add 单个文件名|通配符.</code>：工作区-&gt;暂存区</li><li><code>git commit -m &#39;注释内容&#39;</code>：暂存区-&gt;本地仓库的当前分支</li><li><code>git-log</code>：查看提交日志</li><li><code>git reset --hard commitID</code>：版本回退；commitID 可以使用 git-log 或 git log 指令查看</li><li><code>git push -f -u origin master</code>：把修改推送至远程</li><li><code>git branch</code>：查看本地分支</li><li><code>git branch 分支名</code>：创建本地分支</li><li><code>git checkout 分支名</code>：切换本地分支</li><li><code>git merge 分支名称</code>：一个分支上的提交合并到另一个分支上</li><li><code>git branch -d 分支名</code>：删除分支，不能删除当前分支<h1 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h1></li></ul><hr><ul><li>生成SSH公钥：<code>ssh-keygen -t rsa</code>   不断回车; 如果公钥已经存在，则自动覆盖</li><li>获取公钥：<code>cat ~/.ssh/id_rsa.pub</code></li><li>公钥获取后，将其添加到github仓库设置中，以获取推送权限</li><li>验证是否配置成功: <code>ssh-T:git@github.com</code></li></ul><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><hr><ul><li>命令：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354039.png" alt="image.png"></li></ul></li></ul><h1 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h1><hr><ul><li>命令：<code>git remote</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354389.png" alt="image.png"></li></ul><h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><hr><ul><li>命令：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>当前分支已经和远端分支关联，则可以省略分支名和远端名<code>git push</code></li><li><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<br><code>git push --set-upstream origin master</code></li></ul><h1 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h1><hr><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354898.png" alt="image.png"></li></ul><h1 id="从远程仓库抓取和拉取"><a href="#从远程仓库抓取和拉取" class="headerlink" title="从远程仓库抓取和拉取"></a>从远程仓库抓取和拉取</h1><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code> </li><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li><p>如果不指定远端名称和分支名，则抓取所有分支。</p></li><li><p>拉取 命令：<code>git pull [remote name] [branch name]</code></p></li><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul><h1 id="其他基础命令"><a href="#其他基础命令" class="headerlink" title="其他基础命令"></a>其他基础命令</h1><h2 id="查看当前仓库大小"><a href="#查看当前仓库大小" class="headerlink" title="查看当前仓库大小"></a>查看当前仓库大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354114.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg&quot; alt=&quot;Uploading file...0i2ar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本</summary>
      
    
    
    
    
    <category term="git" scheme="https://fqzs.netlify.app/tags/git/"/>
    
  </entry>
  
</feed>
