<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风起之时</title>
  
  
  <link href="https://fqzs.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://fqzs.netlify.app/"/>
  <updated>2023-07-15T05:01:46.387Z</updated>
  <id>https://fqzs.netlify.app/</id>
  
  <author>
    <name>风起之时</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高数强化</title>
    <link href="https://fqzs.netlify.app/undefined/60f235f4.html"/>
    <id>https://fqzs.netlify.app/undefined/60f235f4.html</id>
    <published>2023-07-05T20:51:00.000Z</published>
    <updated>2023-07-15T05:01:46.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="考试内容要点精讲"><a href="#考试内容要点精讲" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h2><h3 id="函数的概念及常见函数"><a href="#函数的概念及常见函数" class="headerlink" title="函数的概念及常见函数"></a>函数的概念及常见函数</h3><blockquote><p>略</p></blockquote><h3 id="函数的性态"><a href="#函数的性态" class="headerlink" title="函数的性态"></a>函数的性态</h3><h4 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a><em>单调性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052057975.png" alt="image.png"></p><h4 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a><em>奇偶性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052058171.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100778.png" alt="image.png"></p><h4 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a><em>周期性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052059224.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052106503.png" alt="image.png"></p><h4 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a><em>有界性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052105228.png" alt="image.png"></p><h2 id="常考题型方法与技巧"><a href="#常考题型方法与技巧" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h2><h3 id="题型1-复合函数"><a href="#题型1-复合函数" class="headerlink" title="题型1-复合函数"></a>题型1-复合函数</h3><h3 id="题型2-函数性态"><a href="#题型2-函数性态" class="headerlink" title="题型2-函数性态"></a>题型2-函数性态</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052117557.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052138255.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052155476.png" alt="image.png"></p><h1 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h1><h2 id="考试内容要点精讲-1"><a href="#考试内容要点精讲-1" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h2><h3 id="极限概念"><a href="#极限概念" class="headerlink" title="极限概念"></a>极限概念</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061313246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061315178.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061326428.png" alt="image.png"></p><blockquote><p><em>需要分左右极限求极限的三种问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061328805.png" alt="image.png"></p><h3 id="极限性质"><a href="#极限性质" class="headerlink" title="极限性质"></a>极限性质</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061341030.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061343978.png" alt="image.png"></p><h3 id="极限存在准则"><a href="#极限存在准则" class="headerlink" title="极限存在准则"></a>极限存在准则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061347339.png" alt="image.png"></p><h3 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061348994.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061351785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061353923.png" alt="image.png"></p><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061402353.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061404007.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061408279.png" alt="image.png"></p><h2 id="常考题型方法及技巧"><a href="#常考题型方法及技巧" class="headerlink" title="常考题型方法及技巧"></a>常考题型方法及技巧</h2><h3 id="极限的概念性质及存在准则"><a href="#极限的概念性质及存在准则" class="headerlink" title="极限的概念性质及存在准则"></a>极限的概念性质及存在准则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061417690.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061426091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061429689.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061438026.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061539946.png" alt="image.png"></p><h3 id="求极限"><a href="#求极限" class="headerlink" title="求极限"></a>求极限</h3><h4 id="1-利用有利运算法则求极限"><a href="#1-利用有利运算法则求极限" class="headerlink" title="1.利用有利运算法则求极限"></a>1.利用有利运算法则求极限</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061545829.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061545550.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061552514.png" alt="image.png"></p><h4 id="2-基本极限求极限"><a href="#2-基本极限求极限" class="headerlink" title="2.基本极限求极限"></a>2.基本极限求极限</h4><h3 id="确定极限式中参数"><a href="#确定极限式中参数" class="headerlink" title="确定极限式中参数"></a>确定极限式中参数</h3><h3 id="无穷小量阶的比较"><a href="#无穷小量阶的比较" class="headerlink" title="无穷小量阶的比较"></a>无穷小量阶的比较</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;考试内容要点精讲&quot;&gt;&lt;a href=&quot;#考试内容要点精讲&quot; class=&quot;headerlink&quot; title=&quot;考试内容要点精讲&quot;</summary>
      
    
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/categories/%E9%AB%98%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线代</title>
    <link href="https://fqzs.netlify.app/undefined/43e039bd.html"/>
    <id>https://fqzs.netlify.app/undefined/43e039bd.html</id>
    <published>2023-06-30T12:24:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-行列式的定义与性质"><a href="#01-行列式的定义与性质" class="headerlink" title="01-行列式的定义与性质"></a>01-行列式的定义与性质</h1><h2 id="行列式背景"><a href="#行列式背景" class="headerlink" title="行列式背景"></a>行列式背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于一个二元方程组，每次都要求解就特别麻烦。</span><br><span class="line">为了更加快速的找到方程的解，人们寻找规律，发现解的通式如下</span><br><span class="line">但是通式难以记忆，所以将这种计算规律用行列式表示，规定行列式计算方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301231233.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301500559.png" alt="image.png"></p><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论:一个排列中任意的两个元素对换，排列的奇偶性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301509795.png" alt="image.png"></p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行列式是一个数</span><br><span class="line">行列式计算方法是：</span><br><span class="line">1.取数相乘: 取n个不同行不同列的数 相乘 --&gt; 所以n!种取法，就有n!项</span><br><span class="line">2.冠以符号: 每一项(n个数相乘),将里面的元素，按列排好，然后数 列序号的逆序数τ，</span><br><span class="line">-(1)^τ</span><br><span class="line">3.全部相加: 将所有项n!项相加   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301521315.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按照行列式定义，因为行列式的每一项都是有不同行不同列的n个数相乘</span><br><span class="line">假如取1行1列的数--&gt;x</span><br><span class="line">那么画个十字线，十字线上的数都不能再取</span><br><span class="line">题目要求行列式结果中x^3的系数</span><br><span class="line"></span><br><span class="line">排除法:</span><br><span class="line">假如先取1，画十字线，发现其他行最多只能取到两个x，构不成x^3</span><br><span class="line">假如先取2，同理不行</span><br><span class="line">所以只能取x或x+3</span><br><span class="line"> 取x+3,只有一种情况，可行</span><br><span class="line"> 取x,第二行只能取x,第三行只能取x,第四行只能取x，那么x^4不符合。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301535080.png" alt="image.png"></p><blockquote><p>重要的特殊行列式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt="image.png"></p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a><em>转置</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301557471.png" alt="image.png"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><em>交换</em></h3><p><strong>交换一行实际上是对每一项的逆序数发生改变，导致全部项的正负性改变</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301600178.png" alt="image.png"></p><h3 id="倍乘"><a href="#倍乘" class="headerlink" title="倍乘"></a><em>倍乘</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301619501.png" alt="image.png"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a><em>拆分</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301620199.png" alt="image.png"></p><blockquote><p><em>倍加</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301623438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301627820.png" alt="image.png"></p><hr><h1 id="02-行列式的计算与代数余子式"><a href="#02-行列式的计算与代数余子式" class="headerlink" title="02-行列式的计算与代数余子式"></a>02-行列式的计算与代数余子式</h1><h2 id="分块矩阵的行列式计算"><a href="#分块矩阵的行列式计算" class="headerlink" title="分块矩阵的行列式计算"></a>分块矩阵的行列式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301645404.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301654171.png" alt="image.png"></p><h2 id="行列式按行-列-展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h2><h3 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">余子式M 是特殊的情况，恰好第一行第一个数不是0,该行其余都是0,行列式的值=a11xM11。</span><br><span class="line">代数余子式A是讨论,不是特殊情况时，要考虑符号问题。</span><br><span class="line">就是不断的交换将aij逐行逐列的移到第一个的位置(交换一次改变一次正负号),aij列需要j次</span><br><span class="line">交换，行需要i次交换。所以符号-(1)^i+j x Mij = Aij </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301724746.png" alt="image.png"></p><blockquote><p><em>“么”型通法，按横展开</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301750483.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302120137.png" alt="Uploading file...havyy"></p><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302138234.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302217822.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302141433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302143275.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302148080.png" alt="image.png"></p><h2 id="范德门行列式"><a href="#范德门行列式" class="headerlink" title="范德门行列式"></a>范德门行列式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像这种第一行(或列)是1，第二行(列)是x1,x2..xn;第三行(列)是x1^2,x2^2..xn^2;...第n行(列)是...</span><br><span class="line">这种形式的就是范德蒙行列式，它的值有如下规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302222870.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.加边法</span><br><span class="line">与范德蒙行列式相似的，可以加边使其成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302228111.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.提公因子</span><br><span class="line">每一行提一个公因子，使得第一列的全为1，成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302230815.png" alt="image.png"></p><hr><h1 id="03矩阵及其运算"><a href="#03矩阵及其运算" class="headerlink" title="03矩阵及其运算"></a>03矩阵及其运算</h1><h2 id="矩阵及分块的概念"><a href="#矩阵及分块的概念" class="headerlink" title="矩阵及分块的概念"></a>矩阵及分块的概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矩阵的提出主要源自于数学中的三个问题:</span><br><span class="line">1.线性变换:用于表示未知数的变换关系</span><br><span class="line">2.线性方程组:用于表示方程组各个未知数的系数</span><br><span class="line">3.二次型:方便表示二次型，x^2,y^2,xy,出现的个数</span><br></pre></td></tr></table></figure><blockquote><p><em>数表来源</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302253439.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302255227.png" alt="image.png"></p><blockquote><p><em>特殊矩阵及分块矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302314484.png" alt="image.png"></p><h2 id="矩阵及分块矩阵的计算"><a href="#矩阵及分块矩阵的计算" class="headerlink" title="矩阵及分块矩阵的计算"></a>矩阵及分块矩阵的计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">矩阵加减法要求</span><br><span class="line">1.同型矩阵，m,n相同</span><br><span class="line">2.对应每个元素相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302321222.png" alt="image.png"></p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302346561.png" alt="image.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵乘法，实质是将由x-&gt;y的线性变换通过y-&gt;z的变化 转到x-&gt;z的线性变换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302349135.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011521217.png" alt="image.png"></p><hr><blockquote><p><em>对角矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011524350.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011527225.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵练习</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排列与组合区别在于，组合不要求内部顺序，所以要除以顺序个数</span><br><span class="line"></span><br><span class="line">将A矩阵拆分为--&gt; 单位E矩阵 + “坍缩矩阵”B </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011532335.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011534905.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011535161.png" alt="image.png"></p><blockquote><p><em>成比例矩阵的幂</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每行成比例的矩阵，可以写为如下</span><br><span class="line">成比例矩阵n次幂就可以拆为如下</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011559846.png" alt="image.png"></p><blockquote><p><em>与伴随矩阵相乘</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AxA* --&gt; 乘错行导致只有对应行的与其对应的代数余子式相乘结果才为|A|--&gt;也就是只有对角线上是|A| </span><br><span class="line"></span><br><span class="line">为什么代数余子式，乘错行会=0？ </span><br><span class="line">因为,乘错行，可以看做求一个具有两行相元素的行列式的值--&gt;两行相同元素的行列式=0</span><br><span class="line"></span><br><span class="line">为什么两行相同元素的行列式值是0?</span><br><span class="line">因为，利用交换一次行,矩阵正负性改变,两行相同交换后不变，但正负性改变，那么只能是0</span><br><span class="line"></span><br><span class="line">为什么交换两行元素，矩阵正负性要改变?</span><br><span class="line">因为，交换两行之后，导致每一项列排序发生一次交换--&gt;逆序数奇偶性变化--&gt;正负性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011615201.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011741250.png" alt="image.png"></p><hr><h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011730342.png" alt="image.png"></p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743537.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743180.png" alt="image.png"></p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵定义"><a href="#逆矩阵定义" class="headerlink" title="逆矩阵定义"></a><em>逆矩阵定义</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011859511.png" alt="image.png"></p><h3 id="逆矩阵充要条件"><a href="#逆矩阵充要条件" class="headerlink" title="逆矩阵充要条件"></a><em>逆矩阵充要条件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011901315.png" alt="image.png"></p><blockquote><p><em>原矩阵行列式=0 =&gt;伴随矩阵行列式=0</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011907635.png" alt="image.png"></p><blockquote><p><em>求二阶矩阵的逆矩阵方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011939266.png" alt="image.png"></p><blockquote><p><em>分块矩阵求逆矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011948103.png" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012256386.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求可对角化的矩阵的幂--&gt;先将矩阵写为下列形式，然后相乘，中间可以相互抵消为E(单位矩阵)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012257657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012300822.png" alt="image.png"></p><h2 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012305438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012312191.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012314168.png" alt="image.png"></p><hr><h1 id="04初等变换与初等矩阵"><a href="#04初等变换与初等矩阵" class="headerlink" title="04初等变换与初等矩阵"></a>04初等变换与初等矩阵</h1><h2 id="初等变换、矩阵的行阶梯、行最简、标准形"><a href="#初等变换、矩阵的行阶梯、行最简、标准形" class="headerlink" title="初等变换、矩阵的行阶梯、行最简、标准形"></a>初等变换、矩阵的行阶梯、行最简、标准形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">化为行阶梯型矩阵--&gt;自上而下化简</span><br><span class="line">化为最简型矩阵--&gt;自下而上化简</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012324531.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">矩阵A只进行行变换到B,称A与B 行等价</span><br><span class="line">矩阵A只进行列变换到B,称A与B 列等价</span><br><span class="line">如果即行又列，称A与B 等价 </span><br><span class="line"></span><br><span class="line">不管行等价，列等价，等价 --&gt;其秩都相等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012335843.png" alt="image.png"></p><h2 id="初等矩阵的定义性质"><a href="#初等矩阵的定义性质" class="headerlink" title="初等矩阵的定义性质"></a>初等矩阵的定义性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初等矩阵可以传递三种操作:</span><br><span class="line">1.交换: 左行右列 Eij --&gt;交换第i、j行(列)</span><br><span class="line">2.倍乘: 左行右列 Ei(k) --&gt; 第i行(列) 乘k倍</span><br><span class="line">3.倍加: 左行由列 Eij(k) --&gt; (左)将第i行加上j行的k倍;(右)将第j列加上第i行的k倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012358129.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307020005020.png" alt="image.png"></p><h2 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031442490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031446780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031452285.png" alt="image.png"></p><h2 id="可逆矩阵都可初等变换化为单位阵"><a href="#可逆矩阵都可初等变换化为单位阵" class="headerlink" title="可逆矩阵都可初等变换化为单位阵"></a>可逆矩阵都可初等变换化为单位阵</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031514917.png" alt="image.png"></p><h2 id="初等变换求逆矩阵-解可逆矩阵方程"><a href="#初等变换求逆矩阵-解可逆矩阵方程" class="headerlink" title="初等变换求逆矩阵-解可逆矩阵方程"></a>初等变换求逆矩阵-解可逆矩阵方程</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031520619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.A逆在左，行变换，所以可逆矩阵方程A,B要行摆放</span><br><span class="line">2.A逆在右，列变换，所以可逆矩阵方程A,B要列摆放</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031537723.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031547781.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031553549.png" alt="image.png"></p><hr><h1 id="05-矩阵的秩与线性方程组"><a href="#05-矩阵的秩与线性方程组" class="headerlink" title="05-矩阵的秩与线性方程组"></a>05-矩阵的秩与线性方程组</h1><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="矩阵的秩的定义"><a href="#矩阵的秩的定义" class="headerlink" title="矩阵的秩的定义"></a>矩阵的秩的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初等变换不会改变秩的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031709329.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031717376.png" alt="image.png"></p><h3 id="行阶形求秩"><a href="#行阶形求秩" class="headerlink" title="行阶形求秩"></a>行阶形求秩</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031713196.png" alt="image.png"></p><h3 id="秩的结论"><a href="#秩的结论" class="headerlink" title="秩的结论"></a>秩的结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.矩阵的秩不会超过行数也不会超过列数，因为逆矩阵的秩就是阶梯个数，阶梯怎么画都不会   超过行和列</span><br><span class="line">2.转置矩阵的秩不变很好理解</span><br><span class="line">3.等价的矩阵秩一定相等--&gt;等价的矩阵实际就是在一个矩阵基础上经过若干初等变换得到的   两个矩阵，初等变换不会影响秩的大小</span><br><span class="line">4.P,Q可逆--&gt;P,Q是若干初等矩阵的乘积--&gt;相当于对A经过若干初等行变换+列变换--&gt;秩不变</span><br><span class="line">5.(A,B)矩阵的秩R(A,B)min/max --&gt; A,B都化为标准型之后，看斜对角线</span><br><span class="line">6.矩阵相加的秩，化标准型理解</span><br><span class="line">7.矩阵相乘的秩，化标准型理解(特殊:矩阵与其转置矩阵相乘，秩不变)</span><br><span class="line">8.两矩阵相乘为0矩阵--&gt;标准型中1刚好错开，那么R(A)+R(B)&lt;=n</span><br><span class="line">9....</span><br><span class="line">10....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031725785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031745903.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031749579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031751055.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031755979.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.R(Amxn) =n --&gt;列满秩 ;所以A的标准型是上面E,下面O ; --&gt; 标准型左边乘以可逆矩阵P(等效为若干初等变换) 得到A --&gt; A标准型=PA ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031800370.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031819833.png" alt="image.png"></p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><h3 id="解的判定"><a href="#解的判定" class="headerlink" title="解的判定"></a>解的判定</h3><blockquote><p><em>齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031839448.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031838230.png" alt="image.png"></p><hr><blockquote><p><em>非齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031850780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031852539.png" alt="image.png"></p><h3 id="具体方程组的求解"><a href="#具体方程组的求解" class="headerlink" title="具体方程组的求解"></a>具体方程组的求解</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031859530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031900387.png" alt="image.png"></p><h1 id="06-向量组的线性相关性"><a href="#06-向量组的线性相关性" class="headerlink" title="06-向量组的线性相关性"></a>06-向量组的线性相关性</h1><h2 id="向量及向量空间"><a href="#向量及向量空间" class="headerlink" title="向量及向量空间"></a>向量及向量空间</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-行列式的定义与性质&quot;&gt;&lt;a href=&quot;#01-行列式的定义与性质&quot; class=&quot;headerlink&quot; title=&quot;01-行列式的定义与性质&quot;&gt;&lt;/a&gt;01-行列式的定义与性质&lt;/h1&gt;&lt;h2 id=&quot;行列式背景&quot;&gt;&lt;a href=&quot;#行列式背景&quot; c</summary>
      
    
    
    
    <category term="线代" scheme="https://fqzs.netlify.app/categories/%E7%BA%BF%E4%BB%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>百度网盘不限速下载</title>
    <link href="https://fqzs.netlify.app/undefined/d1267184.html"/>
    <id>https://fqzs.netlify.app/undefined/d1267184.html</id>
    <published>2023-06-18T11:35:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181136945.png" alt="image.png"></p><h2 id="打开解析网站"><a href="#打开解析网站" class="headerlink" title="打开解析网站"></a>打开解析网站</h2><p><a href="https://pan.qsbaidu.com/">点击跳转解析网站</a>（<a href="https://pan.qsbaidu.com/）。">https://pan.qsbaidu.com/）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181139806.png" alt="image.png"></p><p>点击解析分享链接后跳转该界面，点击下载按钮。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181141184.png" alt="image.png"></p><p>之后跳转该界面，推荐使用NDM下载器下载。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181142387.png" alt="image.png"></p><h2 id="NDM下载及配置"><a href="#NDM下载及配置" class="headerlink" title="NDM下载及配置"></a>NDM下载及配置</h2><p>1.官网<a href="http://www.neatdownloadmanager.com/index.php/en/">下载链接</a>（<a href="http://www.neatdownloadmanager.com/index.php/en/）">http://www.neatdownloadmanager.com/index.php/en/）</a></p><ol><li>初次使用要先配置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181147528.png" alt="image.png"></li></ol><p>3.复制上述用户代理名，打开NDM点击设置，将用户代理名填入默认用户代理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181148592.png" alt="image.png"></p><p>4.配置好后，点击新建，将之前的下载链接复制粘贴下载即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181150249.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建链接&quot;&gt;&lt;a href=&quot;#创建链接&quot; class=&quot;headerlink&quot; title=&quot;创建链接&quot;&gt;&lt;/a&gt;创建链接&lt;/h2&gt;&lt;p&gt;选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码&lt;br&gt;&lt;img src=&quot;https://cdn.jsdel</summary>
      
    
    
    
    <category term="百度网盘" scheme="https://fqzs.netlify.app/categories/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    
    
  </entry>
  
  <entry>
    <title>栈为什么从高地址往低地址分配内存</title>
    <link href="https://fqzs.netlify.app/undefined/e44ea15d.html"/>
    <id>https://fqzs.netlify.app/undefined/e44ea15d.html</id>
    <published>2023-06-14T23:19:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？</p><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>程序计数器(<code>Program Counter</code>，简称<code>PC</code>)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。</p><p>因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；</p><p>heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142320352.png" alt="image.png"></p><hr><h2 id="栈由高地址向低地址扩展的优点"><a href="#栈由高地址向低地址扩展的优点" class="headerlink" title="栈由高地址向低地址扩展的优点"></a>栈由高地址向低地址扩展的优点</h2><p><code>stack</code>从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142351623.png" alt="image.png"></p><p>并且<strong>这样设计可以使得堆和栈能够充分利用空闲的地址空间。</strong>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化</p><hr><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：x86，MIPS</li><li>主流2：自由选择：Arm（但个别指令仅支持向低）</li><li>罕见：向高地址扩展：PA-RISC，操作系统Multics</li><li>非主流：System z，栈是个链表[2]</li></ul><hr><h2 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h2><p><strong>1.栈内内存是连续分配</strong></p><pre><code>因位栈空间内存分配连续，如果给一个数组或对象分配内存，栈会优先选择还没有分配的最小的内存地址给数组，数组中的地址是从低地址到高地址依次分配。所以数组的第一个元素的起始地址就是给数组分配的最低地址</code></pre><p><strong>2.栈的栈顶指针ESP默认指向栈顶</strong></p><pre><code>对数组的访问一般都是对一个数组的起始地址进行操作，也就是说我们需要的是数组的起始地址-&gt;也就是低地址，由于栈顶指针默认指向的是栈顶元素，那么只能是栈顶指针指向低地址值--&gt;这样便于对数组的访问。如果栈还是采用从低地址到高地址的扩展，那么就不会默认指向数组的起始地址(数组指针)，不便于访问。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;p&gt;栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？&lt;/p&gt;
&lt;p&gt;计算机内存分了代码段（&lt;code&gt;.text&lt;/code&gt;段）、初始化的</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>LaTaX语言</title>
    <link href="https://fqzs.netlify.app/undefined/31c326ac.html"/>
    <id>https://fqzs.netlify.app/undefined/31c326ac.html</id>
    <published>2023-06-12T16:19:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><code>1.求和表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;n=0&#125;^&#123;\infty&#125;n$$</span><br><span class="line"></span><br><span class="line">其中，\sum表示求和符号，n表示要累加的变量，0表示起始索引，\infty表示末尾索引。所以，上述表达式表示了从0开始到正无穷的所有整数之和。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}n</script><hr><p><code>2.积分表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\int_&#123;-\pi&#125;^&#123;\pi&#125;f(x)dx$$</span><br><span class="line"></span><br><span class="line">其中，$\int$ 表示积分符号，$f(x)$ 表示要积分的函数，$dx$ 表示积分的变量（即积分变量），$-\pi$ 和 $\pi$ 分别表示积分的下限和上限。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(x)dx</script><hr><p><code>3.分式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;a&#125;&#123;b&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$a$ 表示分子，$b$ 表示分母。它表示了 $a$ 与 $b$ 之间的比率关系，也可以理解为 $a$ 中包含了 $b$ 的多少倍。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\frac{a}{b}</script><hr><p><code>4.下标</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$a_i$$</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$$x_&#123;i,j&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$i$ 和 $j$ 是变量的下标，它们用于表示该变量的某个特定元素。在第一个例子中，$a$ 中的 $i$ 表示 $a$ 数组中的第 $i$ 个元素；在第二个例子中，$x$ 中的 $i$ 和 $j$ 分别表示一个二维数组 $x$ 中的第 $i$ 行第 $j$ 列的元素。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">a_i</script><script type="math/tex; mode=display">x_{i,j}</script><hr><p><code>5.向量</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$\vec&#123;v&#125;$ 表示向量，“$$\begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$” 表示以列的形式表示的向量，$v_1$、$v_2$、$\ldots$、$v_n$ 是向量中的元素。如果向量是一个二维向量，那么它还可以写成如下形式：</span><br><span class="line"></span><br><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; x \\ y \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$x$ 和 $y$ 分别是二维向量 $\vec&#123;v&#125;$ 的 $x$ 和 $y$ 分量</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n\end{pmatrix}</script><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}</script><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;1.求和表达式&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="LaTax" scheme="https://fqzs.netlify.app/categories/LaTax/"/>
    
    
  </entry>
  
  <entry>
    <title>多地址指令实际访存次数</title>
    <link href="https://fqzs.netlify.app/undefined/7566551b.html"/>
    <id>https://fqzs.netlify.app/undefined/7566551b.html</id>
    <published>2023-06-10T10:44:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; class=&quot;headerlink&quot; title=&quot;指令&quot;&gt;&lt;/a&gt;&lt;code&gt;指令&lt;/code&gt;&lt;/h4&gt;&lt;p&gt;机器指令按照含有的地址数目可以分为1,2,3,4地址指令。&lt;br&gt;其中指令中存放的地址都是虚拟地址，不是实际物理地</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>english</title>
    <link href="https://fqzs.netlify.app/undefined/2c830200.html"/>
    <id>https://fqzs.netlify.app/undefined/2c830200.html</id>
    <published>2023-06-08T11:44:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a><strong>定语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a><strong>状语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a><strong>同位语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a><strong>插入语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p><h1 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conmence 毕业典礼、开始</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162327530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162328895.png" alt="image.png"></p><h2 id="句子之间的连接方式"><a href="#句子之间的连接方式" class="headerlink" title="句子之间的连接方式"></a>句子之间的连接方式</h2><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162329883.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162349412.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306170009789.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162352377.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162354284.png" alt="image.png"></p><h3 id="主从复合句"><a href="#主从复合句" class="headerlink" title="主从复合句"></a>主从复合句</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207495.png" alt="image.png"></p><h4 id="状语从句-副词性从句"><a href="#状语从句-副词性从句" class="headerlink" title="状语从句(副词性从句)"></a>状语从句(副词性从句)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207245.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181217682.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.It doesn&#x27;t feel like a human or democratic relationship,even if both sides</span><br><span class="line">benefit.</span><br><span class="line">即使双方都受益，也不是人与人之间平等的关系</span><br><span class="line"></span><br><span class="line">2.As the cost to everyone else has become clearer,politicians have begun to</span><br><span class="line">clamp down.</span><br><span class="line">因为每个人所承受的代价变得显而易见了，政客们已经开始施压了</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181225896.png" alt="image.png"></p><h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><h5 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">That the seas are being over fished has been known for years--&gt;主语从句</span><br><span class="line"></span><br><span class="line">--&gt;一般会改写为形式主语--&gt; it has been knows for years that...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181304536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181305134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181306845.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181312445.png" alt="image.png"></p><h5 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181441584.png" alt="image.png"></p><h5 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181444199.png" alt="image.png"></p><h5 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181449900.png" alt="image.png"></p><h5 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181601408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181608655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181612050.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181613273.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181619664.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181620104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181625756.png" alt="image.png"></p><h1 id="层次化阅读和主干隔离"><a href="#层次化阅读和主干隔离" class="headerlink" title="层次化阅读和主干隔离"></a>层次化阅读和主干隔离</h1><h2 id="层次化阅读法"><a href="#层次化阅读法" class="headerlink" title="层次化阅读法"></a>层次化阅读法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052224384.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042239593.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042240478.png" alt="image.png"></p><p><em>substance 物质  、clinical nutirtion 临床营养学 、utilize 利用 、distinct 明显的、essential 必要的 、agent 介质、constituent 组成部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042245516.png" alt="image.png"></p><h2 id="主干隔离法"><a href="#主干隔离法" class="headerlink" title="主干隔离法"></a>主干隔离法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052225973.png" alt="image.png"></p><blockquote><p><em>将主语与谓语连在一起读，中间部分调整语序</em></p></blockquote><p>*artisans 工匠、artists 艺术家、machanic 技工、establishment 机构、组织</p><p>The notion - 这个观念、这个想法</p><p>that learning should have in it an element of inspired play - 观念认为学习应该融入受启发的游戏元素</p><p>would seem - 似乎</p><p>to the greater part of the academic establishment - 对大部分有学术性的机构或组织(如学校、大学等)</p><p>merely silly - 只是一个愚蠢的想法*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052227844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052229938.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052236404.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052237748.png" alt="image.png"></p><h1 id="非谓语动词和独立主格结构"><a href="#非谓语动词和独立主格结构" class="headerlink" title="非谓语动词和独立主格结构"></a>非谓语动词和独立主格结构</h1><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060933764.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060942180.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060946157.png" alt="image.png"></p><h2 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h2><p><em>带有主语的非谓语动词</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060953217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060956043.png" alt="image.png"><br><em>Media 媒体 、epidemic 流行病、cigarette 香烟、liken 比作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061003195.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061007239.png" alt="image.png"></p><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061012037.png" alt="image.png"></p><blockquote><p><em>部分倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061019182.png" alt="image.png"></p><blockquote><p><em>完全倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061023671.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061046014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061049074.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061050328.png" alt="image.png"></p><h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061056945.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061107064.png" alt="image.png"></p><p><em>individual 个体 、maximaize 最大化、profits利润、coupled with 以及(相等于and)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061121649.png" alt="image.png"></p><h1 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061131321.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061130607.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061140766.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061141718.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061142254.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061148829.png" alt="image.png"></p><h1 id="实战解析"><a href="#实战解析" class="headerlink" title="实战解析"></a>实战解析</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061158889.png" alt="image.png"></p><p><em>imposter 冒牌者   、file(ing) cabinet  文件柜、 fraught 充满 、reconcile 调和、和解 、<br>designate 指定、指派(职务)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071032339.png" alt="image.png"></p><p><em>overwhelming 巨大到无法应付的。指某事物之多、之严重以至于无法有效应对。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071556623.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071614505.png" alt="image.png"></p><p><em>Come to a halt的含义是停止;停顿下来。<br>它表示某物停止了运动或工作。强调运动或行为的终止。<br>例句:<br>The car came to a sudden halt.<br>那辆车突然停了下来 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071621176.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071625167.png" alt="image.png"></p><p><em>quantum computers 量子计算机 、crack 破解、encryption加密</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071639372.png" alt="image.png"></p><p><em>mutually 互相、composed of 由..组成  、composed 镇定的，有条理的、simulate模拟<br>interactions 相互影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071727387.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071728023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071804873.png" alt="image.png"></p><hr><p>proportion 的意思是:</p><p>比例,部分,成比例</p><ol><li>proportion 指在整体中所占的百分比或比例。例如:</li></ol><ul><li><p>What proportion of your income do you spend on rent? 你的收入中有多大比例用于支付房租?</p></li><li><p>Only a small proportion of applicants are admitted to this school. 只有一小部分申请者能被这所学校录取。</p></li></ul><ol><li>proportion 也可以表示一个量与另一个量之间的比较关系,指成比例。例如:</li></ol><ul><li><p>Mix the ingredients in the proper proportion. 按正确的比例混合这些材料。</p></li><li><p>The model was built in exact proportion to the original building. 这个模型按原建筑的精确比例建造的。</p></li></ul><ol><li>proportion 还可以指大小、范围或重要性的程度。例如:</li></ol><ul><li><p>The cost overrun was of massive proportion. 造价超支的规模巨大。</p></li><li><p>An issue of such proportion requires careful thought. 这么重大的问题需要慎重考虑。</p></li></ul><p><strong>literacy 的意思是:</strong></p><p>识字能力,读写能力</p><p>literacy 指一个人阅读和写作的基本能力,特别是在 mother tongue(母语)中的读写能力。</p><p>一些关于literacy的例子:</p><ul><li><p>Improving literacy is a priority, as it helps break the cycle of poverty. 提高识字率是优先事项,这有助于打破贫困循环。</p></li><li><p>The government has launched a campaign to boost literacy among adults. 政府启动了一个运动来提高成人的读写能力。</p></li><li><p>Children’s literacy skills develop through reading books and stories. 儿童的读写能力通过读书和故事得到发展。</p></li><li><p>Digital literacy is increasingly important in the internet age. 在互联网时代,数字读写能力越来越重要。</p></li><li><p>Functional literacy refers to the basic skills needed to function in society. 功能性识字能力是指一个人在社会中基本需求的读写能力。</p></li></ul><p><em>institution 机构、制度、组织  ， soild 坚固的、扎实的、牢固的，souvenir 纪念品<br>quill 鹅毛笔</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091525945.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;五大基本句型&quot;&gt;&lt;a href=&quot;#五大基本句型&quot; class=&quot;headerlink&quot; title=&quot;五大基本句型&quot;&gt;&lt;/a&gt;五大基本句型&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    <category term="english" scheme="https://fqzs.netlify.app/categories/english/"/>
    
    
  </entry>
  
  <entry>
    <title>acdemic_gpt添加slack-Claude模型</title>
    <link href="https://fqzs.netlify.app/undefined/6ca9ded9.html"/>
    <id>https://fqzs.netlify.app/undefined/6ca9ded9.html</id>
    <published>2023-06-07T23:16:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p><p><code>3.ppt生成promt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">帮我制作一篇内容关于这篇文章的PPT，要求如下： </span><br><span class="line">第一、一定要使用中文。 </span><br><span class="line">第二、页面形式有3种，封面、目录、列表。 </span><br><span class="line">第三、目录页要列出内容大纲。 </span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页内容使用“=====列表=====”作为开头。 </span><br><span class="line">第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 </span><br><span class="line">第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 </span><br><span class="line">第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 </span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。 </span><br><span class="line">第九、请用代码块回复你生成的内容。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准备&quot; class=&quot;headerlink&quot; title=&quot;前置准备&quot;&gt;&lt;/a&gt;前置准备&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从GitHub仓库中获取acdemic_gpt&lt;/li&gt;
&lt;li&gt;创建Slac</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://fqzs.netlify.app/undefined/e255a10a.html"/>
    <id>https://fqzs.netlify.app/undefined/e255a10a.html</id>
    <published>2023-06-03T17:23:00.000Z</published>
    <updated>2023-07-15T05:01:46.387Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被服务的</span><br><span class="line">关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资源有限同时发</span><br><span class="line">消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主要指</span><br><span class="line">下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上与服务端进</span><br><span class="line">    行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服务端又</span><br><span class="line">是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境当中，下载的</span><br><span class="line">主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一点点</span><br><span class="line">   交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电话(释放</span><br><span class="line">链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，然后再</span><br><span class="line"> 由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段的占用链路，</span><br><span class="line"> 不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机发出报</span><br><span class="line">  文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入10bit</span><br><span class="line">信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间被称为</span><br><span class="line">排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被称为处</span><br><span class="line">理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步(SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载app，网络</span><br><span class="line">断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用户数据</span><br><span class="line">报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返回确认</span><br><span class="line">信息后，才会发送下一段内容；如果没有接收到确认信息，那么会一直发送</span><br><span class="line">当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无需确认</span><br><span class="line">这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发消息，</span><br><span class="line">qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进行区分</span><br><span class="line">例如请qq的消息端口号是1，接收方端口号1的进程(qq)接收该条消息；微</span><br><span class="line">信端口号2，接收方端口号2的进程(微信)接受该条消息</span><br><span class="line">5.拥塞控制</span><br><span class="line">- 传输层协议</span><br><span class="line">1.TCP</span><br><span class="line">2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服务，网</span><br><span class="line">  络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则进行对</span><br><span class="line">分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制校验)</span><br><span class="line">4.拥塞控制：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里开始，</span><br><span class="line">到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合走可</span><br><span class="line">  在链路上传输</span><br><span class="line">- </span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h2><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>三种通信方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/h1&gt;&lt;h2 id=&quot;认识计算机网络&quot;&gt;&lt;a href=&quot;#认识计算机网络&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>字扩展与多模块存储器区别</title>
    <link href="https://fqzs.netlify.app/undefined/a9bcdbf2.html"/>
    <id>https://fqzs.netlify.app/undefined/a9bcdbf2.html</id>
    <published>2023-06-01T22:23:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于一个存储器的一部分，也就是说拥有同一个读写周期。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg&quot; alt=&quot;星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哪些方法可以判断一个有向图是否有环</title>
    <link href="https://fqzs.netlify.app/undefined/d30215e4.html"/>
    <id>https://fqzs.netlify.app/undefined/d30215e4.html</id>
    <published>2023-05-24T22:03:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg&quot; alt=&quot;房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>模4补码与模2补码</title>
    <link href="https://fqzs.netlify.app/undefined/f711f08b.html"/>
    <id>https://fqzs.netlify.app/undefined/f711f08b.html</id>
    <published>2023-05-22T22:13:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg&quot; alt=&quot;女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码、模与运算</title>
    <link href="https://fqzs.netlify.app/undefined/b988fae0.html"/>
    <id>https://fqzs.netlify.app/undefined/b988fae0.html</id>
    <published>2023-05-22T16:32:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg&quot; alt=&quot;晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码的移位</title>
    <link href="https://fqzs.netlify.app/undefined/fe859f5c.html"/>
    <id>https://fqzs.netlify.app/undefined/fe859f5c.html</id>
    <published>2023-05-21T22:55:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对补码左移运算&lt;/code&gt;&lt;br&gt;书里介绍的</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="补码" scheme="https://fqzs.netlify.app/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://fqzs.netlify.app/undefined/8d4b7ae1.html"/>
    <id>https://fqzs.netlify.app/undefined/8d4b7ae1.html</id>
    <published>2023-05-08T20:07:00.000Z</published>
    <updated>2023-07-15T05:01:46.387Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg" alt="白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 </span><br><span class="line">  入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF-Overflow-Flag"><a href="#OF-Overflow-Flag" class="headerlink" title="OF:Overflow Flag"></a>OF:Overflow Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">1011 + 1001 = 1 0100 --&gt; 只有符号位进位 溢出</span><br><span class="line">0100 + 0100 =   1000 --&gt; 只有次高位进位 溢出</span><br><span class="line">1111 + 1100 = 1 1011 --&gt; 符号位和次高位都进位，不溢出</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF-Sign-Flag"><a href="#SF-Sign-Flag" class="headerlink" title="SF: Sign Flag"></a>SF: Sign Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF-Zero-Flag"><a href="#ZF-Zero-Flag" class="headerlink" title="ZF: Zero Flag"></a>ZF: Zero Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF-Carry-Flag"><a href="#CF-Carry-Flag" class="headerlink" title="CF: Carry Flag"></a>CF: Carry Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 进位/借位标志位，表示无符号数的加减法是否发生了进位或借位</span><br><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B</span><br><span class="line">               电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那就需</span><br><span class="line"> 要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10条字选</span><br><span class="line"> 线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内全部</span><br><span class="line">      刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期变为</span><br><span class="line">  1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功耗低</span><br><span class="line">  价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始都为0)</span><br><span class="line">如果表加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位表示块</span><br><span class="line">  号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要6bit位表</span><br><span class="line">  示</span><br><span class="line">--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit数字就是Cache中的块号大小</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></p><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞</span><br><span class="line">  状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块中，因</span><br><span class="line">此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主存块大小相等)</span><br><span class="line">因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑对应，所以出现了一个映射表，存储块号与页号</span><br><span class="line">  的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;10 转换地址 000001(操作码) 10(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺序编</span><br><span class="line"> 址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表示SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码 </span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr><h3 id="汇编语言的考试要求"><a href="#汇编语言的考试要求" class="headerlink" title="汇编语言的考试要求"></a>汇编语言的考试要求</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111601729.png" alt="image.png"></p><h3 id="X86汇编语言基础"><a href="#X86汇编语言基础" class="headerlink" title="X86汇编语言基础"></a>X86汇编语言基础</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是X86?</span><br><span class="line">1978年Intel公司生产了一块CPU芯片代号8086，</span><br><span class="line">之后就出现了80286、80386等一系列86结尾的型号的CPU，都兼容之前的CPU，能够将程序</span><br><span class="line">移植到新的CPU执行。因此X86汇编语言指令，是指能够被这一系列CPU处理的汇编语言指</span><br><span class="line">令</span><br></pre></td></tr></table></figure><hr><h4 id="以mov指令为例"><a href="#以mov指令为例" class="headerlink" title="以mov指令为例"></a>以mov指令为例</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111617341.png" alt="image.png"><br>s-&gt;source-&gt;源操作数<br>d-&gt;destination-&gt;目标操作数<br><code>mov d , s</code>-&gt;将源操作数s复制到目的操作数d所指的位置</p><p>mov指令常用格式有一下几种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111619250.png" alt="image.png"><br>其中当指明的是内存地址的时候，通过dword ptr(双字)、word ptr(单字)、byte ptr(字节)<br>来指明需要读写的长度</p><hr><h4 id="X86CPU有哪些寄存器"><a href="#X86CPU有哪些寄存器" class="headerlink" title="X86CPU有哪些寄存器"></a>X86CPU有哪些寄存器</h4><ul><li>X 结尾：通用寄存器</li><li>I 结尾 ：变址寄存器</li><li>P结尾：堆栈寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111633315.png" alt="image.png"></li></ul><ul><li>寄存器都以E开头，E-&gt;Extenden=32bit，</li><li>对于通用寄存器而言如果指向使用低位的16bit，那么可将E 去掉</li><li>变地址寄存器和堆栈寄存器都不能去掉E ,只能固定使用32bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111638172.png" alt="image.png"></p><hr><h4 id="源、目的-操作数书写格式"><a href="#源、目的-操作数书写格式" class="headerlink" title="源、目的 操作数书写格式"></a>源、目的 操作数书写格式</h4><ul><li>[寄存器] 是指寄存器里所存的地址所指向的数据，相当于寄存器间接寻址</li><li>[地址/寄存器] 前没有指明读学长度时，默认32bit</li><li>[af996-12 h]-&gt;最后h表示16进制，这样写是指地址af886往前偏移12位地址所指数据</li><li>[abx +8]-&gt;是指该寄存器内地址往后+8的主存地址所指向的数据<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111642835.png" alt="image.png"></li></ul><hr><h4 id="常见的算数运算指令"><a href="#常见的算数运算指令" class="headerlink" title="常见的算数运算指令"></a>常见的算数运算指令</h4><ul><li>乘法 mul d,s -&gt; 表示无符号数d * s,乘积存入d</li><li>乘法 imul d,s -&gt; 表示有符号数d * s,乘积存入d</li><li>除法 div s -&gt;无符号数除法，被除数会提前存放在edx:eax中<br>  -&gt;edx:eax表示两个寄存器拼接将被除数从原来的32bit扩展为64bit ;<br>  -&gt;商存入eax,余数存入edx中</li><li>除法 idiv s -&gt;有符号数除法，被除数会提前存放在edx:eax中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111737632.png" alt="image.png"></li></ul><hr><h4 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111750543.png" alt="image.png"></p><hr><h4 id="s、d操作数"><a href="#s、d操作数" class="headerlink" title="s、d操作数"></a>s、d操作数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于X86系统，指令后面的两个操作数不允许两个都来自主存&lt;mem&gt;</span><br><span class="line">2.并且，目的操作数d 不能是常数&lt;con&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172215148.png" alt="image.png"></p><hr><h4 id="AT-amp-T格式指令与Intel格式指令区别"><a href="#AT-amp-T格式指令与Intel格式指令区别" class="headerlink" title="AT&amp;T格式指令与Intel格式指令区别"></a>AT&amp;T格式指令与Intel格式指令区别</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111800835.png" alt="image.png"></p><ul><li>基址+变址 <em> 比例因子+偏移量<br>用于结构体数组内信息的寻址<br>基地址-&gt;寻找数组起始地址<br>变址 </em> 比例因子-&gt;寻找目标元素在数组内的位置<br>偏移量-&gt;寻找目标信息在该元素内的具体位置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111806568.png" alt="Uploading file...npg0j"></li></ul><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><hr><h4 id="jmp指令与cmp指令"><a href="#jmp指令与cmp指令" class="headerlink" title="jmp指令与cmp指令"></a>jmp指令与cmp指令</h4><p><strong>1.程序中选择分支结构</strong></p><ul><li>程序计数器PC又被称为IP寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112305940.png" alt="image.png"></li></ul><hr><p><strong>2.无条件跳转指令—Jmp</strong></p><p>执行该条指令PC会无条件跳转到某个主存地址，执行那个地址的指令</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317121.png" alt="image.png"></p><p>无条件跳转指令格式 -&gt; jmp &lt;地址&gt; </p><ul><li>jmp 128 -&gt;跳转到地址128</li><li>jmp eax -&gt; 地址来自于寄存器</li><li>jmp [999] -&gt;地址来自于主存地址999中存的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317178.png" alt="image.png"></li></ul><hr><p><strong>3.jmp跳转标记位格式</strong></p><pre><code>因为写程序的时候，例如if-else分支语句的时候，通过条件判断决定跳转执行那一条程序语句，这样就有一个问题，如果都采用上面的三种jmp跳转指令--需要先知道需要跳转的程序的主存地址(jmp 116)，这样写死了地址，很不灵活，一旦程序的主存地址一改变，原有的jmp指令就会跳转错误位置，所以就可以通过对需要跳转的语句做标记NEXT ,通过jmp NEXT 的跳转方式实现跳转</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112330386.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112332972.png" alt="image.png"></p><hr><p><strong>4.条件转移指令-jxxx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112334438.png" alt="image.png"></p><p>通常使用条件跳转指令前，需要使用cmp指令。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336192.png" alt="image.png"></p><p>所以cmp指令经常和条件跳转指令搭配使用。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336184.png" alt="image.png"></p><hr><p><strong>5.cmp指令的底层原理</strong></p><p>本质上就是对a,b两个操作数镜像减法运算a-b,并生成了OF、ZF、CF、SF四个标志位信息<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112339041.png" alt="image.png"></p><p>ALU 每进行一次运算的标志位都会自动存入<br>PSW程序状态字寄存器中(Intel称它为“标志寄存器”)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112341179.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340390.png" alt="image.png"></p><p>jxxx指令，就是根据cmp指令得到的标志位，来判断是否= &lt;  &gt; ！=<br>进而决定进行跳转<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112345836.png" alt="image.png"></p><hr><h4 id="条件转移指令jmp实现循环"><a href="#条件转移指令jmp实现循环" class="headerlink" title="条件转移指令jmp实现循环"></a>条件转移指令jmp实现循环</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142216499.png" alt="image.png"></p><hr><h4 id="loop指令实现循环"><a href="#loop指令实现循环" class="headerlink" title="loop指令实现循环"></a>loop指令实现循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 指令：</span><br><span class="line">- 格式loop Looltop  // ecx-- ,若ecx!=0,跳转到Looptop</span><br><span class="line">- 只能用ecx作为循环计数器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142229529.png" alt="image.png"></p><hr><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><h4 id="call、leave、ret指令"><a href="#call、leave、ret指令" class="headerlink" title="call、leave、ret指令"></a>call、leave、ret指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call、leave、ret指令实现函数调用：</span><br><span class="line">call 指令 作用：</span><br><span class="line">1.将IP旧址压栈保存(保存在当前函数的栈帧顶部)</span><br><span class="line">2.设置新的IP值，无条件转移到被调用函数的第一条指令</span><br><span class="line">leave 指令 作用：</span><br><span class="line">1.将现在的函数的栈帧撤销，相当于将该函数弹栈</span><br><span class="line">ret 指令 作用：</span><br><span class="line">1.弹栈后，从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP原有的值指向回原来位</span><br><span class="line">置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142240959.png" alt="image.png"></p><hr><h4 id="如何访问栈帧里的数据？"><a href="#如何访问栈帧里的数据？" class="headerlink" title="如何访问栈帧里的数据？"></a>如何访问栈帧里的数据？</h4><h5 id="访问栈帧数据Push和Pop指令"><a href="#访问栈帧数据Push和Pop指令" class="headerlink" title="访问栈帧数据Push和Pop指令"></a>访问栈帧数据Push和Pop指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ebp和esp：</span><br><span class="line">ebp指向当前栈帧的底部，esp指向当前栈帧的顶部，两者标记了当前栈帧的一个范围</span><br><span class="line">ebp、esp存的是地址不是数据值，ebp和esp只是一个指针</span><br><span class="line"></span><br><span class="line">Push、Pop指令实现入栈出栈操作操作，X86默认以4字节为单位：</span><br><span class="line">格式:</span><br><span class="line">Push ?  //先让esp-4，在将数据压入</span><br><span class="line">Push eax   #将寄存器eax的值压栈</span><br><span class="line">Push 985   #将立即数985压入栈中</span><br><span class="line">Push [ebp+8] #将主存地址[ebp+8]的数据压栈</span><br><span class="line">(所谓压栈是指将esp里保存的地址，所指向的数据的值修改,然后esp-4)</span><br><span class="line">Pop ?  //栈顶元素出栈并写入&lt;寄存器/主存地址&gt;，在esp+4</span><br><span class="line">Pop eax   # 将栈顶元素出栈，写入寄存器eax</span><br><span class="line">Pop [ebp+8] # 将栈顶元素出栈，并写入主存地址[ebp+8]</span><br><span class="line">(所谓出栈是指,将esp保存的地址所指向的值写入?,然后esp+4)</span><br><span class="line">问题： </span><br><span class="line">这样访问栈帧数据不灵活，因为每次Push都只能往esp+4的位置Push(压入数据)</span><br><span class="line">每次Pop也只能一次弹出一个栈顶元素，并写入一个栈顶栈顶元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151025134.png" alt="image.png"></p><hr><h5 id="访问栈帧数据mov指令"><a href="#访问栈帧数据mov指令" class="headerlink" title="访问栈帧数据mov指令"></a>访问栈帧数据mov指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以直接对esp进行加减运算：</span><br><span class="line">可以使用减法/加法，即sub/add修改栈顶指针esp的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151046206.png" alt="image.png"></p><hr><h4 id="如何切换栈帧？"><a href="#如何切换栈帧？" class="headerlink" title="如何切换栈帧？"></a>如何切换栈帧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.先执行call指令：</span><br><span class="line">1.将当前IP(取出call之后自动指向下一条)值，相当于 Push IP</span><br><span class="line">2.将IP设置为被调用函数的第一条指令地址, 相当于jmp add</span><br><span class="line"></span><br><span class="line">2.进入目标函数后：&lt;保存上一个函数的栈帧，并设置当前函数栈帧&gt;</span><br><span class="line">1.Push ebp --&gt;将前一个函数的栈底地址保存入栈(先esp+4,然后将ebp值压入)</span><br><span class="line">2.mov ebp esp --&gt; 将esp的地址值复制给ebp,使ebp指向另一个函数的栈底地址</span><br><span class="line"> ==&gt; 1+2等价于enter指令</span><br><span class="line"> </span><br><span class="line">3.一系列逻辑处理</span><br><span class="line"></span><br><span class="line">4.恢复上一层函数的栈帧：</span><br><span class="line">1.mov esp ebp --&gt; 让esp指向当前函数栈底</span><br><span class="line">2.Pop ebp --&gt; 将栈顶元素出栈，并写入ebp(ebp重新指回上一个函数基底)</span><br><span class="line"> ==&gt; 等价于leave指令</span><br><span class="line">5.ret指令：</span><br><span class="line">从栈顶找到返回的地址(原来基础上继续执行)，出栈并将值写到IP寄存器中，使其继续执</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><code>调用函数</code></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151109099.png" alt="image.png"></p><p><code>函数返回</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151130458.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151214922.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151105535.png" alt="image.png"></p><hr><h4 id="如何传递参数和返回值？"><a href="#如何传递参数和返回值？" class="headerlink" title="如何传递参数和返回值？"></a>如何传递参数和返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈帧最底部(基址)一定是上一层栈帧的基址</span><br><span class="line"></span><br><span class="line">栈帧的最顶部，一定是IP的返回地址(当前栈帧除外)</span><br><span class="line"></span><br><span class="line">栈帧结构，分为以下几块区域，每块区域内同时越靠前定义的就越靠近栈顶:</span><br><span class="line">1.局部变量区域</span><br><span class="line"></span><br><span class="line">2.未使用区域</span><br><span class="line">为什么会有未使用区域？</span><br><span class="line">因为gcc编译器会将每个栈帧大小设置为16B的整数倍(当前函数栈帧除外)</span><br><span class="line">当局部变量和调用参数没有填满栈帧时，就会空出未使用的部分</span><br><span class="line">3.调用参数区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172225143.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172137430.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数，返回值</span><br><span class="line">传低参数：在call指令前，将调用参数写入栈帧顶部区域</span><br><span class="line">接收返回值：在执行ret指令前将函数返回值写入eax寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172234781.png" alt="image.png"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CISC: Complex Instruction Set Computer(复杂指令集)</span><br><span class="line">- 通过一条指令完成复杂的基本功能，所以，它的指令往往是变长的</span><br><span class="line">- 变长，这也决定了它的指令执行效率低，因为需要花时间判断该指令的长度</span><br><span class="line">- 像是前面提到的乘法指令 000100 0000000110 只通过乘法指令就可以进行访存，所以</span><br><span class="line">  CISC指令对指令的访存权限没有限制</span><br><span class="line">- 由于随着CISC指令变得越来越复杂，很难用一个专门的电路硬件来实现，所以&quot;存储程</span><br><span class="line">  序&quot;，就是事先将几条组合指令存储在某个地方，比如要实现矩阵的乘法--&gt;可以通过</span><br><span class="line">  矩阵的加法、减法;整数加法、减法、乘法，5个比较通用的电路之间配合使用来实现复</span><br><span class="line">  杂的矩阵乘法</span><br><span class="line">RISC: Reduced Instruction Set Computer(精简指令集)</span><br><span class="line">- 一条指令只完成一个基本动作，一条指令一个电路</span><br><span class="line">- 由于电路设计简单功耗更低，所以主要用于移动设备:手机、平板等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172336854.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSIC:</span><br><span class="line">1.寄存器数量少，因为可以访存的指令没有限制，可以直接从主存中存取，不会过多的占</span><br><span class="line">  用寄存器的数量</span><br><span class="line">2.难以用优化编译生成高效的目标代码程序，因为，CISC本身就是一个复杂体，又胖又无</span><br><span class="line"> 法切割重组，决定了其效率的上限很低</span><br><span class="line"></span><br><span class="line">RISC:</span><br><span class="line">1.寄存器数量多，因为，可以访存的指令只有Load/Stroe，所以进行计算等操作的时候，</span><br><span class="line">  只能通过寄存器来存放数据，最后再通过Load/Stroe指令来进行写入或删除</span><br><span class="line">2.指令精简，可以很大程度上重组功能，生成更高效的代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172340404.png" alt="image.png"></p><h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041138990.png" alt="image.png"></p><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a><em>CPU的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032012738.png" alt="image.png"></p><h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a><em>运算器和控制器的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032026718.png" alt="image.png"></p><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a><em>运算器的基本结构</em></h3><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个寄存器与ALU之间都有专门的单独的数据通路--&gt;称为专用数据通路</span><br><span class="line">下图所示，所有寄存器与ALU都直接相连，但是我们不需要同时有这么多寄存器同时输入数据</span><br><span class="line">以下有两种解决办法:1.多路选择器;2.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032116421.png" alt="image.png"></p><blockquote><p><em>多路选择器</em></p></blockquote><p><em>使用多路选择器根据控制信号选择一路输出</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032113430.png" alt="image.png"></p><blockquote><p><em>三态门</em></p></blockquote><p>计算机里面<strong>1 0</strong> 分别表示 <strong>是  非</strong> 两种逻辑，但是还不够，因此引入了一种新的状态——<strong>高阻态</strong>(相当于电阻无穷大，断路状态)。</p><p>三态：高电平、低电平、高阻态。</p><p>三态门主要与总线连接，因为总线在同一时间内只能对一个设备有效。<br>通常在数据总线上连接有<strong>多个器件</strong>。同一时刻只能有一个设备选通，用于数据传输；其他设备处于高阻态(断开)。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032142905.png" alt="image.png"></p><p>EN使能信号：<br>    EN是<strong>0信号</strong>表示数据从A-&gt;B ;<strong>1信号</strong>表示数据从B-&gt;A；当EN使能信号无效时(没有产生信号)处于高阻态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032148055.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032150494.png" alt="image.png"></p><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将所有寄存器的输入端和输出端都连接到一条公用的通路上(CPU内部总线)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032203518.png" alt="image.png"></p><p><strong>引入暂存寄存器</strong><br><em>从这开始内部总线就只能同时有一个输入信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032207030.png" alt="image.png"></p><p><strong>为了避免输入信号还没稳定的时候就发出输出信号，在ALU后面再引入一个暂存寄存器+一个三态门</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当输入信号稳定前，期间产生的输出信号被存放在暂存器中(此时三态门没有导通);</span><br><span class="line">当输入信号稳定之后，(三态门接通)最终产生的输出信号才传输到CPU内部总线</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032209466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032216449.png" alt="image.png"></p><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032229276.png" alt="image.png"></p><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041129708.png" alt="image.png"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041136632.png" alt="image.png"></p><hr><h2 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><strong>CPU从主存中每取出并执行一条指令所需的全部时间</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041154511.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041200018.png" alt="image.png"></p><h3 id="数据流-微操作-有效信号"><a href="#数据流-微操作-有效信号" class="headerlink" title="数据流(微操作+有效信号)"></a>数据流(微操作+有效信号)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041429770.png" alt="image.png"><br><strong>注意书写数据流的时候需要写出——&gt; 微操作 + 有效控制信号</strong></p><hr><blockquote><p><em>指令周期的数据流向-取指周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041216231.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-间址周期</em></p></blockquote><p><strong>Ad(MDR) -&gt; MAR</strong> 中Ad 表示的是将MDR数据(取得的指令)中的<code>地址码部分</code>放入MAR中<br><strong>Ad(IR) -&gt; MAR</strong> 中Ad表示的也是将IR数据(取得的指令)中的<code>地址码部分</code>放到MAR中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041238584.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-执行周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041412833.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-中断周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041428150.png" alt="image.png"></p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041435747.png" alt="image.png"></p><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041434691.png" alt="image.png"></p><h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据通路的基本结构有:</span><br><span class="line">1.CPU内部单总线方式</span><br><span class="line">所有CPU部件连接一根内部总线，同时只能一组部件数据交换(一个发出，一个接收)</span><br><span class="line">2.CPU内部多总线方式</span><br><span class="line">为了解决同时只能有一组部件进行数据交换，所以提出CPU内部多总线，所有部件与这些</span><br><span class="line">多根总线都有连接，同时可以支持n组部件数据交换(n是总线根数)</span><br><span class="line">3.专用数据通路方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041936960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041935158.png" alt="image.png"></p><h3 id="数据通路-CPU内部单总线方式"><a href="#数据通路-CPU内部单总线方式" class="headerlink" title="数据通路-CPU内部单总线方式"></a>数据通路-CPU内部单总线方式</h3><blockquote><p><em>完成一次加法运算，完整的数据通路(单总线方式)</em></p></blockquote><p>由于这是单总线方式，一次只能有一组部件传输数据(例如 (ACC)-&gt;Bus-&gt;ALU  实现ACC和ALU之间的 <strong>被加数</strong>传输，<strong>加数</strong>只能先通过MDR-&gt;Bus-&gt;Y 存放在暂存寄存器中)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042005863.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042040431.png" alt="image.png"></p><p>间址周期过程(省略微操作)：<br>    1.R0out  ,MARin 控制信号有效 -&gt;R0内间接地址传送到MAR<br>    2.MemR ,MARout ,MDRinE 控制信号有效 -&gt; 根据间接地址得到的直接地址EA存入<br>       MDR<br>    3.MDRout ,MARin 控制信号有效 -&gt;EA传给MAR<br>    4.MARout ,MemR ,MDRinE 控制信号有效 -&gt; 根据EA找到的操作数()存入MDR<br>    5.MDRout ,Yin 控制信号有效 -&gt; 将目的操作数((R0))放入暂存寄存器Y中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137539.png" alt="image.png"></p><p>执行周期过程(省略微操作):<br>    1.R1out , ALUin ,CU向ALU发送加法操作信号, 控制信号有效 -&gt;将源操作数送入ALU运<br>      算(Y寄存器同时会将之前暂存的目的操作数通过专用数据通路送往ALU)<br>    2.Zout ,MDRin 控制信号有效 -&gt; 将计算结果送入MDR寄存器<br>    3.MemW ,MDRoutE ,MARout -&gt; MDR将计算结果送到主存，MAR目的操作数地址传<br>      给主存，主存根据MAR中已经存在的目的操作数的有效地址，将结果写回到目的操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137717.png" alt="image.png"></p><h3 id="数据通路-专用数据通路方式"><a href="#数据通路-专用数据通路方式" class="headerlink" title="数据通路-专用数据通路方式"></a>数据通路-专用数据通路方式</h3><blockquote><p><em>专用数据通路-取指周期</em></p></blockquote><p>取指周期数据流向:<br>    <em>1</em>. (PC)-&gt;MAR                 C0有效<br>    <em>2</em>. (MAR) -&gt;主存             C1有效<br>    <em>3</em>. 1-&gt;R                          控制单元向主存发送度命令<br>    <em>4</em>.  M(MAR) -&gt; MDR      C2有效<br>    <em>5.</em>  (MAR) -&gt; IR              C3有效<br>    <em>6.</em>  (PC)+1-&gt;PC<br>    <em>7.</em>  Op(IR) -&gt;CU             C4有效【Op是操作码，Ad是地址码；将操作码传给CU分析】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042219807.png" alt="image.png"></p><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><h4 id="什么是硬布线控制器？"><a href="#什么是硬布线控制器？" class="headerlink" title="什么是硬布线控制器？"></a><em>什么是硬布线控制器？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070922995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070924177.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070930551.png" alt="image.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a><em>硬布线控制器的设计</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070934082.png" alt="image.png"></p><blockquote><p><em>1.分析每个阶段的微操作序列</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070935646.png" alt="image.png"></p><p><em>2.选择CPU的控制方式</em><br><strong>这里采用同步控制方式(定长机器周期)—&gt;一个周期安排3个节拍</strong></p><p><em>3.安排微操作时序</em></p><p><strong>取指周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070943155.png" alt="image.png"><br><strong>间址周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070946256.png" alt="image.png"><br><strong>执行周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070945614.png" alt="image.png"></p><p><em>4.电路设计</em><br><strong>a.列出操作时间表</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951515.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952398.png" alt="image.png"><br><strong>b.写出微操作命令的最简表达式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070948343.png" alt="image.png"><br><strong>c.画出逻辑图</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951629.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062351469.png" alt="image.png"></p><h3 id="微程序控制器的基本原理"><a href="#微程序控制器的基本原理" class="headerlink" title="微程序控制器的基本原理"></a>微程序控制器的基本原理</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071919688.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CPU内的控制器包含:CU IR PC</span><br><span class="line">CU控制单元用于实现微指令的执行</span><br><span class="line">1.由于CM 内存储了多种指令 的 微程序,所以“微地址形成部件”需要根据IR内具体的指令</span><br><span class="line">  的操作码，判断该指令对应CM内哪个微程序，以获得其&quot;起始微地址&quot;</span><br><span class="line">  (改正一下表述:所谓微程序既可以说是一条完整指令，包括取指周期、间址周期、执行</span><br><span class="line">  周期、中断周期的所有微指令的总和;也可以说单独的某个周期的微程序，例如:取指周</span><br><span class="line">  期微程序，这里“微地址形成部件，的作用是在根据IR中的操作码特征，分析执行周</span><br><span class="line">  期的微程序的微指令首地址，而不是取指周期微指令首地址.因为取指周期是通用的</span><br><span class="line">  它的地址可以由执行周期中最末尾的微指令的下地址指明，而执行周期的微指令不是</span><br><span class="line">  通用的，所以需要单独通过“微地址形成部件”，来获得首地址)</span><br><span class="line">2.再根据&quot;顺序逻辑&quot; 中&quot;标志&quot;信息判断下一步要执行微指令的存放地址(一般标志信息</span><br><span class="line">  是根据指令地址码(IR中的地址码)的特征，判断是否要进行间址周期，无需间接寻址就</span><br><span class="line">  跳过间址周期微指令;如果要间接寻址,那么按照“CMDR中的下地址”顺序执行下去)</span><br><span class="line">3.CMAR接收来自经过顺序逻辑处理后的“起始微地址”</span><br><span class="line">4.CMAR 将地址(微指令地址)送入地址译码器，找到地址对应的微指令在CM中的位置</span><br><span class="line">5.CM根据位置取出该条微指令(操作控制+下地址) ,送到CMDR</span><br><span class="line">6.CMDR将微指令的操作控制信息 传至CPU内部和系统总线的控制信号</span><br><span class="line">7.CMDR 将下一条(相邻的)微指令地址传给顺序逻辑(顺序逻辑会根据之前获得的标志</span><br><span class="line">  +CLK信息，如果当前执行到了间址周期微指令，会根据标志信息，判断是否跳过)</span><br><span class="line">8.重复这一循环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071924474.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071950460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个微程序包括一条指令的所有周期的微指令，所以一条指令的取指周期微程序+执行周期微程序，其实是一个微程序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071958856.png" alt="image.png"></p><h3 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092240574.png" alt="image.png"></p><h4 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h4><blockquote><p><em>水平型微指令、垂直型微指令、混合型微指令</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092245360.png" alt="image.png"></p><h4 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h4><blockquote><p><em>编码方式</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微指令编码主要方式分为3种</span><br><span class="line">直接编码: </span><br><span class="line">n个微命令-&gt;需要分别对应n个bit信号位</span><br><span class="line">字段直接编码: </span><br><span class="line">采用译码器，将控制字段分段,比如3bit为1段,能产生2^3种不同信号,</span><br><span class="line">这样就能用更少bit存储控制信号。</span><br><span class="line">这样实现，相同字段内的控制信息无法并行进行--&gt;所以互斥信号放在同一字段</span><br><span class="line">字段间接编码:</span><br><span class="line">译码器上加一层译码器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101035576.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101037705.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101047396.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101046382.png" alt="image.png"></p><h4 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h4><blockquote><p><em>方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101050533.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101053029.png" alt="image.png"></p><h3 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h3><blockquote><p><em>微程序控制单元的设计</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141414952.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141419465.png" alt="image.png"></p><p><em>微程序设计的分类</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141420731.png" alt="image.png"></p><p><em>硬布线与微程序的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421167.png" alt="image.png"></p><p><em>微程序控制器回顾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421854.png" alt="image.png"></p></blockquote><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141625402.png" alt="image.png"></p><h3 id="指令流水线基本概念性能指标"><a href="#指令流水线基本概念性能指标" class="headerlink" title="指令流水线基本概念性能指标"></a>指令流水线基本概念性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141515119.png" alt="image.png"></p><h4 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a><em>指令流水的定义</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141632815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141501856.png" alt="image.png"></p></blockquote><h4 id="流水线表示方法"><a href="#流水线表示方法" class="headerlink" title="流水线表示方法"></a><em>流水线表示方法</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141500715.png" alt="image.png"></p></blockquote><h4 id="流水线的性能指标-—吞吐率、加速比、效率"><a href="#流水线的性能指标-—吞吐率、加速比、效率" class="headerlink" title="流水线的性能指标 —吞吐率、加速比、效率"></a><em>流水线的性能指标</em> —<strong>吞吐率、加速比、效率</strong></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513423.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513840.png" alt="image.png"></p></blockquote><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">完成一条指令，常分为五个阶段:</span><br><span class="line">IF(取指阶段)、ID(译码段)、EX(执行段)、M(访存)、WB(写回)</span><br><span class="line"></span><br><span class="line">由于每个功能段需要消耗时间不一致，为了统一方便指令流水线，以最长耗时为准这里就设为100ns</span><br><span class="line"></span><br><span class="line">同时就需要在每个功能段后面加一个缓冲寄存器--&gt;锁存器</span><br><span class="line">目的是为了保证执行更快的阶段，将数据存放，处于缓冲等待的状态，以维持统一</span><br><span class="line"></span><br><span class="line">Instruction Cache(指令Cache)--也就是Cache中存放指令的区域</span><br><span class="line">取指一般都是在指令Cache中取指</span><br><span class="line"></span><br><span class="line">Data Cache(数据Cache)--也就是Cache数据区域</span><br><span class="line">M访存，当Cache命中的情况下，直接访问数据Cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142119460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考试中常见的指令有五类(RSIC精简指令集)</span><br><span class="line">运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142127965.png" alt="image.png"></p><h4 id="各类指令的执行过程"><a href="#各类指令的执行过程" class="headerlink" title="各类指令的执行过程"></a>各类指令的执行过程</h4><h5 id="运算类指令执行过程"><a href="#运算类指令执行过程" class="headerlink" title="运算类指令执行过程"></a>运算类指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142135940.png" alt="image.png"></p><h5 id="LOAD指令执行过程"><a href="#LOAD指令执行过程" class="headerlink" title="LOAD指令执行过程"></a>LOAD指令执行过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD--取数指令，RSIC指令集中唯二可以访存的指令,作用是从主存取数到寄存器中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142144944.png" alt="image.png"></p><h5 id="STORE指令执行过程"><a href="#STORE指令执行过程" class="headerlink" title="STORE指令执行过程"></a>STORE指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142150614.png" alt="image.png"></p><h5 id="条件转移指令执行过程"><a href="#条件转移指令执行过程" class="headerlink" title="条件转移指令执行过程"></a>条件转移指令执行过程</h5><p><strong>WrPC逻辑上既不属于M段，也不属于WB段，只是因为WrPC所需要的功能部件与这5个阶段的功能部件是“相互独立的”，所以可以看做一个独立的阶段，可以自由安排</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142157041.png" alt="image.png"></p><h5 id="无条件转移指令执行过程"><a href="#无条件转移指令执行过程" class="headerlink" title="无条件转移指令执行过程"></a>无条件转移指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142205108.png" alt="image.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207049.png" alt="image.png"></p><h3 id="指令流水线的影响因素"><a href="#指令流水线的影响因素" class="headerlink" title="指令流水线的影响因素"></a>指令流水线的影响因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142243130.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142245235.png" alt="image.png"></p><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142254264.png" alt="image.png"></p><blockquote><p><em>硬件阻塞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142257185.png" alt="image.png"><br><em>NOP空操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142256095.png" alt="image.png"><br><em>数据旁路技术</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142308675.png" alt="image.png"></p></blockquote><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151112357.png" alt="image.png"></p><h3 id="指令流水线分类"><a href="#指令流水线分类" class="headerlink" title="指令流水线分类"></a>指令流水线分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151115488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151120957.png" alt="image.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151125637.png" alt="image.png"></p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127336.png" alt="image.png"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127292.png" alt="image.png"></p><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151153767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151258121.png" alt="new.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg&quot; alt=&quot;白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Telegram</title>
    <link href="https://fqzs.netlify.app/undefined/fd45428c.html"/>
    <id>https://fqzs.netlify.app/undefined/fd45428c.html</id>
    <published>2023-04-28T18:47:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用bot&quot;&gt;&lt;a href=&quot;#常用bot&quot; class=&quot;headerlink&quot; title=&quot;常用bot&quot;&gt;&lt;/a&gt;常用bot&lt;/h1&gt;&lt;p&gt;&lt;code&gt;@SMS24.me&lt;/code&gt;&lt;br&gt;&lt;figure class=&quot;highlight plainte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python安装</title>
    <link href="https://fqzs.netlify.app/undefined/ae5c380e.html"/>
    <id>https://fqzs.netlify.app/undefined/ae5c380e.html</id>
    <published>2023-04-14T18:11:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg" alt="绘梨衣壁纸_彼岸壁纸.jpg"></p><h1 id="配置python"><a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><hr><ul><li><code>下载好python环境，将文件夹配置到环境变量当中</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355861.png" alt="image.png"></li></ul><ul><li><code>CMD输入python查看版本信息，若显示说明配置成功</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355755.png" alt="image.png"></li></ul><ul><li><code>若不显示，打开CMD窗口，where python查看python安装位置 path查看环境变量配置</code></li><li><code>不显示，而是打开微软商店，需要将变量中的python移到Microsoft上方,或者删除Microsoft环境变量</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355535.png" alt="image.png"></li></ul><h1 id="添加pip"><a href="#添加pip" class="headerlink" title="添加pip"></a>添加pip</h1><hr><p><strong>pip</strong>是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包</p><ul><li>将图中<code>\python311\Script</code>配置到环境变量当中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355943.png" alt="image.png"></li></ul><ul><li><code>查看配置是否成功</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure></li></ul><h1 id="最便捷方式"><a href="#最便捷方式" class="headerlink" title="最便捷方式"></a>最便捷方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装python后，install前勾选pip to path</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg&quot; alt=&quot;绘梨衣壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;配置python&quot;&gt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://fqzs.netlify.app/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>CMD命令</title>
    <link href="https://fqzs.netlify.app/undefined/3e5cd712.html"/>
    <id>https://fqzs.netlify.app/undefined/3e5cd712.html</id>
    <published>2023-04-12T23:12:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg" alt="可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="调出远程桌面控制"><a href="#调出远程桌面控制" class="headerlink" title="调出远程桌面控制"></a>调出远程桌面控制</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><p><code>输入ip地址</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352256.png" alt="image.png"></p><h1 id="查看连接过的wifi密码"><a href="#查看连接过的wifi密码" class="headerlink" title="查看连接过的wifi密码"></a>查看连接过的wifi密码</h1><hr><p><code>1.查看历史所有wifi</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure></p><p><code>2.查看指定wifi的密码</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile name=&quot;wifi名&quot; key=clear</span><br></pre></td></tr></table></figure></p><h1 id="查询本机当前ip地址"><a href="#查询本机当前ip地址" class="headerlink" title="查询本机当前ip地址"></a>查询本机当前ip地址</h1><hr><ul><li><code>查看当前局域网ip和其他信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353460.png" alt="image.png"></li></ul><ul><li><code>查看更详细信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353598.png" alt="image.png"></li></ul><ul><li><code>查看当前外网地址</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L ip.tool.lu</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353405.png" alt="image.png"></li></ul><h1 id="ping检测ip地址或服务器网络情况"><a href="#ping检测ip地址或服务器网络情况" class="headerlink" title="ping检测ip地址或服务器网络情况"></a>ping检测ip地址或服务器网络情况</h1><hr><ul><li><code>短暂监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353128.png" alt="image.png"></li></ul><ul><li><code>持续监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名) -t</span><br></pre></td></tr></table></figure></li></ul><h1 id="调出资源监测器"><a href="#调出资源监测器" class="headerlink" title="调出资源监测器"></a>调出资源监测器</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfmon.msc</span><br></pre></td></tr></table></figure><p><code>监测磁盘、网络、CPUz占用率</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353676.png" alt="image.png"></p><h1 id="查看电脑当前所有用户"><a href="#查看电脑当前所有用户" class="headerlink" title="查看电脑当前所有用户"></a>查看电脑当前所有用户</h1><hr><p><code>查看用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354885.png" alt="image.png"></p><p><code>删除用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user 名字 /del</span><br></pre></td></tr></table></figure></p><h1 id="修复丢失或损坏的系统文件"><a href="#修复丢失或损坏的系统文件" class="headerlink" title="修复丢失或损坏的系统文件"></a>修复丢失或损坏的系统文件</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具可以允许用户扫描所有受保护的系统文件，并且检查系统文件的完整性，然后恢复Windows损坏的系统文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg&quot; alt=&quot;可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="cmd" scheme="https://fqzs.netlify.app/tags/cmd/"/>
    
  </entry>
  
  <entry>
    <title>C语言(三)</title>
    <link href="https://fqzs.netlify.app/undefined/1db5c403.html"/>
    <id>https://fqzs.netlify.app/undefined/1db5c403.html</id>
    <published>2023-04-10T21:42:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg" alt="北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jpg"></p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="补码解析"><a href="#补码解析" class="headerlink" title="补码解析"></a>补码解析</h2><hr><ul><li><code>补码</code>：计算机只能加法运算<code>2+(-5)</code>,所以需要补码，补码大小是<code>原码取反+1</code></li><li><p><code>原码</code>：补码取反+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0101     //5的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5    fffffffb </span><br></pre></td></tr></table></figure><p><code>由于X8架构采用的是小端存储</code>：低字节在前(低地址)，高字节在后(高地址) —&gt; <code>fbffffff</code></p></li><li><p><code>补码原码相加</code>：对应位置相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010     //2的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5 </span><br><span class="line"></span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1101     //补码 -3 =2+(-5)  --&gt;依次相加</span><br></pre></td></tr></table></figure></li><li><p>对于有符号数，最高位为1，就是负数</p></li></ul><h2 id="整型不同类型"><a href="#整型不同类型" class="headerlink" title="整型不同类型"></a>整型不同类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">整型类型</th><th style="text-align:center">符号</th><th style="text-align:center">字节</th><th style="text-align:center">整型数范围</th></tr></thead><tbody><tr><td style="text-align:left">基本整型</td><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31~(2^31-1)</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15~(2^15-1)</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:center">long</td><td style="text-align:center">(32位)4;(64位)8</td><td style="text-align:center">-2^31~(2^31-1)或-2^63~(-2^63-1)</td></tr><tr><td style="text-align:left">无符号整型</td><td style="text-align:center">unsigned int</td><td style="text-align:center">4</td><td style="text-align:center">0~2^32-1</td></tr><tr><td style="text-align:left">无符号短整型</td><td style="text-align:center">unsigned short</td><td style="text-align:center">2</td><td style="text-align:center">0~2^16-1</td></tr><tr><td style="text-align:left">无符号长整型</td><td style="text-align:center">unsigned long</td><td style="text-align:center">(32位)4;(62位)8</td><td style="text-align:center">0~(2^32-1)或0~(-2^64-1)</td></tr></tbody></table></div><ul><li><code>有符号数</code>：最高位只表示正负，不代表大小</li><li><code>无符号数</code>：最高位代表大小，不表示正负</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short最小数字：</span><br><span class="line">1000 0000 0000 0000  //补码 -32768 </span><br><span class="line">1000 0000 0000 0000  //原码  32768</span><br></pre></td></tr></table></figure><h2 id="溢出解析"><a href="#溢出解析" class="headerlink" title="溢出解析"></a>溢出解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">32767</span>;   <span class="comment">//01111 1111 1111 1111     32767</span></span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);  <span class="comment">//10000 0000 0000 0000    -32768 </span></span><br><span class="line"><span class="comment">//解决办法是用更大的空间存储</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=a+<span class="number">1</span>;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304111919441.png" alt="image.png"></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><h3 id="浮点数IEE754标准解析"><a href="#浮点数IEE754标准解析" class="headerlink" title="浮点数IEE754标准解析"></a>浮点数IEE754标准解析</h3><hr><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>格式</th><th>SEEEEEEE</th><th>EMMMMMMM</th><th>MMMMMMMM</th><th>MMMMMMMM</th></tr></thead><tbody><tr><td>二进制</td><td>01000000</td><td>10010000</td><td>00000000</td><td>00000000</td></tr><tr><td>十六进制</td><td>40</td><td>90</td><td>00</td><td>00</td></tr></tbody></table></div><ul><li><code>S</code>：符号位1表示正，0表示负</li><li><code>E</code>：指数部分，(指数部分的值规定只能是1到254，不能是全0，全1)，指数部分运算前都要减去127(这是EEE-754的规定)，因为还要表示负指数。这里的<code>10000001</code>转换为十进制数为129,129-127=2，即实际指数部分为2.<code>表示小数部分小数点往后移两位</code></li><li><code>M</code>：小数部分 <code>0010000 00000000 00000000</code> 左边默认省略了一个1，应该是<code>1.0010000 00000000 00000000(二进制数)</code></li></ul><blockquote><p>分析上面浮点数<br>S=0，表示正数<br>E=2^0+2^7-127=129-127=2,表示小数点向后移动两位<br>M=<code>0010000 00000000</code> ，前面默认有个1，<code>1.0010000 00000000 00000000</code><br>因为E，M小数点向后移动两位，<code>100.10000 00000000 00000000</code> =2^2 + 2^-1 =4.5</p></blockquote><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><hr><ul><li>浮点型变量分为单精度（float）型、双精度（double）型</li><li>float的数值范围：<code>2^-126~2^127</code>(因为指数部分值1~254，再减去127，得到的-126~127，也就是二进制位数小数点后126位，到小数点前127位)</li><li>float的精度：<code>6~7位</code></li><li>double数值范围：<code>2^-1022~2^1023</code></li><li>double的精度：<code>15~16位</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们赋给a的值为1.23456789e10,加20后，应该得到的值为1.234567892e10,</span><br><span class="line">但b输出结果却是b=12345678848.000000,变得更小了。我们将这种现象称为精度丢失，因</span><br><span class="line">为float型数据能够表示的有效数字为7位，最多只保证1.234567e10的正确性，要使结果正确，</span><br><span class="line">就需要把a和b均改为double型，因为double可以表示的精度为15~16位。</span><br></pre></td></tr></table></figure><code>int 溢出 可以考虑改用double存储</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg&quot; alt=&quot;北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jp</summary>
      
    
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C语言" scheme="https://fqzs.netlify.app/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git远程仓库</title>
    <link href="https://fqzs.netlify.app/undefined/3f8bae1e.html"/>
    <id>https://fqzs.netlify.app/undefined/3f8bae1e.html</id>
    <published>2023-04-09T18:20:00.000Z</published>
    <updated>2023-07-15T05:01:46.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg" alt="Uploading file...0i2ar"></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>当安装Git后首先要做的事情是设置用户名称和emailt地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息</p><ul><li><code>git config --global user.name &quot;itcast&quot;</code></li><li><code>git config --global user.email &quot;hello@iteast.cn&quot;</code></li></ul><p>查看用户信息</p><ul><li><code>git config --global user.name</code></li><li><code>git config --global user.email</code></li></ul><h1 id="获取本地仓库及其基础操作指令"><a href="#获取本地仓库及其基础操作指令" class="headerlink" title="获取本地仓库及其基础操作指令"></a>获取本地仓库及其基础操作指令</h1><ul><li>初始化仓库文件夹：<code>git init</code></li><li><code>git status</code>：查看的修改的状态（暂存区、工作区）</li><li><code>git add 单个文件名|通配符.</code>：工作区-&gt;暂存区</li><li><code>git commit -m &#39;注释内容&#39;</code>：暂存区-&gt;本地仓库的当前分支</li><li><code>git-log</code>：查看提交日志</li><li><code>git reset --hard commitID</code>：版本回退；commitID 可以使用 git-log 或 git log 指令查看</li><li><code>git push -f -u origin master</code>：把修改推送至远程</li><li><code>git branch</code>：查看本地分支</li><li><code>git branch 分支名</code>：创建本地分支</li><li><code>git checkout 分支名</code>：切换本地分支</li><li><code>git merge 分支名称</code>：一个分支上的提交合并到另一个分支上</li><li><code>git branch -d 分支名</code>：删除分支，不能删除当前分支<h1 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h1></li></ul><hr><ul><li>生成SSH公钥：<code>ssh-keygen -t rsa</code>   不断回车; 如果公钥已经存在，则自动覆盖</li><li>获取公钥：<code>cat ~/.ssh/id_rsa.pub</code></li><li>公钥获取后，将其添加到github仓库设置中，以获取推送权限</li><li>验证是否配置成功: <code>ssh-T:git@github.com</code></li></ul><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><hr><ul><li>命令：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354039.png" alt="image.png"></li></ul></li></ul><h1 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h1><hr><ul><li>命令：<code>git remote</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354389.png" alt="image.png"></li></ul><h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><hr><ul><li>命令：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>当前分支已经和远端分支关联，则可以省略分支名和远端名<code>git push</code></li><li><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<br><code>git push --set-upstream origin master</code></li></ul><h1 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h1><hr><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354898.png" alt="image.png"></li></ul><h1 id="从远程仓库抓取和拉取"><a href="#从远程仓库抓取和拉取" class="headerlink" title="从远程仓库抓取和拉取"></a>从远程仓库抓取和拉取</h1><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code> </li><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li><p>如果不指定远端名称和分支名，则抓取所有分支。</p></li><li><p>拉取 命令：<code>git pull [remote name] [branch name]</code></p></li><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul><h1 id="其他基础命令"><a href="#其他基础命令" class="headerlink" title="其他基础命令"></a>其他基础命令</h1><h2 id="查看当前仓库大小"><a href="#查看当前仓库大小" class="headerlink" title="查看当前仓库大小"></a>查看当前仓库大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354114.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg&quot; alt=&quot;Uploading file...0i2ar&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;基本</summary>
      
    
    
    
    
    <category term="git" scheme="https://fqzs.netlify.app/tags/git/"/>
    
  </entry>
  
</feed>
