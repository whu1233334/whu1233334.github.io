<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风起之时</title>
  
  
  <link href="https://fqzs.netlify.app/atom.xml" rel="self"/>
  
  <link href="https://fqzs.netlify.app/"/>
  <updated>2023-09-10T03:27:41.777Z</updated>
  <id>https://fqzs.netlify.app/</id>
  
  <author>
    <name>风起之时</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于一阶线性微分方程绝对值问题</title>
    <link href="https://fqzs.netlify.app/undefined/10a45d8c.html"/>
    <id>https://fqzs.netlify.app/undefined/10a45d8c.html</id>
    <published>2023-09-02T17:58:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082319443.png" alt="wallhaven-85g55j.png"></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在做某些微分方程问题时，有些题目的标准答案要加上绝对值，有些又不用加。按理说凡是涉及 ln 的我全加上就好了，但是加上绝对值又不便下一步计算，为此特地查阅一些资料，将考研数学微分方程中绝对值相关问题整理记录。</p><h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>开头提到的微分方程中绝对值问题其实本质上就是不定积分中对 <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021805380.png" alt="image.png">中绝对值的去留问题。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021806141.png" alt="image.png"></p><h1 id="分析与讨论"><a href="#分析与讨论" class="headerlink" title="分析与讨论"></a>分析与讨论</h1><p>对于<strong>例1</strong>很好分析，我们按照常规方式来求解。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021807007.png" alt="图片alt"> </p><p>此时由于 y= ±e<sup>C<sub>1</sub></sup>|x|，而如果我们令 ±e<sup>C<sub>1</sub></sup> =C<sub>2</sub>，此时上式可以写为 y=C<sub>2</sub>x，也就是说绝对值可以去掉，且C<sub>2</sub>≠0。<br>但是上述讨论不具有一般性，不够严谨，我们还可以通过判断<strong>函数族</strong>是否相同的方式来判断两个解函数是否为相等。<br><strong><em>那么现在问题描述如下：</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021815711.png" alt="image.png"></p><p>如此一来对于经过积分运算，得到形如 (1) 式的微分方程的通解，是否去掉绝对值，取决于我们的选择，若去掉绝对值（即表示为 (2) 式的形式）则需要先将对数函数变为指数函数，再更改C<sub>2</sub>的范围由任意常数到非零常数。</p><p>对于<strong>例2</strong>，求得的通解形式为 ln|y|<sup>2</sup> = ln|x| + C ,此时取对数y<sup>2</sup> = e<SUP>C&lt;/sup&gt;|x|，显然绝对值是无法直接去掉的</p><p>但是对于<strong>例3</strong>却并不能用上述结论，因为一阶线性微分方程的解</p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021824603.png" alt="图片alt"> </p><br>的函数族不同于 (1) 式确定的函数族。那么当我们遇到 这种情况，绝对值是否可以省？</p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021826510.png" alt="图片alt"> </p><br>下面经过分类讨论来证明 (6) 式中 e 右上角的对数函数内的绝对值符号可以省去，不影响一阶线性微分方程的解。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830584.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830314.png" alt="image.png"><br>所以<strong>例3</strong>中的绝对值可以去掉。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对形如 l n ∣ g ( x , y ) ∣ = φ ( x , y ) + C 的微分方程，可以通过变对数为指数，同时改变常数​C<sub>2</sub>的取值范围来去掉绝对值。对一阶线性微分方程通解同时，可以对 e 的右上角的指数同时去绝对值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082319443.png&quot; alt=&quot;wallhaven-85g55j.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;</summary>
      
    
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/categories/%E9%AB%98%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线代强化</title>
    <link href="https://fqzs.netlify.app/undefined/df063bf9.html"/>
    <id>https://fqzs.netlify.app/undefined/df063bf9.html</id>
    <published>2023-08-24T10:41:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082352925.png" alt="image.png"></p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><mark>主对角线与副对角线矩阵的值</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：主对角线的矩阵的值等于对角线元素相乘，而副对角线矩阵的值等于-1<sup>n(n-1)/2 </sup>a<sub>1,n </sub>a<sub>2,n-1 </sub>a<sub>3,n-2</sub>....a<sub>n,1</sub></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt=""></p><p><mark>含有x的行列式的求导数，等于逐行求导，相加</mark></p><div style="background-color: #fffacd;padding:20px;"> 证明过程很简单，不过不重要</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241044514.png" alt="Uploading file...x8n1s"></p><p><mark>爪型行列式的计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：爪型行列式的特点是，只有第一行，第一列全部不为0，像一个箭头，这种行列式转化为上三角或下三角矩阵</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241112575.png" alt="image.png"></p><p><mark>“么”型行列式计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 么型行列式按照，展开""么"那一“横”，计算就十分简单</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241130123.png" alt="image.png"></p><p><mark>加边法计算行列式</mark></p><div style="background-color: #fffacd;padding:20px;"> "加边法"适合<font color="#FF0000">有规律的数</font>当加一行可以消去很多的行时，可以用加边法</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241136486.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241137978.png" alt="image.png"></p><p><mark style="background-color: #FFB6C1;">梭型行列式计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 按照第一行展开D<sub>n</sub>=4D<sub>n-1</sub> - 3D<sub>n-2</sub> 得到 D<sub>n</sub>-D<sub>n-1</sub>=3(D<sub>n-1</sub> - D<sub>n-2</sub>) 。递推得到<br>D<sub>n</sub>-D<sub>n-1</sub>=3<sup></sup>(D<sub>n-1</sub>- D<sub>n-2</sub>)<br>D<sub>n-1</sub>-D<sub>n-2</sub>=3<sup></sup>(D<sub>n-2</sub>- D<sub>n-3</sub>)<br>.......<br>D<sub>3</sub>- D<sub>2</sub>=3<sup></sup>(D<sub>2</sub>- D<sub>1</sub>)<br><font color="#FF0000">所以D<sub>n</sub>-D<sub>n-1</sub>=3<sup>n-2</sup>(D<sub>2</sub> - D<sub>1</sub>)=3<sup>n</sup></font><br>D<sub>n</sub>-D<sub>n-1</sub>=3<sup>n</sup><br>D<sub>n-1</sub>-D<sub>n-2</sub>=3<sup>n-1</sup><br>.......<br>D<sub>3</sub>- D<sub>2</sub>=3<sup>3</sup><br>D<sub>2</sub>- D<sub>1</sub>=3<sup>2</sup><br><font color="#FF0000">等比数列相加得D<sub>n</sub> - D<sub>1</sub> 即可计算出D<sub>n</sub> </font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241237733.png" alt=""></p><h1 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h1><p><mark>错误命题</mark></p><div style="background-color: #fffacd;padding:20px;"> 倒推并不成立，下面是一个反例</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241530903.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241532838.png" alt="image.png"></p><p><mark>坍缩矩阵</mark> </p><font color="#FF0000">坍缩矩阵每次与自己相乘，有效信息都会被往外挤一次</font><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241645861.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;">利用坍缩矩阵性质求下列问题？</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241645221.png" alt="image.png"></p><p><mark>秩为1的矩阵</mark></p><div style="background-color: #fffacd;padding:20px;">矩阵秩为1，对应每一行都成比例，有下面这样的一个结论 <br><center>A<sup>n</sup>= <cite>l</cite><sup>n-1</sup>A </center><li><cite>l</cite> 是A对角线元素之和</li></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241650052.png" alt="image.png"></p><p><mark>若A=αβ<sup>T</sup>，r(A)=1</mark></p><div style="background-color: #fffacd;padding:20px;"><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031937096.png" alt="图片alt"> </p> </div><p><mark>求一个矩阵与另一个矩阵的逆矩阵相乘AP<sup>-1</sup></mark></p><div style="background-color: #fffacd;padding:20px;">已知矩阵A、P但是P的逆矩阵未知，所以可以先求出P<sup>-1</sup>,再矩阵相乘。不过更好的方法是将P/A 竖的写在一起，将P通过列变换为E ,对于A来说，相当于乘了一个P<sup>-1</sup>,那么A就变成了B</div><p><mark>结论A<sup>T</sup>+B<sup>T</sup>= (A+B)<sup>T</sup></mark></p><p><mark style="background-color: #FFB6C1;">向量的线性组合写成矩阵的乘法，</mark></p><div style="background-color: #ffe599;padding:15px;"> B是A的线性组合，写成两矩阵相乘形式，可以直观分离出矩阵A和所做的线性变换</div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242056948.png" alt="Uploading file...q2o0q"></p><p><mark>伴随矩阵的重要性质</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>A<sup>*</sup>A=AA<sup>*</sup>=|A| E  <mark style="background-color: #FFB6C1;">=></mark> A<sup>*</sup>= |A| A<sup>-1</sup></li><li>伴随矩阵的秩  n  、1 、 0</li></div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242119009.png" alt="image.png"></p><p><mark>抽象矩阵求逆</mark> <mark style="background-color: #FFB6C1;">有难度</mark></p><div style="background-color: #fffacd;padding:20px;"> 抽象矩阵求逆，题目中要求 (A+E)<sup>-1</sup><br>必然需要能通过题目得到一个等式 (A+E)(....)=E<br><li>(...)里的必然与A有关，相乘必然得到A<sup>2</sup>,所以先求A<sup>2</sup></li><li>求出A<sup>2</sup>-4A=-3E，利用多项式除法凑出括号里的因式</li></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242151041.png" alt="image.png"></p><p><mark>综合表</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242202685.png" alt="image.png"></p><h1 id="初等矩阵、秩、分块矩阵"><a href="#初等矩阵、秩、分块矩阵" class="headerlink" title="初等矩阵、秩、分块矩阵"></a>初等矩阵、秩、分块矩阵</h1><p><mark>初等矩阵</mark>是<mark>单位矩阵</mark>经过<mark>一次初等变化后得到的矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>初等对换矩阵E<sub>i,j</sub> : 由单位矩阵，交换i,j行或列得到</li><li>初等倍乘矩阵E<sub>i</sub>(k) ：由单位矩阵，第i行或列乘k倍得到(k!=0)</li><li>初等倍乘矩阵E<sub>i,j</sub>(k)：由单位矩阵，第i行+k*第j行得到 或 第 j列+k*第i列</li><br><mark style="background-color: #FFB6C1;">重要</mark>：E<sub>i,j</sub>(k)A是对A做 行变化；AE<sub>i,j</sub>(k)是对A做 列变化</div><div style="background-color: #fffacd;padding:20px;"> <li> E<sub>i,j</sub><sup>-1</sup> = E<sub>i,j</sub></li><li>E<sub>i</sub>(k)<sup>-1</sup>=E<sub>i</sub>(1/k)</li><li>E<sub>i,j</sub>(k)<sup>-1</sup>=E<sub>i,j</sub>(-k)</li><br><li> E<sub>i,j</sub><sup>T</sup> = E<sub>i,j</sub></li><li>E<sub>i</sub>(k)<sup>T</sup>=E<sub>i</sub>(k)</li><li>E<sub>i,j</sub>(k)<sup>T</sup>=E<sub>j,i</sub>(k)</li></div><p><mark>AB=O</mark></p><div style="background-color: #fffacd;padding:20px;">正规证明： 当矩阵A、B相乘得到零矩阵，可以想象A<sub>(mxn)</sub>是系数矩阵，B<sub>(nxm)</sub>是解向量矩阵；<font color="#FF0000">一个齐次线性方程组的线性无关解向量数=n-r(A)</font> <br>简便记忆：标准型记忆法</div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281134787.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281241592.png" alt="图片alt"> </p><p><strong>例题</strong>：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281240608.png" alt="image.png"></p><p><mark>重要结论：r(AA<sup>T</sup>)=r(A<sup>T</sup>A)=r(A)</mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281150001.png" alt="图片alt"> </p><p><mark style="background-color: #FFB6C1;">分块矩阵的结论</mark></p><div style="background-color: #fffacd;padding:20px;"> 合理利用矩阵分块，将矩阵分块成更小的方阵，可以简便计算</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281311896.png" alt="image.png"></p><p><mark style="background-color: #FFB6C1;">二阶矩阵的逆矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> 主 对调；副 变号</div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281407149.png" alt="图片alt"> </p><p><mark>左行右列，BA=C</mark></p><div style="background-color: #fffacd;padding:20px;"> 将矩阵B看做一种线性变换。<br>BA可由 A经过B行变换得到；<br>但是反过来A不一定可由BA经过B<sup>-1</sup>行变换得到，因为B不一定可逆。<br>所以下面这个式子中，BA可以被上面的A经过行变换后逐项消去</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281449983.png" alt="image.png"></p><p><strong>例题</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281624716.png" alt="image.png"></p><h1 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h1><p><mark>向量组等价</mark></p><div style="background-color: #fffacd;padding:20px;"> 矩阵等价，只需要两矩阵秩相等；<br>向量组等价，需要两向量组A: α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>...α<sub>n</sub>与向量组B：β<sub>1</sub>,β<sub>2</sub>,β<sub>3</sub>...β<sub>m</sub>,可以互相线性表示，也就是r(A,B)=r(A)=r(B),对于A来说B的任何一个向量加入都是混子，对于B来说A的任何一个向量加入都是混子</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281954916.png" alt="image.png"></p><p><mark>问题：已知α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>线性无关，判断下列是否线性无关？</mark></p><div style="background-color: #ffe599;padding:15px;"> 请判断α<sub>1</sub>+α<sub>2</sub>+α<sub>3</sub>，α<sub>1</sub>+2α<sub>2</sub>-3α<sub>3</sub>，α<sub>1</sub>+5α<sub>3</sub>是否线性无关？<br><br><font color="#FF0000">思路1：</font>凑系数k1,k2,k3，当只有k1,k2,k3全为0时才满足k1(α<sub>1</sub>+α<sub>2</sub>+α<sub>3</sub>)+k2(α<sub>1</sub>+2α<sub>2</sub>-3α<sub>3</sub>)+k3(α<sub>1</sub>+5α<sub>3</sub>)=0,这时向量组就是线性无关的，都是无法相互消去的<br><br><font color="#FF0000">思路2：</font>像这种比较难凑，写成矩阵相乘，将线性变换用矩阵写出，然后根据r(α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>)=3，所以相乘矩阵的秩=后面的线性变换矩阵的秩，计算行列式，如果不等于0，说明满秩，从而向量组线性无关</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308282128367.png" alt="image.png"></p><p><mark>用定义法证明向量组线性无关</mark> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291034365.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;">解：令k<sub>1</sub>α<sub>1</sub>+k<sub>2</sub>α<sub>2</sub>+k<sub>3</sub>α<sub>3</sub>=0 ① <br><center>两边同乘A</center>    k<sub>1</sub>Aα<sub>1</sub> + k<sub>2</sub>Aα<sub>2</sub> + k<sub>3</sub>Aα<sub>3</sub>= k<sub>1</sub>α<sub>1</sub> + k<sub>2</sub>(α<sub>1</sub> + α<sub>2</sub>) + k<sub>3</sub>(α<sub>2</sub>+α<sub>3</sub>)=0  ②<center>②-①得</center>k<sub>2</sub>α<sub>1</sub> + k<sub>3</sub>α<sub>2</sub>=0 ③ <center>两边再次同乘A</center>k<sub>2</sub>Aα<sub>1</sub> + k<sub>3</sub>Aα<sub>2</sub>= k<sub>2</sub>α<sub>1</sub> + k<sub>3</sub>(α<sub>1</sub>+α<sub>2</sub>) =0 ④ <center>④-③得</center>k<sub>3</sub>α<sub>1</sub>=0，由于α<sub>1</sub>!=0,所以k<sub>3</sub>=0,往回代入，求得k<sub>2</sub>=0，k<sub>1</sub>=0,所以三个向量线性无关</div><mark>求一个向量在以另一组向量作为基底下，的坐标</mark><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291233458.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;">就是求x<sub>1</sub>α<sub>1</sub> + x<sub>2</sub>α<sub>2</sub> + x<sub>3</sub>α<sub>3</sub> = α，α在基底下的坐标就是(x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>)<br>1.可以直接列方程解；2.也可以作为非齐次方程求解<br><br><font color="#FF0000">注：一组基，一定是一组线性无关的向量</font></div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291247167.png" alt="图片alt"> </p><p><mark>过渡矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> AP=B,则称，A过渡到B的过渡矩阵是P </div><h1 id="线性方程组求解"><a href="#线性方程组求解" class="headerlink" title="线性方程组求解"></a>线性方程组求解</h1><p><mark>典型例题</mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291500199.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291709453.png" alt="图片alt"> </p><p><mark>若AB=O,则r(A)+r(B)≤n  </mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291629673.png" alt="图片alt"> </p><p><mark>典型例题2</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291757672.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291901198.png" alt="图片alt"> </p></div><p><mark>两个方程有公共解问题</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292048495.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292120045.png" alt="图片alt"> </p></div><p><mark>两个方程组有同解问题</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292156785.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> ①两方程组，同解，那么基础解系个数一定相等，分别求出两线性方程矩阵的秩；<br>②然后再根据其中一个方程，求出解系，代入另外一个方程，使得等式恒成立<br>③求出结果，带回去验证秩是否符合<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292159880.png" alt="图片alt"> </p></div><h1 id="公共解、同解与特征值特征向量"><a href="#公共解、同解与特征值特征向量" class="headerlink" title="公共解、同解与特征值特征向量"></a>公共解、同解与特征值特征向量</h1><div style="background-color: #fffacd;padding:20px;"> 对于任何一个矩阵，矩阵对角线系数之和=它的特征值之和</div>![](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111542797.png)<mark>解特征值，特征向量的方法</mark><div style="background-color: #fffacd;padding:20px;"> 方法1.常规方式，解非齐次方程<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031407519.png" alt="图片alt"> </p><br>方法2.技巧性方法<br>①.这题的矩阵A可以拆开为一个秩为1的矩阵  B-E<br>②r(B)=1，特征值0, 0，λ<sub>3</sub><br>③利用对角线元素之和=特征值之和=6，所以λ<sub>3</sub>=6<br>④A=B-E，Aα=Bα-Eα ，λ<sub>A</sub>α=λ<sub>B</sub>α - α，所以λ<sub>A</sub>=λ<sub>B</sub>-1，对应特征值是一样的<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031437515.png" alt="图片alt"> </p></div><p><mark>各种矩阵的特征值</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031618236.png" alt="image.png"></p><p><mark>很经典的一道题</mark></p><div style="background-color: #fffacd;padding:20px;"> 考察伴随矩阵的特征值之和<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309032041923.png" alt="图片alt"> </p> </div><p><mark>判断一个矩阵A可否对角化</mark></p><div style="background-color: #fffacd;padding:20px;">1.证明存在三个线性无关的特征向量，能组成P，使得P<sup>-1</sup>AP=∧ <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309040824393.png" alt="图片alt"> </p></div><p><mark>特征值不是重根的特征向量的组合，求其特征值</mark></p><div style="background-color: #fffacd;padding:20px;">对于P=(α<sub>1</sub>  α<sub>2</sub>  α<sub>3</sub>), 它是A的特征向量组成的矩阵，对应的特征值分别为λ<sub>1</sub>、λ<sub>2</sub>、λ<sub>3</sub>，则有AP=λP  ==>  P<sup>-1</sup>AP=∧<sub>p</sub><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309050922183.png" alt="图片alt"> </p></div><p><mark>典型例题</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309050948357.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309050949301.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309050951483.png" alt="图片alt"> </p></div><h1 id="实对称矩阵与二次型的标准型"><a href="#实对称矩阵与二次型的标准型" class="headerlink" title="实对称矩阵与二次型的标准型"></a>实对称矩阵与二次型的标准型</h1><p><mark>实对称矩阵性质</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>若A是实对称矩阵，则一定可以对角化即P<sup>-1</sup>AP = ∧，且P内各向量组是相互正交的</li><li>实对称矩阵进行相似变换的矩阵P的各个向量是正交，所以将P单位化成一个正交矩阵Q，可以使得Q<sup>-1</sup>AQ=∧</li><li>又因为正交矩阵有性质Q<sup>-1</sup>=Q<sup>T</sup>，所以Q<sup>T</sup>AQ = ∧，称之为合同对角化</li></div><p><mark>例题</mark></p><div style="background-color: #fffacd;padding:20px;"> 这里A有两个特征值，0,-1。又因为r(A)=3，所以他的对角矩阵的秩也等于3，那么只能是3个-1 </div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051051560.png" alt="image.png"></p><p><mark>矩阵的正交化合单位化</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051132633.png" alt="image.png"></p><p><mark>求方阵的幂次A<sup>n</sup></mark></p><div style="background-color: #fffacd;padding:20px;"> <li>方法1.利用方阵成比例，如果方阵成比例，r(A)=1, A<sup>n</sup>=l<sup>n-1</sup>A</li><li>方法2.利用对角化，P<sup>-1</sup>AP=∧，则A=P∧P<sup>-1</sup>,则A<sup>n</sup>=P ∧<sup>n </sup> P<sup>-1</sup></li></div><p><mark>二次型的基本概念</mark></p><div style="background-color: #fffacd;padding:20px;"> 1.一般型 <font color="#FF0000">f(x)=X<sup>T</sup>AX </font><br>2.标准型 <font color="#FF0000">X<sup>T</sup>AX = X<sup>T</sup>P<sup>-1</sup> ∧ PX = Y<sup>T</sup>∧Y  【X=PY就是正交变换，P为正交矩阵】</font><br>3.规范型 <font color="#FF0000">换元对角线系数全为1</font></div><p><mark>解二次型问题</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051722209.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051724270.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051724604.png" alt="图片alt"> </p>解二次型，一般先转换为标准型，解出Y，利用正交变换解出X<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051725304.png" alt="图片alt"> </p></div><p><mark>例题</mark></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309051910925.png" alt="图片alt"> </p></div><h1 id="二次型的正定性与合同"><a href="#二次型的正定性与合同" class="headerlink" title="二次型的正定性与合同"></a>二次型的正定性与合同</h1><p><mark>正定二次型的判定</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>二次型f(x)=X<sup>T</sup>AX,对于任意x取值，都为正，就称之为正定</li> <li>所以正定的二次型，配方转换为标准型(只有平方项)，那么平方项系数都大于0</li><li>另外还能通过各阶主子式都大于0，确认正定</li><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071215239.png" alt="图片alt"> </p></div><p><mark>区分等价、相似、合同之间的关系</mark></p><div style="background-color: #fffacd;padding:20px;"> 假设P、Q可逆<li>等价：PAQ=B，称A与B等价</li> <li>相似：P<sup>-1</sup>AP=B，称A于B相似</li><li>合同：P<sup>T</sup>AP=B，称A与B合同【<font color="#0000FF">注：一般只考察二次型的合同</font>】</li><br><br>那要如何判断两个二次型是否合同？<br><font size="2.5"><br>1与二次型矩阵合同的矩阵一定也是一个对称矩阵因为P<sup>T</sup>AP=B，则B<sup>T</sup>=P<sup>T</sup>AP=B，得先满足这个条件<br>2.满足上述条件后，如果两个二次型对应的标准型的正负号相同(特征值的符号相同)，那么就是这两个二次型合同的</font></div><p><mark>若A是方阵，α是向量则，Aα，任然是一个向量</mark></p><p><mark>典型例题</mark></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071607583.png" alt="图片alt"> </p></div><h1 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082352925.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;行列式&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="线代" scheme="https://fqzs.netlify.app/categories/%E7%BA%BF%E4%BB%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构打卡</title>
    <link href="https://fqzs.netlify.app/undefined/11e6645a.html"/>
    <id>https://fqzs.netlify.app/undefined/11e6645a.html</id>
    <published>2023-08-24T00:09:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082317124.png" alt="wallhaven-zypzdj.png"></p><h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a><em>树的应用</em></h1><h2 id="二叉树的定义、性质、画图"><a href="#二叉树的定义、性质、画图" class="headerlink" title="二叉树的定义、性质、画图"></a>二叉树的定义、性质、画图</h2><h3 id="总结二叉树的度、树高、结点数等属性之间的关系"><a href="#总结二叉树的度、树高、结点数等属性之间的关系" class="headerlink" title="总结二叉树的度、树高、结点数等属性之间的关系"></a>总结二叉树的度、树高、结点数等属性之间的关系</h3><blockquote><p>通过王道书 5.2.3 课后小题来复习“二叉树的性质”</p></blockquote><h3 id="定义顺序存储的二叉树—下标从1开始"><a href="#定义顺序存储的二叉树—下标从1开始" class="headerlink" title="定义顺序存储的二叉树—下标从1开始"></a><em>定义顺序存储的二叉树—下标从1开始</em></h3><blockquote><p>二叉树顺序存储的数据结构定义，需要注意以下两点：<br> 1 .二叉树的结点用数组存储，每个结点需要标记“是否为空”<br> 2.各结点的数组下标隐含结点关系，要能根据一个结点的数组下标 i，计算出其父节点、左孩子、右孩子的数组下标</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">若顺序二叉树从数组下标1开始存储结点，则：</span><br><span class="line"></span><br><span class="line">● 结点 i 的父结点编号为 i/2</span><br><span class="line">● 结点 i 的左孩子编号为 i*2</span><br><span class="line">● 结点 i 的右孩子编号为 i*2+1</span><br><span class="line"></span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data; <span class="comment">//结点中的数据元素</span></span><br><span class="line"><span class="type">bool</span> isEmpty; <span class="comment">//结点是否为空</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序存储的二叉树，所有结点标记为&quot;空&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqBiTree</span> <span class="params">(TreeNode t[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">   t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现函数，找到结点-i-的父结点、左孩子、右孩子"><a href="#实现函数，找到结点-i-的父结点、左孩子、右孩子" class="headerlink" title="实现函数，找到结点 i 的父结点、左孩子、右孩子"></a><em>实现函数，找到结点 i 的父结点、左孩子、右孩子</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断下标为 index 的结点是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= length || index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//下标超出合法范围</span></span><br><span class="line"><span class="keyword">return</span> t[index].isEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的左孩子，并返回左孩子的下标，如果没有左孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> lChild = index * <span class="number">2</span>; <span class="comment">//如果左孩子存在，则左孩子的下标一定是 index * 2</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, lChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//左孩子为空</span></span><br><span class="line"><span class="keyword">return</span> lChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的右孩子，并返回右孩子的下标，如果没有右孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> rChild = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//如果右孩子存在，则右孩子的下标一定是 index * 2 + 1</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, rChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//右孩子为空</span></span><br><span class="line"><span class="keyword">return</span> rChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的父节点，并返回父节点的下标，如果没有父节点，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFather</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//根节点没有父节点</span></span><br><span class="line"><span class="type">int</span> father = index / <span class="number">2</span>; <span class="comment">//如果父节点存在，则父节点的下标一定是 index/2，整数除法会自动向下取整</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, father)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> father;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用上述三个函数，实现先-中-后序遍历"><a href="#利用上述三个函数，实现先-中-后序遍历" class="headerlink" title="利用上述三个函数，实现先/中/后序遍历"></a><em>利用上述三个函数，实现先/中/后序遍历</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从下标为 index 的结点开始先序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">PreOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">InOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//中序遍历左子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">InOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PostOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//后序遍历左子树</span></span><br><span class="line">PostOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//后序遍历右子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...在空二叉树中插入数据</span></span><br><span class="line"><span class="comment">//...略</span></span><br><span class="line">InOrderSqTree (t, <span class="number">100</span>, <span class="number">1</span>); <span class="comment">//从根节点1出发，进行中序遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义顺序存储的二叉树（从数组下标0开始存储）"><a href="#定义顺序存储的二叉树（从数组下标0开始存储）" class="headerlink" title="定义顺序存储的二叉树（从数组下标0开始存储）"></a><em>定义顺序存储的二叉树（从数组下标0开始存储）</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">与 上面思路相同，只不过结点编号的计算有些区别而已</span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><h3 id="定义链式存储的二叉树"><a href="#定义链式存储的二叉树" class="headerlink" title="定义链式存储的二叉树"></a><em>定义链式存储的二叉树</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  树的定义、性质、画图</span><br><span class="line"></span><br><span class="line">### *用双亲表示法定义顺序存储的树*</span><br><span class="line">![image.png](https:<span class="comment">//cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231706440.png)</span></span><br><span class="line">###  使用“孩子表示法”，定义链式存储的树（以及森林）</span><br><span class="line">![image.png](https:<span class="comment">//cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231733631.png)</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">//Child表示下一个孩子的信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Child&#123;</span><br><span class="line"><span class="type">int</span> index; <span class="comment">//孩子编号</span></span><br><span class="line"><span class="keyword">struct</span> Child * next; <span class="comment">//下一个孩子</span></span><br><span class="line">&#125; Child;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeNode用于保存结点信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line"><span class="type">char</span> data; <span class="comment">//结点信息</span></span><br><span class="line">    Child * firstChild; <span class="comment">//指向第一个孩子</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode tree[<span class="number">10</span>]; <span class="comment">//定义一棵拥有10个结点的树（孩子表示法）</span></span><br></pre></td></tr></table></figure><h3 id="使用“孩子兄弟表示法”，定义链式存储的树（以及森林）"><a href="#使用“孩子兄弟表示法”，定义链式存储的树（以及森林）" class="headerlink" title="使用“孩子兄弟表示法”，定义链式存储的树（以及森林）"></a>使用“孩子兄弟表示法”，定义链式存储的树（以及森林）</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231733226.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">ElemType data;     <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span> <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><h3 id="总结树的度、树高、结点数等属性之间的关系"><a href="#总结树的度、树高、结点数等属性之间的关系" class="headerlink" title="总结树的度、树高、结点数等属性之间的关系"></a>总结树的度、树高、结点数等属性之间的关系</h3><blockquote><p>通过王道书 5.1.4、5.4.4 课后小题来复习“树和森林的性质”</p></blockquote><h2 id="树的定义、性质、画图"><a href="#树的定义、性质、画图" class="headerlink" title="树的定义、性质、画图"></a>树的定义、性质、画图</h2><h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><h3 id="实现并查集的数据结构定义，并实现-Union、Find-两个基本操作"><a href="#实现并查集的数据结构定义，并实现-Union、Find-两个基本操作" class="headerlink" title="实现并查集的数据结构定义，并实现 Union、Find 两个基本操作"></a>实现并查集的数据结构定义，并实现 Union、Find 两个基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE]; <span class="comment">//用一个数组表示并查集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find “查”操作，找x所属集合（返回x所属根结点）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>) <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作，将两个集合合并为一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">   <span class="comment">//要求Root1与Root2是不同的集合</span></span><br><span class="line">   <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可采取“小树合并到大树”的策略优化 Union操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union “并”操作，小树合并到大树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(S[Root2]&gt;S[Root1]) &#123; <span class="comment">//Root2结点数更少</span></span><br><span class="line">       S[Root1] += S[Root2]; <span class="comment">//累加结点总数</span></span><br><span class="line">       S[Root2]=Root1; <span class="comment">//小树合并到大树</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">S[Root2] += S[Root1]; <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1]=Root2; <span class="comment">//小树合并到大树      </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可采取“路径压缩”的策略优化 Find 操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作优化，先找到根节点，再进行“压缩路径”</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> root = x;</span><br><span class="line"><span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)  root=S[root]; <span class="comment">//循环找到根</span></span><br><span class="line"><span class="keyword">while</span>(x!=root)&#123; <span class="comment">//压缩路径</span></span><br><span class="line"><span class="type">int</span> t=S[x]; <span class="comment">//t指向x的父节点</span></span><br><span class="line">S[x]=root; <span class="comment">//x直接挂到根节点下</span></span><br><span class="line">x=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root; <span class="comment">//返回根节点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计一个例子，对10个元素-Union"><a href="#设计一个例子，对10个元素-Union" class="headerlink" title="设计一个例子，对10个元素 Union"></a>设计一个例子，对10个元素 Union</h3><p>假设初始长度为 10 （ 0 ～ 9 ）的并查集，按 1-2、3-4、5-6、7-8、 0-5 、1-9、9-3、8-0、4-6 的顺序进行Union操作<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232246922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232247420.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232247735.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232248314.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232248446.png" alt="image.png"></p><h3 id="基于上述例子，进行若干次-Find，并完成“压缩路径”"><a href="#基于上述例子，进行若干次-Find，并完成“压缩路径”" class="headerlink" title="基于上述例子，进行若干次 Find，并完成“压缩路径”"></a>基于上述例子，进行若干次 Find，并完成“压缩路径”</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232249488.png" alt="image.png"></p><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a><em>图的应用</em></h1><h2 id="图数据结构的定义"><a href="#图数据结构的定义" class="headerlink" title="图数据结构的定义"></a><em>图数据结构的定义</em></h2><h3 id="写代码：定义一个顺序存储的图（邻接矩阵实现）"><a href="#写代码：定义一个顺序存储的图（邻接矩阵实现）" class="headerlink" title="写代码：定义一个顺序存储的图（邻接矩阵实现）"></a>写代码：定义一个顺序存储的图（邻接矩阵实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                  <span class="comment">//顶点最大数目</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> Vex[MaxVertexNum];               <span class="comment">//顶点</span></span><br><span class="line"><span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//边</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum;                    <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h3 id="写代码：定义一个链式存储的图（邻接表实现）"><a href="#写代码：定义一个链式存储的图（邻接表实现）" class="headerlink" title="写代码：定义一个链式存储的图（邻接表实现）"></a>写代码：定义一个链式存储的图（邻接表实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> vexIndex;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="type">int</span> weight;            <span class="comment">//该弧的权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;  <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">VNode vex[N]       <span class="comment">//N个顶点</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum; <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph;              <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure><h3 id="自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231819084.png" alt="image.png"></p><h3 id="自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231820810.png" alt="image.png"></p><h2 id="图的应用：最小生成树"><a href="#图的应用：最小生成树" class="headerlink" title="图的应用：最小生成树"></a><em>图的应用：最小生成树</em></h2><h3 id="自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231830567.png" alt="image.png"></p><h3 id="基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"><a href="#基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价" class="headerlink" title="基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"></a>基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从顶点0开始，运行 Prim 算法的过程如下：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231834367.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从顶点7开始，运行 Prim 算法的过程如下。这里想强调的是：当同时有两个代价相同的顶点时，优先将编号小的顶点加入MST。如：第 1 轮从顶点7出发，与其相连的顶点3、顶点5代价都是最小的，优先选择编号更小的顶点3。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231835740.png" alt="image.png"></p><h3 id="基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"><a href="#基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价" class="headerlink" title="基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"></a>基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231837287.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Kruskal 算法的执行过程是：先将各条边按照权值递减的排序，再按顺序依次检查是否将这些边加入MST。各条边排序结果如下：</span><br><span class="line"></span><br><span class="line">( 2 ,4 ) ——权值 1</span><br><span class="line"></span><br><span class="line">( 2, 5 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 3, 7 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 5, 7 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 0, 3 ) ——权值 5</span><br><span class="line"></span><br><span class="line">( 6, 7 ) ——权值 5</span><br><span class="line"></span><br><span class="line">( 5, 6 ) ——权值 6</span><br><span class="line"></span><br><span class="line">( 1, 2 ) ——权值 9</span><br><span class="line"></span><br><span class="line">可见，当多条边的权值相同时，“起点”编号更小的边排在前面。因此，在Kruskal算法的第2轮中，虽然有3条边 (2,5) (3,7) (5,7) 的权值都是最小的，但算法会优先选择将排序靠前的 (2,5) 加入MST。</span><br></pre></td></tr></table></figure><h2 id="图的应用：最短路径"><a href="#图的应用：最短路径" class="headerlink" title="图的应用：最短路径"></a><em>图的应用：最短路径</em></h2><h3 id="基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程"><a href="#基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程" class="headerlink" title="基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程"></a>基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程</h3><blockquote><p>下面将从顶点1出发，执行 Dijkstra 算法<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232118172.png" alt="image.png"></p></blockquote><p>注1：如果题目让你描述迪杰斯特拉算法的执行过程，可以试着模仿王道书画一张表。如下所示。你会发现这个表画起来很崩溃，复杂的飞起。相信我，老师改卷也不愿意改这么复杂的答案。因此，考场上不太可能让你画这么复杂的表。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>顶点（这一列不包含起点）</td><td>第 1 轮</td><td>第 2 轮</td><td>第 3 轮</td><td>第 4 轮</td><td>第 5 轮</td><td>第 6 轮</td><td>第 7 轮</td></tr><tr><td>0</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr><tr><td>2</td><td>4<br><br>1→2</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>3</td><td>∞</td><td>∞</td><td>7<br><br>1→5→3</td><td>7<br><br>1→5→3</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>4</td><td>∞</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>已完成</td><td>已完成</td></tr><tr><td>5</td><td>5<br><br>1→5</td><td>5<br><br>1→5</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>6</td><td>5<br><br>1→6</td><td>5<br><br>1→6</td><td>5<br><br>1→6</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>7</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>14<br><br>1→2→4→7</td><td>已完成</td></tr><tr><td>集合S</td><td>{1, 2}</td><td>{1,2,5}</td><td>{1,2,5,6}</td><td>{1,2,5,6,3}</td><td>{1,2,5,6,3,4}</td><td>{1,2,5,6,3,4,7}</td><td>{1,2,5,6,3,4,7,0}</td></tr></tbody></table></div><p>注2：以下是一种更适合考试的“简洁答题方法”。自己打草稿，快速确定每一轮Dijkstra算法的运行结果，然后按下面这种方式答题到试卷上。</p><blockquote><p>答：<br>从顶点1出发，运行迪杰斯特拉算法的过程如下：<br>第一轮：顶点1到2的最短路径为 1→2，距离为4<br>第二轮：顶点1到5的最短路径为 1→5，距离为5<br>第三轮：顶点1到6的最短路径为 1→6，距离为5<br>第四轮：顶点1到3的最短路径为 1→5→3，距离为7<br>第五轮：顶点1到4的最短路径为 1→2→4，距离为13<br>第六轮：顶点1到7的最短路径为 1→2→4→7，距离为14<br>第七轮：不存在顶点1到0的路径，距离为∞</p></blockquote><h2 id="图的应用：拓扑排序"><a href="#图的应用：拓扑排序" class="headerlink" title="图的应用：拓扑排序"></a><em>图的应用：拓扑排序</em></h2><h3 id="自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子"><a href="#自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子" class="headerlink" title="自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子"></a>自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231849895.png" alt="image.png"></p><h3 id="用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储"><a href="#用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储" class="headerlink" title="用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储"></a>用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储</h3><p><em>注：有向无环图，一定可以转化为一个上三角或下三角矩阵。但是需要调整顶点的编号。</em><br><em>如果要用上三角矩阵表示有向无环图的邻接矩阵，<strong>可以对图进行拓扑排序，按照拓扑排序序列，重新调整各个顶点的编号。这样可以确保，所有的弧都是从小编号顶点指向大编号顶点，从而也就保证了邻接矩阵可以转化为“上三角矩阵”</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231852642.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231851554.png" alt="image.png"></p><p>“上三角矩阵”可以按行优先压缩存储，如下所示：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231852474.png" alt="image.png"></p><h3 id="基于你设计的带权有向无环图，写出所有合法的拓扑排序序列"><a href="#基于你设计的带权有向无环图，写出所有合法的拓扑排序序列" class="headerlink" title="基于你设计的带权有向无环图，写出所有合法的拓扑排序序列"></a>基于你设计的带权有向无环图，写出所有合法的拓扑排序序列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231854808.png" alt="image.png"></p><p>拓扑排序序列1：0,1,2,3,4,5,6,7</p><p>拓扑排序序列2：0,1,2,3,5,4,6,7</p><p>拓扑排序序列3：0,1,2,4,3,5,6,7</p><p>拓扑排序序列4：0,1,4,2,3,5,6,7</p><h3 id="文字描述：拓扑排序的过程"><a href="#文字描述：拓扑排序的过程" class="headerlink" title="文字描述：拓扑排序的过程"></a>文字描述：拓扑排序的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231854579.png" alt="image.png"></p><h2 id="图的应用：关键路径"><a href="#图的应用：关键路径" class="headerlink" title="图的应用：关键路径"></a><em>图的应用：关键路径</em></h2><h3 id="基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度"><a href="#基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度" class="headerlink" title="基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度"></a>基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231856300.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用手算的方式求关键路径，就是要找到从起点到终点的所有路径中最长的那条。</span><br><span class="line"></span><br><span class="line">在上面这个图中，起点是0，终点是7，从0到7最长的路径是 0→1→2→3→5→6→7，关键路径总长度为 25</span><br></pre></td></tr></table></figure><h3 id="文字描述：关键路径总长度的现实意义是什么？"><a href="#文字描述：关键路径总长度的现实意义是什么？" class="headerlink" title="文字描述：关键路径总长度的现实意义是什么？"></a>文字描述：关键路径总长度的现实意义是什么？</h3><p>AOE网可以表示一个项目，每个顶点表示事件，每个有向边表示活动。关键路径的总长度为25，意味着从启动项目到完成该项目，时间开销至少需要25。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231858516.png" alt="image.png"></p><h1 id="查找算法的分析和应用"><a href="#查找算法的分析和应用" class="headerlink" title="查找算法的分析和应用"></a>查找算法的分析和应用</h1><blockquote><p>考研大纲中，要求我们掌握的查找算法是：</p></blockquote><ol><li>顺序查找</li><li>分块查找</li><li>折半查找</li><li>树形查找（二叉查找树、平衡二叉树、红黑树）</li><li>B树</li><li>散列查找</li><li>字符串的模式匹配</li></ol><p>其中，顺序查找过于简单，不可能在应用题中专门考察；红黑树、B树难度较大，也不太可能在应用题中专门考察；字符串的模式匹配通常以小题考察为主。因此，在应用题中最有可能专门考察的是 分块查找、折半查找、二叉查找树、平衡二叉树、散列查找。其中，二叉查找树、平衡二叉树的可能考法已在本文档的 3.6 有详细介绍。接下来我们主要训练 分块查找、折半查找、散列查找在应用题中的可能考法</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><h3 id="自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引"><a href="#自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引" class="headerlink" title="自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引"></a>自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232009538.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><font color="FF0000">上图中，共有15个元素，计算查找成功时的平均查找长度ASL，每个元素被查找的概率相同，都是 1/15。每个元素的查找都需要先查分块索引，再顺序查找分块内各个元素。</font>查找元素9时，查找长度为 1+1查找元素7时，查找长度为 1+2查找元素10时，查找长度为 1+3查找元素2时，查找长度为 1+4查找元素19时，查找长度为 2+1查找元素14时，查找长度为 2+2查找元素15时，查找长度为 2+3查找元素20时，查找长度为 3+1查找元素25时，查找长度为 3+2查找元素22时，查找长度为 3+3查找元素30时，查找长度为 3+4查找元素43时，查找长度为 4+1查找元素36时，查找长度为 4+2查找元素55时，查找长度为 4+3查找元素40时，查找长度为 4+4综上，查找成功的ASL=(2+3+4+5+3+4+5+4+5+6+7+5+6+7+8)×1/15=4.933<font color="FF0000">对于查找失败的情况，题目不太可能让你分析查找失败的平均查找长度ASL（因为查找失败的情形很多，我们无法预估出现每一种失败情形的概率）。因此，如果分块查找要考察“查找失败”的情形，很有可能是给你一个特定的关键字，让你分析该关键字查找失败时的查找长度。</font><p>例：如下图所示，查找元素 29（查找失败）时，首先顺序查找分块索引；确认元素29属于第三个分块，该分块在数组中下标范围是 7~10；紧接着在数组中查找下标为 7~10 的几个元素，所有元素和目标关键字都不匹配，最终可确定查找失败。<br>综上，查找元素 29（查找失败）时，总计对比关键字7次。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232040248.png" alt="image.png"></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树"><a href="#自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树" class="headerlink" title="自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树"></a>自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232044612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232044221.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL-1"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL-1" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232045710.png" alt="image.png"></p><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突"><a href="#自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突" class="headerlink" title="自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突"></a>自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突</h3><font color="FF0000">设散列表长度为<mark>16</mark>，采用线性探测法解决冲突，从空表开始，依次插入关键字 {19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数 <mark>H(key)=key%13</mark><mark>注：散列表的长度可以比散列函数的映射范围更大，散列函数的映射范围是 0~12，散列表的后面几个位置 13~15 不可能被散列函数直接映射，但是在线性探测法处理冲突时，可能被使用到</mark></font>![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232058651.png)![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232059087.png)### 基于上述例子，计算查找成功的ASL、查找失败ASL<font color="FF0000">考虑查找成功的所有情况。各元素查找成功时的查找长度如下：</font><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232100921.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232101576.png" alt="image.png"></p><p><font color="FF0000">考虑查找失败的所有情况。若目标元素的散列值为0，则只需对比位置0的关键字即可确定查找失败，查找长度为1；若目标元素的散列值为1，采用线性探测法，需对比位置#1~#13，才能确定查找失败，查找长度是13；若目标元素的散列值为2，采用线性探测法，需对比位置#2~#13，才能确定查找失败，查找长度是12；其他散列值同理。</font><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232103235.png" alt="image.png"></p><h3 id="基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）"><a href="#基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）" class="headerlink" title="基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）"></a>基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232111869.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL-2"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL-2" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><p>考虑查找成功的所有情况。元素 14、68、19、29、23、11 的查找长度为1；元素1、55、84、10 的查找长度为2；元素27的查找长度为3；元素79的查找长度为4，因此：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232112214.png" alt="image.png"></p><p>考虑查找失败的所有情况。若目标元素的散列值为0，则无需对比任何关键字即可确定查找失败，查找长度为0；若目标元素的散列值为1，则需要依次对比关键字14、1、27、79才能确定查找失败，查找长度为4；其他散列值同理。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232112216.png" alt="image.png"></p><h1 id="排序算法的分析和应用"><a href="#排序算法的分析和应用" class="headerlink" title="排序算法的分析和应用"></a>排序算法的分析和应用</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态"><a href="#自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态" class="headerlink" title="自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态"></a>自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232113983.png" alt="image.png"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态"><a href="#自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态" class="headerlink" title="自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态"></a>自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232115754.png" alt="image.png"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h4 id="自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0-99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表"><a href="#自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0-99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表" class="headerlink" title="自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0~99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表"></a>自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0~99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232121150.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082317124.png&quot; alt=&quot;wallhaven-zypzdj.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;树的应用</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://fqzs.netlify.app/undefined/d04bd5bc.html"/>
    <id>https://fqzs.netlify.app/undefined/d04bd5bc.html</id>
    <published>2023-08-17T10:19:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171023019.png" alt="image.png"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a><em>操作系统的基本概念</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171040837.png" alt="image.png"></p><h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a><em>操作系统的定义</em></h3><ol><li>操作系统是系统资源的管理者</li><li>向上提供方便使用的服务</li><li>是最接近硬件的一层软件<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171043675.png" alt="image.png"></li></ol><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a><em>操作系统的功能</em></h3><h4 id="1-作为系统资源管理者"><a href="#1-作为系统资源管理者" class="headerlink" title="1.作为系统资源管理者"></a><strong><em>1.作为系统资源管理者</em></strong></h4><ul><li><em>处理机管理</em></li><li><em>存储器管理</em></li><li><em>文件管理</em></li><li><em>设备管理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171044644.png" alt="image.png"></li></ul><h4 id="2-向上提供方便易用的服务"><a href="#2-向上提供方便易用的服务" class="headerlink" title="2.向上提供方便易用的服务"></a><strong><em>2.向上提供方便易用的服务</em></strong></h4><p><em>操作系统把一些丑陋的硬件功能<strong>封装成简单易用的服务</strong>，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</em></p><p><em>向上提供服务：</em></p><ul><li><em>给普通用户提供的：GUI、命令接口(联机、脱机)</em></li><li><em>给程序员提供的：程序接口(系统调用)</em></li></ul><blockquote><p><em>例如GUI图形化用户接口：用户可以直观理解界面进行操作，方便用户使用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171047670.png" alt="image.png"></p><p><em>例如联机命令接口，也称交互式命令接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171049719.png" alt="image.png"></p><p><em>例如脱机命令接口，也称批处理命令接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171050983.png" alt="image.png"></p><p><em>例如程序接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171051366.png" alt="image.png"></p></blockquote><h4 id="3-作为最接近硬件的层次"><a href="#3-作为最接近硬件的层次" class="headerlink" title="3.作为最接近硬件的层次"></a><em>3.作为最接近硬件的层次</em></h4><p><em>没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171056491.png" alt="image.png"></p><h3 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a><em>操作系统的四个特征</em></h3><p><em>没有并发性和共享性，就谈不上虚拟和异步，因此并发和异步是操作系统最基本的两个特征</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171141733.png" alt="image.png"></p><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1.并发性"></a><strong><em>1.并发性</em></strong></h4><ul><li><em>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</em></li><li><em>并行：指两个或多个事件在同一时刻同时发生。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171142677.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171143447.png" alt="image.png"></p><h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2.共享性"></a><strong><em>2.共享性</em></strong></h4><p><em>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</em></p><p>(1)<strong>资源共享根据属性可分为两种形式：</strong></p><ul><li>互斥共享形式:（当资源被程序A占用时,其他想使用的话只能等待，只有进程A使用完以后,其他进程才可以使用该资源）</li><li>同时访问形式 :（某种资源在一段时间内并发地被多个程序访问，这种“同时”是宏观的,从宏观去看该资源可以被同时访问,<strong>本质是一种微观的互斥共享</strong>）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171146597.png" alt="image.png"></p><p>(2)<strong>并发性与共享性互为存在条件</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171147935.png" alt="image.png"></p><h4 id="3-虚拟性"><a href="#3-虚拟性" class="headerlink" title="3.虚拟性"></a><em>3.虚拟性</em></h4><ul><li><em>虚拟：是把一个物理上的实体变为若干逻辑上的对应物。</em></li><li><em>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</em></li><li><em>虚拟技术：用于实现虚拟的技术</em></li><li><em>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</em></li><li><em>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</em></li><li><em>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</em></li><li><em>操作系统的虚拟技术科归纳为：</em><ul><li>时分复用技术：如处理器的分时共享；一个单核的计算机，却可以同时运行多个程序（<strong>虚拟处理器技术 —— 时分复用技术</strong>）</li><li>空间复用技术：如虚拟存储器；一个 4 GB 内存的电脑，却可以运行远大于 4 GB 内存的程序（<strong>虚拟存储技术 —— 空分复用技术</strong>）</li></ul></li></ul><h4 id="4-异步性"><a href="#4-异步性" class="headerlink" title="4.异步性"></a><em>4.异步性</em></h4><p><em>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</em></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a><em>操作系统的发展与分类</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171355528.png" alt="image.png"></p><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a><em>手工操作阶段</em></h3><p><em>手工操作阶段主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低，手工装卸纸带的时间占了大部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171401918.png" alt="image.png"></p><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a><em>批处理阶段</em></h3><blockquote><p>批处理阶段又分为<strong>单道批处理系统</strong>和<strong>多道批处理系统</strong></p></blockquote><p><strong><em>1.单道批处理系统</em></strong><br><em>引入脱机输入/输出技术（用外围机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出；通过外围机把程序提前存到磁带里</em></p><ul><li><em>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</em></li><li><em>主要缺点：内存中<strong>仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171406543.png" alt="image.png"></li></ul><p><strong><em>2.多道批处理系统</em></strong><br><em>每次往内存中读入多道程序，操作系统正式诞生，用于支持多道程序并发运行</em></p><ul><li><em>主要优点：多道程序<strong>并发执行</strong>，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大</em></li><li><em>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171409395.png" alt="image.png"></li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a><em>分时操作系统</em></h3><p><em>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</em></p><ul><li><em>主要优点：<strong>用户请求可以被即时响应，解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</em></li><li><em>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171411274.png" alt="image.png"></li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a><em>实时操作系统</em></h3><p><em>实时操作系统要求计算机系统在接收到外部信号后及时进行处理，并且要在严格的时间内处理完事件，其主要特点是<strong>及时性</strong>和<strong>可靠性</strong>。</em></p><ul><li><em>主要优点：<strong>能够优先响应一些紧急任务</strong>，某些紧急任务不需时间片排队</em></li></ul><blockquote><p><em>实时操作系统又分为<strong>硬实时系统和软实时系统。</strong></em></p></blockquote><p><strong><em>1.硬实时系统</em></strong><br><em>硬实时系统必须在绝对严格的规定时间内完成处理，比如导弹控制系统、自动驾驶系统等。</em></p><p><strong><em>2.软实时系统</em></strong><br><em>软实时系统能够接受偶尔违反时间的规定，例如订票系统。</em></p><h3 id="其他几种操作系统"><a href="#其他几种操作系统" class="headerlink" title="其他几种操作系统"></a><em>其他几种操作系统</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171416513.png" alt="image.png"></p><h2 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a><em>操作系统运行环境</em></h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a><em>操作系统的运行机制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171448145.png" alt="image.png"></p><h4 id="程序时如何运行的？"><a href="#程序时如何运行的？" class="headerlink" title="程序时如何运行的？"></a><em>程序时如何运行的？</em></h4><p><em>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</em><br><em>很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也称为“令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171451468.png" alt="image.png"></p><h4 id="内核程序vs应用程序"><a href="#内核程序vs应用程序" class="headerlink" title="内核程序vs应用程序"></a><em>内核程序vs应用程序</em></h4><ul><li><em>普通程序员写的程序就是“应用程序”</em></li><li><em>微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”</em></li></ul><blockquote><p><em>由很多内核程序组成了“操作系统内核”，或简称“内核（Kernel）”内核是操作系统最重要最核心的部分，也是最接近硬件的部分甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核）<br>操作系统的功能未必都在内核中，如图形化用户界面 GUI</em></p></blockquote><h4 id="特权指令vs非特权指令"><a href="#特权指令vs非特权指令" class="headerlink" title="特权指令vs非特权指令"></a><em>特权指令vs非特权指令</em></h4><ul><li><em>应用程序只能使用“<strong>非特权指令</strong>”，如：加法指令、减法指令等</em></li><li><em>操作系统内核作为 “管理者”，有时会让CPU执行一些<strong>特权指令</strong> ，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</em></li></ul><h4 id="内核态vs用户态"><a href="#内核态vs用户态" class="headerlink" title="内核态vs用户态"></a><em>内核态vs用户态</em></h4><p><em>CPU 有两种状态，“内核态”和“用户态”<br>处于<strong>内核态</strong>时，说明此时正在运行的是内核程序，此时可以执行特权指令<br>处于<strong>用户态</strong>时，说明此时正在运行的是应用程序，此时只能执行非特权指令</em></p><blockquote><p><em>拓展：CPU 中有一个寄存器叫 程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”<br><strong>别名：内核态=核心态=管态；用户态=目态</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171503005.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171504734.png" alt="image.png"></p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a><em>中断和异常</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171558465.png" alt="image.png"></p><h4 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a><em>中断的作用</em></h4><p>“中断”是让操作系统内核夺回CPU使用权的唯一途径如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。</p><blockquote><p><strong>内核态-&gt;用户态</strong>：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。<br><strong>用户态-&gt;内核态</strong>：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。</p></blockquote><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><em>中断的分类</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171601329.png" alt="image.png"></p><h4 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a><em>中断机制的基本原理</em></h4><p>不同的中断信号，需要用不同的<strong>中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p><p>显然，中断处理程序一定是内核程序，需要运行在“内核态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171602489.png" alt="image.png"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><em>系统调用</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171635635.png" alt="image.png"></p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a><em>什么是系统调用？</em></h4><p><strong>Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用</strong>。用户可以通过系统调用命令在自己的应用程序中调用它们。<br>从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。</p><h4 id="系统调用与库函数的区别？"><a href="#系统调用与库函数的区别？" class="headerlink" title="系统调用与库函数的区别？"></a><em>系统调用与库函数的区别？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171629803.png" alt="image.png"></p><h4 id="为什么系统调用时必须的？"><a href="#为什么系统调用时必须的？" class="headerlink" title="为什么系统调用时必须的？"></a><em>为什么系统调用时必须的？</em></h4><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，<strong>为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制</strong>。 也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。</p><h4 id="什么功能需要系统调用？"><a href="#什么功能需要系统调用？" class="headerlink" title="什么功能需要系统调用？"></a><em>什么功能需要系统调用？</em></h4><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作</strong>（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以<strong>保证系统的稳定性和安全性，防止用户进行非法操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171633407.png" alt="image.png"></p><h4 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a><em>系统调用的过程</em></h4><p>传递系统调用参数—&gt;执行陷入指令（用户态） —&gt;执行相应的内请求核程序处理系统调用（核心态） —&gt;返回应用程序<br>【注意】：</p><ol><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171635515.png" alt="image.png"></li></ol><h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a><em>操作系统体系结构</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171703375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171849554.png" alt="image.png"></p><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a><em>操作系统的内核</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171706701.png" alt="image.png"></p><h4 id="操作系统的内核是什么？"><a href="#操作系统的内核是什么？" class="headerlink" title="操作系统的内核是什么？"></a><em>操作系统的内核是什么？</em></h4><p>内核是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。<strong><em>内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171714480.png" alt="image.png"></p><h4 id="内核分为大内核和微内核"><a href="#内核分为大内核和微内核" class="headerlink" title="内核分为大内核和微内核"></a><em>内核分为大内核和微内核</em></h4><p><strong><em>大内核</em></strong></p><blockquote><p>特性思想：功能包括，时钟管理、中断处理、原语(设备驱动、CPU切换)、进程管理、存储器管理、设备管理等功能。所有的系统功能都放在内核里（大内核结构的OS通常也采用了”模块化“的设计思想）</p></blockquote><ul><li>优点：<ol><li>高性能，内核各种功能都能直接相互调用</li></ol></li><li>缺点：<ol><li>内核代码庞大，结构混乱，难以维护。</li><li>大内核中某个功能模块出错，就可能导致整个系统崩渍</li></ol></li></ul><p><strong><em>微内核</em></strong></p><blockquote><p>特性思想：功能包括，时钟管理、中断处理、原语。只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</p></blockquote><ul><li>优点：<ol><li>内核功能少，结构清晰，方便维护；</li><li>内核外的某个功能模块出错不会导致整个系统崩溃</li></ol></li><li>缺点：<ol><li>性能低，需要频繁的切换用户态/核心态。</li><li>用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信.</li></ol></li></ul><blockquote><p><em>如果使用大内核操作系统，应用程序请求操作系统的服务，那么只需要用户态-&gt;内核态，内核态-&gt;用户态，总共两次变态</em><br><em>如果使用的是微内核，上述需要6次变态</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171719529.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171722329.png" alt="image.png"></p><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><blockquote><p><em>特性思想：内核分多层，每层可单向调用更低一层提供的接口</em></p></blockquote><p><em>优点：</em></p><ol><li>便于调试和验证，自底向上逐层测试验证</li><li>易扩充和维护，各层之间调用接口清晰固定<br><em>缺点：</em></li><li>仅可调用相邻低层，难以合理定义各层的边界</li><li>效率低，不可跨层调用，系统调用执行时间长<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171840327.png" alt="image.png"></li></ol><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a><em>模块化</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171901517.png" alt="image.png"></p><blockquote><p>特性思想：将内核划分为多个模块，各模块之间相互协作。<br>内核=主模块+可加载内核模块<br>主模块：只负责核心功能，如进程调度、内存管理<br>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171854395.png" alt="image.png"></p><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a><em>外核</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171904125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171942853.png" alt="image.png"></p><h2 id="操作系统的引导-开机过程-Boot"><a href="#操作系统的引导-开机过程-Boot" class="headerlink" title="操作系统的引导(开机过程/Boot)"></a><em>操作系统的引导(开机过程/Boot)</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172014896.png" alt="image.png"></p><h3 id="什么是操作系统的引导？"><a href="#什么是操作系统的引导？" class="headerlink" title="什么是操作系统的引导？"></a><em>什么是操作系统的引导？</em></h3><p>操作系统引导（boot）——开机的时候，怎么让操作系统运行起来？</p><h3 id="磁盘里面有哪些相关数据？"><a href="#磁盘里面有哪些相关数据？" class="headerlink" title="磁盘里面有哪些相关数据？"></a><em>磁盘里面有哪些相关数据？</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172015330.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172016247.png" alt="image.png"></p><h3 id="操作系统引导过程"><a href="#操作系统引导过程" class="headerlink" title="操作系统引导过程"></a><em>操作系统引导过程</em></h3><p><code>BIOS(Basic Input/Output System):基本输入输出系统</code><br>操作系统引导：<br>①CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）<br>②将磁盘的第一块——主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>③从活动分区（又称主分区，即安装了操作系统的分区—C盘）读入分区引导记录，执行其中的程序<br>④从根目录下找到完整的操作系统初始化程序（即 启动管理器）并执行，完成“开机”的一系列动作</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172019273.png" alt="image.png"></p><blockquote><p><em>拓展</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172021369.png" alt="image.png"></p></blockquote><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><em>虚拟机</em></h2><h3 id="什么是虚拟机和虚拟机管理程序？"><a href="#什么是虚拟机和虚拟机管理程序？" class="headerlink" title="什么是虚拟机和虚拟机管理程序？"></a><em>什么是虚拟机和虚拟机管理程序？</em></h3><p><strong><em>虚拟机—VM</em></strong><br>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统</p><p><strong><em>虚拟机管理程序—VMM</em></strong><br>虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor；是创建和运行虚拟机的软件。管理程序允许一台主机通过虚拟共享其资源（例如内存和处理器）来支持多个虚拟机(VM)。由于虚拟机独立于主机硬件，因此虚拟机管理程序可以使用更多系统的可用资源，并提供更大的 IT 移动性。这意味着它们可以轻松地在不同服务器之间移动。</p><h3 id="两类管理程序"><a href="#两类管理程序" class="headerlink" title="两类管理程序"></a><em>两类管理程序</em></h3><blockquote><p>有两种主要的管理程序类型，称为“类型 1”（或“裸机”）和“类型 2”（或“托管”）。</p></blockquote><ul><li><strong>类型 1 也称裸机管理程序</strong>，它就像一个轻量级操作系统，直接在主机硬件上运行。</li><li><strong>类型 2 也称托管管理程序</strong>，它是一个软件层，运行在一个操作系统上，就像其他计算机程序一样。</li></ul><blockquote><p><em>第1类和第2类虚拟机管理程序的区别</em></p></blockquote><p>虽然第 1 类和第 2 类虚拟机监控器的共同目标是运行和协调虚拟机（VM），但它们之间有一些显著差异。<br> <strong>资源分配</strong><br>第 1 类虚拟机监控器<strong><em>直接访问底层计算机资源</em></strong>。这些虚拟机监控器可以实施自己的自定义资源分配策略来为虚拟机提供服务。<br>第 2 类虚拟机监控器与<strong><em>操作系统协商资源分配</em></strong>，这会使流程变慢且效率降低。</p><p><strong>易于管理</strong><br>管理第 1 类虚拟机监控器序及其虚拟机配置需要具备系统管理员级别的知识，因为此类管理相对复杂。<br>相比之下，可以将第 2 类虚拟机监控器作为应用程序在操作系统上安装和管理。即使是非技术型用户也可以操作这些应用程序。</p><p> <strong>性能</strong><br>第 1 类虚拟机监控器可为其虚拟机提供更卓越的性能。这是因为这些虚拟机监控器不需要与操作系统协商资源，也不需要穿过操作系统层。第 1 类虚拟机监控器无需进行任何协商即可提供专用的底层资源。<br>第 2 类虚拟机监控器只能使用操作系统愿意提供的资源。</p><p> <strong>隔离</strong><br>第 1 类虚拟机监控器为每种虚拟环境提供更高程度的隔离。因此，在此类环境中没有共享层，而第 2 类虚拟机监控器则以操作系统作为共享层。这使得在第 1 类虚拟机监控器上运行的虚拟机本质上更加安全。但是，更新和修补虚拟机操作系统就成为一项关键的安全活动。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308180952142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181052696.png" alt="image.png"></p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组成和特征"><a href="#进程的概念、组成和特征" class="headerlink" title="进程的概念、组成和特征"></a><em>进程的概念、组成和特征</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181056630.png" alt="image.png"></p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><em>进程的概念</em></h4><ul><li><strong>*程序</strong>：是静态的，就是个存放在磁盘里的可执行文件，如：QQ.exe*</li><li><strong>*进程</strong>：是动态的，是程序的一次执行过程，如：可同时启动多次QQ程序，同一个程序多次执行会对应多个进程*</li></ul><h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a><em>进程的组成</em></h4><p>进程（进程实体）由<code>程序段</code>、<code>数据段</code>、<code>PCB</code> 三部分组成。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181125594.png" alt="image.png"></p><blockquote><p><strong><em>进程组成—PCB(进程控制块)</em></strong></p></blockquote><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— PID（Process ID，进程ID）。<strong>PCB是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p><p>PCB(进程控制块)是一个数据结构，记录了如下的信息：</p><ul><li><em>操作系统要记录PID、进程所属用户ID（UID，基本的进程描述信息，可以<br>让操作系统区分各个进程。</em></li><li><em>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件，可用于实现操作系统对资源的管理。</em></li><li><em>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）可用于实现操作系统对进程的控制、调度。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181103067.png" alt="image.png"></p><blockquote><p><strong><em>进程的组成—程序段、数据段</em></strong></p></blockquote><ul><li><em>程序段，程序代码即存放在此</em></li><li><em>数据段，程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181117444.png" alt="image.png"></li></ul><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a><em>进程的特征</em></h4><p><code>动态性试进程最基本特征</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181127194.png" alt="image.png"></p><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a><em>进程的状态与转换</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181150472.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181156795.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181158647.png" alt="image.png"></p><blockquote><p><em>! 当一个进程被阻塞时,它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。</em></p></blockquote><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a><em>进程的组织</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181159329.png" alt="image.png"></p><blockquote><p><em>链接方式</em></p></blockquote><p><em>按照进程状态，将PCB分为多个队列；操作系统维持有指向各个队列的指针</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181201974.png" alt="image.png"></p><blockquote><p><em>索引方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181202612.png" alt="image.png"></p><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a><em>进程的控制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181551528.png" alt="image.png"></p><h4 id="什么是进程控制？"><a href="#什么是进程控制？" class="headerlink" title="什么是进程控制？"></a><em>什么是进程控制？</em></h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：反正进程控制就是要实现进程状态转换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181553266.png" alt="image.png"></p><h4 id="如何实现进程控制？"><a href="#如何实现进程控制？" class="headerlink" title="如何实现进程控制？"></a><em>如何实现进程控制？</em></h4><blockquote><p><em>进程控制必须是一气呵成的</em></p></blockquote><p><em>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181558800.png" alt="image.png"></p><blockquote><p><em>如何实现进程控制一气呵成，不受中断信号的影响呢？</em></p></blockquote><p><strong><em>原语</em></strong><br>原语是一种<strong>特殊的程序</strong>，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。原语通常是由底层硬件直接实现的。原语(Primitive)指的是操作系统或编程语言提供的最基本的操作单元。原语不能再细分拆分,必须由硬件直接执行。</p><p><strong><em>原语的原子性</em></strong><br>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用 “<strong>关中断指令”和“开中断指令</strong>”这两个特权指令实现原子性。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181602882.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181604840.png" alt="image.png"></p><h4 id="进程控制相关原语"><a href="#进程控制相关原语" class="headerlink" title="进程控制相关原语"></a><em>进程控制相关原语</em></h4><blockquote><p><em>进程的创建—创建原语</em></p></blockquote><p><em>操作系统创建一个进程时使用的原语</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181609558.png" alt="image.png"></p><blockquote><p><em>进程的终止—撤销原语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181611603.png" alt="image.png"></p><blockquote><p><em>进程的阻塞和唤醒</em></p></blockquote><p><em>阻塞原语和唤醒原语必须成对使用，被阻塞了必须要被唤醒</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181613808.png" alt="image.png"></p><blockquote><p><em>进程的切换—切换原语</em></p></blockquote><p><em>进程运行环境，就是进程运行过程，执行指令产生的各种数据暂时存放在寄存器中(PC 程序计数器、通用寄存器等存放着一些该进程运行的数据)，但是当时间片用完，或者其他原因，需要让下一个进程运行，那么寄存器里面的内容就会被覆盖，当进程重新得到时间片时，就无法从中断处继续。所以就需要将<strong>运行环境信息</strong>存入PCB</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181615929.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181622645.png" alt="image.png"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181738454.png" alt="image.png"></p><h4 id="什么是进程通信？"><a href="#什么是进程通信？" class="headerlink" title="什么是进程通信？"></a><em>什么是进程通信？</em></h4><p>进程间通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互，类似于，我用微博将消息分享到微信的过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181740317.png" alt="image.png"></p><h4 id="为什么进程通信需要操作系统支持？"><a href="#为什么进程通信需要操作系统支持？" class="headerlink" title="为什么进程通信需要操作系统支持？"></a><em>为什么进程通信需要操作系统支持？</em></h4><p>各个进程被分配了，相互独立的地址空间，但是这些进程只能访问自己的地址空间，无法访问别的进程地址空间，这样是为了保证安全<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181743324.png" alt="image.png"></p><h4 id="进程通信三种方式"><a href="#进程通信三种方式" class="headerlink" title="进程通信三种方式"></a><em>进程通信三种方式</em></h4><blockquote><p><em>1.共享存储</em></p></blockquote><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，<strong>可以由需要访问的进程将其映射到自己的私有地址空间</strong>。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的<strong>同步及互斥</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181750956.png" alt="image.png"></li></ul><p><em>两类共享存储方式：</em><code>基于数据结构的共享、基于存储区的共享</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181751732.png" alt="image.png"></p><blockquote><p><em>2.消息传递</em></p></blockquote><p>进程间的数据交换以<strong>格式化的消息（Message）为单位</strong>。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181832664.png" alt="image.png"></p><p><strong><em>1.直接通信方式</em></strong><br><em>消息发送进程要指明接收进程的ID</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181834479.png" alt="image.png"></p><p><strong><em>2.间接通信方式</em></strong><br><em>通过“信箱”间接地通信。因此又称“信箱通信方式”</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181834010.png" alt="image.png"></p><blockquote><p><em>管道通信</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181837173.png" alt="image.png"></p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道（由操作系统实现）</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。</li></ol><h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a><em>线程的概念与特点</em></h3><h4 id="为什么引入线程？"><a href="#为什么引入线程？" class="headerlink" title="为什么引入线程？"></a><em>为什么引入线程？</em></h4><ul><li>可以把线程理解为“轻量级进程”。</li><li><strong>线程是一个基本的CPU执行单元</strong>，也是程序执行流的最小单位。</li><li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</li><li>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元</strong>。</li></ul><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来<strong>增加并发度</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191025557.png" alt="image.png"></p><h4 id="引入线程后的变化"><a href="#引入线程后的变化" class="headerlink" title="引入线程后的变化"></a><em>引入线程后的变化</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191029801.png" alt="image.png"></p><p>【注：系统开销减小，是因为线程并发减少了进程之间的切换，也就减少了进程运行环境的切换，所以开销减小】</p><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a><em>线程的属性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191032300.png" alt="image.png"></p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><em>线程的实现方式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191043598.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191108611.png" alt="image.png"></p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a><em>用户级线程</em></h4><p>早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。这种线程实现方式被称为“用户级线程”。</p><ol><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）。</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</li><li>处理机的分配单元是进程，所以时间片是按照进程分配，其中一个线程阻塞，整个进程就阻塞(该进程下的其他进程也相应无法执行)，所以这种线程并发度不高。</li><li>优缺点</li></ol><ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191046222.png" alt="image.png"></li></ul><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a><em>内核级线程</em></h4><ol><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li><li>处理机的分配单元是内核级线程，时间片按照线程分配，一个内核线程阻塞，该进程下其他内核线程任然可以获得时间片，执行下去，并发度高。</li><li>优缺点</li></ol><ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191059723.png" alt="image.png"></li></ul><blockquote><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p></blockquote><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a><em>一对一模型</em></h5><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br><strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191101082.png" alt="image.png"></p><h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a><em>多对一模型</em></h5><p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p><p><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。<br><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p><p><code>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191102668.png" alt="image.png"></p><h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a><em>多对多模型</em></h5><p>多对多模型：n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191107042.png" alt="image.png"></p><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a><em>线程的状态与转换</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191354458.png" alt="image.png"></p><blockquote><p><em>线程状态转换</em></p></blockquote><p><em>与进程的状态转换差不多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191356107.png" alt="image.png"></p><blockquote><p><em>线程的组成</em></p></blockquote><p><em>线程控制块TCB，类似于进程控制块</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191357118.png" alt="image.png"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a><em>处理机调度</em></h2><h3 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a><em>调度的概念、层次</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191402481.png" alt="image.png"></p><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a><em>调度的基本概念</em></h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a><em>调度的三个层次</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191544856.png" alt="image.png"></p><ol><li><p><strong><em>高级调度（作业调度）</em></strong><br><code>作业：一个具体的任务。</code><br><code>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</code></p><blockquote><p><em>&lt;创建进程&gt;</em><br>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB),以使它（们）获得竟争处理机的权利。高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB,作业调出时才撤销PCB。<code>高级调度主要是指调入的问题</code>，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></blockquote></li></ol><ol><li><strong><em>中级调度（内存调度）</em></strong></li></ol><blockquote><p><em>&lt;将已有进程，调出/入内存，缓解内存不足&gt;</em><br>为了使内存中的内存不至于太多，有时需要把某些进程从内存中调到外存，暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。在内存使用情况紧张时，将一些暂时不能运行的进程从内存中对换到外存中等待。当内存有足够的空闲空间时，再将合适的进程重新换入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191429994.png" alt="image.png"></p><ol><li><strong><em>低级调度（进程调度/处理机调度）</em></strong><blockquote><p><em>&lt;给进程分配处理机，时间片&gt;</em><br>主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p></blockquote></li></ol><p><strong><em>回顾</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191553260.png" alt="image.png"></p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a><em>调度算法的评价指标</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191554650.png" alt="image.png"></p><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a><em>CPU利用率</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191556060.png" alt="image.png"></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a><em>系统吞吐量</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191558772.png" alt="image.png"></p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a><em>周转时间</em></h4><blockquote><p><em>周转时间，是指从<strong>作业被提交给系统开始</strong>，到作业完成为止的这段时间间隔。</em><br>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p></blockquote><p><code>只有作业真正提交/到达，进入外存后备队列开始，才算进程开始周转</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191603979.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于周转时间相同的两个作业，实际运行时</span><br><span class="line">间长的作业在相同时间内被服务的时间更多，</span><br><span class="line">带权周转时间更小，用户满意度更高。</span><br><span class="line"></span><br><span class="line">对于实际运行时间相同的两个作业，周转时</span><br><span class="line">间短的带权周转时间更小，用户满意度更高</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191605602.png" alt="image.png"></p><blockquote><p><em>eg</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201025453.png" alt="image.png"></p></blockquote><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a><em>等待时间</em></h4><p>计算机的用户希望自己的作业尽可能少的等待处理机。等待时间，指进程/作业处于<strong><em>等待处理机状态时间之和</em></strong>，等待时间越长，用户满意度越低。</p><ul><li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的(被CPU服务)，所以不计入等待时间。</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li></ul><blockquote><p>对于等待I/O完成的进程,操作系统确实会视其为在运行状态,因为这只是一种阻塞的等待,进程仍在内核态运行。就进程而言,它发出了I/O请求后,并不知道具体的等待时间,只能被动等待通知,所以从进程角度来看,它仍是运行状态。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191614084.png" alt="image.png"></p></blockquote><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a><em>响应时间</em></h4><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。响应时间，指从用户提交请求到首次产生响应所用的时间</p><h3 id="进程调度-低级调度"><a href="#进程调度-低级调度" class="headerlink" title="进程调度(低级调度)"></a><em>进程调度(低级调度)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191704700.png" alt="image.png"></p><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a><em>进程调度的时机</em></h4><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p><strong>一、需要进程调度与切换的情况</strong></p><ol><li>当前运行的进程主动放弃处理机：<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如 等待I/O）</li></ul></li><li>当前运行的进程被动放弃处理机：<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ol><p><strong>二、不能进行进程调度与切换的情况</strong></p><ol><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在操作系统<strong><em>内核程序临界区中</em></strong>。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol><blockquote><p><em>扩展</em><br><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br><strong>临界区</strong>：访问临界资源的那段代码。<br><strong>内核程序临界区</strong>：一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成）</p><p><strong><em>进程在操作系统内核程序临界区中不能进行调度与切换</em></strong>；<br>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191714892.png" alt="image.png"></p><p><strong><em>进程处于临界区时能进行处理机调度</em></strong><br>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191717378.png" alt="image.png"></p></blockquote><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a><em>进程调度的方式</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191745572.png" alt="image.png"></p><h4 id="进程调度与切换"><a href="#进程调度与切换" class="headerlink" title="进程调度与切换"></a><em>进程调度与切换</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191746352.png" alt="image.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><em>总结</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191747879.png" alt="image.png"></p><h3 id="调度器和闲逛进程"><a href="#调度器和闲逛进程" class="headerlink" title="调度器和闲逛进程"></a><em>调度器和闲逛进程</em></h3><h4 id="调度器-调度程序"><a href="#调度器-调度程序" class="headerlink" title="调度器/调度程序"></a><em>调度器/调度程序</em></h4><p><em>调度程序实现的是就绪态和运行态之间的切换，而不包括与阻塞态转换。</em></p><blockquote><p>什么事件会触发”调度程序“？<br><em>1.创建新进程：新的进程计入就绪队列，并需调度程序，决定是否进入运行态</em><br><em>2. 进程退出：进程结束，需要调度程序，决定哪个就绪进程运行</em><br><em>3.运行进程阻塞：阻塞，需要进程顶上</em><br><em>4.非抢占式调度策略：只有运行阻塞，或完后退出才能发生调度</em><br><em>5. 抢占式调度策略：每个时钟周期(时钟中断)，进程时间片重新被争夺，需要调度就绪-&gt;运行</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308200958066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调度程序的调度对象是进程还是线程，取决于操作系统是否支持内核级线程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201013710.png" alt="image.png"></p><h4 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a><em>闲逛进程</em></h4><p><em>仅仅作为备胎，当没有进程能够运行时，就运行闲逛进程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201015373.png" alt="image.png"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><em>调度算法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201126098.png" alt="image.png"></p><h4 id="批处理系统调度算法"><a href="#批处理系统调度算法" class="headerlink" title="批处理系统调度算法"></a><em>批处理系统调度算法</em></h4><h5 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h5><p><strong><em>Fisrt Come First Serve</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201126403.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201127783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201128037.png" alt="image.png"></p><h5 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h5><p><strong><em>Short Job First</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201130542.png" alt="image.png"></p><blockquote><p><em>非抢占式-例子</em></p></blockquote><p><em>严格来说，用于进程调度应该称为 短进程优先调度算法（ SPF ）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201134217.png" alt="image.png"></p><blockquote><p><em>抢占式-例子</em></p></blockquote><p>严格来说，抢占式的短作业优先算法又称“最短剩余时间优先算法（SRTN）“<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201136734.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201136027.png" alt="image.png"></p><blockquote><p><em>注意区分</em></p></blockquote><ol><li>如果题目中未特别说明，所提到的“短作业/进程优先算法”<strong><em>默认是非抢占式的</em></strong></li><li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”；如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ol><h5 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h5><p><strong><em>High Response High Ratio Next</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201141228.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201143104.png" alt="image.png"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><em>总结</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201146459.png" alt="image.png"><br>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，<strong>交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p><h4 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a><em>交互式系统的调度算法</em></h4><h5 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a><em>时间片轮转算法</em></h5><p><strong><em>RR, Round-Robin</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201249395.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><strong>*特点</strong>：常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间；*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201250160.png" alt="image.png"></p><p>0时刻（P1(5)）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片。<br>2时刻（P2(4) -&gt;P1(3)）-&gt;2时刻 P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意： 2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况， 默认 新到达的进程先进入就绪队列）。<br>4时刻（P1(3) -&gt; P3(1) -&gt; P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾。<br>5时刻（P3(1) -&gt; P2(2) -&gt; P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）。<br>6时刻（P3(1) -&gt; P2(2) -&gt; P4(6) -&gt; P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度<br>7时刻（P2(2) -&gt; P4(6) -&gt; P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>9时刻（P4(6) -&gt; P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机。<br>11时刻（P1(1) -&gt; P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机。<br>12时刻（P4(4) ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机。<br>14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>16时刻：所有进程运行结束。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">！注意：</span><br><span class="line">如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</span><br><span class="line">另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比</span><br></pre></td></tr></table></figure></p><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a><em>优先级调度算法</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201307199.png" alt="image.png"></p><blockquote><p><em>非抢占式—例子</em></p></blockquote><p><strong>*特点</strong>：用优先级区分紧急程度，适用于实时操作系统*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201424709.png" alt="image.png"></p><blockquote><p><em>抢占式—例子</em></p></blockquote><p><strong>*特点</strong>：用优先级区分紧急程度，适用于实时操作系统*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201308329.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级</span><br><span class="line">高的进程排在更靠近队头的位置</span><br><span class="line">根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</span><br><span class="line">静态优先级：创建进程时确定，之后一直不变。(非抢占式)</span><br><span class="line">动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。(抢占式)</span><br><span class="line"></span><br><span class="line">系统进程优先级 高于 用户进程</span><br><span class="line">前台进程优先级 高于 后台进程</span><br><span class="line">操作系统更偏好 I/O型进程（或称 I/O繁忙型进程）</span><br><span class="line">注：与I/O型进程相对的是计算型进程（或称 CPU繁忙型进程）</span><br></pre></td></tr></table></figure><h5 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a><em>多级反馈队列算法</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201423858.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201421945.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201422214.png" alt="image.png"></p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><em>总结</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201246490.png" alt="image.png"><br>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）</p><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a><em>同步与互斥</em></h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a><em>同步与互斥的基本概念</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201542327.png" alt="image.png"><br><strong><em>进程互斥</em></strong><br>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201549332.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">临界区是进程中访问临界资源的代码段。</span><br><span class="line">进入区和退出区是负责实现互斥的代码段。</span><br><span class="line">临界区也可称为“临界段”</span><br><span class="line"></span><br><span class="line">如果一个进程暂时不能进入临界区，</span><br><span class="line">那么该进程是否应该一直占着处理</span><br><span class="line">机？该进程有没有可能一直进不了</span><br><span class="line">临界区？</span><br><span class="line"></span><br><span class="line">为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</span><br><span class="line">1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</span><br><span class="line">2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</span><br><span class="line">3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</span><br><span class="line">4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</span><br></pre></td></tr></table></figure></p><p><strong><em>进程同步</em></strong><br>是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！<br><strong><em>为什么需要进程同步</em></strong><br>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。操作系统要提供“进程同步机制”来解决异步问题。</p><h3 id="软件实现与硬件实现的概念"><a href="#软件实现与硬件实现的概念" class="headerlink" title="软件实现与硬件实现的概念"></a><em>软件实现与硬件实现的概念</em></h3><p>硬件实现是直接在硬件电路上实现功能,软件实现是通过软件代码进行模拟或者抽象来间接实现功能。</p><p>硬件实现的特点是:</p><ul><li>直接在数字逻辑电路或者模拟电路上对功能进行设计,实现速度很快。</li><li>不需要指令的翻译和调度,执行效率高。</li><li>硬件电路功能一旦实现就固化了,不太容易修改。</li></ul><p>软件实现的特点是:</p><ul><li>使用编程语言编写代码,通过代码逻辑来模拟实现功能。</li><li>需要将高级语言翻译成机器指令,存在一定的执行开销。</li><li>可以通过修改代码来调整功能实现,更加灵活。</li><li>可以通过软件在不同硬件上运行,更加通用。<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a><em>进程互斥的软件实现方法</em></h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201722851.png" alt="image.png"></p><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a><em>单标志法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算法思想：两个进程在 访问完临界区后 会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</span><br><span class="line"></span><br><span class="line">turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。</span><br><span class="line">若 P1 先上处理机运行，则会一直卡在 ⑤。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在 ⑤。只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</span><br><span class="line">因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</span><br><span class="line"></span><br><span class="line">只能按 P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt;……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不需要访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。</span><br><span class="line">因此，单标志法存在的主要问题是：违背“空闲让进”原则。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201725094.png" alt="image.png"></p><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a><em>双标志先检查法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</span><br><span class="line"></span><br><span class="line">若按照 ①⑤②⑥③⑦….的顺序执行，P0 和 P1 将会同时访问临界区。</span><br><span class="line">因此，双标志先检查法的主要问题是：违反“忙则等待”原则。</span><br><span class="line">原因在于，进入区的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201734331.png" alt="image.png"></p><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a><em>双标志后检查法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题</span><br><span class="line"></span><br><span class="line">若按照 ①⑤②⑥….的顺序执行，P0 和 P1 将都无法进入临界区</span><br><span class="line">因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。</span><br><span class="line">两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201740280.png" alt="image.png"></p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a><em>Peterson算法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</span><br><span class="line"></span><br><span class="line">Peterson 算法用软件方法解决了进</span><br><span class="line">程互斥问题，遵循了空闲让进、忙</span><br><span class="line">则等待、有限等待 三个原则，但是</span><br><span class="line">依然未遵循让权等待的原则。</span><br><span class="line">Peterson 算法相较于之前三种软件</span><br><span class="line">解决方案来说，是最好的，但依然</span><br><span class="line">不够好。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201741666.png" alt="image.png"></p><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a><em>进程互斥的硬件实现方法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201817781.png" alt="image.png"></p><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a><em>中断屏蔽方法</em></h4><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><p><strong>优点</strong>：简单、高效<br><strong>缺点</strong>：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</p><h4 id="TeatAndSet指令"><a href="#TeatAndSet指令" class="headerlink" title="TeatAndSet指令"></a><em>TeatAndSet指令</em></h4><p><code>注意：TestAndSet指令是通过硬件实现的，这里将指令用代码表示，是为了描述逻辑，硬件实现的内容，本质上并不是用代码实现的</code></p><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。<br><strong><em>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</em></strong>。以下是用c语言描述的逻辑<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201826526.png" alt="image.png"></p><p><em>若刚开始lock 是 false，则TSL返回的old值为 false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock 是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</em><br><strong><em>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</em></strong></p><p><strong>优点</strong>：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境(当一个进程陷入等待，等待任然占用着处理机，如果是单核处理机，那么其他进程就一直没办法得到处理机，无法执行别的进程)<br><strong>缺点</strong>：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a><em>Swap指令</em></h4><p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201826713.png" alt="image.png"><br>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。<br><strong>优点</strong>：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br><strong>缺点</strong>：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><em>互斥锁</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211008173.png" alt="image.png"><br>特性：<br>• 需忙等，进程时间片用完才下处理机，违反“让权等待”<br>• 优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则    等待代价很低<br>• 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区<br>• 不太适用于单处理机系统，忙等的过程中不可能解锁<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211009131.png" alt="image.png"></p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><em>信号量机制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211114104.png" alt="image.png"></p><h4 id="为什么需要信号量机制？"><a href="#为什么需要信号量机制？" class="headerlink" title="为什么需要信号量机制？"></a><em>为什么需要信号量机制？</em></h4><p><em>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）</em></p><ol><li>在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；</li><li>所有的解决方案都无法实现“让权等待”</li></ol><p><em>所以，1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制</em></p><h4 id="信号量机制的实现"><a href="#信号量机制的实现" class="headerlink" title="信号量机制的实现"></a><em>信号量机制的实现</em></h4><p><strong>信号量</strong>其实就是一个变量 ，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。<strong>原语是由关中断/开中断指令实现的</strong>。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能<strong>把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</strong>。</p><p>一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。wait、signal 原语常简称为 P、V操作（来自荷兰语 proberen 和<br>verhogen）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为<br>P(S)、V(S)</p><h4 id="整数型信号量"><a href="#整数型信号量" class="headerlink" title="整数型信号量"></a><em>整数型信号量</em></h4><ol><li>整数型信号量S是一个int 整数，直接记录资源数量</li><li>检查和上锁一气呵成，避免并发、异步导致的临界资源同时访问的问题</li><li>不满足“让权等待”，陷入自旋实际上还是占用着处理机<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 整型信号量S，表示某种资源的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// wait原语</span></span><br><span class="line"><span class="keyword">while</span>(S &lt;= <span class="number">0</span>); <span class="comment">// 资源数不足，循环等待</span></span><br><span class="line">S = S - <span class="number">1</span>; <span class="comment">// 占用资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// signal原语</span></span><br><span class="line">S = S + <span class="number">1</span>;<span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a><em>记录型信号量</em></h4><ol><li>记录型信号量S是一个结构体，里面包含着，资源数量和等待队列的信息</li><li>满足让权等待，资源不足时，直接bloack进入阻塞(并非循环)，此时不占用处理机。它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> value; <span class="comment">// 某种资源的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123; <span class="comment">// wait原语</span></span><br><span class="line">S.value--;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bloack(S.L); <span class="comment">// 阻塞进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123; <span class="comment">// signal原语</span></span><br><span class="line">S.value++;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">wakeup(S.L); <span class="comment">// 唤醒进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211113344.png" alt="image.png"></li></ol><h3 id="信号量机制实现进程互斥、同步、前驱关系"><a href="#信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="信号量机制实现进程互斥、同步、前驱关系"></a><em>信号量机制实现进程互斥、同步、前驱关系</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211206401.png" alt="image.png"></p><ul><li><em>默认使用记录型信号量</em></li></ul><h4 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a><em>信号量实现进程互斥</em></h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 mutex，初值为 1</li><li>在进入区 P(mutex)——申请资源</li><li>在退出区 V(mutex)——释放资源</li></ol><p>【对不同的临界资源需要设置不同的互斥信号量。P、V操作必须成对出现。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211211699.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化semaphore mutex =1 是伪代码，实际上是对结构体内的value赋值为1</span><br><span class="line">这里简写了</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211210890.png" alt="image.png"></p><h4 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a><em>信号量实现进程同步</em></h4><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置同步信号量 S, 初始为 0</li><li>在“前操作”之后执行 V(S)</li><li>在“后操作”之前执行 P(S)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">理解：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，</span><br><span class="line">而又只能由P1产生这种资源</span><br><span class="line"></span><br><span class="line">若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作时，由于 S=1，表示有可用资源，会执行 S--，S 的值变回 0，P2 进程不会执行 block 原语，而是继续往下执行代码4。</span><br><span class="line"></span><br><span class="line">若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。之后当执行完代码2，继而执行 V(S) 操,S++，使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4 了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211215280.png" alt="image.png"></p><h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a><em>信号量机制实现前驱关系</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211223105.png" alt="image.png"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a><em>管程</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211320578.png" alt="image.png"></p><h4 id="什么是管程？"><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a><em>什么是管程？</em></h4><blockquote><p><em>概念</em></p></blockquote><p>管程(Monitor)从概念上更接近一个类,而不是一个函数。</p><p>管程有以下特点:</p><ul><li>管程包含了数据字段(属性)和过程(方法)。这与面向对象编程中的类非常类似。</li><li>管程的数据字段和过程是绑定在一起的,对管程的访问需要通过其公开的过程,不能直接访问其内部数据,这提供了封装性。类也有相同的封装特性。</li><li>管程有其独立的实例,每个管程实例包含独立的私有数据,这也是类的一个特征。</li><li>管程的过程(方法)共享管程的私有数据,不同实例的数据相互隔离,这符合类的设计。</li></ul><p>而如果将管程看作一个函数,则不太恰当:</p><ul><li>函数通常没有内部状态(属性),只有输入输出参数。但管程有自己的内部状态。</li><li>函数不具备多实例的特性。管程可以创建多个实例。</li><li>函数的调用不具备互斥和同步特性。管程通过互斥锁和条件变量可实现复杂的同步。</li></ul><p>所以,从面向对象设计的角度,管程更接近一个类,它提供了封装性、数据隐藏、实例化等关键特征。<br>当然,管程也有与类不同的地方,它直接内置了同步和互斥的语义。但是从软件设计抽象的层面,管程是对一个同步对象的封装,可以看作是一个同步类。</p><blockquote><p><em>特征</em></p></blockquote><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><h4 id="为什么要引入管程？"><a href="#为什么要引入管程？" class="headerlink" title="为什么要引入管程？"></a><em>为什么要引入管程？</em></h4><p><em>主要是因为，编写程序时，每一个进程与进程之间P、V操作都要单独编写考虑，太过麻烦，且容易出错，所以引入管程，将内部逻辑封装，直接调用就可以逻辑自洽</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211323126.png" alt="image.png"></p><h4 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a><em>管程解决生产者消费者问题</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211327231.png" alt="image.png"></p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a><em>生产者-消费者问题</em></h3><p><strong><em>1.问题描述</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211454074.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211503162.png" alt="image.png"></p><ol><li><em>隐含两对同步</em><br>生产者、消费者共享一个初始为空、大小为n的缓冲区。<br>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。<br>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li><em>互斥性</em><br>缓冲区是临界资源，各进程必须互斥地访问。</li></ol><p><strong><em>3.如何实现</em></strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex是互斥信号量，用于实现互斥访问，初始=1</span><br><span class="line">empty=n是同步信号量，表示空闲区数目，用于实现仓库满时，生产等待消费先完成</span><br><span class="line">full=0是同步信号量，表示产品数量，用于实现仓库空是，消费等待生产先完成</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211458064.png" alt="image.png"></p><p><strong><em>4.能否改变相邻 P 、 V 操作的顺序？</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211503373.png" alt="image.png"></p><p><strong>P不能互换顺序</strong><br>若此时缓冲区内已经放满产品，则 empty=0，full=n。<br>则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。因此，实现互斥的P操作一定要在实现同步的P操作之后</p><p><strong>V可以互换顺序</strong><br>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p><h3 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a><em>多生产者-多消费者问题</em></h3><blockquote><p><em>”多“，只的是一个仓库，“多类产品和多类消费者“，并不是指“多个”。与上一个问题的区别，在于，产品类别有多个类，消费者也有多种</em></p></blockquote><p><strong><em>1.问题描述</em></strong><br>爸爸专向盘子中放苹果，妈妈专向盘子中放橘子。<br>儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。<br>只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211622711.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong></p><p><strong>互斥关系</strong>：（mutex = 1）<br>对缓冲区（盘子）的访问要互斥地进行</p><p><strong>同步关系（一前一后）</strong>：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果</li></ol><p><strong><em>3.如何实现</em></strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…所以即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</span><br><span class="line"></span><br><span class="line">如果容量是2，就必须专门设置互斥变量mutex.</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211631853.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211633643.png" alt="image.png"></p><p><strong><em>4.总结</em></strong><br>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。<br>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。<br>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：</p><ul><li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</li><li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果<br>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？<br>正确的分析方法应该从“事件”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<br>盘子变空事件-&gt;放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件”既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211636726.png" alt="image.png"></li></ul><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a><em>吸烟者问题</em></h3><p><strong><em>1.问题描述</em></strong><br>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。<br>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供<br>应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211702567.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211704490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211705087.png" alt="image.png"></p><p><strong><em>3.如何实现</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211707985.png" alt="image.png"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a><em>读者-写者问题</em></h3><p><strong><em>1.问题描述</em></strong><br>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<br>因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者<br>往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211752201.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br>两类进程：写进程、读进程<br>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p><p><strong><em>3.如何实现</em></strong><br><em>其核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若两个读进程并发执行，则 count=0时两个进程也许都能满足 if 条件，都会执行</span><br><span class="line">P(rw)，从而使第二个读进程阻塞的情况。如何解决：出现上述问题的原因在于对count 变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count 的访问是互斥的。</span><br><span class="line"></span><br><span class="line">潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211755529.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改进：</span><br><span class="line">在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为“读写公平法”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211801533.png" alt="image.png"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a><em>哲学家进餐问题</em></h3><p><strong><em>1.问题描述</em></strong><br>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211905578.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong></p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。<strong><em>这个问题中只有互斥关系</em></strong>，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。<strong><em>如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</em></strong></li><li>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。</li></ol><p><strong><em>3.如何实现</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211907670.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211908557.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211908147.png" alt="image.png"></p><p><strong><em>5.总结</em></strong><br>哲学家进餐问题的关键在于解决进程死锁。<br>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。<br>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。可以参考哲学家就餐问题解决死锁的三种思路</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><em>死锁</em></h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a><em>死锁的概念</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221047994.png" alt="image.png"></p><blockquote><p>! <em>补充：当一个进程被阻塞时,它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。这也是为什么会产生死锁（记录型信号量机制，只是会使进程阻塞释放CPU,但是对其他已经申请的资源保持占有）</em></p><p>! <em>补充：未必发生循环等待就一定死锁，但死锁一定发生循环等待</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221116933.png" alt="image.png"></p><h3 id="死锁处理策略—预防死锁"><a href="#死锁处理策略—预防死锁" class="headerlink" title="死锁处理策略—预防死锁"></a><em>死锁处理策略—预防死锁</em></h3><p><em>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。是一种<strong>静态的策略</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221220785.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221128419.png" alt="image.png"></p><h4 id="破坏“互斥条件”"><a href="#破坏“互斥条件”" class="headerlink" title="破坏“互斥条件”"></a><em>破坏“互斥条件”</em></h4><p>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。</p><blockquote><p>缺点：但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</p></blockquote><h4 id="破坏“不剥夺条件”"><a href="#破坏“不剥夺条件”" class="headerlink" title="破坏“不剥夺条件”"></a><em>破坏“不剥夺条件”</em></h4><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。<br>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p><blockquote><p>缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol></blockquote><h4 id="破坏“请求和保持条件”"><a href="#破坏“请求和保持条件”" class="headerlink" title="破坏“请求和保持条件”"></a><em>破坏“请求和保持条件”</em></h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。<br>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><blockquote><p><em>缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</em></p></blockquote><h4 id="破坏“循环等待条件”"><a href="#破坏“循环等待条件”" class="headerlink" title="破坏“循环等待条件”"></a><em>破坏“循环等待条件”</em></h4><p>破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁(死锁发生只可能是大编号往小编号申请，但是违反了规则不会出现，所以死锁不会发生)。</p><blockquote><p>缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号；</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol></blockquote><h3 id="死锁处理策略—避免死锁"><a href="#死锁处理策略—避免死锁" class="headerlink" title="死锁处理策略—避免死锁"></a><em>死锁处理策略—避免死锁</em></h3><p><em>避免死锁： 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221221115.png" alt="image.png"></p><h4 id="什么是安全序列？安全状态？"><a href="#什么是安全序列？安全状态？" class="headerlink" title="什么是安全序列？安全状态？"></a><em>什么是安全序列？安全状态？</em></h4><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，安全序列可能有多个。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221228929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221232296.png" alt="image.png"></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a><em>银行家算法</em></h4><p>银行家算法：是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p><blockquote><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p></blockquote><p><strong>例子</strong><br><em>资源总数 (10, 5, 7)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221239776.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时系统是否处于安全状态？</span><br><span class="line">思路：尝试找出一个安全序列…</span><br><span class="line">依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求</span><br><span class="line">可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)</span><br><span class="line">依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)</span><br><span class="line">依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求…………</span><br><span class="line">以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。实际做题时可以更快速的得到安全序列。</span><br></pre></td></tr></table></figure></p><h4 id="银行家算法实现"><a href="#银行家算法实现" class="headerlink" title="银行家算法实现"></a><em>银行家算法实现</em></h4><p>数据结构：<br>长度为 m 的一维数组 Available 表示还有多少可用资源<br>nxm 矩阵 Max 表示各进程对资源的最大需求数<br>nxm 矩阵 Allocation 表示已经给各进程分配了多少资源<br>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</p><p>银行家算法步骤：<br>①检查此次申请是否超过了之前声明的最大需求数<br>②检查此时系统剩余的可用资源是否还能满足这次请求<br>③试探着分配，更改各数据结构<br>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全性算法步骤：<br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设系统中有 n 个进程，m 种资源.每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为 最大需求矩 阵 Max，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源</span><br><span class="line">Rj。同理，系统可以用一个 n*m 的 分配矩 阵 Allocation表示对所有进程的资源分配情况。Max – Allocation =Need 矩 阵 ，表示各进程最多还需要多少各类资源。另外，还要用一个 长 度为 m 的一 维 数 组 Available 表示当前系统中还有多少可用资源。某进程Pi向系统申请资源，可用一个长度为m的一维数组 Request i 表示本次申请的各种资源量。</span><br><span class="line"></span><br><span class="line">可用银行家算法预判本次分配是否会导致系统进入不安全状态：</span><br><span class="line">①如果 Request i [j]≤Need[i, j] (0≤j≤m)便转向②；否则认为出错。</span><br><span class="line">②如果 Request i [j]≤Available[j] (0≤j≤m)，便转向③ ；否则表示尚无足够资源，Pi必须等待。</span><br><span class="line">③系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：</span><br><span class="line">Available = Available - Request i ;</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Request i [j];</span><br><span class="line">Need[i, j] = Need[i, j] – Request i [j]</span><br><span class="line">④操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221251516.png" alt="image.png"></p><h3 id="死锁处理策略—检测和解除"><a href="#死锁处理策略—检测和解除" class="headerlink" title="死锁处理策略—检测和解除"></a><em>死锁处理策略—检测和解除</em></h3><p><em>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221414947.png" alt="image.png"></p><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a><em>死锁的检测</em></h4><p>为了能对系统是否已发生了死锁进行检测，必须：<br>①用某种数据结构来保存资源的请求和分配信息；<br>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221416320.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221416384.png" alt="image.png"></p><blockquote><p><em>绿色边，代表已经被分配出去的一个资源，蓝色边代表还需要申请的资源<br>资源足够时，进程结束会将资源归还，从而消除这些边，如果能将所有边消除就称这个图是<strong>可完全简化的</strong>此时一定没有发生死锁（相当于能找到一个安全序列）如果最终不能消除所有边，那么此时就是发生了死锁。</em></p></blockquote><p><em>1.可以消除所有的边说明没有发生死锁</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221419926.png" alt="image.png"></p><p><em>2.不可以消除所有的边，说明发生死锁</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221419782.png" alt="image.png"></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a><em>死锁的解除</em></h4><p>一旦检测出死锁的发生，就应该立即解除死锁。<br>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。</p><p><em>解除死锁的主要方法有：</em></p><ol><li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li><strong>撤销进程法（或称终止进程法）</strong>。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221426075.png" alt="image.png"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221426118.png" alt="image.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251038806.png" alt="image.png"></p><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251058031.png" alt="image.png"></p><p><mark>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</mark></p><div style="background-color: #fffacd;padding:20px;"> 1. 操作系统负责<mark style="background-color: #FFB6C1;">内存空间的分配与回收</mark><br></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251105578.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;">2. 操作系统需要提供某种技术从逻辑上 对<mark style="background-color: #FFB6C1;">内存空间进行扩充</mark></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251107271.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 3.操作系统需要提供地址转换功能，负责程序的<mark style="background-color: #FFB6C1;">逻辑地址</mark>与<mark style="background-color: #FFB6C1;">物理地址</mark>的转换 </div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251108361.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 4.操作系统需要提供内存保护 功能。保证各进程只能访问自己进程所在的内存空间，不干扰其他进程 </div><blockquote><p><strong>内存保护</strong>可以采取两种方式：</p></blockquote><ul><li><p>方法1：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251119698.png" alt="image.png"></p></li><li><p>方法2：采用<font color="#FF0000">重定位寄存器</font>（又称<font color="#FF0000">基址寄存器</font>）和<font color="0000FF">界地址寄存器</font>（又称<font color="0000FF">限长寄存器</font>）进行越界检查。重定位寄存器中存放的是进程的<font color="#FF0000">起始物理地址</font>。界地址寄存器中存放的是进程的<font color="0000FF">最大逻辑地址.</font><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251120552.png" alt="image.png"></p></li></ul><h2 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h2><p><mark>这是一段代码，分别对应存储在不同的内存区域当中</mark></p><div style="background-color: #fffacd;padding:20px;"> <li><mark style="background-color: #808080;">操作系统内核区</mark> :存进程控制块PCB</li><li><mark style="background-color: #FFB6C1;">用户栈(stack)</mark>：存局部变量以及传递参数</li><li><mark style="background-color: #ffe599;">共享库的存储映射区</mark>：被调用的库函数，如：<code>#include  studio.h头文件包括的库函数</code></li><li><mark style="background-color: #00FFFF;">堆（heap）</mark>：由 malloc/free 分配、回收的数据</li><li><mark style="background-color: #00FF00;">读/写数据</mark>：定义在函数外的全局变量、由 static 关键字修饰的变量</li><li><mark style="background-color:#CCCCFF;">只读代码/数据</mark>：程序代码、由 const 关键字修饰的常量</li><br><font color="#FF0000">注意：#define X 1024 宏定义的常量不专门分配存储空间，在预编译阶段就将程序中所有X都想替换成了1024</font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251427815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251424521.png" alt=""></p><blockquote><p><em>32位系统的，内存空间是4GB。32位是MAR位数，指的是最多有2<sup>32</sup>个内存地址，按照字节寻址，所以总容量就是2<sup>32</sup>B=4GB</em></p></blockquote><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311059270.png" alt="image.png"></p><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251536268.png" alt="image.png"></p><h4 id="进程的覆盖技术与交换技术"><a href="#进程的覆盖技术与交换技术" class="headerlink" title="进程的覆盖技术与交换技术"></a>进程的覆盖技术与交换技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251530850.png" alt="image.png"></p><p><strong><em>1.覆盖技术</em></strong><br>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为<font color="#FF0000">一个“固定区”</font>和<font color="#FF0000">若干个“覆盖区”。</font>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251540297.png" alt="image.png"></p><blockquote><p>缺点：<mark>必须由程序员声明覆盖结构</mark>，操作系统完成自动覆盖。<mark>对用户不透明，增加了用户编程负担</mark>。覆盖技术只用于早期的操作系统中，现在已成为历史。</p></blockquote><p><strong><em>2.交换技术</em></strong><br>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存（以进程为单位进行交换,），把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度），<font color="#FF0000">中级调度(内存调度)</font>实现。暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251544003.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 交换技术需要考虑的问题<br>1. 应该在外存（磁盘）的什么位置保存被换出的进程？<br>2. 什么时候应该交换？<br>3. 应该换出哪些进程？</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251547948.png" alt="image.png"></p><ol><li>具有对换功能的操作系统中，通常把磁盘空间分为<mark>文件区</mark>和<mark style="background-color: #00FFFF;">对换区</mark>两部分。<font color="#FFA500">文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；</font><font color="#0000FF">对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式</font>（学过文件管理章节后即可理解）。总之，对换区的I/O速度比文件区的更快。</li><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</li><li>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（注意：PCB 会常驻内存，不会被换出外存）</li></ol><h4 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a><em>虚拟存储技术</em></h4><p>虚拟存储技术是通过把内存扩展到外部存储设备,让程序可以获得比实际内存更大的逻辑地址空间。它通过把内存分页,并与外部存储建立页面映射表,当需要访问不在内存的页面时,通过页面置换算法将其换入内存。</p><div style="background-color: #fffacd;padding:20px;"> <mark>虚拟存储技术与交换技术的区别？</mark><font size="3"><br>1. 虚拟存储以页面为单位,交换技术以进程为单位。<br>2. 虚拟存储需要建立地址映射表,维护页面与外存地址的对应关系。交换技术不需要。<br>3. 虚拟存储发生页面异常时才发生换页,交换技术在进程切换时就进行。<br>4. 虚拟存储对程序是透明的,程序不必关心页面访问,交换技术程序需要关心整个进程的换入换出。<br>5. 虚拟存储可以同时维持多个进程/程序的工作集,交换技术每次只能有一个进程在运行。</font><br><br> <mark>虚拟存储技术与覆盖技术的区别？</mark><br><font size="3">1. 工作方式不同<br>虚拟存储是把内存扩展到外部存储设备,建立页面映射表,实现地址映射和自动页面调度。数据按需换入换出。<br>覆盖技术是在内存中维持多个覆盖程序,只加载当前需要执行的覆盖程序到内存。数据不会自动调度,需要程序员控制。<br>2. 程序个数不同<br>虚拟存储可以同时维持多个进程在内存和外存的工作集。<br>覆盖技术每次只能加载一个覆盖程序到内存执行。<br>3. 对程序的影响不同<br>虚拟存储对运行程序透明,程序不必关心页面调度。<br>覆盖技术程序员必须控制程序的覆盖和重定位。<br>4. 实现难度不同<br>虚拟存储实现较复杂,需要建立地址映射、页面置换算法等机制。<br>覆盖技术原理简单,直接通过程序员控制实现。<br>5. 使用范围不同<br>虚拟存储广泛用于各种通用操作系统。<br>覆盖技术只适用于特定的嵌入式系统。</div></font>>*具体会在3.5中作详细介绍*### 内存空间的分配与回收#### 连续分配管理方式<mark>连续分配是指为用户分配的必须是连续的一段内存空间</mark>![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251611336.png)##### ***1.单一连续分配***在单一连续分配方式中，内存被分为<mark>系统区</mark>和<mark>用户区</mark>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<mark>内存中只能有一道用户程序，用户程序独占整个用户区空间。</mark>>**优点**：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。>**缺点**：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低<div style="background-color: #ffe599;padding:15px;"> 注：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”</div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251614067.png" alt="image.png"></p><h5 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2.固定分区分配"></a><strong><em>2.固定分区分配</em></strong></h5><p>出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<mark>将整个用户空间划分为若干个固定大小的分区</mark>，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p><mark style="background-color: #00FFFF;">分区大小相等</mark>：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）<br><mark style="background-color: #00FFFF;">分区大小不等</mark>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分比如：划分多个小分区、适量中等分区、少量大分区）</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251650375.png" alt="image.png"></p><div style="background-color: #ffe599;padding:15px;"> 这些分区，用什么方式记录管理分配呢？ </div> <p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回<br>收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<br>大小、起始地址、状态（是否已分配）。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251656124.png" alt="image.png"><br>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，<br>从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状<br>态为“已分配”</p><blockquote><p><strong>优点</strong>：实现简单，<font color="#FF0000">无外部碎片。</font><br><strong>缺点</strong>：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采<br>用覆盖技术来解决，但这又会降低性能；b. <font color="#FF0000">会产生内部碎片</font>，内存利用率低。</p></blockquote><p><mark>注</mark>：<em>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</em></p><h5 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3.动态分区分配"></a><strong><em>3.动态分区分配</em></strong></h5><p>动态分区分配又称为可变分区分配。<mark>这种分配方式不会预先划分内存分区</mark>，而是在进程装入内存时，<mark>根据进程的大小动态地建立分区</mark>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</p><ol><li><p>系统要用什么样的数据结构记录内存的使用情况？<br>答：空闲分区表和空闲分区链（记录的都是空闲内存区域）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251704694.png" alt="image.png"></p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？应该用最大的分区进行分配 ？还 是用最小的分区进行分配 ？ 又或是用地址最低 的部分进行分配?<br>答：下一节讨论</p></li><li><p>如何进行分区的分配与回收操作？<br>答：相邻的空闲分区合并为一个</p></li></ol><blockquote><p>动态分区分配没有内部碎片，但是有外部碎片。<br>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p></blockquote><h5 id="（动态分区分配算法）"><a href="#（动态分区分配算法）" class="headerlink" title="!（动态分区分配算法）"></a>!（动态分区分配算法）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251845899.png" alt="image.png"></p><p><strong>引入</strong><br>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p><strong>1.首次适应算法</strong><br><strong><em>算法思想</em></strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br><strong><em>如何实现</em></strong>：空闲分区以<strong>地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251847680.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251849013.png" alt="image.png"></p><p><strong>2.最佳适应算法</strong><br><strong><em>算法思想</em></strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。<br><strong><em>如何实现</em></strong>：空闲分区按<strong>容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><blockquote><p>缺点：每次都是选取最小的分区进行分配，会留下越来越多，很小的难以利用的内存块，因此会产生很多的外部碎片<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251850723.png" alt="image.png"></p></blockquote><p><strong>3.最坏适应算法</strong><br><strong><em>算法思想</em></strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br><strong><em>如何实现</em></strong>：空闲分区按<strong>容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><blockquote><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251854915.png" alt="image.png"></p><p><strong>4.邻近适应算法</strong><br><strong><em>算法思想</em></strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。<br><strong><em>如何实现</em></strong>：空闲分区以<strong>地址递增的顺序排列</strong>（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始查找空闲分区链</strong>（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251857013.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251858752.png" alt="image.png"></p><p><strong>总结</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251859958.png" alt="image.png"></p><h4 id="非连续非配管理方式"><a href="#非连续非配管理方式" class="headerlink" title="非连续非配管理方式"></a>非连续非配管理方式</h4><p><mark>非连续分配是指为用户分配的可以是一些分散的内存空间</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261122291.png" alt="image.png"></p><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a><strong><em>基本分页存储管理</em></strong></h5><p><strong><em>1.什么是分页存储？</em></strong><br>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），<strong><em>页框号从 0 开始</em></strong></p><p>将进程的逻辑地址空间也分为 与页框大小相等 的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，<strong><em>页号也是 从 0 开始 。</em></strong></p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。</p><blockquote><p>注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</p></blockquote><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261131317.png" alt="图片alt"> </p><p><strong><em>2.分页存储的逻辑地址结构</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262117101.png" alt="image.png"></p><p><strong><em>3.页表</em></strong><br>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。【注：页表通常存在PCB（进程控制块）中】</p><ol><li>一个进程对应一张页表。</li><li>进程的每个页面对应一个页表项。</li><li>每个页表项由“页号”和“块号”组成。</li><li>页表记录进程页面和实际存放的内存块之间的映射关系。</li><li>每个页表项的长度是相同的。</li></ol><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261138273.png" alt="图片alt"> </p><p><strong><em>4.每个页表项占多少个字节？</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261142588.png" alt="image.png"></p><blockquote><p>注：页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）</p></blockquote><p><em>假设页表中的各页表项从内存地址为 X 的地方开始连续存放…如何找到页号为 i 的页表项？（按字节编址）</em></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261356850.png" alt="图片alt"> </p><p>i 号页表项的存放地址 = X + 3 * I 因此，页表中的页号可以是隐含的，即页号不占用存储空间。通过页号结合页表项长度，计算得出块号存放起始地址，然后就可以取得块号，最后将取得的块号与逻辑偏移量拼接就得到物理地址了</p><p><strong><em>5.如何实现地址转换？</em></strong><br>将进程地址空间 分页 之后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261149066.png" alt="image.png"></p><blockquote><p>在计算机内部，地址是用二进制表示的，如果页面大小 刚好是 2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261348326.png" alt="image.png"></p><p><strong>总结：页面大小 刚好是 2 的整数幂有什么好处？</strong><br>①逻辑地址的拆分更加迅速——如果每个页面大小为 2 K B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。<br>②物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261349033.png" alt="image.png"></p><h5 id="（基本地址变换机构）"><a href="#（基本地址变换机构）" class="headerlink" title="!（基本地址变换机构）"></a>!（基本地址变换机构）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261433939.png" alt="image.png"></p><p><strong><em>地址变换过程</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261448746.png" alt="image.png"></p><blockquote><p>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放页表在内存中的起始地址F 和页表长度M。进程未执行时，<strong><em>页表的始址和页表长度</em></strong> 放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p></blockquote><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：<br>①计算页号 P 和页内偏移量W（ 如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）。<br>②比较页号P 和页表长度M，若 P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少是1，因此 P=M 时也会越界）。<br>③页表中页号P对应的页表项地址 = 页表起始地址F + 页号P <em> 页表项长度，取出该页表项内容b，即为内存块号。（<font color="#FF0000">注意区分页表项长度、页表长度、页面大小的区别。<mark>页表长度指的是这个页表中总共有几个页表项，即总共有几个页</mark>；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间</font>）。<br>④计算 E = b </em> L + W，用得到的物理地址E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261453894.png" alt="image.png"></p><h5 id="（具有快表的地址变换机构）"><a href="#（具有快表的地址变换机构）" class="headerlink" title="!（具有快表的地址变换机构）"></a>!（具有快表的地址变换机构）</h5><p><strong><em>1.什么是快表？</em></strong><br>快表，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p><blockquote><p>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p></blockquote><p><strong><em>2.引入快表后，地址变换过程</em></strong><br>① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。<br>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。<br>③ 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261532866.png" alt="图片alt"> </p><p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p><p>(1+100) <em> 0.9 + (1+100+100) </em> 0.1 = 111 us<br>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) <em> 0.9 + (100+100) </em> 0.1 =110.9 us<br>若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p><blockquote><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p></blockquote><p><strong><em>3.什么是局部性原理？</em></strong></p><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）<br><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261539092.png" alt="图片alt"> </p><p><strong><em>4.区别</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261558477.png" alt="image.png"></p><h5 id="（两级页表）"><a href="#（两级页表）" class="headerlink" title="!（两级页表）"></a>!（两级页表）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261912045.png" alt="image.png"></p><p><strong><em>1.单页表存在的问题</em></strong></p><p>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<br>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261915514.png" alt="image.png"></p><p><strong><em>2.如何解决单级页表的问题</em></strong></p><p>解决问题一：把<strong>页表再分页并离散存储</strong>，然后再建立一张页表记录页表各个部分的存放位置，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>，或称<strong>顶层页表</strong>。</p><p>解决问题二：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断/异常），然后将目标页面从外存调入内存。</p><p><strong><em>3.二级页表的原理、地址结构</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262011315.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262012145.png" alt="image.png"></p><p><strong><em>4.如何实现地址变换</em></strong><br>①按照地址结构将逻辑地址拆分成三部分<br>②从PCB 中读出页目录表始址，再根据一级页号查页目录<br>表，找到下一级页表在内存中的存放位置<br>③根据二级页号查二级页表，找到最终想访问的内存块号<br>④结合页内偏移量得到物理地址</p><p>例：将逻辑地址 (0000000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262019570.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262022937.png" alt="image.png"></p><p><strong><em>5.需要注意的几个细节</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262027027.png" alt="image.png"></p><h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同。在分页当中，每个页面的大小是相同的；分段当中，每个段的大小是不同的。</p><p><strong><em>1.什么是分段存储？</em></strong><br>进程的地址空间：按照程序自身的逻辑关系划分为若干个大小不一的段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262112169.png" alt="image.png"></p><p><strong><em>2.分段存储的逻辑地址结构</em></strong><br>分段系统的&lt;&gt;逻辑地址&lt;&gt;结构由段号（段名）和段内地址（段内偏移量）所组成。如：</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262118933.png" alt="image.png"><br>在上述例子中，若系统是按字节寻址的，<br>则段号占16位，因此在该系统中，每个进程最多有 2 16 = 64K 个段。<br>段内地址占 16位，因此每个段的最大长度是 2 16 = 64KB。</p><p><strong><em>3.段表</em></strong></p><ol><li><strong>每个段对应一个段表项</strong>，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。（由于主存中的分段大小不一，所以不能只存块号，应直接存基址）</li><li><strong>各个段表项的长度是相同的</strong>。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K * 6</li></ol><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262122760.png" alt="图片alt"> </p><p><strong><em>4.如何实现地址转换?</em></strong></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262126386.png" alt="图片alt"> </p><p><strong><em>5.分段与分页管理的对比</em></strong></p><div style="background-color: #fffacd;padding:20px;"> <font color="#FF0000">页是信息的物理单位</font>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<font color="#FF0000">对用户是不可见的</font>。<br><font color="#FF0000">段是信息的逻辑单位</font>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<font color="#FF0000">分段对用户是可见的</font>，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。<br><br><font color="#FF0000">分页</font> 的用户进程<font color="#FF0000">地址空间是一维的</font>，程序员只需给出一个记忆符即可表示一个地址。<br><font color="#FF0000">分段</font> 的用户进程<font color="#FF0000">地址空间是二维的</font>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。<br><br>访问一个逻辑地址需要几次访存？<br>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存。<br>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。<mark>分段比分页更容易实现信息的共享和保护</mark></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如要共享进程中绿色部分信息：</span><br><span class="line"></span><br><span class="line">如果进程是分段存储管理，很容易将这部分共享信息单独分一个段出来，设置为可共享。</span><br><span class="line"></span><br><span class="line">如果进程是分页存储管理，由于每一个页面大小固定，本分割放到两个不同的块中，由于绿色部分需要实现共享，但是其他部分信息不应该共享，这样就使得信息共享变得困难，也使得很难用页表实现信息保护</span><br></pre></td></tr></table></figure><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262140725.png" alt="图片alt"> </p><p><strong><em>6.总结</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262147649.png" alt="image.png"></p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a><em>虚拟内存管理</em></h2><h3 id="虚拟内存管理基本概念"><a href="#虚拟内存管理基本概念" class="headerlink" title="虚拟内存管理基本概念"></a><em>虚拟内存管理基本概念</em></h3><h4 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h4><p>上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：</p><ol><li>一次性<br>作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：<ul><li>当作业很大，不能全部被装入内存时，将使该作业无法运行；</li><li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li></ul></li></ol><ol><li>驻留性<br>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态。  </li></ol><p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311107301.png" alt="图片alt"> </p><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a><em>虚拟内存的定义和特征</em></h4><ul><li><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p></li><li><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p></li></ul><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p><p>虚拟内存有一下三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul><h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a><em>如何实现虚拟内存技术</em></h4><blockquote><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<mark>离散分配</mark>的内存管理方式基础上。虚拟内存的实现有以下三种方式：</p></blockquote><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311114432.png" alt="图片alt"> </p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311115631.png" alt="image.png"></p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p><strong>请求分页系统</strong>是建立在基本分页的基础上的，为了能支持<strong>虚拟存储器</strong>功能而增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能。<br>相应地，每次<strong>调入</strong>和<strong>换出</strong>的基本单位都是长度固定的页面，这使得请求分页系统在实现上要比请求分段系统简单。<br>请求分段系统在换进和换出时是<strong>可变长度的段</strong>因此，请求分页便成为目前最常用的一种实现虚拟存储器的方式</p><p><strong><em>请求分页中的硬件支持</em></strong><br>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一台具有一定容量的内存及外存的计算机系统外，还需要有<strong>页表机制</strong>、<strong>缺页中断机构</strong>以及<strong>地址变换机构</strong></p><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a><mark>页表机制</mark></h4><p>在请求分页系统中所需要的主要<strong>数据结构</strong>是<strong>页表</strong>。其基本作用仍然是将<strong>用户空间</strong>中的<strong>逻辑地址</strong>变换为<strong>内存空间</strong>中的<strong>物理地址</strong>。<br>由于只将应用程序的<strong>一部分调入内存</strong>，还有一部分仍在盘上，故需在页表中再<font color="#FF0000">增加4个字段</font>，供程序（数据）在换进、换出时参考。</p><p>请求分页系统中的每个页表项如下所示：</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311254870.png" alt="图片alt"> </p><ul><li><strong>状态位P</strong>：用于指示该页<strong>是否已调入内存</strong>，供<strong>程序访问</strong>时参考。</li><li><strong>访问字段A</strong>：用于记录本页在<strong>一段时间内被访问的次数</strong>，或记录本页最近已有多长时间未被访问，供选择<strong>换出页面</strong>时参考。</li><li><strong>修改位M</strong>：表示该页在调入内存后是否被修改过。供<strong>置换页面</strong>时参考。由于内存中的每一页都在<strong>外存上有一份副本</strong>，因此，若<strong>未被修改</strong>，在置换该页时就<strong>不需要</strong>将该页写回到外存上，以减少<strong>系统的开销</strong>和<strong>启动磁盘</strong>的次数；若<strong>已被修改</strong>，则必须将该页<strong>重写到外存</strong>上，以保证外存中所保留的始终是最新副本。</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址</li></ul><h4 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a><mark>缺页中断机制</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311334123.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311335392.png" alt="image.png"></p><h4 id="地址变换机制"><a href="#地址变换机制" class="headerlink" title="地址变换机制"></a><mark>地址变换机制</mark></h4><div style="background-color: #fffacd;padding:20px;"><font color="#FF0000">请求分页存储管理与基本分页存储管理的主要区别:</font> <font size="3"><br>1.操作系统要提供请求调页功能，将缺失页面从外存调入内存<br>2.操作系统要提供页面置换的功能，将暂时用不到的页面换出外存<br><br><font color="#FF0000">在具有快表机构的请求分页系统中访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</font><br>查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元<br><br>补充细节<br>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。<br>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场<br>③需要用某种“页面置换算法”来决定一个换出页面（下节内容）<br>④换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销<br>⑤页面调入内存后，需要修改慢表(页表)，同时也需要将表项复制到快表中</font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311341324.png" alt="image.png"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><em>页面置换算法</em></h3><p>请求分页存储管理与基本分页存储管理的主要区别：<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。<font color="#FF0000">用页面置换算法决定应该换出哪个页面</font></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011838965.png" alt="image.png"></p><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a><mark>最佳置换算法(OPT)</mark></h4><p>最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是<font color="#FF0000">以后永不使用</font>，或者在<font color="#FF0000">最长时间内不再被访问的页面</font>，这样可以保证最低的缺页率。<br>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<font color="#FF0000">操作系统无法提前预判页面访问序列</font>。因此，<font color="#FF0000">最佳置换算法是无法实现的</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011900075.png" alt="image.png"></p><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a><mark>先进先出置换算法(FIFO)</mark></h4><p>先进先出置换算法（FIFO）：每次<font color="#FF0000">选择淘汰的页面是最早进入内存的页面</font><br>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011904558.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <font color="#FF0000">Belady 异常</font>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011905761.png" alt="图片alt"> </p><font color="#FF0000">只有 FIFO 算法会产生 Belady 异常</font>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<font color="#FF0000">算法性能差</font></div><h4 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法(LRU)"></a><mark>最近最久未使用置换算法(LRU)</mark></h4><p>最近最久未使用置换算法（LRU，least recently used）：<font color="#FF0000">每次淘汰的页面是最近最久未使用的页面</font>。<br>实现方法：赋予每个页面对应的页表项中，用<font color="#FF0000">访问字段记录</font>该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。(<strong>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011913528.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011914280.png" alt="image.png"></p><h4 id="时针置换算法-CLOCK"><a href="#时针置换算法-CLOCK" class="headerlink" title="时针置换算法(CLOCK)"></a><mark>时针置换算法(CLOCK)</mark></h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用。置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算(NRU，NotRecently Used)。</p><font color="#FF0000">简单的CLOCK 算法实现方法</font>：为每个页面设置一个<font color="#FF0000">访问位</font>，再将内存中的页面都通过<font color="#FF0000">链接指针链接成一个循环队列</font>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，<font color="#FF0000">因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</font><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011940090.png" alt="image.png"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a><mark>改进型的时钟置换算法</mark></h4><p><code>简单的时钟置换算法</code>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<code>只有被淘汰的页面被修改过时，才需要写回外存</code>。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，<font color="#FF0000">避免I/O操作</font>。这就是改进型的时钟置换算法的思想。<br><code>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过</code>。<br>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011943937.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011943702.png" alt="图片alt"> </p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011945804.png" alt="image.png"></p><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a><em>页面分配策略</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309012117487.png" alt="image.png"></p><h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a><mark>驻留集</mark></h4><p>指请求分页存储管理中<mark style="background-color: #FFB6C1;">给进程分配的物理块的集合</mark>。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应大小合理</p><div style="background-color: #fffacd;padding:20px;"> 考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页。</div><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a><mark>页面分配、置换策略</mark></h4><p><mark style="background-color: #FFB6C1;">分配</mark></p><ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</li></ul><p><mark style="background-color: #FFB6C1;">置换</mark></p><ul><li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</li><li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><div style="background-color: #fffacd;padding:20px;"> 所以，驻留集是固定分配时，只能局部置换；驻留集是可变分配时，可以全局、也可以局部置换<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309012129658.png" alt="图片alt"> </p></div><ul><li><font color="#FF0000">固定分配局部置换</font>:  <font color="#0000FF">系统为每个进程分配一定数量的物理块</font>，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)。</li><li><font color="#FF0000">可变分配全局置换</font>:  <font color="#0000FF">刚开始会为每个进程分配一定数量的物理块</font>。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</li><li><font color="#FF0000">可变分配局部置换</font>:  <font color="#0000FF">刚开始会为每个进程分配一定数量的物理块</font>。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ul><h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a><mark>调入页面的时机</mark></h4><ol><li><p>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略<font color="#FF0000">主要用于进程的首次调入</font>，由程序员指出应该先调入哪些部分。<mark>运行前调入</mark></p></li><li><p>请求调页策略：<font color="#FF0000">进程在运行期间发现缺页时才将所缺页面调入内存</font>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。<mark>运行时调入</mark></p></li></ol><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a><mark>从何处调入页面</mark></h4><ol><li><font color="#FF0000">系统拥有足够的对换区空间</font>：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022206236.png" alt=""></li></ol><ol><li><font color="#FF0000">系统缺少足够的对换区空间</font>：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022208007.png" alt="image.png"></li></ol><ol><li><font color="#FF0000">UNIX 方式</font>：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022208479.png" alt="image.png"></li></ol><h4 id="抖动现象"><a href="#抖动现象" class="headerlink" title="抖动现象"></a><mark>抖动现象</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022211970.png" alt="image.png"></p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a><mark>工作集</mark></h4><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。<br>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><p>操作系统会根据“窗口尺寸”来算出工作集。例：<br>某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022213330.png" alt="图片alt"> </p><p>实际上<font color="#FF0000">工作集大小可能小于窗口尺寸</font>，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。<br>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么<font color="#FF0000">说明该进程有很好的局部性</font>，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。<br>一般来说，<font color="#FF0000">驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</font>。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><mark>总结</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022216598.png" alt="image.png"></p><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a><em>内存映射文件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031238320.png" alt="image.png"></p><h4 id="什么是内存映射文件？"><a href="#什么是内存映射文件？" class="headerlink" title="什么是内存映射文件？"></a><mark>什么是内存映射文件？</mark></h4><p>内存映射文件——操作系统向上层程序员提供的功能（系统调用）<br>• 方便程序员访问文件数据<br>• 方便多个进程共享同一个文件</p><h4 id="传统的内存访问方式"><a href="#传统的内存访问方式" class="headerlink" title="传统的内存访问方式"></a><mark>传统的内存访问方式</mark></h4><p>open 系统调用——打开文件<br>seek 系统调用——将读写指针移到某个位置<br>read 系统调用——从读写指针所指位置读入若干数据（从磁盘读入内存）<br>write 系统调用——将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031241603.png" alt="image.png"></p><h4 id="内存映射文件访问方式"><a href="#内存映射文件访问方式" class="headerlink" title="内存映射文件访问方式"></a><mark>内存映射文件访问方式</mark></h4><p>open 系统调用——打开文件<br>mmap 系统调用——将文件映射到进程的虚拟地址空间<br>• 以访问内存的方式访问文件数据<br>• 文件数据的读入、写出由操作系统自动完成(缺页时系统自动调入内存)<br>• 进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031242313.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 多个进程可以映射同一个文件，实现<mark>共享</mark>。在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马“看到<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031245538.png" alt="图片alt"> </p></div><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><mark>总结</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309031245979.png" alt="image.png"></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h2 id="初识文件管理"><a href="#初识文件管理" class="headerlink" title="初识文件管理"></a>初识文件管理</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071705475.png" alt="image.png"></p><p><mark>内存的逻辑地址与外存的逻辑地址区别</mark></p><ol><li>内存的逻辑地址是CPU通过段基址寄存器和偏移地址计算得到的,用于访问内存。外存的逻辑地址是文件系统生成的,用于定位文件在外存上的位置。</li><li>内存的逻辑地址需要映射为物理地址才能真正访问内存。外存的逻辑地址可以直接对应到外存的物理位置。</li><li>内存的逻辑地址用于程序代码和数据。外存的逻辑地址对应于文件系统的文件及目录。</li><li>内存的逻辑地址由内存管理单元(MMU)映射。外存的逻辑地址由文件系统解析。</li><li>内存的逻辑地址对程序是透明的。外存的逻辑地址可以为用户程序所见。</li><li>内存的逻辑地址空间连续统一。外存的逻辑地址分散不连续。</li><li>内存的逻辑地址方便程序编址。外存的逻辑地址方便文件查找。</li><li>内存的逻辑地址范围由操作系统管理。外存的逻辑地址用户可更改。</li></ol><p>总之,两者是不同的地址体系,内存逻辑地址由CPU产生,外存逻辑地址由文件系统管理,用途和转换机制不同。但都提供了更简单的地址抽象。</p><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><h3 id="文件结构的分类"><a href="#文件结构的分类" class="headerlink" title="文件结构的分类"></a>文件结构的分类</h3><p>按文件是否有结构分类，可以分为无结构文件、有结构文件两种。</p><ul><li><strong>无结构文件</strong>：文件内部的数据就是一系列二进制流或字符流组成。又称“<font color="#FF0000">流式文件</font>”。如：Windows 操作系统中的 .txt 文件。</li><li><strong>有结构文件</strong>：由一组相似的记录组成，又称“<font color="#FF0000">记录式文件</font>”。每条记录又若干个数据项组成。如：数据库表文件。一般来说，每条记录有一个数据项可作为关键字。根据各条记录的长度（占用的存储空间）是否相等，又可分为<font color="#FF0000">定长记录</font>和<font color="#FF0000">可变长记录</font>两种。下边图示的表格就是一个定长记录的有结构文件</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071810845.png" alt="image.png"></p><h3 id="有结构文件"><a href="#有结构文件" class="headerlink" title="有结构文件"></a>有结构文件</h3><p>由一组相似的记录组成，又称“记录式文件”。每条记录又若干个数据项组成。如：<br>数据库表文件。一般来说，每条记录有一个数据项可作为关键字。根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种。</p><blockquote><p>有结构文件按各条记录长度是否相等分为定长和不定长记录两种</p></blockquote><p><strong>1.定长记录的有结构文件</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071812057.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071812206.png" alt="image.png"></p><p>这个有结构文件由<font color="#FF0000">定长记录</font>组成，每条记录的长度都相同（共 128 B）。各数据项都处在<br>记录中相同的位置，具有相同的顺序和长度（前32B一定是学号，之后32B一定是姓名……）</p><p><strong>2.不定长记录的有结构文件</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071817882.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071817147.png" alt="image.png"><br>这个有结构文件由可变长记录组成，由于各个学生的特长存在很大区别，因此“特长”这个数据项的长度不确定，这就导致了各条记录的长度也不确定。当然，没有特长的学生甚至可以去掉“特长”数据项</p><h3 id="有结构文件的逻辑结构"><a href="#有结构文件的逻辑结构" class="headerlink" title="有结构文件的逻辑结构"></a>有结构文件的逻辑结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072129208.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072102475.png" alt="image.png"></p><h4 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h4><p>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072105845.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072108165.png" alt="image.png"></p><blockquote><p>为什么变长记录的顺序存储无法实现随机存取，而定长记录的顺序存储可以？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072110425.png" alt="image.png"></p><p>对于不定长记录的顺序存储，由于记录长度不等，寻找第i个记录时，就需要从前往后依次将前i-1个记录长度相加，得到第i个记录的长度所在的位置。</p><p>但是对于定长记录的顺序存储，由于记录长度相等，寻找第i个记录时，只需要，字段长度 L * i ,瞬间得到第i个字段的长度位置。</p><p>一般来说，考试题目中所说的“顺序文件”指的是物理上顺序存储的顺序文件。之后的讲解中提到的顺序文件也默认如此。可见，顺序文件的缺点是增加/删除一个记录比较困难（如果是串结构则相对简单）</p><p>对于可变长记录文件，要找到第 i 个记录，必须先顺序第查找前 i-1 个记录，但是很多应用场景中又必须使用可变长记录。如何解决这个问题？这就需要<strong>索引文件</strong></p><h4 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h4><p>索引表本身是定长记录的顺序文件。因此可以快速找到第 i 个记录对应的索引项。可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。每当要增加/删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072121271.png" alt="image.png"></p><p>思考索引文件的缺点：每个记录对应一个索引表项，因此索引表可能会很大。比如：文件的每个记录平均只占 8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。这就需要<strong>索引顺序文件</strong></p><h4 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h4><p>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立<br>一张索引表，但不同的是：并不是每个记录对应一个索引表项，而是<font color="#FF0000">一组记录</font>对应一个<br>索引表项。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072124893.png" alt="image.png"></p><blockquote><p>用这种策略确实可以让索引表“瘦身”，但是能否解决不定长记录的顺序文件检索速度慢的问题呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072125340.png" alt="image.png"></p><p>为了进一步提高检索效率，可以为顺序文件建立多级索引表。</p><h4 id="多级索引表"><a href="#多级索引表" class="headerlink" title="多级索引表"></a>多级索引表</h4><p>例如，对于一个含 10 6 个记录的文件，可先为该文件建立一张低级索引表，每 100 个记录为一组，故低级索引表中共有 10000 个表项（即10000个定长记录），再把这 10000 个定长记录分组，每组100个，为其建立顶级索引表，故顶级索引表中共有 100 个表</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072128732.png" alt="image.png"></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><p>文件目录就是我们很熟悉的Windows操作系统的文件夹</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072146300.png" alt="image.png"></p><h3 id="文件控制块-FCB"><a href="#文件控制块-FCB" class="headerlink" title="文件控制块(FCB)"></a>文件控制块(FCB)</h3><p>.<font color="#FF0000">目录</font>本身就是一种<font color="#FF0000">有结构文件</font>，由一条条记录组成。每条记录对应一个在该放在该目录下的文件.</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072150505.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072150094.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309080948652.png" alt="image.png"></p><p>目录文件中的一条记录就是一个“文件控制块（FCB)“</p><p>FCB 的有序集合称为“文件目录”，<font color="#FF0000">一个FCB就是一个文件目录项</font>。FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。<font color="#FF0000">最重要，最基本</font>的还是 <font color="#FF0000">文件名、文件存放的物理地址</font>。FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”。</p><blockquote><p>需要对目录进行哪些操作？</p></blockquote><p>搜索：当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项<br>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项<br>删除文件：当删除一个文件时，需要在目录中删除相应的目录项<br>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性<br>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项（如：文件重命名）</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。</p><p>单级目录实现了“按名存取”，但是<font color="#FF0000">不允许文件重名</font>。</p><p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中</p><p>显然，<font color="#FF0000">单级目录结构不适用于多用户操作系统</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309072328115.png" alt="image.png"></p><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p>早期的多用户操作系统，采用两级目录结构。分为主文件目录（MFD，Master File Directory）和用户文件目录（UFD，User Flie Directory）。</p><p>允许不同用户的文件重名。文件名虽然相同，但是对应的其实是不同的文件</p><p>两级目录结构允许不同用户的文件重名，也可以在目录上实现实现访问限制（检查此时登录的用户名是否匹配）。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309080953833.png" alt="image.png"></p><p>但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类，所以提出了<font color="#FF0000">多级目录结构</font></p><h4 id="多级目录结构"><a href="#多级目录结构" class="headerlink" title="多级目录结构"></a>多级目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309080955806.png" alt="image.png"></p><p>又称树形目录结构<br>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。从<font color="#FF0000">根目录</font>出发的路径称<font color="#FF0000">为绝对路径</font>。例如：<font color="#FF0000">自拍.jpg 的绝对路径是 “/照片/2015-08/自拍.jpg”</font></p><p>每次都从根目录开始查找，是很低效的。因此可以设置一个“当前目录”。例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用从<font color="#FF0000">当前目录</font>出发的“<font color="#FF0000">相对路径</font>” 。在 Linux 中，“.”表示当前目录，因此如果“照片”是当前目录，则”<font color="#FF0000">自拍.jpg”的相对路径为：<br>“./2015-08/自拍.jpg</font>”。</p><p>.<font color="#FF0000">树形目录结构</font>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构<font color="#FF0000">不便于实现文件的共享</font>。为此，提出了“<font color="#FF0000">无环图目录结构</font>”</p><h4 id="无环图目录结构"><a href="#无环图目录结构" class="headerlink" title="无环图目录结构"></a>无环图目录结构</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081027982.png" alt="image.png"><br>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。<br>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点。用户提出删除结<br>点的请求时，只是删除该用户的FCB、并使共享计数器减1，并不会直接删除共享结点。<br>只有共享计数器减为0时，才删除结点。<br>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化。</p><h3 id="索引结点-FCB的改进"><a href="#索引结点-FCB的改进" class="headerlink" title="索引结点(FCB的改进)"></a>索引结点(FCB的改进)</h3><p>思考有何好处？<br>假设一个FCB是64B，磁盘块的大小为1KB，则每个盘块中只能存放16个FCB。若一个文件目录中共有640个目录项，则共需要占用640/16 = 40 个盘块。因此按照某文件名检索该目录，平均需要查询320 个目录项，平均需要启动磁盘20次（每次磁盘I/O读入一块）。</p><p>若使用索引结点机制，文件名占14B，索引结点指针站2B，则每个盘块可存放64个目录项，那么按文件名检索目录平均只需要读入 320/64 = 5 个磁盘块。显然，这将大大提升文件检索速度。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081040657.png" alt="image.png"></p><p>当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。存放在<font color="#FF0000">外存中的</font>索引结点称为<font color="#FF0000">“磁盘索引结点</font>”，当索引结点<font color="#FF0000">放入内存</font>后称为“<font color="#FF0000">内存索引结点”</font>。<font color="#FF0000">相比之下内存索引结点中需要增加一些信息</font>，比如：文件是否被修改、此时有几个进程正在访问该文件等。</p><h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081043512.png" alt="image.png"></p><h2 id="文件的物理结构（分配方式）"><a href="#文件的物理结构（分配方式）" class="headerlink" title="文件的物理结构（分配方式）"></a>文件的物理结构（分配方式）</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081117508.png" alt="image.png"></p><blockquote><p>首先了解文件块与磁盘块</p></blockquote><p>在内存管理中，进程的逻辑地址空间被分为一个一个页面，同样的在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为了一个一个的文件“块”。于是文件的逻辑地址也可以表示为（逻辑块号，块内地址）的形式。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081111977.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081116116.png" alt="image.png"></p><h3 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h3><p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p><blockquote><p>连续分配的优点有哪些？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081149501.png" alt="image.png"></p><p>磁盘分为很多的扇形块，读取一个块时，需要移动读写头，到对应的扇区，而连续分配方式，使得文件数据存放的扇区相邻，读取某个磁盘块时，需要移动磁头。访问的两个磁盘块相隔越远，移动磁头所需时间就越长。<br>所以，<font color="#FF0000">连续分配的文件在顺序读/写时速度最快</font></p><p>用户给出要访问的逻辑块号，操作系统找到该文件对应的目录项（FCB）…<br>.<font color="#FF0000">物理块号 = 起始块号 + 逻辑块号</font><br>当然，还需要检查用户提供的逻辑块号是否合法（逻辑块号 ≥ 长度 就不合法）<br>可以直接算出逻辑块号对应的物理块号，因此<font color="#FF0000">连续分配支持顺序访问和直接访问（即随机访问）</font></p><blockquote><p>连续分配的缺点有哪些？</p></blockquote><p>.<font color="#FF0000">不方便文件拓展；存储空间利用率低，会产生磁盘碎片</font></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081153482.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081156936.png" alt="image.png"></p><h3 id="链接分配"><a href="#链接分配" class="headerlink" title="链接分配"></a>链接分配</h3><p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块。分为隐式链接和显式链接两种。</p><p><strong>1.隐式链接</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081159897.png" alt="image.png"><br>目录中记录了文件存放的起始块号和结束块号。当然，也可以增加一个字段来表示文件的长度</p><p>除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户是透明的</p><blockquote><p>隐式链接又是如何实现文件逻辑块号到物理块号的转变的？</p></blockquote><p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…<br>从目录项中找到起始块号（即0号块），将0号逻辑块读入内存，由此知道1号逻辑块存<br>放的物理块号，于是读入1号逻辑块，再找到2号逻辑块的存放位置……以此类推。<br>因此，读入i号逻辑块，总共需要 i+1 次磁盘I/O。</p><p>结论：采用链式分配（隐式链接）方式的文件，<font color="#FF0000">只支持顺序访问，不支持随机访问</font>，查<br>找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。</p><blockquote><p>隐式链接是否方便拓展文件呢？</p></blockquote><p>若此时要拓展文件，则可以随便找一个空闲磁盘块，挂到文件的磁盘块链尾，并修改文件的FCB</p><p>结论：采用隐式链接的链接分配方式，<font color="#FF0000">很方便文件拓展。另外，所有的空闲磁盘块都可以被利用，不会有碎片问题</font>，外存利用率高</p><p><strong>2.显示连接</strong></p><p>把用于链接文件各物理块的指针显式地存放在一张表中。即 文件分配表（FAT，File Allocation Table）</p><p>假设某个新创建的文件“aaa”依<br>次存放在磁盘块 2 -&gt;5 -&gt;0 -&gt;1</p><p>假设某个新创建的文件“bbb”依<br>次存放在磁盘块 4 -&gt;23 -&gt;3</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081207970.png" alt="image.png"></p><p>.<font color="#FF0000">注意：一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存</font>。 FAT 的各个表项在物理上连续存储，且每一个表项长度相同，因此<font color="#FF0000">“物理块号”字段可以是隐含的</font></p><blockquote><p>显示链接是如何实现文件的逻辑块号到物理块号的转变的？</p></blockquote><p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…<br>从目录项中找到起始块号，若i&gt;0，则查询内存中的文件分配表FAT，往后找到 i 号逻辑块对应的物理块号。<font color="#FF0000">逻辑块号转换成物理块号的过程不需要读磁盘操作</font>。</p><p>结论：采用链式分配（显式链接）方式的文件，<font color="#FF0000">支持顺序访问，也支持随机访问（想访问 i 号逻辑块时，并不需要依次访问之前的 0 ~ i-1号逻辑块）</font>，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。</p><p>显然，显式链接也不会产生外部碎片，也可以很方便地对文件进行拓展。</p><p><strong>注意：考试题目中遇到未指明隐式/显式的“链接分配”，默认指的是隐式链接的链接分配</strong></p><p>显示链接需要借助文件分配表，但是文件分配表也需要占用一定的内存，显然当外存中文件内容很多时，文件分配表就会很大大，有没有办法解决呢？引出了索引分配</p><h3 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h3><p>.<font color="#FF0000">索引分配</font>允许文件<strong>离散</strong>地分配在各个磁盘块中，<font color="#FF0000">系统会为每个文件建立一张索引表</font>，索引表中<font color="#FF0000">记录了文件的各个逻辑块对应的物理块</font>（索引表的功能类似于内存管理中的页表——建立逻辑页面到物理页之间的映射关系）。<font color="#FF0000">索引表存放的磁盘块称为索引块</font>。文件数据存放的磁盘块称为数据块。</p><p>假设某个新创建的文件“aaa”的数据依次存放在磁盘块 2 -&gt;5 -&gt;13 -&gt;9 。7号磁盘块作为“aaa”的索引块，索引块中保存了索引表的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081318316.png" alt="image.png"></p><p><strong>注：在显式链接的链式分配方式中，文件分配表FAT 是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张</strong></p><p>可以用固定的长度表示物理块号（如：假设磁盘总容量为1TB=2 40 B，磁盘块大小为1KB，则共有 2 30 个磁盘块，则可用4B 表示磁盘块号），因此，索引表中的“逻辑块号”可以是隐含的。</p><blockquote><p>如何实现文件逻辑块号到物理块号的转换？</p></blockquote><p>用户给出要访问的逻辑块号 i，操作系统找到该文件对应的目录项（FCB）…从目录项中可知索引表存放位置，将索引表从外存读入内存，并查找索引表即可只 i 号逻辑块在外存中的存放位置。</p><p>.<font color="#FF0000">可见，索引分配方式可以支持随机访问。文件拓展也很容易实现</font>（只需要给文件分配<br>一个空闲块，并增加一个索引表项即可）但是<font color="#FF0000">索引表需要占用一定的存储空间</font></p><blockquote><p>若每个磁盘块1KB，一个索引表项4B，则一个磁盘块只能存放 256 个索引项。如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决这个问题？</p></blockquote><p>①链接方案<br>②多层索引<br>③混合索引</p><p><strong>1.链接方案</strong></p><p>①链接方案：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081322085.png" alt="image.png"><br>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。若一个文件大小为 256 <em> 256KB =65,536 KB = 64MB该文件共有 256 </em> 256 个块，也就对应256 * 256个索引项，也就需要 256 个索引块来存储，这些索引块用链接方案连起来。若想要访问文件的最后一个逻辑块，就必须找到最后一个索引块（第256个索引块），而各个索引块之间是用指针链接起来的，因此必须先顺序地读入前 255 个索引块。</p><p>这显然是很低效的。如何解决呢？</p><p><strong>2.多层索引</strong><br>②多层索引：建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081446417.png" alt="image.png"></p><p>假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256 个索引项。若某文件采用两层索引，则该文件的最大长度可以到256<em>256</em>1KB = 65,536 KB = 64MB可根据逻辑块号算出应该查找索引表中的哪个表项。</p><p>如：要访问 1026 号逻辑块，则1026/256 = 4，1026%256 = 2因此可以先将一级索引表调入内存，查询 4 号表项，将其对应的二级索引表调入内存，再查询二级索引表的2号表项即可知道 1026 号逻辑块存放的磁盘块号了。访问目标数据块，需要3次磁盘I/O。</p><p><strong>注</strong>：<br>1.采用 K 层索引结构，且<font color="#FF0000">顶级索引表未调入内存</font>，则访问一个数据块只需要 K + 1 次<br>读磁盘操作<br>2.若采用多层索引，则<font color="#FF0000">各层索引表大小不能超过一个磁盘块</font></p><p><strong>3.混合索引</strong><br>③混合索引：多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级间接索引（指向两层索引表） 。</p><p>对于小文件，只需较少的读磁盘次数就可以访问目标数据块。（一般计算机中小文件更多）</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081459467.png" alt="image.png"></p><h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081502448.png" alt="image.png"></p><h2 id="逻辑结构vs物理结构"><a href="#逻辑结构vs物理结构" class="headerlink" title="逻辑结构vs物理结构"></a>逻辑结构vs物理结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081603946.png" alt="image.png"></p><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><p>文件的物理结构探讨的是对非空闲磁盘块的管理<br>.<font color="#FF0000">文件存储空间的管理探讨的是对空闲磁盘块的管理</font></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081649801.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081651319.png" alt="image.png"></p><h3 id="存储空间的划分与初始化"><a href="#存储空间的划分与初始化" class="headerlink" title="存储空间的划分与初始化"></a>存储空间的划分与初始化</h3><p>安装 Windows 操作系统的时候，一个必经步骤是——为磁盘分区（C: 盘、D: 盘、E: 盘等）<font color="#FF0000">存储空间的划分</font>：就是将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘）</p><p>.<font color="#FF0000">存储空间的初始化</font>：将各个文件卷划分为目录区、文件区<br>目录区主要存放文件目录信息（FCB）、用于磁盘存储空间管理的信息。<br>文件区用于存放文件数据</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081654458.png" alt="image.png"></p><h3 id="存储空间管理方法"><a href="#存储空间管理方法" class="headerlink" title="存储空间管理方法"></a>存储空间管理方法</h3><h4 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a><mark>空闲表法</mark></h4><blockquote><p>空闲表法适用于怎样的分配方式？</p></blockquote><p>适用于 “连续分配方式”<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081700904.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081700627.png" alt="image.png"></p><blockquote><p>空闲表法如何分配空闲磁盘块给文件使用呢？</p></blockquote><p>与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法来决定要为文件分配哪个区间。</p><blockquote><p>空闲表法又是如何回收磁盘块呢？</p></blockquote><p>与内存管理中的动态分区分配很类似，当回收某个存储区时需要有四种情况——①回收区的前后都没有相邻空闲区；②回收区的前后都是空闲区；③回收区前面是空闲区；④回收区后面是空闲区。<font color="#FF0000">总之，回收时需要注意表项的合并问题</font>。</p><h4 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a><mark>空闲链表法</mark></h4><p>空闲链表法有可以链结点单位不同分为<strong>空闲盘区链</strong>、<strong>空闲盘块链</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081704779.png" alt="image.png"></p><p><strong>1.空闲盘块链</strong></p><p>.<font color="#FF0000">适用于离散分配</font>的物理结构。为文件分配多个盘块时可能要重复多次操作</p><p>操作系统保存着<font color="#FF0000">链头、链尾指针</font>。</p><blockquote><p>如何分配?</p></blockquote><p>若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针。</p><blockquote><p>如何回收？</p></blockquote><p>回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081707389.png" alt="image.png"></p><p><strong>2.空闲盘区链</strong></p><p>.<font color="#FF0000">离散分配、连续分配都适用</font>。为一个文件分配多个盘块时效率更高</p><p>操作系统保存着<font color="#FF0000">链头、链尾指针</font>。</p><blockquote><p>如何分配?</p></blockquote><p>若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据。</p><blockquote><p>如何回收？</p></blockquote><p>若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081711896.png" alt="image.png"></p><h4 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a><mark>位示图法</mark></h4><p>每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081714346.png" alt="image.png"></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081729966.png" alt="图片alt"> </p><p>如本例中盘块号、字号、位号从0开始，若n表示字长，则…<br>(字号, 位号)=(i, j) 的二进制位对应的 盘块号 b = ni + j<br>b号盘块对应的字号 i = b/n，位号 j = b%n</p><blockquote><p>如何分配?</p></blockquote><p>若文件需要K个块，①顺序扫描位示图，找到K个相邻或不相邻的“0”；②根据字号、位号算出对应的盘块号，将相应盘块分配给文件；③将相应位设置为“1”。</p><blockquote><p>如何回收?</p></blockquote><p>①根据回收的盘块号计算出对应的字号、位号；②将相应二进制位设为“0”</p><h4 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a><mark>成组链接法</mark></h4><p>.<font color="#FF0000">空闲表法、空闲链表法不适用于大型文件系统</font>，因为空闲表或空闲链表可能过大过长。<strong>UNIX系统中采用了成组链接法对磁盘空闲块进行管理</strong>。它克服了空闲链表法表太长的缺点，但是保持了其优点，即分配和回收一个盘块比较简单。<br>文件卷的目录区中专门用一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的“超级块”数据一致.</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081733269.png" alt="图片alt"> </p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081757247.png" alt="image.png"></p><p>这张图我得好好解释一下，首先来看左边绿色的空闲盘块号栈，这是第一组(唯一进入内存的一组，只有它会占据存储空间)。看到S.free = 100了没，这表示该组有100个空闲块数目，再往下看，第0号对应的是300，表示下一组物理空闲块的物理盘块号为300，你看它指向的是不是300号对应的磁盘块。再看黄色的块，这些块里保存的才是真正的可用的空闲块，也就是说每组中只有99个块可用。尽管如此，每组还是有100个块的。特别要注意的是，最后一组的下一组盘块号不是没有么，我们这里采用的是结束标记“0”，也就是最右边一个蓝色块的第二项为0。</p><blockquote><p>如何分配？</p></blockquote><p>记住一点的是，分配过程是从前往后分配，先分配第一组，然后分配第二组……</p><p>Eg ：需要100个空闲块<br>①检查第一个分组的块数是否足够。100=100，是足够的。<br>②分配第一个分组中的100个空闲块。但是由于300号块内存放了再下一组的信息，因此300号块的数据需要复制到超级块中</p><blockquote><p>如何回收？</p></blockquote><p>回收过程是正好相反，从后往前分配，先将释放的空闲块放入第一组，第一组满了，再开辟一组，之前的第一组变为第二组……</p><p>Eg ：假设每个分组最多为100个空闲块，此时第一个分组已有100个块，还要再回收一块。需要将超级块中的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081822170.png" alt="image.png"></p><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081900540.png" alt="image.png"></p><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>进行 Create 系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小（如：一个盘块，即1KB）</li><li>文件存放路径（“D:/Demo”）</li><li>文件名（这个地方默认为“新建文本文档.txt”）</li></ol><p>操作系统在处理 Create 系统调用时，主要做了两件事：</p><ol><li>在外存中找到文件所需的空间（结合上小节学习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</li><li>根据文件存放路径的信息找到该目录对应的目录文件（此处就是 D:/Demo 目录），在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309081904315.png" alt="image.png"></li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>进行 Delete 系统调用时，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li></ol><p>操作系统在处理 Delete 系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</li><li>根据该目录项记录的文件在外存的存放位置、文件大小等信息，回收文件占用的磁盘块。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）。</li><li>从目录表中删除文件对应的目录项。</li></ol><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用 open 系统调用“打开文件”，需要提供的几个主要参数：</p><ol><li>文件存放路径（“D:/Demo”）</li><li>文件名（“test.txt”）</li><li>要对文件的操作类型（如：r 只读；rw 读写等）</li></ol><p>操作系统在处理 open 系统调用时，主要做了几件事：</p><ol><li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</li><li>将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082037096.png" alt="image.png"></p><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>进程使用完文件后，要“关闭文件”操作系统在处理 Close 系统调用时，主要做了几件事：</p><ol><li>将进程的打开文件表相应表项删除</li><li>回收分配给该文件的内存空间等资源</li><li>系统打开文件表的打开计数器count 减1，若 count =0，则删除对应表项</li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082039990.png" alt="image.png"></p><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><p>可以“读文件”，将文件数据读入内存，才能让CPU处理（双击后，“记事本”应用程序通过操作系统提供的“读文件”功能，即 read 系统调用，将文件数据从外存读入内存，并显示在屏幕上）</p><p>进程使用 read系统调用完成写操作。</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），</li><li>还需要指明要读入多少数据（如：读入 1KB）、指明读入的数据要放在内存中的什么位置。</li><li>操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082046540.png" alt="image.png"></p><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>进程使用 write 系统调用完成写操作，</p><ul><li>需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可）</li><li>还需要指明要写出多少数据（如：写出 1KB）、写回外存的数据放在内存中的什么位置</li><li>操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082048833.png" alt="image.png"></p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082049048.png" alt="image.png"></p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082103676.png" alt="image.png"></p><blockquote><p>文件共享的含义</p></blockquote><p>注意：多个用户共享同一个文件，意味着系统中只有“一份”文件数据。并且只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。<br>如果是多个用户都“复制”了同一个文件，那么系统中会有“好几份”文件数据。其中一个用<br>户修改了自己的那份文件数据，对其他用户的文件数据并没有影响。</p><h3 id="基于索引结点的共享方式-硬连接"><a href="#基于索引结点的共享方式-硬连接" class="headerlink" title="基于索引结点的共享方式(硬连接)"></a>基于索引结点的共享方式(硬连接)</h3><blockquote><p>索引结点是什么？前面讲过，先回顾一下</p></blockquote><p>索引结点，是一种文件目录瘦身策略。由于检索文件时只需用到文件名，因此可以将除<br>了文件名之外的其他信息放到索引结点中。这样目录项就只需要包含文件名、索引结点指针。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082105001.png" alt="image.png"></p><blockquote><p>那要如何通过索引结点来实现文件的共享呢？</p></blockquote><p>索引结点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p><ul><li>若 count = 2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。</li><li>若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减 1。</li><li>若 count&gt;0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。</li><li>当 count = 0 时系统负责删除文件。</li></ul><h3 id="基于符号链的共享方式-软连接"><a href="#基于符号链的共享方式-软连接" class="headerlink" title="基于符号链的共享方式(软连接)"></a>基于符号链的共享方式(软连接)</h3><blockquote><p>硬链接不是也借助了索引结点吗？他与硬链接有什么区别吗</p></blockquote><p>区别在于，硬链接是直接将不同用户目录的目录项的索引结点指针指向同一个索引结点，从而共同指向一个文件；<br>但是软连接，是将目录中目录项的索引结点指针指向link文件(Link类型文件记录了存放文件1的存放路径，类似于Windows操作系统的快捷方式)，再通过Link文件层层查找找到User1的目录表中，aaa的表项，于是就找到了文件1的索引结点</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082108416.png" alt="image.png"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309082117071.png" alt="image.png"></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091114090.png" alt="image.png"></p><h3 id="口令保护"><a href="#口令保护" class="headerlink" title="口令保护"></a>口令保护</h3><p>为文件设置一个“口令”（如：abc112233），用户请求访问该文件时必须提供“口令”。<br>口令一般存放在文件对应的 FCB 或索引结点中。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件</p><ul><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小。</li><li>缺点：正确的“口令”存放在系统内部，不够安全。<h3 id="加密保护"><a href="#加密保护" class="headerlink" title="加密保护"></a>加密保护</h3></li></ul><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。</p><blockquote><p>Eg：一个最简单的加密算法——异或加密假设用于加密/解密的“密码”为“01001”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091246631.png" alt="image.png"></p><ul><li>优点：保密性强，不需要在系统中存储“密码”</li><li>缺点：编码/译码，或者说加密/解密要花费一定时间<h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3></li></ul><p>在每个文件的FCB（或索引结点）中增加一个访问控制列表（Access-ControlList,ACL)，该表中记录了各个用户可以对该文件执行哪些操作。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091247996.png" alt="image.png"></p><blockquote><p>有的计算机可能会有很多个用户，因此访问控制列表可能会很大，可以用精简的访问列表解决这个问题</p></blockquote><p>精简的访问列表：以“组”为单位，标记各“组”用户可以对文件执行哪些操作。<br>如：分为 系统管理员、文件主、文件主的伙伴、其他用户 几个分组。<br>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091248173.png" alt="image.png"></p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091235903.png" alt="image.png"></p><h2 id="文件系统的层次"><a href="#文件系统的层次" class="headerlink" title="文件系统的层次"></a>文件系统的层次</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091231262.png" alt="image.png"></p><p>用一个例子来辅助记忆文件系统的层次结构：<br>假设某用户请求删除文件 “D:/工作目录/学生信息.xlsx” 的最后100条记录。</p><ol><li>用户需要通过操作系统提供的接口发出上述请求——用户接口</li><li>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——<font color="#FF0000">文件目录系统</font></li><li>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限——<font color="#FF0000">存取控制模块（存取控制验证层）</font></li><li>验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址——<font color="#FF0000">逻辑文件系统与文件信息缓冲区</font></li><li>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址——<font color="#FF0000">物理文件系统</font></li><li>要删除这条记录，必定要对磁盘设备发出请求——<font color="#FF0000">设备管理程序模块</font></li><li>删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收——<font color="#FF0000">辅助分配模块</font></li></ol><h2 id="文件系统的全局结构"><a href="#文件系统的全局结构" class="headerlink" title="文件系统的全局结构"></a>文件系统的全局结构</h2><h3 id="文件系统在外存中的结构"><a href="#文件系统在外存中的结构" class="headerlink" title="文件系统在外存中的结构"></a>文件系统在外存中的结构</h3><blockquote><p>要认识文件系统在外存中如何一步一步建立起来的，首先从磁盘各个生产阶段开始</p></blockquote><p><strong>1.原始磁盘</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091202204.png" alt="image.png"></p><p><strong>2.物理格式化后</strong><br>物理格式化，即低级格式化——划分扇区，检测坏扇区，并用备用扇区替换坏扇区<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091203475.png" alt="image.png"></p><p><strong>3.磁盘分区后</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091203572.png" alt="image.png"></p><p><strong>4.逻辑格式化后</strong><br>磁盘分区（分卷 Volume）后，对各分区进行逻辑格式化<br><mark>逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091204113.png" alt="image.png"></p><blockquote><p>了解了文件系统在外存中的结构，接下来了解文件系统在内存当中的结构</p></blockquote><h3 id="文件系统在内存中的结构"><a href="#文件系统在内存中的结构" class="headerlink" title="文件系统在内存中的结构"></a>文件系统在内存中的结构</h3><p>文件系统在内存中的结构分为三个部分：</p><ul><li>目录缓存</li><li>系统打开文件表</li><li>进程打开文件表</li></ul><p><strong>1.目录的缓存</strong><br>查找目录需要将外存中目录M中的FCB都读入主存，所以为了避免每次查找目录都需要访问外存，所以近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091219886.png" alt="image.png"></p><p><strong>2.系统打开文件表</strong><br>系统打开文件表是内核维护的一个数据结构，它记录了所有打开文件的信息，包括文件描述符、文件状态标志、文件偏移量、文件结构体指针等。当一个文件被打开时，系统会在系统打开文件表中为该文件分配一个对应的条目，以便内核对该文件进行管理和跟踪。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091221711.png" alt="image.png"></p><p><strong>3.用户打开文件表</strong><br>用户打开文件时，会在进程打开文件表中增加一个条目，记录文件打开方式，需要注意的是进程打开文件表中不会保存文件的FCB，而是保存系统打开文件表中的索引，通过系统打开文件表找到打开文件的FCB<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091226133.png" alt="image.png"></p><h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><blockquote><p>普通的文件系统是如何的？</p></blockquote><p>普通的文件系统，外存文件如果使用的不同系统，那么对文件的访问使用的方法以及参数各不相同，用户进程就需要使用不同的方法以及参数才能访问文件，这样是十分不方便的，有没有方法使得接口统一呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091342595.png" alt="image.png"></p><blockquote><p>虚拟文件系统？它有什么作用？</p></blockquote><p>虚拟文件系统（Virtual File System，简称VFS）是Linux内核的子系统之一，它为用户程序提供文件和文件系统操作的统一接口，屏蔽不同文件系统的差异和操作细节。借助VFS可以直接使用<code>open()</code>、<code>read()</code>、<code>write()</code>这样的系统调用操作文件，而无须考虑具体的文件系统和实际的存储介质。</p><p>举个例子，Linux用户程序可以通过<code>read()</code> 来读取<code>ext3</code>、<code>NFS</code>、<code>XFS</code>等文件系统的文件，也可以读取存储在<code>SSD</code>、<code>HDD</code>等不同存储介质的文件，无须考虑不同文件系统或者不同存储介质的差异。</p><p>通过VFS系统，Linux提供了通用的系统调用，可以跨越不同文件系统和介质之间执行，极大简化了用户访问不同文件系统的过程。另一方面，新的文件系统、新类型的存储介质，可以无须编译的情况下，动态加载到Linux中。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091347369.png" alt="image.png"></p><blockquote><p>存在的问题：不同的文件系统，表示文件数据结构各不相同。打开文件后，其在内存中的表示就不同，VFS是如何解决的呢？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091351444.png" alt="image.png"></p><blockquote><p>VFS每打开一个文件，VFS就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。</p></blockquote><p>注意：vnode 只存在于主存中，而 inode(索引结点) 既会被调入主存，也会在外存中存储<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091353001.png" alt="image.png"></p><p>打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文<br>件系统的函数功能。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091354426.png" alt="image.png"></p><h2 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h2><p>文件系统挂载（mounting），即文件系统安装/装载——如何将一个文件系统挂载到操作系统中？</p><p>文件系统挂载要做的事：<br>①在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。<br>②新挂载的文件系统，要向VFS提供一个函数地址列表。<br>③将新文件系统加到挂载点（mountpoint），也就是将新文件系统挂载在某个父目录下。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091357192.png" alt="image.png"></p><h2 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h2><p>详见组成原理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091539169.png" alt="image.png"></p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091604341.png" alt="image.png"></p><h3 id="一次磁盘读-写操作需要的时间"><a href="#一次磁盘读-写操作需要的时间" class="headerlink" title="一次磁盘读/写操作需要的时间"></a>一次磁盘读/写操作需要的时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">寻找时间（寻道时间）T S ：在读/写数据前，将磁头移动到指定磁道所花的时间。</span><br><span class="line">①启动磁头臂是需要时间的。假设耗时为 s；</span><br><span class="line">②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一</span><br><span class="line">个磁道耗时为 m，总共需要跨越 n 条磁道。则：</span><br><span class="line">寻道时间 T S = s + m*n</span><br><span class="line"></span><br><span class="line">延迟时间T R ：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。</span><br><span class="line">设磁盘转速为 r （单位：转/秒，或 转/分），则</span><br><span class="line">平均所需的延迟时间 T R = (1/2)*(1/r) = 1/(2r)</span><br><span class="line"></span><br><span class="line">传输时间T t ：从磁盘读出或向磁盘写入数据所经历的时间，假</span><br><span class="line">设磁盘转速为 r，此次读/写的字节数为 b，每个磁道上的字节</span><br><span class="line">数为 N。则：</span><br><span class="line">传输时间T t = (1/r) * (b/N) = b/(rN)</span><br><span class="line"></span><br><span class="line">延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性，因此操</span><br><span class="line">作系统也无法优化延迟时间和传输时间。所以磁盘调度算法主要优化的是寻道时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091604664.png" alt="image.png"></p><h3 id="先来向服务算法（FCFS）"><a href="#先来向服务算法（FCFS）" class="headerlink" title="先来向服务算法（FCFS）"></a>先来向服务算法（FCFS）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根据进程请求访问磁盘的先后顺序进行调度。</span><br><span class="line"></span><br><span class="line">Eg.假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道。</span><br><span class="line">按照 FCFS 的规则，按照请求到达的顺序，磁头需要依次移动到 55、58、39、18、90、160、150、38、184 号磁道</span><br><span class="line"></span><br><span class="line">磁头总共移动了 45+3+19+21+72+70+10+112+146 = 498 个磁道</span><br><span class="line">响应一个请求平均需要移动 498/9 = 55.3 个磁道（平均寻找长度）</span><br><span class="line"></span><br><span class="line">优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过的去</span><br><span class="line">缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091608419.png" alt="image.png"></p><h3 id="最短寻找时间优先（SSTF）"><a href="#最短寻找时间优先（SSTF）" class="headerlink" title="最短寻找时间优先（SSTF）"></a>最短寻找时间优先（SSTF）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">描述：SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优）</span><br><span class="line"></span><br><span class="line">Eg.假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</span><br><span class="line"></span><br><span class="line">磁头总共移动了 (100-18) + (184-18) = 248 个磁道</span><br><span class="line">响应一个请求平均需要移动 248/9 = 27.5 个磁道（平均寻找长度）</span><br><span class="line">优点：性能较好，平均寻道时间短</span><br><span class="line">缺点：可能产生“饥饿”现象</span><br><span class="line"></span><br><span class="line">【本例中，如果在处理18号磁道的访问请求时又来了一个38号磁道的访问请求，处理38号磁道</span><br><span class="line">的访问请求时又来了一个18号磁道的访问请求。如果有源源不断的 18号、38号磁道的访问请求到来的话，150、160、184 号磁道的访问请求就永远得不到满足，从而产生“饥饿”现象。】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091609299.png" alt="image.png"></p><h3 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">描述：SSTF 算法会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法（SCAN）的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法。</span><br><span class="line"></span><br><span class="line">Eg.假设某磁盘的磁道为 0~200号，磁头的初始位置是100号磁道，且此时磁头正在往磁道号增大的方向移动，有多个进程先后陆续地请求访问 55、58、39、18、90、160、150、38、184 号磁道</span><br><span class="line"></span><br><span class="line">磁头总共移动了 (200-100) + (200-18) = 282 个磁道</span><br><span class="line">响应一个请求平均需要移动 282/9 = 31.3 个磁道（平均寻找长度）</span><br><span class="line"></span><br><span class="line">优点：性能较好，平均寻道时间较短，不会产生饥饿现象</span><br><span class="line">缺点：</span><br><span class="line">①只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求</span><br><span class="line">之后就不需要再往右移动磁头了。</span><br><span class="line">②SCAN算法对于各个位置磁道的响应频率不平均（如：假设此时磁头正在往右移动，且刚</span><br><span class="line">处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离；而响应</span><br><span class="line">了184号磁道的请求之后，很快又可以再次响应 184 号磁道的请求了）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091611880.png" alt="image.png"></p><h3 id="LOOK调度算法"><a href="#LOOK调度算法" class="headerlink" title="LOOK调度算法"></a>LOOK调度算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">描述：扫描算法（SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。LOOK 调度算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。（边移动边观察，因此叫 LOOK）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091616919.png" alt="image.png"></p><h3 id="循环扫描算法（C-SCAN）"><a href="#循环扫描算法（C-SCAN）" class="headerlink" title="循环扫描算法（C-SCAN）"></a>循环扫描算法（C-SCAN）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">描述：SCAN算法对于各个位置磁道的响应频率不平均，而 C-SCAN 算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091618760.png" alt="image.png"></p><h3 id="C-LOOK调度算法"><a href="#C-LOOK调度算法" class="headerlink" title="C-LOOK调度算法"></a>C-LOOK调度算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">描述：C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091619090.png" alt="image.png"></p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>若题目中无特别说明，则SCAN 就是 LOOK，C-SCAN 就是C-LOOK</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091620631.png" alt="image.png"></p><h2 id="减少磁盘延迟时间的方法"><a href="#减少磁盘延迟时间的方法" class="headerlink" title="减少磁盘延迟时间的方法"></a>减少磁盘延迟时间的方法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091653505.png" alt="image.png"></p><h3 id="交替编号"><a href="#交替编号" class="headerlink" title="交替编号"></a>交替编号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁头读取一块的内容（也就是一个扇区的内容）后，需要一小段时间处理，而盘片又在不停地旋转,因此，如果2、3号扇区相邻着排列，则读完2号扇区后无法连续不断地读入3号扇区,就需要等到下一圈来到3号扇区才能够读取，所以为了空出充分的处理时间给磁头，于是就采用交替编号的策略</span><br><span class="line"></span><br><span class="line">采用交替编号的策略，即让逻辑上相邻的扇区(逻辑上连续的内容)在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091655808.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091657525.png" alt="image.png"></p><h3 id="磁盘地址结构的设计"><a href="#磁盘地址结构的设计" class="headerlink" title="磁盘地址结构的设计"></a>磁盘地址结构的设计</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">磁盘地址结构采用(柱面号，磁盘号，扇区号)，而不是采用(磁盘号，柱面号，扇区号)</span><br><span class="line"></span><br><span class="line">这样可以减少磁头读取连续物理地址区域时，磁头的移动次数，从而减少磁盘延迟时间</span><br><span class="line"></span><br><span class="line">Eg.若物理地址结构是（盘面号，柱面号，扇区号），且需要连续读取物理地址 （00, 000, 000）~（00, 001, 111）的扇区.</span><br><span class="line">（00, 000, 000） ~（ 00, 000, 111 ） 转两圈可读完【采用交替编号策略】</span><br><span class="line">之后再读取物理地址相邻的区域，即</span><br><span class="line">（00, 001, 000） ~（ 00, 001, 111 ），需要启动磁头臂，将磁头移动到下一个磁道</span><br><span class="line"></span><br><span class="line">Eg.若物理地址结构是（柱面号，盘面号，扇区号），且需要连续读取物理地址 （000, 00, 000）~（000, 01, 111）的扇区.</span><br><span class="line">（000, 00, 000） ~（ 000, 00, 111 ） 由盘面0的磁头读入数据</span><br><span class="line">之后再读取物理地址相邻的区域，即</span><br><span class="line">（000, 01, 000） ~（ 000, 01, 111 ），由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091702861.png" alt="image.png"></p><h3 id="错位命名"><a href="#错位命名" class="headerlink" title="错位命名"></a>错位命名</h3><blockquote><p>不采用错位命名，相邻的盘面相对位置相同处扇区编号相同</p></blockquote><p>注意，所有盘面都是一起连轴转的。<br>读取完磁盘块（000,00, 111）之后，需要短暂的时间处理，而盘面又在不停地转动，因此当（000, 01, 000）第一次划过1号盘面的磁头下方时，并不能读取数据，只能再等该扇区再次划过磁头。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091705589.png" alt="image.png"></p><blockquote><p>错位命名，相邻的盘面相对位置相同处扇区编号不相同</p></blockquote><p>由于采用错位命名法，因此读取完磁盘块（000, 00, 111）之后，还有一段时间处理，当（000, 01, 000）第一次划过1号盘面的磁头下方时，就可以直接读取数据。从而减少了延迟时间<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091707917.png" alt="image.png"></p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091708283.png" alt="image.png"></p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091733749.png" alt="image.png"></p><h3 id="磁盘初始化"><a href="#磁盘初始化" class="headerlink" title="磁盘初始化"></a>磁盘初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">磁盘初始化：</span><br><span class="line">Step 1：进行低级格式化（物理格式化），将磁盘的各个磁道</span><br><span class="line">划分为扇区。一个扇区通常可分为 头、数据区域（如512B大</span><br><span class="line">小）、尾 三个部分组成。管理扇区所需要的各种数据结构一般</span><br><span class="line">存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC</span><br><span class="line">循环冗余校验码等，校验码用于校验扇区中的数据是否发生错</span><br><span class="line">误）</span><br><span class="line">Step 2：将磁盘分区，每个分区由若干柱面组成（即分为我们</span><br><span class="line">熟悉的 C盘、D盘、E盘）</span><br><span class="line"></span><br><span class="line">Step 3：进行逻辑格式化，创建文件系统。包括创建文件系统</span><br><span class="line">的根目录、初始化存储空间管理所用的数据结构（如 位示图、</span><br><span class="line">空闲分区表）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091736235.png" alt="image.png"></p><h3 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h3><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的。</p><p>初始化程序可以放在ROM （只读存储器）中。ROM中的数据在出厂时就写入了，并且以后不能再修改。</p><blockquote><p>初始化程序程序（自举程序）放在ROM中存在什么问题？</p></blockquote><p>万一需要更新自举程序，将会很不方便，因为ROM中的数据无法更改</p><blockquote><p>那要怎么解决呢？</p></blockquote><p>ROM中只存放很小的“自举装入程序”.完整的自举程序放在<mark>磁盘的启动块（即引导块/启动分区）</mark>上，启动块位于磁盘的固定位置。拥有启动分区的磁盘称为 启动磁盘 或系统磁盘 （C:盘）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091738463.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091740556.png" alt="image.png"></p><h3 id="坏块的处理"><a href="#坏块的处理" class="headerlink" title="坏块的处理"></a>坏块的处理</h3><p>坏了、无法正常使用的扇区就是“坏块”。这属于硬件故障，操作系统是无法修复的。应该将坏块标记出来，以免错误地使用到它。</p><ul><li>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在 FAT 表上标明。（在这种方式中，坏块对操作系统不透明）</li><li>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。会保留一些“备用扇区”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，坏块对操作系统透明。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091743994.png" alt="image.png"></p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091743234.png" alt="image.png"></p><h2 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091752572.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091753182.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091753230.png" alt="image.png"></p><h1 id="输入输出-IO-管理"><a href="#输入输出-IO-管理" class="headerlink" title="输入输出(IO)管理"></a>输入输出(IO)管理</h1><h2 id="I-O设备的基本概念和分类"><a href="#I-O设备的基本概念和分类" class="headerlink" title="I/O设备的基本概念和分类"></a>I/O设备的基本概念和分类</h2><h3 id="什么是I-O设备"><a href="#什么是I-O设备" class="headerlink" title="什么是I/O设备"></a>什么是I/O设备</h3><p>“I/O” 就是 “输入/输出”（Input/Output）<br>I/O 设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091829621.png" alt="image.png"></p><h3 id="I-O设备按使用特性分类"><a href="#I-O设备按使用特性分类" class="headerlink" title="I/O设备按使用特性分类"></a>I/O设备按使用特性分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091831579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091849088.png" alt="image.png"></p><h3 id="I-O设备按传输速率分类"><a href="#I-O设备按传输速率分类" class="headerlink" title="I/O设备按传输速率分类"></a>I/O设备按传输速率分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091831353.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091833135.png" alt="image.png"></p><h3 id="I-O设备按信息交换单位分类"><a href="#I-O设备按信息交换单位分类" class="headerlink" title="I/O设备按信息交换单位分类"></a>I/O设备按信息交换单位分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091834902.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091834929.png" alt="image.png"></p><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091850456.png" alt="image.png"></p><h2 id="IO控制器"><a href="#IO控制器" class="headerlink" title="IO控制器"></a>IO控制器</h2><h3 id="为什么要有I-O控制器？"><a href="#为什么要有I-O控制器？" class="headerlink" title="为什么要有I/O控制器？"></a>为什么要有I/O控制器？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">I/O设备由机械部件和电子部件组成</span><br><span class="line"></span><br><span class="line">I/O设备的机械部件主要用来执行具体I/O操作。</span><br><span class="line">如我们看得见摸得着的鼠标/键盘的按钮；显示器的LED屏；移动硬盘的磁臂、磁盘盘面。</span><br><span class="line"></span><br><span class="line">I/O设备的电子部件通常是一块插入主板扩充槽的印刷电路板。</span><br><span class="line"></span><br><span class="line">CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。这个电子部件就是I/O控制器，又称设备控制器。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309092114373.png" alt="image.png"></p><h3 id="I-O控制器的功能"><a href="#I-O控制器的功能" class="headerlink" title="I/O控制器的功能"></a>I/O控制器的功能</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.接收和识别CPU发出的命令</span><br><span class="line">如CPU发来的 read/write 命令，I/O控制器中会有相应的控制寄存器来存放命令和参数</span><br><span class="line">2.向CPU报告设备的状态</span><br><span class="line">I/O控制器中会有相应的状态寄存器，用于记录I/O设备的当前状态。如：1表示空闲，0表</span><br><span class="line">示忙碌</span><br><span class="line">3.数据交换</span><br><span class="line">I/O控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存CPU发来的数据，之</span><br><span class="line">后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据</span><br><span class="line">寄存器中取走数据。</span><br><span class="line">4.地址识别</span><br><span class="line">类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个</span><br><span class="line">特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309092127744.png" alt="image.png"></p><h3 id="I-O控制器的组成"><a href="#I-O控制器的组成" class="headerlink" title="I/O控制器的组成"></a>I/O控制器的组成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">值得注意的小细节：</span><br><span class="line">①一个I/O控制器可能会对应多个设备；</span><br><span class="line">②数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制/状态寄存器对应一个具体</span><br><span class="line">的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占</span><br><span class="line">用内存地址的一部分，称为内存映像I/O；另一些计算机则采用I/O专用地址，即寄存器独立编址。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309092131813.png" alt="image.png"></p><h3 id="内存映像-I-O-v-s-寄存器独立编址"><a href="#内存映像-I-O-v-s-寄存器独立编址" class="headerlink" title="内存映像 I/O v.s. 寄存器独立编址"></a>内存映像 I/O v.s. 寄存器独立编址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">寄存器独立编制。控制器中的寄存器使用单独的地址</span><br><span class="line">缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</span><br><span class="line"></span><br><span class="line">内存映射I/O。控制器中的寄存器与内存地址统一编址</span><br><span class="line">优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309092158956.png" alt="image.png"></p><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>如下图所示，计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字， CPU 需要对外设状态进行循环检查，直到确定该字已经在I/0 控制器的数据寄存器中。在程序直接控制方式中，由于CPU 的高速性和I/0设备的低速性，致使CPU 的绝大部分时间都处于等待I/0 设备完成数据I/0 的循环测试中，造成了CPU 资源的极大浪费。在该方式中， CPU 之所以要不断地测试I/0 设备的状态，就是因为在CPU 中未采用中断机构，使I/0 设备无法向CPU报告它已完成了一个字符的输入操作。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309101051877.png" alt="图片alt"> </p><p>!!! warning<br>【痛点】程序直接控制方式虽然简单且易于实现，但其缺点也显而易见，由于CPU 和I/0 设备只能串行工作，导致CPU 的利用率相当低。  </p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><blockquote><p>[!TIP]<br>其实后一种的方式都是对前一种的方式的一种改进（OS里面都是为了提高资源利用率和并发性等才改进的，其他也差不多），408的课程很多都可以用这样的方法学习，不要硬背，这些都不是孤立的，回答的时候体现出改进，一步一步的讲出来，条理和逻辑会比较清楚！</p></blockquote><p>中断驱动方式的思想是，允许I/0 设备主动打断CPU 的运行并请求服务，从而“解放”CPU, 使得其向I/0 控制器发送读命令后可以继续做其他有用的工作。如下图所示，我们从I/0 控制器和CPU 两个角度分别来看中断驱动方式的工作过程:</p><p>①从I/0 控制器的角度来看， I/0 控制器从CPU 接收一个读命令，然后从外围设备读数据。一且数据读入该I/0 控制器的数据寄存器，便通过控制线给CPU 发出一个中断信号，表示数据已准备好，然后等待CPU 请求该数据。I/0 控制器收到CPU 发出的取数据请求后，将数据放到数据总线上，传到CPU 的寄存器中。至此，本次I/0 操作完成， I/0 控制器又可开始下一次I/0操作。<br>②从CPU 的角度来看， CPU 发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾， CPU 检查中断。当有来自I/0 控制器的中断时， CPU 保存当前正在运行程序的上下文，转去执行中断处理程序以处理该中断。这时， CPU 从I/0 控制器读一个字的数据传送到寄存器，并存入主存。接着， CPU 恢复发出I/0 命令的程序（或其他程序）的上下文，然后继续运行。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309101054918.png" alt="图片alt"> </p><blockquote><p>[!CAUTION]<br>【痛点】：中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/0 控制器之间的传输都必须经过CPU, 这就导致了中断驱动方式仍然会消耗较多的CPU 时间。<br>【注意】：什么叫经过CPU呢？ 答：在DMA(Direct memory access 直接存储器访问)之前，输入数据流大概是这样的： 【外围设备-&gt;I/O控制器的数据寄存器-&gt;CPU寄存器-&gt;存储器】，这就叫经过CPU，或者说传输数据的过程需要CPU的干预，于是引出了所谓的DMA(直接在I/O设备和内存之间建立数据通路)。</p></blockquote><h3 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h3><p>为何引入DMA前面提到了，所有改进如下：</p><ol><li>基本单位是数据块（前面是一个字）。</li><li>所传送的数据，是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU 干预，整块数据的传送是在DMA控制器的控制下完成的。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309101058806.png" alt="image.png"></p><blockquote><p>[!NOTE]</p><ul><li>命令／状态寄存器(CR) 。用于接收从CPU 发来的I/0 命令或有关控制信息，或设备的状态。</li><li>内存地址寄存器(MAR) 。在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li><li>数据寄存器(DR) 。用于暂存从设备到内存或从内存到设备的数据。</li><li>数据计数器(DC) 。存放本次要传送的字（节）数。</li></ul></blockquote><p>如下图所示，DMA方式的工作过程是： CPU 接收到I/O 设备的DMA 请求时，它给I/0 控制器发出一条命令，启动DMA 控制器，然后继续其他工作。之后CPU 就把控制操作委托给DMA 控制器，由该控制器负责处理。DMA 控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU 参与。传送完成后，DMA 控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与(预处理【设置CR、MAR、DC等】和后处理【中断处理、唤醒因该I/O阻塞的进程程等】)。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309101100920.png" alt="image.png"></p><blockquote><p>[!CAUTION]<br>DMA控制方式与中断驱动方式的主要区别是:中断驱动方式在每个数据需要传输时中断 CPU, 而DMA 控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU; 此外，中断驱动方式数据传送是在中断处理时由CPU 控制完成的，而DMA 控制方式则是在DMA 控制器的控制下完成的（前面提到了，加深印象！）。<br>❝<br>【不算痛点】：如何进一步提高资源利用率呢？当然是请更牛逼的秘书（通道），老板（CPU）尽可能的从累活中解放出来。<br>❞</p></blockquote><h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><p>I/0 通道是指专门负责输入／输出的处理机。I/O通道方式是DMA方式的发展，它可以进一步 减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I/0 设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p><blockquote><p>[!for example]<br>❝ 例如，当CPU要完成一组相关的读（或写）操作及有关控制时，只需向I/O 通道发送一条 I/O 指令，以给出其所要执行的通道程序的首地址和要访问的I/0 设备，通道接到该指令后，执行通道程序便可完成CPU 指定的I/O任务，数据传送结束时向CPU发中断请求。(都有预处理和后处理，毕竟CPU才是老板！)<br>❞<br>❝ I/O通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通 道程序是放在主机的内存中的，也就是说通道与CPU 共享内存。<br>❞<br>❝ I/O 通道与DMA方式的区别是:DMA 方式需要CPU 来控制传输的数据块大小、传输的内 存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA 控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换(包工头；也是上面提到的三者能并行的原因)。<br>❞</p></blockquote><h3 id="总-举例子"><a href="#总-举例子" class="headerlink" title="总(举例子)"></a>总(举例子)</h3><blockquote><p>[!for example]<br>❝ 想象一位客户要去裁缝店做一批衣服的情形。<br>1）采用程序直接控制时，裁缝没有客户的联系方式，客户必须每隔一段时间去裁缝店看看裁缝 把衣服做好了没有，这就浪费了客户不少的时间。<br>2）采用中断驱动方式时，裁缝有客户的联系方式，每当他完成一件衣服后，给客户打一个电话，让客户去拿，与程序直接控制能省去客户不少麻烦，但每完成一件衣服就让客户去拿一次，仍然比较浪费客户的时间。<br>3）采用DMA 方式时，客户花钱雇一位单线秘书，并向秘书交代好把衣服放在哪里（存放仓库），裁缝要联系就直接联系秘书，秘书负责把衣服取回来并放在合适的位置，每处理完100 件衣服，秘书就要给客户报告一次（大大节省了客户的时间）。<br>4）采用通道方式时，秘书拥有更高的自主权，与DMA方式相比，他可以决定把衣服存放在哪里，而不需要客户操心。而且，何时向客户报告，是处理完100 件衣服就报告，还是处理完10000件衣服才报告，秘书是可以决定的。客户有可能在多个裁缝那里订了货，一位DMA 类的秘书只能负责与一位裁缝沟通，但通道类秘书却可以与多名裁缝进行沟通。<br>❞</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309101108299.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171023019.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机系统概述&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="操作系统" scheme="https://fqzs.netlify.app/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>高数严选题</title>
    <link href="https://fqzs.netlify.app/undefined/c037e1e7.html"/>
    <id>https://fqzs.netlify.app/undefined/c037e1e7.html</id>
    <published>2023-07-20T10:44:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png" alt="image.png"></p><h1 id="1-函数极限连续"><a href="#1-函数极限连续" class="headerlink" title="1.函数极限连续"></a>1.函数极限连续</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>开区间连续，两端点单侧极限存在，是函数有界的充分条件，而不是必要条件</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201100161.png" alt="image.png"></p><p><em>相乘的极限存在，不想代表，各自都有极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201114713.png" alt="image.png"></p><p><em>利用夹逼定理，单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201121973.png" alt="image.png"></p><p><em>极限要求趋向于0，但不等于0，没有说明φ(x)不等于0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201126863.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201131884.png" alt="image.png"></p><p><em>1.注意加减关系不能直接等价代换，等价代换实质上是一种精度不太高的泰勒展开(低阶展开)，当f(x)与g(x)存在加减关系时，例如这题是相加关系，如果f(x)与g(x)的低阶无穷小相互抵消(limf(x)/g(x)=-1),那么就需要比较高阶的无穷小；但是等价代换就没有高阶项，所以精度丢失- - -&gt;</em><br><em>2.拆成两项极限求和的前提是—&gt;两项极限都存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201145234.png" alt="image.png"></p><p><em>确定变上限积分函数，无穷小的阶数—&gt;N(M+1)原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201358107.png" alt="image.png"></p><p><em>1.当a=2,arctanx-sin2x可以分别等价代换，为什么？不是说加减不能等价代换吗？ —&gt;等价代换实质就是一次低阶泰勒展开，当展开之后，最低阶的无穷小两者不相等时，意味着相减，不会消去这个低阶无穷小，就不需要比较高阶无穷小，那么就可以直接等价代换 ；arctanx-sin2x ~ x-2x</em></p><p><em>2.当a=1时，arctanx-sinx不能分别等价为x-x，因为低阶无穷小项，互相消去，需要比较高阶无穷小，但是arctanx的泰勒展开不熟悉，只能通过arctanx-x~-1/3 x³  ,sinx-x~ -1/6 x³  ;</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201404411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201415098.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201424934.png" alt="image.png"></p><p><em>极限x-&gt;1不需要讨论1+,1-，因为极限保号性；同理x-&gt; -1; 但是x-&gt;0,时，考虑0+,0-,因为两侧正负不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201429124.png" alt="image.png"></p><p><em>最关键的还是，幂指函数指数化 来处理幂指函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201454848.png" alt="image.png"></p><p><em>考察了基本极限x^n ,e^nx</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201505101.png" alt="image.png"></p></blockquote><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>对于这种分母中含有两根号相减的，—&gt;1.是有理化  2.是拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201511419.png" alt="image.png"></p><p><em>考察知识点很综合<br>1.导数几何意义<br>2.基本极限求极限1^∞型<br>3.洛必达法则<br>4.变上限积分求导<br>5.导数的定义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201528282.png" alt="image.png"></p><p><em>ln(x+√1+x²) ~ x</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201543906.png" alt="image.png"></p><p><em>1.利用到了ln(x+√1+x²) ~ x,判断时1^∞型<br>2.写基本极限标准型lim (1+a(x))^β(x) =e^ a(x)β(x)</em><br><em>3.利用等价代换(1+a(x))^β(x) -1 ~ a(x)β(x) </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201549785.png" alt="image.png"></p><p><em>1.n项连乘 直接夹逼不出来，化为对数<br>2.关键再利用基本常用不等式<br>3.再夹逼</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201602526.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201607237.png" alt="image.png"></p></blockquote><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>0/0型</em><br><em>1)洛必达法则<br>2)等价无穷小代换<br>3)泰勒公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201614121.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201620034.png" alt="image.png"></p><p><em>1.第一眼看，我想用1^∞型极限，但是这里不能拆开求极限因为，右半部分的极限不存在，所以不能1^∞极限直接做<br>2.正确的做法是将幂指函数，化为指数，然后将整个分子，e^x -1 ~ x等价代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201708362.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201735817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201754350.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201801518.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201900306.png" alt="image.png"><br><em>用到拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201903837.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201909167.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915159.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915846.png" alt="image.png"></p><p><em>1.自平方项，前n项和，公式要记住<br>2.到底是选择夹逼，还是定积分定义，看每一项变化的那个地方，看是占大头(同量级，选择定积分定义)，还是小头(变化对分母整体量影响不大，用夹逼)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201920638.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201925221.png" alt="image.png"></p><p><em>分子变化部分相对于主体是次量级，用夹逼；分母变化部分相对于主体是同量级，用定积分定义</em><br><em>对分子放大—&gt;所有项分子=n+1/n;  缩小—&gt;所有项分子=n+1</em><br><em>对分母提出1/n，可爱因子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201932498.png" alt="image.png"></p><p><em>经典的找间断点，和类型题目</em><br><em>在求间断点的极限时，是否要分开考虑左右极限，是根据，左右会不会对函数正负性有影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201938018.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201944583.png" alt="image.png"></p><p><em>极限存在一般根据极限存在准则：<br>1.夹逼定理<br>2.单调有界准则<br>该题只需要证明极限存在，只需单调有界就可证明极限存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202046598.png" alt="image.png"></p><p><em>1.先看递推式函数是否单调增<br>2.函数单调增说明数列有单调性，再根据x1,x2判断数列单调增还是减<br>3.假设极限=A，根据递推式代入A求出A<br>5.再证明有界且界限=A</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202055627.png" alt="image.png"></p><p><em>1.先看递推式函数，是否单调增,如果单调减则数列没有单调性<br>2.接着没有单调性则，直接证明xn-√2的极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202103715.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202114022.png" alt="image.png"></p><p><em>零点定理—证明区间两端点异号，则区间内必有一点=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202123672.png" alt="image.png"></p><p><em>介值定理—函数值介于最大与最小之间，必有一点,f(β)=该值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202128724.png" alt="image.png"></p></blockquote><h1 id="2-一元函数微分"><a href="#2-一元函数微分" class="headerlink" title="2.一元函数微分"></a>2.一元函数微分</h1><h2 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>既要趋近于0，又要同时趋近0+,0-，才能判定该点导数存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231415896.png" alt="image.png"></p><p><em>考察连续的概念、导数的概念、导函数连续的概念</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231422649.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231431041.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231509976.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231525936.png" alt="image.png"></p><p><em>1.拆开求导。2.求得导数等于0的点，用二阶导数判定是极小还是极大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231553956.png" alt="image.png"></p><p><em>求得二阶导数=0，继续代入求三阶导数，看二阶导数是否单调，如果单调，那么该点就是拐点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231627232.png" alt="image.png"></p><p><em>求斜或水平渐近线，直接将原式改写，为y=ax+b形式，利用x-&gt;∞极限求出a,b</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231643077.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231648475.png" alt="image.png"></p></blockquote><h2 id="填空题-2"><a href="#填空题-2" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>不能用洛必达，没有一阶可导条件，并且数列不是函数，不连续</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231657600.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231701991.png" alt="image.png"></p><p><em>利用链导法，而不是将所有表达式求出来，再求导，那样太麻烦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231726425.png" alt="image.png"></p><p><em>反函数的导数，注意反函数是对y求导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231735491.png" alt="image.png"></p><p><em>高阶导数具体点导数—用泰勒展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232115462.png" alt="image.png"></p><p><em>求高阶导数—总结规律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232114368.png" alt="image.png"></p><p><em>根据罗尔定律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232121848.png" alt="image.png"></p><p><em>解一元三次方程=0，一般方法，凑1,2,3,4…整数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232146981.png" alt="image.png"></p></blockquote><h2 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232220253.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241057847.png" alt="image.png"></p><p><em>1.积分上限用变量代换<br>2.定积分定义求0点导数<br>3.求x-&gt;0，导数极限看是否=0点导数<br>4.运用到了积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241123900.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141774.png" alt="image.png"></p><p><em>这种参数方程求积分问题，要注意变换积分上下限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241347626.png" alt="image.png"></p><p><em>单中值—微分中值定理证明题，主要是微分中值定理的构造</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241611635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241626811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241829186.png" alt="image.png"></p><p><em>运用柯西定理、拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241854086.png" alt="image.png"></p><p><em>双中值—两中值点没有要求不同<br>分开两部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242018794.png" alt="image.png"></p><p><em>双中值—要求中值点不同<br>1.先将【0,1】段用c分开，假设存在一点c，使得…</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242027225.png" alt="image.png"></p><p><em>证明中值，含有高阶导数—泰勒展开，在给出信息最多的那一点展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242131657.png" alt="Uploading file...swyug"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242134232.png" alt="image.png"></p></blockquote><h1 id="3-一元函数积分学"><a href="#3-一元函数积分学" class="headerlink" title="3.一元函数积分学"></a>3.一元函数积分学</h1><h2 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>原函数是否存在判定<br>1.函数连续，一定存在原函数<br>2.函数有第一类间断点，就一定没有原函数（证明：通过原函数的定义或者导函数的介值定理，F(X)在a,b可导，则其导数在[a，b]内不会有第一类间断。）<br>3.有第二类间断点，可能有原函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242146129.png" alt="image.png"></p><p><em>直接判断导函数是否连续，如果有第一类间断点，那么原函数必定不可导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242237240.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251023049.png" alt="image.png"></p><p><em>积分区域相同，比较被积函数，被积函数大，积分就大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251028390.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251033971.png" alt="image.png"></p><p><em>旋转体体积问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251046107.png" alt="image.png"></p></blockquote><h2 id="填空题-3"><a href="#填空题-3" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>简单有理函数积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251137183.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251151287.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251249954.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251433037.png" alt="image.png"></p><p><em>对称区间，奇偶性判断</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251449741.png" alt="image.png"></p><p><em>1.取根号，要注意加绝对值，分区间计算<br>2.善用结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251458855.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251631501.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251642326.png" alt="image.png"></p><p><em>1.利用定积分定义，转化为定积分的计算<br>2.利用几何意义，想象为，一个半圆的面积的积分，直接求面积<br>3.也可以将x=sint，左变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251651125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251707587.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251718611.png" alt="image.png"></p><p><em>多项式分数，根式里面一次，一般变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251906680.png" alt="image.png"></p><p><em>根式含有平方项，三角代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251907971.png" alt="image.png"></p><p><em>边界曲线，用极坐标给出，求面积的问题<br>可以直接套公式，<br>任然还有问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251922342.png" alt="image.png"><br><em>对比着看</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261610407.png" alt="image.png"></p><p><em>运用弧长积分公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251926365.png" alt="image.png"></p><p><em>通过分部积分法，将f(x)写成导数计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252055735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252126968.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252153239.png" alt="image.png"></p></blockquote><h2 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261042264.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261116190.png" alt="image.png"></p><p><em>积分中值定理+介值定理+两次罗尔定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261131711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261205973.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261235506.png" alt="image.png"></p><p><em>方法1.利用介值定理，介于最大最小值之间</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261329751.png" alt="image.png"><br><em>方法2.利用构造辅助函数，常规方法，然后再说明有两个点，辅助函数值相等(罗尔定理)，就证明等式成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261334817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261400953.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261417494.png" alt="image.png"></p><p><em>难题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261443061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261446496.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261506664.png" alt="image.png"></p><p><em>长条中质心的积分计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261509020.png" alt="image.png"></p><p><em>典型，积分求旋转体体积</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261604721.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261607358.png" alt="image.png"></p></blockquote><h1 id="4-常微分方程"><a href="#4-常微分方程" class="headerlink" title="4.常微分方程"></a>4.常微分方程</h1><h2 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292225471.png" alt="image.png"></p><blockquote><p><em>直到三阶常系数齐次线性微分方程的特解，直接从特解中看出特征根，然后根据特征根写出特征方程，即可</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292150830.png" alt="image.png"></p><p><em>非齐次解具有叠加性，可以拆开分析</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292154652.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292200338.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292214416.png" alt="image.png"></p></blockquote><h2 id="填空题-4"><a href="#填空题-4" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301428202.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301530231.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301545683.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301551914.png" alt="image.png"></p><h2 id="解答题-3"><a href="#解答题-3" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>1.三个线性无关特解，两两相减=通解<br>2.然后通过消去系数得到最终方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301634920.png" alt="image.png"></p><p><em>不属于已知的类型，通过x,y对调,令y’ =1/x’,化为x为函数，y为自变量的函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301638682.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301713823.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916345.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302054499.png" alt="image.png"></p><p><em>通过导数定义，构建微分方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302136747.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307310953433.png" alt="image.png"></p><p><em>微分方程与全微分结合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311007885.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311033425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311047528.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311409647.png" alt="image.png"></p></blockquote><h1 id="5-二重积分"><a href="#5-二重积分" class="headerlink" title="5.二重积分"></a>5.二重积分</h1><h2 id="选择题-3"><a href="#选择题-3" class="headerlink" title="选择题"></a>选择题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311421096.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311647617.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311656049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311710142.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311713317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311750227.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311754610.png" alt="image.png"></p><p><em>二重积分是一个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311805140.png" alt="image.png"></p><p><em>区域相同，比较被积函数大小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311808151.png" alt="image.png"></p><p><em>轮换对称性、奇偶性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311816485.png" alt="image.png"></p><p><em>经典</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311824085.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311827837.png" alt="image.png"></p><p><em>累次积分对t求导<br>1.通过转换积分次序，使得只有外层积分保留t<br>2.将外层0~t积分对应微分的变量，在内层用t替换</em><br><em>例1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312059190.png" alt="image.png"><br><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011156555.png" alt="image.png"><br><em>例3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011228116.png" alt="image.png"></p></blockquote><h2 id="填空题-5"><a href="#填空题-5" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312129808.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312156656.png" alt="image.png"></p><p><em>拆开、奇偶性、轮换对称性、极坐标法<br>太妙了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312207638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011058407.png" alt="image.png"></p><p><em>此时极坐标方便—&gt;换位直角坐标，然后(x-1)关于(1,0)点的奇函数，利用奇偶性；最后计算简单</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011107023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222340.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222036.png" alt="image.png"></p></blockquote><h2 id="解答题-4"><a href="#解答题-4" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>数列n项和，转化为定积分定义，最终得到一个累次积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011224321.png" alt="image.png"></p><p><em>题目给的积分不好积分，就交换积分次序<br>1.先画域<br>2.重新确定积分次序，就可以简便积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011402509.png" alt="image.png"></p><p><em>该题很有规律，不要硬算，算不出来</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417984.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417329.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011438457.png" alt="image.png"></p><p><em>没想到的，极坐标不好用，换成极坐标</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011518588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529261.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529642.png" alt="image.png"></p><p><em>利用奇偶性、对称性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011538891.png" alt="image.png"></p><p><em>圆形不再原点的，通过平移，使得圆心在原点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011636328.png" alt="image.png"></p><p><em>注意奇函数乘偶函数=奇函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012100835.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012128361.png" alt="image.png"></p><p><em>积分的绝对值&lt;=绝对值的积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012138798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012151775.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012150173.png" alt="image.png"></p></blockquote><h1 id="6-多元函数微分学"><a href="#6-多元函数微分学" class="headerlink" title="6.多元函数微分学"></a>6.多元函数微分学</h1><h2 id="选择题-4"><a href="#选择题-4" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>求偏导数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021328671.png" alt="image.png"></p><p><em>D.正确<br>从x方向趋向于x0,的极限，而y0固定的，相当于一个一元函数从x方向的一元函数，由于x方向的偏导数存在=a, 再根据一元函数可导必定连续，说明该函数极限就等于函数值f(x0,y0) ;同理y方向趋向于y0极限也存在也等于f(x0,y0)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021336253.png" alt="image.png"></p><p><em>1.首先证明偏导数存不存在(用定义法)<br>2.判断出两个偏导数都存在，接着通过可微判断式，判断是否等于0<br>3.最终式子如下，利用y=kx（其中一个方向趋向于y0）,看极限手否与趋向的方向无关(也就是如果极限与k有关，那么极限就不存在)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021351399.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021420120.png" alt="image.png"></p><p><em>偏x方向导数&gt;0,所以延x方向是增加的，同理延y方向减小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021422359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021430141.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021507965.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021520285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021527756.png" alt="image.png"></p><p><em>极限保号性，既然当x-&gt;0,y-&gt;0时 f(x,y)&gt;0, 且f(0,0)=0,所以f(0,0)就是极小值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021532707.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031454924.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031502939.png" alt="image.png"></p><blockquote><p><em>AC-B^2 &lt;0 所以内部无极值点，那么由于这是一个有界区域，所以最值位于边界上的点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031505371.png" alt="image.png"></p></blockquote><h2 id="填空题-6"><a href="#填空题-6" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031537091.png" alt="image.png"></p><p><em>知道偏导，求函数本身—&gt;偏积分法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031542061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031600766.png" alt="image.png"></p><p>*公式法，将x,y,z看做独立的变量，而不用再将z看做x,y的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031607224.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031654172.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031721585.png" alt="image.png"></p></blockquote><h2 id="解答题-5"><a href="#解答题-5" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031728679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031736577.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032041935.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032100874.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032321526.png" alt="image.png"></p><p><em>AC-B^2=0，不能确定是否有极值，需要通过定义判定<br>1.极值的定义是，一个极小区域内无论函数从哪个方向趋向于极值点，函数值都是要么都同号，不会有正负都出现的情况</em><br><em>2.所以分别从y=x方向与y=-x方向趋向于(0,0)点，发现两个方向趋向于该点，一个方向值为+，一个方向为-，就说明该点不是极值点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041021953.png" alt="image.png"></p><p><em>我做错了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041154395.png" alt="image.png"></p><p><em>数形结合，起始就是求z坐标绝对值的最大值，由于|z|不好求，所以改为求z^2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041507215.png" alt="image.png"></p><p><em>1.利用齐次方程，有非零解时，系数行列式=0的特点<br>2.求长半轴与短半轴长度之比，实际就是求椭球距离原点最长最短距离之比</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041515026.png" alt="image.png"></p><p><em>把证明不等式的问题，转化为证明一个条件下，最大最小值的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041519753.png" alt="image.png"></p></blockquote><h1 id="7-无穷级数"><a href="#7-无穷级数" class="headerlink" title="7-无穷级数"></a>7-无穷级数</h1><h2 id="选择题-5"><a href="#选择题-5" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061036658.png" alt="image.png"></p><p><em>(1)好理解<br>(2)采用比值法，需要取极限，而不是单单相除，例如(1/n+1) / (1/n) &lt;1 但是取极限就是=1，而1/n级数是发散的<br>(3)比值法，前提是两个都是正项级数<br>(4)  0&lt;=bn-an&lt;=cn-an ; $\sum<em>{n=1}^{\infty}a_n$ 与$\sum</em>{n=1}^{\infty}c<em>n$都收敛，所以$\sum</em>{n=1}^{\infty}c_n-a_n$ 收敛<br>大收则小收，bn-an也收敛，因为bn = (bn-an)+an,两个收敛相加依然收敛，故bn收敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061054853.png" alt="image.png"></p><p><em>关键：级数与函数有关，函数连续，想到函数必定有界，设M</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061135473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061209429.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061211017.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061348192.png" alt="image.png"></p><p><em>A. an-&gt;0,所以anbn&lt;bn ,大收则小收，但是不确定bn是正项级数还是有负的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061354692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061415331.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061416527.png" alt="image.png"></p></blockquote><h2 id="填空题-7"><a href="#填空题-7" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122547.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122923.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072200181.png" alt="image.png"></p><p>*级数$\sum<em>{n=1}^{\infty}a_n$ 是等价于 $\sum</em>{n=1}^{\infty}\frac{1}{ln n}$,是发散的，<br>原级数$\sum<em>{n=1}^{\infty}\frac{(-1)^na_n}{n}(x+1)^n$ 看做是$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$逐项求导，收敛半径不变。<br>$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$将x=0代入，是$\sum</em>{n=1}^{\infty}(-1)^na_n$条件收敛<br>又因为幂级数条件收敛的点只可能发生在收敛区间端点，所以0是区间一个端点，所以收敛半径=1；收敛区间（-2,0）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072207881.png" alt="image.png"></p><p><em>我的方法是直接代入，x=3,-3(根据直觉)，发现x=-3时条件收敛，那么x=-3一定是收敛区间端点，接着就能找出收敛域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308080950111.png" alt="image.png"></p></blockquote><h2 id="解答题-6"><a href="#解答题-6" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>考察对各类级数敛散性判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081000284.png" alt="image.png"></p><p><em>x的范围一定要写，原公式-1&lt;x&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081018049.png" alt="image.png"></p><p><em>像是arctan，的幂级数展开，一般是求导，展开，再积分<br>积分是要变上限积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081039482.png" alt="image.png"></p><p><em>省略二次求导，再积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081122483.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081144158.png" alt="image.png"></p><p><em>这种题，和函数的导四次，回到原来的和函数，建立微分方程，求解<br>【注意通解中含有4个变量，需要四个函数值，0! =1,所以y(0)=1,y’(0)=0….】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130847.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130620.png" alt="image.png"></p><p><em>求常数项级数的求和，借助幂级数，写成常用的展开的形式，再代入x=1（这题来说代入x=1,恢复原来式子）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081236378.png" alt="image.png"></p><p><em>这种微分方程不好解，那只能代入方程，将x化为同次幂，关注其常数项系数=0，就能找出幂级数系数的关系式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081342834.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081343735.png" alt="image.png"></p><p><em>与上面一样的做法，将x化为同次幂，找幂级数系数的关系</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081350959.png" alt="image.png"></p><p><em>S’(x)，和函数的导数，这个导数幂级数要从n=1开始，因为n=0的项是常数a0,求导之后没了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081407634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452179.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452832.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504136.png" alt="image.png"></p><p><em>运用到了柯西积分不等式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081513995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081512357.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081532609.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081533525.png" alt="image.png"></p><p><em>傅里叶级数展开的系数问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081547512.png" alt="image.png"></p></blockquote><h1 id="8-向量代数与空间几何"><a href="#8-向量代数与空间几何" class="headerlink" title="8-向量代数与空间几何"></a>8-向量代数与空间几何</h1><h2 id="选择题-6"><a href="#选择题-6" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>直线L2由两个平面相交给出，；</em><br><em>1.求出两条直线的方向向量，【L2,方向向量，由两平面法向量叉乘得出】</em><br><em>2.方向向量知道，就能求出余弦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141322734.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141323837.png" alt="image.png"></p><p><em>曲面和平面的法线都是将函数写成F(x,y,z)=0,的形式，法线向量坐标都是对x,y,z求偏导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141419054.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141423635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141427969.png" alt="image.png"></p><p><em>梯度计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141430332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141430693.png" alt="image.png"></p></blockquote><h2 id="填空题-8"><a href="#填空题-8" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>混合积有轮换对称性质</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141442031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141443127.png" alt="image.png"></p></blockquote><h2 id="解答题-7"><a href="#解答题-7" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141637104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141644925.png" alt="image.png"></p><p><em>方向导数最大时，就是延梯度的方向且方向导数的最大值是梯度的模</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141707509.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141734592.png" alt="image.png"></p><p><em>投影直线绕某坐标轴转所得到的旋转面的方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141801003.png" alt="image.png"></p><p><em>直线L的方向向量是(2,1,-1),而不是(2,1,-2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141829609.png" alt="image.png"></p><p><em>根据两面写出平面束方程（经过该直线的所有平面），然后利用平面法向量垂直于该直线方向向量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142038188.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142038826.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142054263.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142054491.png" alt="image.png"></p><p><em>梯度向量是空间曲面在平面上的投影的水平方向的向量</em><br><em>这题就是利用了水滴会延梯度向量方向(平面向量)流动，并且流动轨迹xoy面投影的切线向量就是梯度向量方向</em><br><em>解微分方程，求出了投影曲线的柱面方程，联立球面方程，就是路线方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142117410.png" alt="image.png"></p></blockquote><h1 id="9-多元积分的应用"><a href="#9-多元积分的应用" class="headerlink" title="9-多元积分的应用"></a>9-多元积分的应用</h1><blockquote><p><em>在竖着的椭圆内是正的，在外边积分是负的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152123987.png" alt="image.png"></p><p><em>这题，先拆开利用奇偶性，消去部分项，然后，分别对三项积分，只积分其中一项，(中间利用椭圆面积=πab),然后推出其他两项的积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152151016.png" alt="image.png"></p><p><em>画出积分域，交换积分次序</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152227715.png" alt="image.png"></p><p><em>我做出来了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308160928731.png" alt="image.png"></p><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308160938156.png" alt="image.png"></p><p><em>这题是对空间平面的积分，一般有几种方法：1,斯托克公式，2.化为一维平面(降维)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161028846.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161048379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161048465.png" alt="image.png"></p><p><em>形心计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161530603.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-函数极限连续&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="高数" scheme="https://fqzs.netlify.app/categories/%E9%AB%98%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线代</title>
    <link href="https://fqzs.netlify.app/undefined/43e039bd.html"/>
    <id>https://fqzs.netlify.app/undefined/43e039bd.html</id>
    <published>2023-06-30T12:24:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png" alt="image.png"></p><h1 id="01-行列式的定义与性质"><a href="#01-行列式的定义与性质" class="headerlink" title="01-行列式的定义与性质"></a>01-行列式的定义与性质</h1><h2 id="行列式背景"><a href="#行列式背景" class="headerlink" title="行列式背景"></a>行列式背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于一个二元方程组，每次都要求解就特别麻烦。</span><br><span class="line">为了更加快速的找到方程的解，人们寻找规律，发现解的通式如下</span><br><span class="line">但是通式难以记忆，所以将这种计算规律用行列式表示，规定行列式计算方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301231233.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301500559.png" alt="image.png"></p><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论:一个排列中任意的两个元素对换，排列的奇偶性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301509795.png" alt="image.png"></p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行列式是一个数</span><br><span class="line">行列式计算方法是：</span><br><span class="line">1.取数相乘: 取n个不同行不同列的数 相乘 --&gt; 所以n!种取法，就有n!项</span><br><span class="line">2.冠以符号: 每一项(n个数相乘),将里面的元素，按列排好，然后数 列序号的逆序数τ，</span><br><span class="line">-(1)^τ</span><br><span class="line">3.全部相加: 将所有项n!项相加   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301521315.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按照行列式定义，因为行列式的每一项都是有不同行不同列的n个数相乘</span><br><span class="line">假如取1行1列的数--&gt;x</span><br><span class="line">那么画个十字线，十字线上的数都不能再取</span><br><span class="line">题目要求行列式结果中x^3的系数</span><br><span class="line"></span><br><span class="line">排除法:</span><br><span class="line">假如先取1，画十字线，发现其他行最多只能取到两个x，构不成x^3</span><br><span class="line">假如先取2，同理不行</span><br><span class="line">所以只能取x或x+3</span><br><span class="line"> 取x+3,只有一种情况，可行</span><br><span class="line"> 取x,第二行只能取x,第三行只能取x,第四行只能取x，那么x^4不符合。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301535080.png" alt="image.png"></p><p><mark>主对角线与副对角线矩阵的值</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：主对角线的矩阵的值等于对角线元素相乘，而副对角线矩阵的值等于-1<sup>n(n-1)/2 </sup>a<sub>1,n </sub>a<sub>2,n-1 </sub>a<sub>3,n-2</sub>....a<sub>n,1</sub></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt="image.png"></p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a><em>转置</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301557471.png" alt="image.png"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><em>交换</em></h3><p><strong>交换一行实际上是对每一项的逆序数发生改变，导致全部项的正负性改变</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301600178.png" alt="image.png"></p><h3 id="倍乘"><a href="#倍乘" class="headerlink" title="倍乘"></a><em>倍乘</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301619501.png" alt="image.png"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a><em>拆分</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301620199.png" alt="image.png"></p><blockquote><p><em>倍加</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301623438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301627820.png" alt="image.png"></p><hr><h1 id="02-行列式的计算与代数余子式"><a href="#02-行列式的计算与代数余子式" class="headerlink" title="02-行列式的计算与代数余子式"></a>02-行列式的计算与代数余子式</h1><h2 id="分块矩阵的行列式计算"><a href="#分块矩阵的行列式计算" class="headerlink" title="分块矩阵的行列式计算"></a>分块矩阵的行列式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301645404.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301654171.png" alt="image.png"></p><h2 id="行列式按行-列-展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h2><h3 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">余子式M 是特殊的情况，恰好第一行第一个数不是0,该行其余都是0,行列式的值=a11xM11。</span><br><span class="line">代数余子式A是讨论,不是特殊情况时，要考虑符号问题。</span><br><span class="line">就是不断的交换将aij逐行逐列的移到第一个的位置(交换一次改变一次正负号),aij列需要j次</span><br><span class="line">交换，行需要i次交换。所以符号-(1)^i+j x Mij = Aij </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301724746.png" alt="image.png"></p><blockquote><p><em>“么”型通法，按横展开</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301750483.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302120137.png" alt="Uploading file...havyy"></p><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302138234.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302217822.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302141433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302143275.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302148080.png" alt="image.png"></p><h2 id="范德门行列式"><a href="#范德门行列式" class="headerlink" title="范德门行列式"></a>范德门行列式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像这种第一行(或列)是1，第二行(列)是x1,x2..xn;第三行(列)是x1^2,x2^2..xn^2;...第n行(列)是...</span><br><span class="line">这种形式的就是范德蒙行列式，它的值有如下规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302222870.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.加边法</span><br><span class="line">与范德蒙行列式相似的，可以加边使其成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302228111.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.提公因子</span><br><span class="line">每一行提一个公因子，使得第一列的全为1，成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302230815.png" alt="image.png"></p><hr><h1 id="03矩阵及其运算"><a href="#03矩阵及其运算" class="headerlink" title="03矩阵及其运算"></a>03矩阵及其运算</h1><h2 id="矩阵及分块的概念"><a href="#矩阵及分块的概念" class="headerlink" title="矩阵及分块的概念"></a>矩阵及分块的概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矩阵的提出主要源自于数学中的三个问题:</span><br><span class="line">1.线性变换:用于表示未知数的变换关系</span><br><span class="line">2.线性方程组:用于表示方程组各个未知数的系数</span><br><span class="line">3.二次型:方便表示二次型，x^2,y^2,xy,出现的个数</span><br></pre></td></tr></table></figure><blockquote><p><em>数表来源</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302253439.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302255227.png" alt="image.png"></p><blockquote><p><em>特殊矩阵及分块矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302314484.png" alt="image.png"></p><h2 id="矩阵及分块矩阵的计算"><a href="#矩阵及分块矩阵的计算" class="headerlink" title="矩阵及分块矩阵的计算"></a>矩阵及分块矩阵的计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">矩阵加减法要求</span><br><span class="line">1.同型矩阵，m,n相同</span><br><span class="line">2.对应每个元素相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302321222.png" alt="image.png"></p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302346561.png" alt="image.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵乘法，实质是将由x-&gt;y的线性变换通过y-&gt;z的变化 转到x-&gt;z的线性变换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302349135.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011521217.png" alt="image.png"></p><hr><blockquote><p><em>对角矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011524350.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011527225.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵练习</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排列与组合区别在于，组合不要求内部顺序，所以要除以顺序个数</span><br><span class="line"></span><br><span class="line">将A矩阵拆分为--&gt; 单位E矩阵 + “坍缩矩阵”B </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011532335.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011534905.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011535161.png" alt="image.png"></p><blockquote><p><em>成比例矩阵的幂</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每行成比例的矩阵，可以写为如下</span><br><span class="line">成比例矩阵n次幂就可以拆为如下</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011559846.png" alt="image.png"></p><blockquote><p><em>与伴随矩阵相乘</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AxA* --&gt; 乘错行导致只有对应行的与其对应的代数余子式相乘结果才为|A|--&gt;也就是只有对角线上是|A| </span><br><span class="line"></span><br><span class="line">为什么代数余子式，乘错行会=0？ </span><br><span class="line">因为,乘错行，可以看做求一个具有两行相元素的行列式的值--&gt;两行相同元素的行列式=0</span><br><span class="line"></span><br><span class="line">为什么两行相同元素的行列式值是0?</span><br><span class="line">因为，利用交换一次行,矩阵正负性改变,两行相同交换后不变，但正负性改变，那么只能是0</span><br><span class="line"></span><br><span class="line">为什么交换两行元素，矩阵正负性要改变?</span><br><span class="line">因为，交换两行之后，导致每一项列排序发生一次交换--&gt;逆序数奇偶性变化--&gt;正负性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011615201.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011741250.png" alt="image.png"></p><hr><h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011730342.png" alt="image.png"></p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743537.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743180.png" alt="image.png"></p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵定义"><a href="#逆矩阵定义" class="headerlink" title="逆矩阵定义"></a><em>逆矩阵定义</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011859511.png" alt="image.png"></p><h3 id="逆矩阵充要条件"><a href="#逆矩阵充要条件" class="headerlink" title="逆矩阵充要条件"></a><em>逆矩阵充要条件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011901315.png" alt="image.png"></p><blockquote><p><em>原矩阵行列式=0 =&gt;伴随矩阵行列式=0</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011907635.png" alt="image.png"></p><blockquote><p><em>求二阶矩阵的逆矩阵方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011939266.png" alt="image.png"></p><blockquote><p><em>分块矩阵求逆矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011948103.png" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012256386.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求可对角化的矩阵的幂--&gt;先将矩阵写为下列形式，然后相乘，中间可以相互抵消为E(单位矩阵)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012257657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012300822.png" alt="image.png"></p><h2 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012305438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012312191.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012314168.png" alt="image.png"></p><hr><h1 id="04初等变换与初等矩阵"><a href="#04初等变换与初等矩阵" class="headerlink" title="04初等变换与初等矩阵"></a>04初等变换与初等矩阵</h1><h2 id="初等变换、矩阵的行阶梯、行最简、标准形"><a href="#初等变换、矩阵的行阶梯、行最简、标准形" class="headerlink" title="初等变换、矩阵的行阶梯、行最简、标准形"></a>初等变换、矩阵的行阶梯、行最简、标准形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">化为行阶梯型矩阵--&gt;自上而下化简</span><br><span class="line">化为最简型矩阵--&gt;自下而上化简</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012324531.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">矩阵A只进行行变换到B,称A与B 行等价</span><br><span class="line">矩阵A只进行列变换到B,称A与B 列等价</span><br><span class="line">如果即行又列，称A与B 等价 </span><br><span class="line"></span><br><span class="line">不管行等价，列等价，等价 --&gt;其秩都相等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012335843.png" alt="image.png"></p><h2 id="初等矩阵的定义性质"><a href="#初等矩阵的定义性质" class="headerlink" title="初等矩阵的定义性质"></a>初等矩阵的定义性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初等矩阵可以传递三种操作:</span><br><span class="line">1.交换: 左行右列 Eij --&gt;交换第i、j行(列)</span><br><span class="line">2.倍乘: 左行右列 Ei(k) --&gt; 第i行(列) 乘k倍</span><br><span class="line">3.倍加: 左行由列 Eij(k) --&gt; (左)将第i行加上j行的k倍;(右)将第j列加上第i行的k倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012358129.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307020005020.png" alt="image.png"></p><h2 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031442490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031446780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031452285.png" alt="image.png"></p><h2 id="可逆矩阵都可初等变换化为单位阵"><a href="#可逆矩阵都可初等变换化为单位阵" class="headerlink" title="可逆矩阵都可初等变换化为单位阵"></a>可逆矩阵都可初等变换化为单位阵</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031514917.png" alt="image.png"></p><h2 id="初等变换求逆矩阵-解可逆矩阵方程"><a href="#初等变换求逆矩阵-解可逆矩阵方程" class="headerlink" title="初等变换求逆矩阵-解可逆矩阵方程"></a>初等变换求逆矩阵-解可逆矩阵方程</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031520619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.A逆在左，行变换，所以可逆矩阵方程A,B要行摆放</span><br><span class="line">2.A逆在右，列变换，所以可逆矩阵方程A,B要列摆放</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031537723.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031547781.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031553549.png" alt="image.png"></p><hr><h1 id="05-矩阵的秩与线性方程组"><a href="#05-矩阵的秩与线性方程组" class="headerlink" title="05-矩阵的秩与线性方程组"></a>05-矩阵的秩与线性方程组</h1><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="矩阵的秩的定义"><a href="#矩阵的秩的定义" class="headerlink" title="矩阵的秩的定义"></a>矩阵的秩的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初等变换不会改变秩的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031709329.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031717376.png" alt="image.png"></p><h3 id="行阶形求秩"><a href="#行阶形求秩" class="headerlink" title="行阶形求秩"></a>行阶形求秩</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031713196.png" alt="image.png"></p><h3 id="秩的结论"><a href="#秩的结论" class="headerlink" title="秩的结论"></a>秩的结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.矩阵的秩不会超过行数也不会超过列数，因为逆矩阵的秩就是阶梯个数，阶梯怎么画都不会   超过行和列</span><br><span class="line">2.转置矩阵的秩不变很好理解</span><br><span class="line">3.等价的矩阵秩一定相等--&gt;等价的矩阵实际就是在一个矩阵基础上经过若干初等变换得到的   两个矩阵，初等变换不会影响秩的大小</span><br><span class="line">4.P,Q可逆--&gt;P,Q是若干初等矩阵的乘积--&gt;相当于对A经过若干初等行变换+列变换--&gt;秩不变</span><br><span class="line">5.(A,B)矩阵的秩R(A,B)min/max --&gt; A,B都化为标准型之后，看斜对角线</span><br><span class="line">6.矩阵相加的秩，化标准型理解</span><br><span class="line">7.矩阵相乘的秩，化标准型理解(特殊:矩阵与其转置矩阵相乘，秩不变)</span><br><span class="line">8.两矩阵相乘为0矩阵--&gt;标准型中1刚好错开，那么R(A)+R(B)&lt;=n</span><br><span class="line">9.伴随矩阵的秩与原矩阵的秩的关系...</span><br><span class="line">10....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031725785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031745903.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031749579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031751055.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031755979.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.R(Amxn) =n --&gt;列满秩 ;所以A的标准型是上面E,下面O ; --&gt; 标准型左边乘以可逆矩阵P(等效为若干初等变换) 得到A --&gt; A标准型=PA ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031800370.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031819833.png" alt="image.png"></p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><h3 id="解的判定"><a href="#解的判定" class="headerlink" title="解的判定"></a>解的判定</h3><blockquote><p><em>齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031839448.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031838230.png" alt="image.png"></p><hr><blockquote><p><em>非齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031850780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031852539.png" alt="image.png"></p><h3 id="具体方程组的求解"><a href="#具体方程组的求解" class="headerlink" title="具体方程组的求解"></a>具体方程组的求解</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031859530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031900387.png" alt="image.png"></p><h1 id="06-向量组的线性相关性"><a href="#06-向量组的线性相关性" class="headerlink" title="06-向量组的线性相关性"></a>06-向量组的线性相关性</h1><h2 id="向量及向量空间"><a href="#向量及向量空间" class="headerlink" title="向量及向量空间"></a>向量及向量空间</h2><blockquote><p><em>(a1，a2，β)向量组，其中如果三个向量共平面【其中一个向量，可以由另外两个向量通过线性运算：k1a1+k2a2 =β,得到，那么称为这组向量线性相关】<br>如果三个向量，不不再同一个平面，那么无法通过线性运算得到第三个向量，则线性无关</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101707649.png" alt="image.png"></p><h2 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h2><h3 id="线性表示-1"><a href="#线性表示-1" class="headerlink" title="线性表示"></a>线性表示</h3><blockquote><p><em>加入一个新的向量b，原矩阵的秩如果不变，说明向量b没有开拓新的维度<br>，就是可以用前面的向量线性表示出来，与其他向量线性相关，就是一个混子向量，没有作用<br>反之，若果秩增加，说明，是骨干向量，在几何上表现为翘了起来，开拓了新的维度，与之前的向量线性无关</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101741794.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101821801.png" alt="image.png"></p></blockquote><h3 id="向量组等价"><a href="#向量组等价" class="headerlink" title="向量组等价"></a>向量组等价</h3><p><em>两个向量组能够互相线性表示，那么这两个向量组等价</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101828818.png" alt="image.png"></p><p><em>两个矩阵等价，只要求矩阵秩相等；<br>1.所以矩阵等价，推不出向量组等价，因为向量组1，和向量组2表示的平面不一定是同一个平面；<br>2.同理，向量组等价，推不出矩阵等价，因为向量组等价可以不同型，比如一个3列，一个2列，虽然向量组等价(多了一个混子向量)，但是矩阵不等价(矩阵等价需要同行同列)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111027220.png" alt="image.png"></p><blockquote><p><em>例题</em><br><em>1.将两向量组和成一个，看维度是多少(秩是多少)<br>2.发现秩=2，且向量组1的秩也等于2，说明向量组2的加入没有增加维度，<br>3.继续看向量组2的秩=2，说明向量组1的加入没有增加2的维度<br>4.所以两个向量组可以互相线性表示，是等价的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111035825.png" alt="image.png"></p><p><em>推论</em></p></blockquote><p><em>1.如果向量组A可由B线性表示，那么R(A)&lt;=R(B)<br>反之不成立，因为如果R(A=1,一条线；R(B)=2,一个面，线不再面上，无法被B线性表示</em></p><h2 id="线性相关性-齐次线性方程组有无非零解问题"><a href="#线性相关性-齐次线性方程组有无非零解问题" class="headerlink" title="线性相关性(齐次线性方程组有无非零解问题)"></a>线性相关性(齐次线性方程组有无非零解问题)</h2><p><em>k不全为0，满足下列方程，那么可以互相消去，说明有混子向量，所以有非零解，线性相关的<br>k全为0，才满足下列等式，那么无法互相消去，全都是不重复的骨干向量，只有全0才成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111047039.png" alt="image.png"></p><blockquote><p><em>例题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111058837.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111100449.png" alt="image.png"></p><p><em>推论</em><br><em>特别对于第二个结论：向量的维度，就是向量的坐标轴个数，一个三维向量，就是x,y,z坐标轴，最多三个骨干向量（分别表示x,y,z方向），再多一个都是混子，重复；同理四维向量，有4个坐标轴，最多四个骨干向量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111108087.png" alt="image.png"></p></blockquote><h2 id="向量组的极大无关组"><a href="#向量组的极大无关组" class="headerlink" title="向量组的极大无关组"></a>向量组的极大无关组</h2><p><em>就是向量组的骨干组，但凡多一个都是混子，所以极大无关组的向量个数也就是向量组的秩</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111112705.png" alt="image.png"></p><h2 id="线性方程组解的结构与判定"><a href="#线性方程组解的结构与判定" class="headerlink" title="线性方程组解的结构与判定"></a>线性方程组解的结构与判定</h2><h3 id="基础解系"><a href="#基础解系" class="headerlink" title="基础解系"></a><em>基础解系</em></h3><ul><li><em>基础解系个数=自由变量的个数=未知数个数-主元的个数=n-r(A)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111403819.png" alt="image.png"></li></ul><h3 id="解的结构"><a href="#解的结构" class="headerlink" title="解的结构"></a><em>解的结构</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111406790.png" alt="image.png"></p><p><strong><em>例题</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111352578.png" alt="image.png"></p><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a><em>向量空间</em></h3><blockquote><p><em>基于坐标</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111502596.png" alt="image.png"></p><blockquote><p><em>过渡矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111503426.png" alt="image.png"></p><h1 id="07-矩阵的特征值与特征向量"><a href="#07-矩阵的特征值与特征向量" class="headerlink" title="07-矩阵的特征值与特征向量"></a>07-矩阵的特征值与特征向量</h1><p><strong><em>1.定义</em></strong><br><em>设  A 是 n 阶矩阵，如果存在数 λ和n 维非零 列向量 α成立使 <strong>Aα=λα</strong><br>那么称 λ为方阵A的一个特征值，α 称为 A 的对应于特征值λ的 特征向量.</em></p><ul><li><em>转化为求齐次方程有非零解的问题，系数方程是λE-A，解向量是α</em></li><li><em>有非零解—&gt;系数矩阵秩&lt;n,所以矩阵的行列式=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111523447.png" alt="image.png"></li></ul><p><strong><em>例题</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111530978.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111532815.png" alt="image.png"></p><p><strong><em>2.性质</em></strong></p><ul><li><em>特征值的和=矩阵对角线系数的和</em></li><li><em>特征值的积=矩阵行列式的值</em></li><li><em>不同特征值对应的特征向量线性无关</em></li><li><em>n重根的特征值对应的线性无关的特征向量,最多n个</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111542797.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111546245.png" alt="image.png"></li></ul><p><strong><em>3.与A相关的矩阵的特征值与特征向量</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111601614.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111602079.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111604997.png" alt="image.png"></p><p><strong><em>例题</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111608623.png" alt="image.png"></p><h1 id="08-相似矩阵与相似对角化"><a href="#08-相似矩阵与相似对角化" class="headerlink" title="08-相似矩阵与相似对角化"></a>08-相似矩阵与相似对角化</h1><h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><p><strong><em>1.定义</em></strong><br><strong><em>两矩阵相似，可以推出以下5个推论</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112016067.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112016218.png" alt="image.png"></p><p><strong><em>2.性质</em></strong></p><ul><li><em>相似矩阵特征值相同，但是特征值相同的矩阵不一定相似</em></li><li><em>相似矩阵秩相等(利用初等变换理解)，但是秩相等的不一定相似</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112025588.png" alt="image.png"></li></ul><h2 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h2><ul><li><em>若n阶矩阵A与对角矩阵相似，pAp^-1 = ∧ ，那么对角线上的n个值就是A的n个特征值</em></li><li><p><em>证明如下：矩阵A一定能写成Aα=λα，那么A(α1,α2,α3)=(Aα1,Aα2,Aα3)=(λ1α1,λ2α2,λ3α3) ; 假设P=(α1,α2,α3)且可逆，那么AP=P∧ ，这个对角矩阵∧对角线上的值就是特征值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112031274.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112034083.png" alt="image.png"></p></li><li><p><em>判断一个矩阵可不可以对角化，就是看他的特征向量组成的矩阵是不是线性无关的—&gt;可逆的</em></p></li><li><em>因为矩阵|A|=特征值相乘—&gt;那么将A进行初等变换不改变矩阵行列式的值—&gt;对角化相当于对A进行初等变换，行列式的值不变，那么得到pAp^-1 = ∧，<br>|∧|=特征值相乘，所以对角线上就是特征值；进而可知，这个P矩阵就是特征向量矩阵（α1，α2，α3），如果这个P矩阵可逆，就说明相似矩阵∧(对角矩阵）存在，那么就是可对角化；如果P不可逆，说明pAp^-1 = ∧不成立，A 与<br>∧不相似，就是不可对角化。</em></li><li><em>所以，需要证明一个矩阵A可不可以对角化</em><br><em>1.就是要先求出所有特征值。<br>2.分为三种情况讨论：<br>(1). λ1 != λ2 != λ3,分别所对应的特征向量α1，α2，α3)线性无关，P=（α1，α2，α3）一定可逆，所以A与∧相似，可对角化；<br>(2) λ1 = λ2 != λ3，可以确定α2，α3线性无关，接着判定α1，α2是否线性无关即可，如果不是线性无关,那么P就不可逆，相似不成立；<br>(3) λ1 = λ2 = λ3，….</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112057256.png" alt="image.png"></p><ul><li><em>定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121106054.png" alt="image.png"></li></ul><p><strong><em>例题1</em></strong></p><ul><li><em>计算特征值，可以<strong>展开某一行</strong>，也可以直接算，然后通过<strong>多项式除法</strong>化为因式相乘</em></li><li><em>代入特征值，解齐次线性方程得出对应特征向量</em></li><li><em>注意P向量中特征向量与对角矩阵中特征值的位置顺序要对应</em></li><li><em>令P=(α2，-α1，2α3)  ,A的对角矩阵中对角线上的特征值还是原来，只是换了位置，【λ是替代的A,与特征向量倍数无关】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121110355.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121115003.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121121835.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131955578.png" alt="image.png"></li></ul><p><strong><em>例题2</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121131338.png" alt="image.png"></p><p><strong><em>结论1</em></strong></p><ul><li><em>n阶方阵A的秩&lt;n,则A一定有特征值=0，|A||α|=λ|α|</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121157839.png" alt="image.png"></li></ul><h1 id="09-对称矩阵的对角化"><a href="#09-对称矩阵的对角化" class="headerlink" title="09-对称矩阵的对角化"></a>09-<em>对称矩阵的对角化</em></h1><h2 id="1-对称矩阵的性质"><a href="#1-对称矩阵的性质" class="headerlink" title="1.对称矩阵的性质"></a><strong><em>1.对称矩阵的性质</em></strong></h2><ul><li><em>对称矩阵特征值一定是实数</em></li><li><em>对称矩阵两个不同特征值对应的特征向量是正交的</em></li><li><em>对称矩阵一定可以对角化</em></li><li><em>对称矩阵，一定有正交矩阵可以与其相似对角化和合同对角化</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121227448.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121243861.png" alt="image.png"></li></ul><blockquote><p><em>例题1</em><br><em>1.对称矩阵，且三个特征值互不相等，所以三特征向量正交，互相内积为0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121235970.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121241038.png" alt="image.png"></p></blockquote><h2 id="2-正交矩阵与合同对角化"><a href="#2-正交矩阵与合同对角化" class="headerlink" title="2.正交矩阵与合同对角化"></a><strong><em>2.正交矩阵与合同对角化</em></strong></h2><p><strong><em>正交矩阵</em></strong><br><strong>*与自己的转置矩阵相乘=单位矩阵的矩阵，称为正交矩阵</strong>，顾名思义，正交矩阵，里面的向量两两正交；另外需要满足，<strong>正交矩阵的向量都是单位向量*</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131918495.png" alt="image.png"></p><p><strong><em>合同的定义</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131922372.png" alt="image.png"></p><p><strong><em>合同对角化的步骤</em></strong></p><p><em>一般只讨论对称矩阵的合同对角化</em></p><ol><li><em>将对称矩阵合同对角化，就是求出P矩阵，可使得P^TAP=∧；</em></li><li><em>要求出P，由于讨论的是对称矩阵A，所以就是求可以使得A相似对角化的可逆矩阵P，同时必须满足P是正交矩阵</em></li><li><em>所以步骤依旧是：求出特征值，分别算出特征向量</em><ul><li>当λ1 != λ2 != λ3，则对于对称矩阵，特征向量一定两两正交</li><li>当λ1 = λ2 != λ3，α1、α2都与α3正交，但α1与α2不正交。这时需要假定其中一个不动，再平面上组合取一个与其正交的特征向量即可【只有同一个特征值对应的几个特征向量才能互相组合，组合后还是特征向量】</li><li>当λ1 = λ2 = λ3，不会考这种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132034395.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132051582.png" alt="image.png"></li></ul></li></ol><blockquote><p><em>例题1</em><br><em>单位化和正交化</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132158933.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132158918.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132159244.png" alt="image.png"></p></blockquote><h1 id="10-二次型及其标准型"><a href="#10-二次型及其标准型" class="headerlink" title="10-二次型及其标准型"></a>10-二次型及其标准型</h1><h2 id="二次型及其系数矩阵"><a href="#二次型及其系数矩阵" class="headerlink" title="二次型及其系数矩阵"></a><em>二次型及其系数矩阵</em></h2><ul><li><em>系数矩阵要求是对称矩阵</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141016752.png" alt="image.png"></li></ul><h2 id="正交变换化二次型为标准型"><a href="#正交变换化二次型为标准型" class="headerlink" title="正交变换化二次型为标准型"></a><em>正交变换化二次型为标准型</em></h2><ul><li><em>二次型的系数矩阵是对称矩阵，二次型的标准型是只有平方项，也就是说，标准型是对角矩阵</em></li><li><em>要化系数矩阵A为标准型的矩阵∧，就是进行对角化</em></li><li><em>这种题目一般是要求一个<strong>正交变换</strong>，使得系数矩阵能够化为标准型</em></li><li><em>首先要知道，任何一个二次型,都可以用矩阵方式表示X^T A X  </em></li><li><strong>*正交变换</strong>，是指存在一个正交矩阵P,进行x=Py的线性变化使得系数矩阵化为标准型*</li><li><em>要求这个正交变换，实质就是进行相似对角化，求特征值，得出特征向量，写出P,正交化，单位化，这个P就是正交变换</em></li><li><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141052467.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141029622.png" alt="image.png"></p><h2 id="配方法化二次型为标准型"><a href="#配方法化二次型为标准型" class="headerlink" title="配方法化二次型为标准型"></a><em>配方法化二次型为标准型</em></h2><p><em>配出来的P矩阵要验证是否可逆，不需要P是单位阵，也不需要是正交矩阵，只需要可逆即可，因为这没有利用相似化做</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141058649.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141059748.png" alt="image.png"></p><blockquote><p><em>例题1</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141129771.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141140917.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141140862.png" alt="image.png"></p></blockquote><h2 id="规范型"><a href="#规范型" class="headerlink" title="规范型"></a><em>规范型</em></h2><p><em>规范型，就是标准型，系数都为1，只保留符号正负</em><br><em>由于标准型系数五花八门，标准不统一，所以化为规范型，好阅卷</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141145399.png" alt="image.png"></p><h2 id="二次型的正定性"><a href="#二次型的正定性" class="headerlink" title="二次型的正定性"></a><em>二次型的正定性</em></h2><p><em>判断一个对称矩阵是否正定：</em></p><ol><li>正交变换法化为标准型，看得到标准型矩阵，对角线的特征值是否都&gt;0</li><li>配方法化标准型，看得到的标准型矩阵，对角线的数是否都&gt;0</li><li>看正惯性指数，看是否全都是正的</li><li>看A的各阶主子式是否都为正<br><em>判断一个对称矩阵是否负定：</em></li><li>前三条与上面正好相反</li><li>看A的各阶主子式，奇数阶为负，偶数阶为正，那么就是负定<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141156228.png" alt="image.png"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141157090.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141204541.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141208397.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;01-行列式的定义与性质&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="线代" scheme="https://fqzs.netlify.app/categories/%E7%BA%BF%E4%BB%A3/"/>
    
    
  </entry>
  
  <entry>
    <title>百度网盘不限速下载</title>
    <link href="https://fqzs.netlify.app/undefined/d1267184.html"/>
    <id>https://fqzs.netlify.app/undefined/d1267184.html</id>
    <published>2023-06-18T11:35:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png" alt="image_2022-11-16_11-48-14.png"></p><h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181136945.png" alt="image.png"></p><h2 id="打开解析网站"><a href="#打开解析网站" class="headerlink" title="打开解析网站"></a>打开解析网站</h2><p><a href="https://pan.qsbaidu.com/">点击跳转解析网站</a>（<a href="https://pan.qsbaidu.com/）。">https://pan.qsbaidu.com/）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181139806.png" alt="image.png"></p><p>点击解析分享链接后跳转该界面，点击下载按钮。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181141184.png" alt="image.png"></p><p>之后跳转该界面，推荐使用NDM下载器下载。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181142387.png" alt="image.png"></p><h2 id="NDM下载及配置"><a href="#NDM下载及配置" class="headerlink" title="NDM下载及配置"></a>NDM下载及配置</h2><p>1.官网<a href="http://www.neatdownloadmanager.com/index.php/en/">下载链接</a>（<a href="http://www.neatdownloadmanager.com/index.php/en/）">http://www.neatdownloadmanager.com/index.php/en/）</a></p><ol><li>初次使用要先配置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181147528.png" alt="image.png"></li></ol><p>3.复制上述用户代理名，打开NDM点击设置，将用户代理名填入默认用户代理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181148592.png" alt="image.png"></p><p>4.配置好后，点击新建，将之前的下载链接复制粘贴下载即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181150249.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png&quot; alt=&quot;image_2022-11-16_11-48-14.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
    <category term="百度网盘" scheme="https://fqzs.netlify.app/tags/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>栈为什么从高地址往低地址分配内存</title>
    <link href="https://fqzs.netlify.app/undefined/e44ea15d.html"/>
    <id>https://fqzs.netlify.app/undefined/e44ea15d.html</id>
    <published>2023-06-14T23:19:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png" alt="image.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？</p><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>程序计数器(<code>Program Counter</code>，简称<code>PC</code>)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。</p><p>因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；</p><p>heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142320352.png" alt="image.png"></p><hr><h2 id="栈由高地址向低地址扩展的优点"><a href="#栈由高地址向低地址扩展的优点" class="headerlink" title="栈由高地址向低地址扩展的优点"></a>栈由高地址向低地址扩展的优点</h2><p><code>stack</code>从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142351623.png" alt="image.png"></p><p>并且<strong>这样设计可以使得堆和栈能够充分利用空闲的地址空间。</strong>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化</p><hr><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：x86，MIPS</li><li>主流2：自由选择：Arm（但个别指令仅支持向低）</li><li>罕见：向高地址扩展：PA-RISC，操作系统Multics</li><li>非主流：System z，栈是个链表[2]</li></ul><hr><h2 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h2><p><strong>1.栈内内存是连续分配</strong></p><pre><code>因位栈空间内存分配连续，如果给一个数组或对象分配内存，栈会优先选择还没有分配的最小的内存地址给数组，数组中的地址是从低地址到高地址依次分配。所以数组的第一个元素的起始地址就是给数组分配的最低地址</code></pre><p><strong>2.栈的栈顶指针ESP默认指向栈顶</strong></p><pre><code>对数组的访问一般都是对一个数组的起始地址进行操作，也就是说我们需要的是数组的起始地址-&gt;也就是低地址，由于栈顶指针默认指向的是栈顶元素，那么只能是栈顶指针指向低地址值--&gt;这样便于对数组的访问。如果栈还是采用从低地址到高地址的扩展，那么就不会默认指向数组的起始地址(数组指针)，不便于访问。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>LaTaX语言</title>
    <link href="https://fqzs.netlify.app/undefined/31c326ac.html"/>
    <id>https://fqzs.netlify.app/undefined/31c326ac.html</id>
    <published>2023-06-12T16:19:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png" alt="image.png"></p><p><code>1.求和表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;n=0&#125;^&#123;\infty&#125;n$$</span><br><span class="line"></span><br><span class="line">其中，\sum表示求和符号，n表示要累加的变量，0表示起始索引，\infty表示末尾索引。所以，上述表达式表示了从0开始到正无穷的所有整数之和。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}n</script><hr><p><code>2.积分表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\int_&#123;-\pi&#125;^&#123;\pi&#125;f(x)dx$$</span><br><span class="line"></span><br><span class="line">其中，$\int$ 表示积分符号，$f(x)$ 表示要积分的函数，$dx$ 表示积分的变量（即积分变量），$-\pi$ 和 $\pi$ 分别表示积分的下限和上限。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(x)dx</script><hr><p><code>3.分式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;a&#125;&#123;b&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$a$ 表示分子，$b$ 表示分母。它表示了 $a$ 与 $b$ 之间的比率关系，也可以理解为 $a$ 中包含了 $b$ 的多少倍。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\frac{a}{b}</script><hr><p><code>4.下标</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$a_i$$</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$$x_&#123;i,j&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$i$ 和 $j$ 是变量的下标，它们用于表示该变量的某个特定元素。在第一个例子中，$a$ 中的 $i$ 表示 $a$ 数组中的第 $i$ 个元素；在第二个例子中，$x$ 中的 $i$ 和 $j$ 分别表示一个二维数组 $x$ 中的第 $i$ 行第 $j$ 列的元素。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">a_i</script><script type="math/tex; mode=display">x_{i,j}</script><hr><p><code>5.向量</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$\vec&#123;v&#125;$ 表示向量，“$$\begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$” 表示以列的形式表示的向量，$v_1$、$v_2$、$\ldots$、$v_n$ 是向量中的元素。如果向量是一个二维向量，那么它还可以写成如下形式：</span><br><span class="line"></span><br><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; x \\ y \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$x$ 和 $y$ 分别是二维向量 $\vec&#123;v&#125;$ 的 $x$ 和 $y$ 分量</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n\end{pmatrix}</script><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}</script><hr><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号``，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\&#123; \&#125;</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum<em>{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A</em>{k<em>0}A</em>{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li><li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li><li>矩阵，符号：<script type="math/tex">\left[ \begin{array}{ccc} 1 & 0 & 0\\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{array} \right]</script><br>$\left[ \begin{array}{ccc} 1 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right]$<br>$\left[ \begin{array}{ccc} a &amp; b \ c &amp; d \end{array} \right]^{-1}$= $\left[ \begin{array}{ccc} d &amp; -b \ -c &amp; a \end{array} \right]$<br>$\left[ \begin{array}{ccc} 1 &amp; 1 &amp; 0\ 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 \end{array} \right]$ · $\left[ \begin{array}{ccc} x1\ x2\ x3 \end{array} \right]$ = $\left[ \begin{array}{ccc} 2\ 0\ 0 \end{array} \right]$ ——&gt; $\left[ \begin{array}{ccc} 1 &amp; 1 &amp; 0 &amp; 2\ 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 \end{array} \right]$<br>$\ α = \begin{pmatrix} a_1 \ a_2 \ a_3 \end{pmatrix}$   $\ β = \begin{pmatrix} b_1 \ b_2 \ b_3 \end{pmatrix}$ </li></ol><p>A=αβ<sup>T</sup>=$\  \begin{pmatrix} a_1 \ a_2 \ a_3 \end{pmatrix}$  $\ \begin{pmatrix} b_1 &amp;b_2&amp;  b_3 \end{pmatrix}$ =  $\ \begin{pmatrix} a_1b_1&amp;a_1b_2&amp;a_1b_3 \ a_2b_1&amp;a_2b_2&amp;a_2b_3 \ a_3b_1&amp;a_3b_2&amp;a_3b_3\end{pmatrix}$</p><p>所以r(A)=1，对角线元素之和 <em>l</em> = a<sub>1</sub>b<sub>1</sub>+a<sub>2</sub>b<sub>2</sub>+a<sub>3</sub>b<sub>3</sub>= 向量内积  α<sup>T</sup>β</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li><li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.求和表达式&lt;/code&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="LaTax" scheme="https://fqzs.netlify.app/categories/LaTax/"/>
    
    
  </entry>
  
  <entry>
    <title>多地址指令实际访存次数</title>
    <link href="https://fqzs.netlify.app/undefined/7566551b.html"/>
    <id>https://fqzs.netlify.app/undefined/7566551b.html</id>
    <published>2023-06-10T10:44:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png" alt="image.png"></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;指令&quot;&gt;&lt;a href=&quot;#指令&quot; c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>english</title>
    <link href="https://fqzs.netlify.app/undefined/2c830200.html"/>
    <id>https://fqzs.netlify.app/undefined/2c830200.html</id>
    <published>2023-06-08T11:44:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png" alt="image.png"></p><h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a><strong>定语</strong></h2><p><em>hypocritical虚伪的、spectacle壮观的场面、intense激烈的、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a><strong>状语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a><strong>同位语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a><strong>插入语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p><h1 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conmence 毕业典礼、开始</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162327530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162328895.png" alt="image.png"></p><h2 id="句子之间的连接方式"><a href="#句子之间的连接方式" class="headerlink" title="句子之间的连接方式"></a>句子之间的连接方式</h2><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162329883.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162349412.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306170009789.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162352377.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162354284.png" alt="image.png"></p><h3 id="主从复合句"><a href="#主从复合句" class="headerlink" title="主从复合句"></a>主从复合句</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207495.png" alt="image.png"></p><h4 id="状语从句-副词性从句"><a href="#状语从句-副词性从句" class="headerlink" title="状语从句(副词性从句)"></a>状语从句(副词性从句)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207245.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181217682.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.It doesn&#x27;t feel like a human or democratic relationship,even if both sides</span><br><span class="line">benefit.</span><br><span class="line">即使双方都受益，也不是人与人之间平等的关系</span><br><span class="line"></span><br><span class="line">2.As the cost to everyone else has become clearer,politicians have begun to</span><br><span class="line">clamp down.</span><br><span class="line">因为每个人所承受的代价变得显而易见了，政客们已经开始施压了</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181225896.png" alt="image.png"></p><h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><h5 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">That the seas are being over fished has been known for years--&gt;主语从句</span><br><span class="line"></span><br><span class="line">--&gt;一般会改写为形式主语--&gt; it has been knows for years that...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181304536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181305134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181306845.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181312445.png" alt="image.png"></p><h5 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181441584.png" alt="image.png"></p><h5 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181444199.png" alt="image.png"></p><h5 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181449900.png" alt="image.png"></p><h5 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181601408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181608655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181612050.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181613273.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181619664.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181620104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181625756.png" alt="image.png"></p><h1 id="层次化阅读和主干隔离"><a href="#层次化阅读和主干隔离" class="headerlink" title="层次化阅读和主干隔离"></a>层次化阅读和主干隔离</h1><h2 id="层次化阅读法"><a href="#层次化阅读法" class="headerlink" title="层次化阅读法"></a>层次化阅读法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052224384.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042239593.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042240478.png" alt="image.png"></p><p><em>substance 物质  、clinical nutirtion 临床营养学 、utilize 利用 、distinct 明显的、essential 必要的 、agent 介质、constituent 组成部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042245516.png" alt="image.png"></p><h2 id="主干隔离法"><a href="#主干隔离法" class="headerlink" title="主干隔离法"></a>主干隔离法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052225973.png" alt="image.png"></p><blockquote><p><em>将主语与谓语连在一起读，中间部分调整语序</em></p></blockquote><p>*artisans 工匠、artists 艺术家、machanic 技工、establishment 机构、组织</p><p>The notion - 这个观念、这个想法</p><p>that learning should have in it an element of inspired play - 观念认为学习应该融入受启发的游戏元素</p><p>would seem - 似乎</p><p>to the greater part of the academic establishment - 对大部分有学术性的机构或组织(如学校、大学等)</p><p>merely silly - 只是一个愚蠢的想法*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052227844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052229938.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052236404.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052237748.png" alt="image.png"></p><h1 id="非谓语动词和独立主格结构"><a href="#非谓语动词和独立主格结构" class="headerlink" title="非谓语动词和独立主格结构"></a>非谓语动词和独立主格结构</h1><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060933764.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060942180.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060946157.png" alt="image.png"></p><h2 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h2><p><em>带有主语的非谓语动词</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060953217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060956043.png" alt="image.png"><br><em>Media 媒体 、epidemic 流行病、cigarette 香烟、liken 比作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061003195.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061007239.png" alt="image.png"></p><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061012037.png" alt="image.png"></p><blockquote><p><em>部分倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061019182.png" alt="image.png"></p><blockquote><p><em>完全倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061023671.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061046014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061049074.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061050328.png" alt="image.png"></p><h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061056945.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061107064.png" alt="image.png"></p><p><em>individual 个体 、maximaize 最大化、profits利润、coupled with 以及(相等于and)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061121649.png" alt="image.png"></p><h1 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061131321.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061130607.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061140766.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061141718.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061142254.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061148829.png" alt="image.png"></p><h1 id="实战解析"><a href="#实战解析" class="headerlink" title="实战解析"></a>实战解析</h1><p><em>cognitive认知 、caregiver看护者</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061158889.png" alt="image.png"></p><p><em>imposter 冒牌者   、file(ing) cabinet  文件柜、 fraught 充满 、reconcile 调和、和解 、<br>designate 指定、指派(职务)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071032339.png" alt="image.png"></p><p><em>overwhelming 巨大到无法应付的。指某事物之多、之严重以至于无法有效应对。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071556623.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071614505.png" alt="image.png"></p><p><em>Come to a halt的含义是停止;停顿下来。<br>它表示某物停止了运动或工作。强调运动或行为的终止。<br>例句:<br>The car came to a sudden halt.<br>那辆车突然停了下来 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071621176.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071625167.png" alt="image.png"></p><p><em>quantum computers 量子计算机 、crack 破解、encryption加密</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071639372.png" alt="image.png"></p><p><em>mutually 互相、composed of 由..组成  、composed 镇定的，有条理的、simulate模拟<br>interactions 相互影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071727387.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071728023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071804873.png" alt="image.png"></p><hr><blockquote><p>!!!</p></blockquote><p>proportion 的意思是:</p><p>比例,部分,成比例</p><ol><li>proportion 指在整体中所占的百分比或比例。例如:</li></ol><ul><li><p>What proportion of your income do you spend on rent? 你的收入中有多大比例用于支付房租?</p></li><li><p>Only a small proportion of applicants are admitted to this school. 只有一小部分申请者能被这所学校录取。</p></li></ul><ol><li>proportion 也可以表示一个量与另一个量之间的比较关系,指成比例。例如:</li></ol><ul><li><p>Mix the ingredients in the proper proportion. 按正确的比例混合这些材料。</p></li><li><p>The model was built in exact proportion to the original building. 这个模型按原建筑的精确比例建造的。</p></li></ul><ol><li>proportion 还可以指大小、范围或重要性的程度。例如:</li></ol><ul><li><p>The cost overrun was of massive proportion. 造价超支的规模巨大。</p></li><li><p>An issue of such proportion requires careful thought. 这么重大的问题需要慎重考虑。</p></li></ul><p><strong>literacy 的意思是:</strong></p><p>识字能力,读写能力</p><p>literacy 指一个人阅读和写作的基本能力,特别是在 mother tongue(母语)中的读写能力。</p><p>一些关于literacy的例子:</p><ul><li><p>Improving literacy is a priority, as it helps break the cycle of poverty. 提高识字率是优先事项,这有助于打破贫困循环。</p></li><li><p>The government has launched a campaign to boost literacy among adults. 政府启动了一个运动来提高成人的读写能力。</p></li><li><p>Children’s literacy skills develop through reading books and stories. 儿童的读写能力通过读书和故事得到发展。</p></li><li><p>Digital literacy is increasingly important in the internet age. 在互联网时代,数字读写能力越来越重要。</p></li><li><p>Functional literacy refers to the basic skills needed to function in society. 功能性识字能力是指一个人在社会中基本需求的读写能力。</p></li></ul><p><em>institution 机构、制度、组织  ， soild 坚固的、扎实的、牢固的，souvenir 纪念品<br>quill 鹅毛笔</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091525945.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>fitigue 的意思是疲劳,疲惫。</p><p>它是一个来自法语的英语词汇,常见的用法有:</p><ol><li><p>身体上的疲劳,疲惫 例句:After a long run, I felt fatigue in my legs. 长时间跑步后,我腿感到了疲劳。</p></li><li><p>精神上的疲惫 例句:Mental fatigue built up after hours of study. 坐了几个小时后精神上感到了疲惫。</p></li><li><p>金属疲劳 例句:The metal wing suffered fatigue after many flights. 金属机翼在多次飞行后出现了金属疲劳。</p></li><li><p>造成疲劳的因素或过程 例句:Sleep deprivation leads to increased fatigue. 睡眠不足会导致疲劳加剧。</p></li></ol><p>poll 有以下几层常见意思:</p><ol><li>民意调查;选举投票</li></ol><p>例句:The latest polls show he has a slim lead over his opponent. 最新民调显示他比对手略占优势。</p><ol><li>票数;票汇总</li></ol><p>例句:After the polls closed, vote counting began immediately. 在投票结束后,票票汇总工作立即开始。</p><ol><li>投票站;选区</li></ol><p>例句:There were long lines at the polls this morning. 今天早晨投票站前有长长的队伍。</p><ol><li>票选,投票</li></ol><p>例句:About 60% of voters polled today. 大约有60%的选民今天参与了投票。</p><ol><li>统计,调查</li></ol><p>例句:Let’s take a poll of everyone’s opinion on this matter. 让我们统计一下每个人对这个问题的看法。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152210940.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217622.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217842.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>acknowledge 的意思是:</p><ol><li>承认,认可</li></ol><p>例句:He acknowledged that he had made a mistake. 他承认了自己犯了一个错误。</p><ol><li>感谢,表达谢意</li></ol><p>例句:I acknowledge all the staff for their hard work. 我对全体员工的辛勤工作表示感谢。</p><ol><li>回复,对…作出响应</li></ol><p>例句:She acknowledged my email with a quick reply. 她很快回复了我的电子邮件。</p><ol><li>收到,收悉</li></ol><p>例句:Please acknowledge receipt of this document. 收到此文件请回执。</p><p><em>cut adrift 被抛弃、sector行业，领域、self-critical自我批判、landlord房东</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152225925.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>dynamic 的常见意思有:</p><ol><li>动态的,不断变化的</li></ol><p>例句:a dynamic economy 动态变化的经济</p><ol><li>积极有活力的</li></ol><p>例句:a dynamic young leader 一个精力充沛的年轻领导者</p><ol><li>(音量)强弱变化的</li></ol><p>例句:the dynamic range of the music 音乐的动态范围</p><ol><li>(力学术语)动力学的</li></ol><p>例句:dynamic equilibrium 动态平衡</p><ol><li>动力的,与动力相关的</li></ol><p>例句:a dynamic microphone 动力麦克风</p><p>所以,dynamic的意思是“动态的、变化的”,强调不断变化和活力,与“static”相对。可以广泛地应用于许多领域</p><p><em>publishing industry出版行业</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161009103.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>casino 是赌场的意思。</p><p>例句:</p><ol><li><p>There are many large casinos in Las Vegas. 拉斯维加斯有许多大型赌场。</p></li><li><p>He lost a lot of money gambling in the casino. 他在赌场赌博损失了很多钱。</p></li><li><p>The new casino brought in tourism revenue for the city. 新的赌场为这座城市带来了旅游收入。</p></li><li><p>She always plays blackjack when she visits casinos. 她每次去赌场都会玩二十一点。</p></li><li><p>The casino was open 24 hours and full of slot machines. 这个赌场24小时营业,里面满是老虎机。</p></li></ol><p>综上所述,casino 代表赌场这个场所,里面有各种赌博游戏,例如扑克、轮盘、老虎机等。赌场主要为赌博提供场所,通常还有酒店、餐厅、商场等设施和娱乐活动。</p><hr><p>gambling 的意思是赌博、赌钱。</p><p>常见的词义包括:</p><ol><li><p>赌博活动 例句:Gambling is illegal in some countries. 在一些国家赌博是非法的。</p></li><li><p>赌钱 例句:Many people lose a lot of money through gambling. 很多人通过赌博损失了大量金钱。</p></li><li><p>冒险 例句:Changing jobs now would be a gamble. 现在换工作将是一次冒险。</p></li><li><p>对…抱有希望 例句:I’m gambling that the weather will be nice tomorrow. 我抱着明天天气会好的希望。</p></li><li><p>孜孜不倦地追求 例句:He is gambling for fame and reputation. 他孜孜不倦地追求名誉和声望。</p></li></ol><p>综上所述,gambling 意思是赌博、赌钱,通常涉及金钱的风险投机。延伸意思是冒险以及抱有希望。</p><hr><p>coasting on 意思是“依靠,利用(之前的成就或努力)”。</p><p>这是一个常见的英语习语,意思是指一个人或组织停止努力,而是依靠或利用过去的成就和努力来维持当前的状态或成功。</p><p>例句:</p><ol><li><p>After the company’s initial success, the CEO has just been coasting on its reputation rather than innovating. 在公司最初成功之后,CEO一直依靠其声誉,而不是创新。</p></li><li><p>The actor admitted to coasting on his previous roles and hasn’t taken up new challenges lately. 这位演员承认自己近期沿用老角色,没有接受新挑战。</p></li><li><p>The professor seems to be coasting on her book’s popularity rather than producing new research. 这位教授似乎依靠她书籍的畅销,而不是进一步研究。</p></li><li><p>Successful entrepreneurs cannot afford to coast on past achievements. 成功的企业家不能依赖过去的成就。</p></li></ol><p>综上所述,coasting on 意味着依靠过去努力的成果,而不是继续付出努力。通常有负面的含义,意味着一个人或组织变得自满和懒惰。</p><hr><p>pan out 是一个英语习语,意思是“结果变成,发展成”。</p><p>例句:</p><ol><li><p>His business idea didn’t pan out as he had hoped. 他的商业想法结果没有如他所愿。</p></li><li><p>We’re still waiting to see how this new project pans out. 我们仍在观望这个新项目的发展。</p></li><li><p>I don’t think this relationship is going to pan out after all. 我认为这段关系结果不会太理想。</p></li><li><p>If their date pans out, they might start a relationship. 如果他们的约会进展顺利,他们可能会开始一段关系。</p></li><li><p>His career as a musician never really panned out. 他作为音乐家的职业生涯结果并不成功。</p></li></ol><p>综上所述,pan out 意思是经过发展或等待结果后,事情的结果最后如何,是否成功或达到预期。也可以表示事情最终结果的好坏。</p><p><em>enormous revenues 意思是“巨大的收入”或“极高的营收”、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161019158.png" alt="image.png"><br><em>big advance 巨额预付金、preexisting先前存在的、frenzy狂热、疯狂失控</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161025712.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>contexts 是名词,复数形式,主要有以下几层含义:</p><ol><li>文章或谈话中的语言环境,提供理解词语或行为的额外信息。<br>例句:You can’t understand what he meant without looking at the wider context of the conversation. 如果不考虑谈话的更广泛语境,你就无法理解他的意思。</li><li>事件或行为发生的背景情况。<br>例句:In the context of high unemployment, the policy makes sense. 在高失业率的背景下,这项政策有意义。</li><li>程序运行或操作的环境。<br>例句:This function behaves differently depending on the software context. 这个功能的运行取决于软件环境的不同而有区别。</li><li>论证或思考的前提条件或框架。<br>例句:Examine the problem in the context of the limitations we face. 在我们面临的限制条件下审视这个问题。</li></ol><hr><p>constraining 的意思是“限制的、约束的”。它来源于动词constrain,意为“限制、抑制”。</p><p>constraining 作为形容词,常用于以下场合:</p><ol><li>限制行为或活动的规则或条件。</li></ol><p>例句:The new policy imposes constraining regulations on business. 新政策对企业施加了限制性规定。</p><ol><li>限制思维或创造力的框架或因素。</li></ol><p>例句:We need to think outside constraining traditional paradigms. 我们需要跳出限制思维的传统模式。</p><ol><li>限制行动或发展的不利环境或因素。</li></ol><p>例句:Poverty is a constraining factor that traps people in disadvantage. 贫穷是一个制约因素,让人们无法摆脱劣势。</p><ol><li>紧缚的、禁锢的衣物或配饰。</li></ol><p>例句:She refused to wear constraining clothes that restricted her movement. 她拒绝穿会限制行动的紧身衣服。</p><hr><p>pertaining 的意思是“关于”,“与…有关”。它是一个正式用语,通常用于描述某人或某事与特定主题、事件或情况有关。</p><p>例句:</p><ol><li><p>All documents pertaining to the legal case must be submitted to the court. 所有与此法律案件有关的文件都必须提交给法院。</p></li><li><p>The police asked questions pertaining to the accident. 警察问了一些关于这起事故的问题。</p></li><li><p>The manager sent a memo pertaining to the new company policy. 经理发了一则与新公司政策相关的备忘录。</p></li><li><p>The museum has a collection of artifacts pertaining to ancient Egypt. 博物馆有一个关于古埃及的藏品收集。</p></li><li><p>I need some advice pertaining to filing my taxes this year. 我需要一些建议,关于今年报税的事宜。</p></li></ol><hr><p>labor 的意思是“劳动,劳力”。它是一个常用词,主要有以下几层含义:</p><ol><li>工作,尤其是体力劳动。</li></ol><p>例句:Farming is hard labor. 农活是体力劳动。</p><ol><li>工人阶级,劳动者。</li></ol><p>例句:The new policy protects the rights of labor. 这项新政策保护劳动者的权益。</p><ol><li>分娩的努力和痛苦,即生产过程。</li></ol><p>例句:The mother was in labor for 10 hours. 这位母亲经历了10小时的分娩过程。</p><ol><li>工作结果,劳动成果。</li></ol><p>例句:The Pyramids are an amazing labor of ancient Egyptians. 金字塔是古埃及人惊人的劳动成果。</p><ol><li>具有特定功能的工作或任务。</li></ol><p>例句:Every part has its own labor in the workings of a machine. 在机器运转中,每个部件都有其特定的功能。</p><p><em>curtail 削弱、缩短、限制、 seek 寻找、pursue追求、 oppressive压迫的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161034961.png" alt="image.png"></p><p><em>vaccine 疫苗、corporate regulation企业监管、 labor劳工、劳动力、civil民事的、公民的 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161043329.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>extract 的意思是“提取;摘录”,是个常用词,主要有以下几层含义:</p><ol><li>从某物中提取或分离出某个成分、物质等。</li></ol><p>例句:extract oil from coal 从煤中提取油</p><ol><li>摘录,选取某文献中的段落或内容。</li></ol><p>例句:extract key passages from the book 从书中摘录主要段落</p><ol><li>获取、套取(信息等)。</li></ol><p>例句:extract a confession from him 从他那里套取口供</p><ol><li>引出,推断出(结论等)。</li></ol><p>例句:extract meaning from the data 从数据中推断出意义</p><ol><li>移去,拔出(牙齿等)。</li></ol><p>例句:The dentist extracted two teeth. 牙医拔除了两颗牙。</p><p>所以,extract 的基本意思是从某物中提取出某部分或物质;也可以指获取一些隐藏或不容易觉察的信息。</p><hr><p>vantage</p><ol><li>有利条件,优势。</li></ol><p>例句:a good vantage point to watch birds 观察鸟类的有利位置</p><ol><li>视野,视力范围。</li></ol><p>例句:Beyond my vantage, I could see the lake. 在我的视野范围之外,我可以看到湖泊。</p><ol><li>预见,预知。</li></ol><p>例句:He plans with vantage for the future. 他预见未来做计划。</p><ol><li>利益,好处。</li></ol><p>例句:I have no personal vantage in this. 这对我没有任何个人利益。</p><hr><p><em>scramble 的基本意思是匆忙或火急火燎的样子、crucial至关重要的、fossil fuels化石燃料、 tear up 撕碎的弄破的、plants植物、工厂、设备、 rural农村的、urban城市的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161330773.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331524.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>dwell 停留、居住、 atmosphere大气、气氛、环境、plain平坦的、平淡的、 dull迟钝的、无聊的·、 version版本 、notification通知、通告、storm风暴</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422007.png" alt="image.png"><br>￼<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422229.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>critics 评论家、 stand as is 保持原样、penguin企鹅</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432549.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432535.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>reframe 的意思是“重新塑造,重构”,reframe 是由前缀 re- (再次)和 frame(框架)组合而成的词。</p><p>reframe 作为动词,主要有以下含义:</p><ol><li>重新组织,调整结构或框架。</li></ol><p>例句:We need to reframe our business strategy. 我们需要重新组织我们的商业战略。</p><ol><li>以新的观点或角度重新审视。</li></ol><p>例句:Let’s reframe this issue in a more positive light. 让我们以更正面的视角来重新审视这个问题。</p><ol><li>重新描绘,重述。</li></ol><p>例句:He reframed his experiences more constructively. 他以更建设的方式重述了他的经历。</p><ol><li>调整态度,换种思维方式。</li></ol><p>例句:Reframing problems as opportunities. 将问题重塑为机遇。</p><p>所以,reframe 意思是把事情放在一个新的框架或视角中进行重新思考,以产生新的结构、见解或态度。</p><hr><p>spectrum 的意思是“范围, 光谱”。主要有以下几层含义:</p><ol><li>范围,系列,一系列邻接的事物。</li></ol><p>例句:There is a wide spectrum of opinions on the issue. 这个问题有广泛的观点范围。</p><ol><li>光谱,按波长顺序排列的电磁波颜色范围。</li></ol><p>例句:Sunlight contains all the wavelengths of the visible light spectrum. 阳光包含了可见光谱中所有的波长。</p><ol><li>分类,按顺序或级别排列的系统。</li></ol><p>例句:the whole political spectrum from left to right 政治光谱上的全部派别</p><ol><li>范围,多种选择或可能性。</li></ol><p>例句:We offer a spectrum of investment options. 我们提供一系列投资选择。</p><ol><li>范畴,领域。</li></ol><p>例句:The issue falls outside the spectrum of this committee. 这个问题超出了委员会的范畴。</p><p><em>beaming面带灿烂笑容、scrolling 滚动、浏览</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161442818.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>physician 的意思是“医生”,尤其是指正式的医学执业医师。</p><p>一些关键点:</p><ol><li><p>physician 指经过长时间医学训练和执业资格认证的医生。</p></li><li><p>它与 doctor 的含义基本相同,但physician 表示更专业和正式的医生身份。</p></li><li><p>physician 通常需要接受8年以上的医学院教育和临床实习。</p></li><li><p>主治医生(attending physician)和内科医生(physician)是两种常见的physician。</p></li><li><p>physician可以自主开业,也可以在医院、诊所、学术机构等工作。</p></li><li><p>与physician对应的是医疗助理职业,如护士、技师等。</p></li><li><p>按专业领域又可细分为儿科医生、外科医生、心理医生等。</p></li><li><p>口语中更常用doctor,但是正式场合仍使用physician。</p></li></ol><p>所以,physician指经过系统医学训练和考核,获得医生资格并执业的医疗专业人士。是医疗保健领域的核心职业之一。</p><hr><p>procedures 的意思是“程序;步骤”,表示完成某项工作或任务所需遵循的一系列步骤或流程。</p><p>些关键点:</p><ol><li><p>procedure 强调按照规定的顺序和方法来进行。</p></li><li><p>医疗程序(medical procedures)指进行疾病治疗或身体检查的标准步骤。</p></li><li><p>行政程序(administrative procedures)指在政府、公司或组织内部的官方工作流程。</p></li><li><p>程序也可以是规范某项活动的准则或方针。</p></li><li><p>程序的目的是提高工作效率、减少错误。</p></li><li><p>遵守程序意味着按照特定顺序执行每一步。</p></li><li><p>程序可能需要书面文档,以方便培训和规范操作。</p></li><li><p>如果情况失控,也可主动终止程序。</p></li><li><p>相比过程(process),程序更加规范化和固定化</p></li></ol><hr><p>strain 的意思有以下几个:</p><ol><li>拉、绷紧</li></ol><p>例句:Strain the rope tightly. 把绳子用力拉紧。</p><ol><li>扭伤;拉伤</li></ol><p>例句:I strained my back lifting those heavy boxes. 我搬动那些重箱子时扭伤了背。</p><ol><li>过度使用;损伤</li></ol><p>例句:Don’t strain your eyes watching TV in the dark. 别在暗处看电视伤眼睛。</p><ol><li>压力;负荷过重</li></ol><p>例句:The recent difficulties have put a strain on their relationship. 近来的困难给他们的关系造成了压力。</p><ol><li>过滤;过滤掉</li></ol><p>例句:Strain the noodles and run them under cold water.过滤面条并在冷水下冲洗。</p><ol><li>费力;竭力</li></ol><p>例句:She strained to hear what they were saying. 她竭力去听他们在说什么。</p><ol><li>(微生物的)菌株</li></ol><p><em>physicians 执业医师、procedures程序步骤、squeeze积压、挤出、incentivize激励</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161454669.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>are only as good as  ..的好坏取决于..  、precisely精确地· 正是、 metabolism新陈代谢<br>commerical 商业的、贸易的、盈利性质的  、variables变量   、dizzying令人头晕目眩的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161530860.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161541216.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>critical 的意思有以下几个方面:</p><ol><li>批评的;批判的</li></ol><p>例句:She has a very critical attitude toward modern art. 她对现代艺术持非常批判的态度。</p><ol><li>关键的;决定性的</li></ol><p>例句:Proper hydration is critical for athletes. 适当的水化对运动员来说非常关键。</p><ol><li>危急的;危重的</li></ol><p>例句:The patient’s condition was listed as critical after the accident. 事故后,病人的情况被列为危重。</p><ol><li>批评;批评意见</li></ol><p>例句:The film received excellent critical reviews. 这部电影获得了极好的评价。</p><ol><li>关键时刻;危急关头</li></ol><p>例句:We made it through the critical moment.我们挺过了最危急的时刻。</p><ol><li>临界;最高点</li></ol><p>例句:The reactor was close to its critical temperature.反应堆的温度接近临界点。</p><p>综上所述,critical 既可形容事物的重要性,也可表示对事物的批判分析,或描述达到极限的状态</p><hr><p>slash 的常见意思有:</p><ol><li>削减;打折</li></ol><p>例句:The store slashed prices for its end-of-season sale. 商店为季末销售大幅削减了价格。</p><ol><li>砍;割</li></ol><p>例句: He slashed through the vines with his machete. 他用大砍刀砍开藤蔓.</p><ol><li>猛砍;乱砍</li></ol><p>例句: The maniac slashed the victim repeatedly with a knife. 那个疯子用刀猛砍受害者。</p><ol><li>斜线</li></ol><p>例句: Write the date using slashes: mm/dd/yy. 用斜线表示日期:月/日/年。</p><ol><li>(在计算机字段中用于表示)一种选择或替代</li></ol><p>例句: Choose A/B/C. 选择A/B/C。</p><ol><li>(音乐样式)迷幻摇滚</li></ol><p>例句: Guns N’ Roses started as an LA slash metal band. 枪与玫瑰乐队最初是洛杉矶的卷舌摇滚乐队。</p><p>综上所述,slash 的意思与切、砍、削减、选择等相关,可以作为动词或名词使用。</p><hr><p>drilling 有以下几层含义:</p><ol><li><p>钻孔 - Drilling a hole into the wall to hang a picture. 为了挂画在墙上钻孔。</p></li><li><p>练习 - Repeatedly drilling math problems to memorize formulas. 重复训练数学题以记住公式。</p></li><li><p>军事训练 - Soldiers drilling every morning on the parade ground. 士兵每天早晨在操场进行军事训练。</p></li><li><p>疾行 - Drilling through the crowded sidewalk. 穿过拥挤的人行道疾行。</p></li><li><p>严格训斥 - The coach kept drilling the players on minor mistakes. 教练一直严厉指责球员的小错误。</p></li><li><p>开采;钻探 - An oil company is drilling for petroleum in the ocean. 石油公司在海洋钻探石油。</p></li><li><p>牙科钻孔 - The dentist will be drilling several cavities today. 今天牙医要钻几个蛀牙。</p></li></ol><p>所以,drilling 的基本意思是通过钻孔或重复性训练来获得或加强某项技能。</p><hr><p><em>methane甲烷  、 emissions排放、 drilling 钻探、maintained保持维持、dramatically显著的</em>、<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161551101.png" alt="image.png"></p><p><em>A risks B —&gt;A有可能导致B</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162306630.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>rage 的常见意思有:</p><ol><li>激怒;狂怒</li></ol><p>例句:Seeing the mess, he flew into a rage. 看到一团糟,他暴怒起来。</p><ol><li>激烈的情感;狂暴</li></ol><p>例句:a poem full of rage and passion 一首充满激愤与激情的诗歌</p><ol><li>风靡;盛行</li></ol><p>例句:A new dance craze is all the rage right now. 一个新的舞蹈热潮现在正风靡一时。</p><ol><li>激烈的争论或斗争</li></ol><p>例句:a philosophical rage 在哲学上的激烈争论</p><ol><li>精力旺盛;热情</li></ol><p>例句:Quitting smoking has filled me with a rage to live. 戒烟让我热情高涨,对生活充满了激情。</p><ol><li>暴力;激烈</li></ol><p>例句:the rage of war 战争的暴力</p><ol><li>(疾病的)流行</li></ol><p>例句:a flu rage 流感的流行</p><p>综上所述,rage 表示强烈愤怒或热情,也可指某事物的风靡或某情绪的强烈爆发。</p><hr><blockquote><p>!!!</p></blockquote><p><em>strategy战略、策略； uncovered揭露，揭示、confession坦白、忏悔、认罪</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171222257.png" alt="image.png"></p><p><em>protest抗议、抗议活动；sin罪行，罪恶；proactive积极主动地&lt;-反-&gt;passive消极的；<br>reputation名誉，声誉；massive大规模的，大量的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171327987.png" alt="image.png"></p><p><em>approach方法；statement声明</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171329142.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>consolidation 的意思是“巩固,加强”。它的常见含义有:</p><ol><li>巩固,加强已获得的地位或者优势。</li></ol><p>例句:The company is seeking to consolidate its dominant position in the market. 该公司正寻求巩固其在市场的主导地位。</p><ol><li>合并,将多个事物整合在一起。</li></ol><p>例句:There was a wave of consolidation among major banks. 主要银行进行了一波合并潮。</p><ol><li>使更加稳固、坚实。</li></ol><p>例句:The new evidence helped consolidate the argument. 新的证据帮助加强了这个论点。</p><ol><li>统一,整合(权力、资源等)。</li></ol><p>例句:The king consolidated his rule over the empire. 国王统一了他对帝国的统治。</p><ol><li>使(知识等)牢固。</li></ol><p>例句:We need to consolidate what we learned in class today. 我们需要巩固今天课堂上学到的知识。</p><ol><li>合并(财务账目等)。</li></ol><p>例句:All the subsidiaries report to HQ for financial consolidation. 所有子公司汇报给总部进行财务合并。</p><hr><p><em>trade-off 取舍、权衡 ；consolidation合并，加强；instance实例，情况</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171333756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171338448.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171343874.png" alt="image.png"></p><p><em>appropriate恰当的，适当的； collective集体的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171345209.png" alt="image.png"></p><hr><p>quo 的常见意思有:</p><ol><li>status quo</li></ol><p>这个词组表示“现状,原状”。</p><p>例句:We cannot continue with the status quo. We need changes. 我们不能维持现状。我们需要改变。</p><ol><li>pro quo</li></ol><p>这个词组表示“交换,回报”。</p><p>例句:Quid pro quo refers to an exchange of goods or services. Quid pro quo 指商品或服务的交换。</p><hr><p><em>is anything but simple不是容易的；pre-pandemic前疫情的  </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171348681.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>episode 的常见意思有:</p><ol><li>事件,故事的一个章节或阶段</li></ol><p>例句:The latest episode of the drama was very moving. 这部电视剧的最新一集非常动人。</p><ol><li>一段经历,一个阶段</li></ol><p>例句:That was an unfortunate episode in my life. 那是我一生中一段不幸的经历。</p><ol><li>发作,发病</li></ol><p>例句:The patient had a sudden episode of chest pain. 这个病人突然胸痛发作。</p><ol><li>一集电视节目</li></ol><p>例句:I missed the first episode of this TV series. 我错过了这个电视剧的第一集。</p><ol><li>情节中的一个片段</li></ol><p>例句:There are several funny episodes in the movie. 这部电影有几个搞笑的片段。</p><ol><li>事件,事变</li></ol><p>例句:The bombing was just one episode in the long conflict. 这次轰炸只是长期冲突中的一个事件。</p><p>所以,episode 指故事、事件发展中的一个阶段或段落,也可以指电视节目中的一集、或病人的一场发作。</p><hr><p>count 的常见意思有:</p><ol><li>计算;数数</li></ol><p>例句:Let me count the coins in my pocket. 让我数数口袋里的硬币。</p><ol><li>计数;计数值</li></ol><p>例句:What was the final count of votes? 最后的投票计数是多少?</p><ol><li>计数单位;数目</li></ol><p>例句:A vast count of stars are visible in the night sky. 夜空中可见无数的星星。</p><ol><li>重要;有影响力</li></ol><p>例句:Your opinion counts. 你的观点很重要。</p><ol><li>认为;视为</li></ol><p>例句:She counted him as one of her closest friends. 她视他为自己最亲密的朋友之一。</p><ol><li>依靠;信赖</li></ol><p>例句:You can always count on him for help. 对于寻求帮助你总能依靠他。</p><ol><li>控诉;指控</li></ol><p>例句:He was accused on five counts of fraud. 他被控五项诈骗罪。</p><ol><li>回数;节拍</li></ol><p>例句:The dancer kept perfect count throughout the performance. 舞者在整场表演中拍子始终正确。</p><hr><p><em>privileged有特权的；implicitly隐含的，默认的；class阶级；administration行政部门，政府机构；rescue营救，解救，脱困；uninsured没有保险的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171402709.png" alt="image.png"></p><p><em>crisis危机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171411443.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>just as significantly同样重要的是；industry行业； precedent先例</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171425766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171429332.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>contrast with与…形成对比 ；stark明显的，极端，荒凉;  elementary基础性的；element 元素，成分，要素</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171450834.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171458497.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>systematically 的意思是“有系统地”,是个副词。其含义是:</p><ol><li>按照系统或方法进行</li></ol><p>例句:We need to systematically analyze all the data. 我们需要系统地分析所有数据。</p><ol><li>有条理地,有步骤地</li></ol><p>例句:He systematically went through all the possible solutions. 他有条不紊地检查了所有可能的解决方案。</p><ol><li>有计划地,有组织地</li></ol><p>例句: The manager systematically arranged all the tasks. 经理有组织地安排了所有任务。</p><ol><li>从根本上,彻底地</li></ol><p>例句: We must systematically change how things are done. 我们必须从根本上改变做事的方式。</p><ol><li>不断重复地,习以为常地</li></ol><p>例句: She was systematically abused by her partner. 她不断遭到伴侣的虐待。</p><p>综上,systematically 意思是按照预定的系统、计划或方法进行,做事有条理和组织,而不是碎片化和随意进行。</p><hr><p><em>bias偏见,偏心，倾斜；pernicious有害的，具有负面破坏性的；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171503468.png" alt="image.png"></p><p><em>strikes 击中，罢工，罢课；health care 医疗保健；pension退休金，养老金<br>median中位数，中线，中间值；household家庭，户，住户</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171558168.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>endure忍受；agency机构；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171614940.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>essence 的意思是:</p><ol><li>本质;实质;真谛<br>例句:The essence of his argument is that we need to focus on education. 他论点的真谛是我们需要关注教育。</li><li>精华;精髓;灵魂<br>例句:She has captured the essence of the book in her summary. 她在摘要中抓住了这本书的精髓。</li><li>(植物、化学品等的)香精;香料;香气<br>例句:This perfume contains floral essences. 这种香水含有花香精华。</li></ol><p>essential 的意思是:</p><ol><li>基本的;本质的;必不可少的<br>例句:Water is essential to human life. 水对人类生命至关重要。</li><li>不可或缺的;必需的<br>例句:An engineer needs an essential understanding of math. 工程师需要必不可少的数学知识。</li><li>香精;香精油</li></ol><hr><p><em>race种族；admission 接纳，录取；essential基本的，本质的；recrut招聘，征招 ；surrogates替代品；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171638065.png" alt="image.png"></p><h1 id="阅读强化"><a href="#阅读强化" class="headerlink" title="阅读强化"></a>阅读强化</h1><h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p><em><code>词汇体现观点</code></em></p><p><em>词汇体现观点、态度<br>stand in favor of sth 支持某事<br>Unfavorable 不支持<br>Lame 跛脚的<br>Ignore 忽视<br>Ignorant 无知的<br>sustainable 可持续的  sustain持续，连续不断<br>alleviate 缓解<br>aggravate 恶化<br>Lost 失去</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181112122.png" alt="image.png"><br><em>the Federal Court 联邦法院 、annually每年的、 is overturned 被推翻、<br>the supreme court 最高法院、 profit利润</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181117962.png" alt="image.png"></p><hr><p><em><code>如何寻找文章的中心对象？</code></em></p><p><em>题目一定是围绕中心对象展开—&gt;所以，找题目中心对象</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181126215.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181127934.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>rail 铁路、fare票价，车票、nationalizaion 国有化、revenue收入、ever-rising</em><br><em>ever-rising 在句子中的意思是“不断上升的;持续增长的”。它由ever和rising两个词组成。<br>ever 有“永远地”的意思。<br>rising 的现在分词形式,有“上升的;增长的”的意思。<br>将ever和rising组合起来,ever-rising就是一个复合形容词,表示某人或某事“不断上升;持续增长”的状态或趋势。</em><br><em>inflation膨胀、通货膨胀</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181145002.png" alt="image.png"></p><p>*collapse 的常见意思有:</p><ol><li>崩溃,倒塌<br>例句:The old building collapsed after the earthquake.<br>这座老房子在地震后倒塌了。</li><li>衰竭,崩溃<br>例句:The company is in danger of financial collapse.<br>这家公司有财务崩溃的危险。</li><li>折叠,收拢<br>例句:The chair can collapse for easy storage.<br>这把椅子可以折叠起来以便储存。</li><li>体力衰竭<br>例句:The runner collapsed from exhaustion midway through the race.<br>这位运动员在比赛中途由于体力透支而倒下。</li><li>瓦解,分崩离析<br>例句:The alliance between the two countries collapsed.<br>两个国家之间的联盟已瓦解。<br>综上所述,collapse 表示由于各种原因导致的崩溃、倒塌或瓦解的状态。*</li></ol><p><em>commuter 乘务员、compensation补偿，赔偿</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181149134.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>townsfolk 城市里的居民、 imitate模仿、tourism旅游业、Cadtle城堡</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181204822.png" alt="image.png"></p><h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p><em>discrimination歧视、condemn谴责、insidious隐藏的，潜在的、alphabetism字母表主义、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181347279.png" alt="image.png"></p><p>overlooked 的意思是“忽视,疏忽”。它是动词 overlook 的过去分词和过去式。<br>下面几个例句可以帮助理解它的意思:</p><ol><li>The teacher overlooked several mistakes in my essay.<br>老师在我的文章中忽视了几处错误。</li><li>Sorry, I overlooked your text message yesterday.<br>不好意思,我昨天忽略了你的短信。</li><li>The security guard overlooked the suspicious person entering the building.<br>安保人员疏忽了那个可疑人物进入大楼。</li><li>Her contributions were often overlooked by her colleagues.<br>她的贡献常常被同事们忽视。</li><li>In his haste, he overlooked a few important details.<br>他匆忙中忽略了几个重要细节。</li><li>The producer apologized for having overlooked the young actor’s talent.<br>制片人为忽视了那位年轻演员的天赋而道歉。<br>综上所述,overlooked 表示注意力不集中导致未注意或忽略某事物、某人的状态或行为,常与动词忽视、疏忽、未注意等意思相对应。</li></ol><p><em>conspicuous 明显的，引人注目的 、prejudice偏见，成见</em></p><p><strong>出现illustrate，is mentioned等等都是举例说明，不是对中心对象的说明 </strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181352977.png" alt="image.png"></p><p><em>subtle微妙的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181357709.png" alt="image.png"></p><p><em>ill-treated虐待</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181401359.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>is comparable to相当于…  、legitimate合法的、正当的、<br>illegal, illegitimate不合法的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181421451.png" alt="image.png"></p><p><em>is quoted to被引用来说明…  、Constitution宪法、interpretation解释，阐释<br>alter 改变，更改 、implement执行、实施、实现、violate违反规则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181426235.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p>diminishing 的意思是“逐渐减少的”,是动词diminish的进行时和过去分词形式。<br>下面几个例句可以帮助理解diminishing的意思:</p><ol><li>The diminishing food supplies posed a threat to the shipwrecked sailors.<br>不断减少的食物供应给那些遇难船员带来了威胁。</li><li>There has been a diminishing number of wildlife in the area due to habitat loss.<br>由于栖息地丧失,该地区的野生动物数量在不断减少。</li><li>His diminishing eyesight made it difficult for him to read.<br>他逐渐衰弱的视力使阅读变得艰难。</li><li>The diminishing sunlight signaled the coming of winter.<br>阳光逐渐减弱,标志着冬季的到来。</li><li>She felt a diminishing desire to socialize with friends.<br>她感到社交的欲望在不断减退。<br>综上所述,diminishing 指 etwas在不断减少或缩小,表示从更多到更少的过程或趋势。与increase, enhance等词义相反。</li></ol><p><em>asset资产财产 、deminish逐渐减少</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181434016.png" alt="image.png"></p><p><em>evade 逃避 、peer同龄人、reform改革、misinterpreted曲解、neglect忽略，忽视 、skepticism怀疑态度、怀疑主义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181435621.png" alt="image.png"></p><h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><blockquote><p><em>细节题，注意词，细节</em></p></blockquote><p><em>partly 部分地、construction建设，构建、transparancy透明度、公开性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192245188.png" alt="image.png"></p><hr><blockquote><p><em>态度题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192251461.png" alt="image.png"></p><blockquote><p><em>例证题</em></p></blockquote><p><em>Toyota Motor 丰田汽车 、demonstrate展示，证明</em></p><p><em>limbic 的意思是“边缘的,边界的”,来源于解剖学术语,常用来形容脑内负责情绪和记忆的结构区域。<br>limbic system 边缘系统,指大脑内边缘部位的一组核团和神经纤维,控制情感反应和本能行为。<br>limbic cortex 边缘皮层,大脑边缘区域的组织。<br>limbic lobe 边缘小叶,位于大脑半球内侧的一部分,与情绪和记忆相关。<br>limbic brain 边缘脑,主管情感反应和本能的脑区。<br>综上所述,limbic 在解剖学上专门用来指代大脑内与情绪和本能相关的结构,因为这些结构位于大脑的边缘区域。它与理性思考和认知判断相对,更多与情感和直觉相关。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192253419.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192258586.png" alt="image.png"></p><blockquote><p><em>词汇题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211010386.png" alt="image.png"></p><blockquote><p><em>推理题</em></p></blockquote><p><em>当题目中没有给出定位信息的时候，，需要主动定位，70%来自段落首句</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211014882.png" alt="image.png"></p><p><em>search agent 搜索代理程序或者搜索机器人、negotiate谈判、磋商</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211024090.png" alt="image.png"></p><blockquote><p><em>主题题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211032732.png" alt="image.png"></p><h2 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h2><blockquote><p><em>比对</em></p></blockquote><p><em>选项和答案来源比对,先根据题目细节定位到句子，再根据名词一定会重现，动词替换原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211036300.png" alt="image.png"></p><p><em>关于定位和比对的专项训练—细节题的定位和比对</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211039422.png" alt="image.png"></p><p><em>sustained 的意思是“持续的,不间断的”,是动词sustain的过去式和过去分词。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211043870.png" alt="image.png"></p><p><em>levy ,tax 税、 impose强制施加，征收税、platform站台，月台、apply primarily主要适用于… 、multinational跨国的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211051386.png" alt="image.png"></p><p><em>出现两个名词，可能要考虑两个名词需要用相近的次替换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211104367.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;五大基本句型&quot;&gt;&lt;a href=&quot;#五</summary>
      
    
    
    
    <category term="english" scheme="https://fqzs.netlify.app/categories/english/"/>
    
    
  </entry>
  
  <entry>
    <title>acdemic_gpt添加slack-Claude模型</title>
    <link href="https://fqzs.netlify.app/undefined/6ca9ded9.html"/>
    <id>https://fqzs.netlify.app/undefined/6ca9ded9.html</id>
    <published>2023-06-07T23:16:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png" alt="image.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p><p><code>3.ppt生成promt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">帮我制作一篇内容关于这篇文章的PPT，要求如下： </span><br><span class="line">第一、一定要使用中文。 </span><br><span class="line">第二、页面形式有3种，封面、目录、列表。 </span><br><span class="line">第三、目录页要列出内容大纲。 </span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页内容使用“=====列表=====”作为开头。 </span><br><span class="line">第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 </span><br><span class="line">第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 </span><br><span class="line">第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 </span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。 </span><br><span class="line">第九、请用代码块回复你生成的内容。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前置准备&quot;&gt;&lt;a href=&quot;#前置准</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="https://fqzs.netlify.app/undefined/e255a10a.html"/>
    <id>https://fqzs.netlify.app/undefined/e255a10a.html</id>
    <published>2023-06-03T17:23:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" alt="image.png"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被</span><br><span class="line">服务的关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资</span><br><span class="line">源有限同时发消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主</span><br><span class="line">要指下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上</span><br><span class="line">与服务端进行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服</span><br><span class="line">务端又是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境</span><br><span class="line">当中，下载的主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一</span><br><span class="line">       点点交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电</span><br><span class="line">话(释放链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，</span><br><span class="line"> 然后再由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段</span><br><span class="line"> 的占用链路，不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机</span><br><span class="line">  发出报文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入</span><br><span class="line">10bit信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间</span><br><span class="line">被称为排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被</span><br><span class="line">称为处理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步</span><br><span class="line">  (SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载</span><br><span class="line">app，网络断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用</span><br><span class="line">  户数据报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返</span><br><span class="line">回确认信息后，才会发送下一段内容；如果没有接收到确认信息，那</span><br><span class="line">么会一直发送当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无</span><br><span class="line">需确认这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速</span><br><span class="line">度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发</span><br><span class="line">消息，qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进</span><br><span class="line">行区分，例如请qq的消息端口号是1，接收方端口号1的进程(qq)接</span><br><span class="line">收该条消息；微信端口号2，接收方端口号2的进程(微信)接受该条消</span><br><span class="line">息</span><br><span class="line">5.拥塞控制</span><br><span class="line">       - 传输层协议</span><br><span class="line">       1.TCP</span><br><span class="line">       2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服</span><br><span class="line">   务，网络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则</span><br><span class="line">进行对分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制</span><br><span class="line">校验)</span><br><span class="line">4.拥塞控制：是一种全局的调控，与流量控制不同(只是控制收发方的流量速</span><br><span class="line">度)，而拥塞控制，是对所有线路可能产生的拥塞进行控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里</span><br><span class="line">开始，到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和</span><br><span class="line">解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制：发送方速度过快或过慢，可以减慢或加速发送速度</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合</span><br><span class="line">都可在链路上传输</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="计算机网络结构分层汇总"><a href="#计算机网络结构分层汇总" class="headerlink" title="计算机网络结构分层汇总"></a>计算机网络结构分层汇总</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><nobr><font size="2">OSI七层模型</font></nobr></th><th style="text-align:center"><nobr><font size="2">TCP/IP概念模型</font></nobr></th><th style="text-align:center"><font size="2"> 功能</font></th><th style="text-align:center"><font size="2"><nobr>TCP/IP协议族</nobr></font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">应用层 </font><td rowspan="3"><font size="2"><center>应用层</center></font></td></td><td style="text-align:center"><font size="2"><nobr>文件传输、电子邮件、文件服务、虚拟终端</nobr></font></td><td style="text-align:center"><font size="2"><nobr>TFTP，HTTP，SNMP，FTP，SMTP，POP3，DNS，RIP，BGP，DHCP</nobr></font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">表示层</font></td><td style="text-align:center"><font size="2"><nobr>数据格式化、代码转换、数据加密</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">会话层</font></td><td style="text-align:center"><font size="2"><nobr>解除或建立与别的接电的联系</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">提供端对端接口</font></td><td style="text-align:center"><font size="2">TCP，UDP</font></td></tr><tr><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">为数据报选择路由</font></td><td style="text-align:center"><font size="2">IP，ICMP，OSPF，ARP，IGMP</font></td></tr><tr><td style="text-align:center"><font size="2">数据链路层</font><td rowspan="2"><center><font size="2">链路层</font></center></td></td><td style="text-align:center"><font size="2">传输有地址的帧以及错误检测功能</font></td><td style="text-align:center"><font size="2">SLIP，CSLIP，PPP，ARP，RARP，NTU</font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">物理层</font></td><td style="text-align:center"><font size="2">以二进制数据形式在物理媒体上传输数据</font></td><td style="text-align:center"><font size="2">IS02110，IEEE802，IEEE802.2</font></td></tr></tbody></table></div><div style="background-color: #fffacd;padding:20px;"> <mark>什么是协议？</mark><li><font size="2">实体：每层要进行处理的数据单元</font></li><li><font size="2">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</font></li><br><mark>如何判断协议属于哪一层？</mark><br>答：根据封装关系；例如：<font color="#FF0000" size="3">BGP协议是应用层的协议使用UDP封装（使用的传输层的封装和传输服务），所以根据下层为上层提供服务的原则，判断该协议属于哪一层</font></div><div style="background-color: #fffacd;padding:20px;"> <mark>数据报与报文的区别？</mark><br>1.数据报(Datagram)<font size="3"><li> 网络层的数据传输单位,由源地址、目的地址、数据等组成。</li><li> 使用不可靠的网络层服务,以独立的形式传输。</li><li> 每个数据报都独立路由转发,不需要建立连接。</li><li> 使用的数据报协议典型如IP协议。</li><br></font>2. 报文(Message)<font size="3"><li>传输层的数据传输单位,由报头、正文组成。</li><li>使用面向连接的传输层服务,需要建立连接</li><li>对于同一连接的报文,必须按顺序逐一传输</li><li>使用的报文协议典型如TCP协议。</li></font><br><br><mark>为什么传输层UPP协议的数据传输单位也是数据报？</mark><br><font size="3">数据报(Datagram)是网络层的传输单位,但UDP作为一种无连接的传输层协议,其传输特性类似网络层,所以其数据传输单位也采用了数据报的形式。UDP和网络层都使用数据报作为传输单位,但UDP还有一些传输层的特性,如端口号、校验等。所以UDP使用数据报只是因为其无连接的传输特性类似网络层,但UDP仍属于传输层协议。</font></div><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基础知识1"><a href="#数据通信基础知识1" class="headerlink" title="数据通信基础知识1"></a>数据通信基础知识1</h3><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>单、半、全三种通信方式</em></p></blockquote><p><em>单工通信：一条单向的信道(一条信道同一时刻要么接收，要么发送)<br>半双工通信：两条单向的信道<br>全双工通信：两条双向的信道(一条信道同一时刻，可以同时发送和接收)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>串行与并行传输方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261729820.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输通信方式</em></p></blockquote><p><em>同步传输：传输数据是连续传输<br>异步传输：数据间间断断，传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261735457.png" alt="image.png"></p><h3 id="数据通信基础知识2"><a href="#数据通信基础知识2" class="headerlink" title="数据通信基础知识2"></a>数据通信基础知识2</h3><blockquote><p><em>码元</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261959550.png" alt="image.png"></p><blockquote><p><em>速率、波特</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001158.png" alt="image.png"></p><blockquote><p><em>带宽</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001622.png" alt="image.png"></p><h3 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h3><blockquote><p><em>奈氏准则</em></p></blockquote><ul><li><em>是在理想低通(无噪声、带宽受到限制)条件下，避免 <strong>码间串扰</strong>  确定的极限的码元的传输速率=2W Baud，所以极限 信息传输速率=2W ×n  （n是码元bit数，就是n进制码元）</em></li><li><em>W 表示带宽，单位Hz</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262100499.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262104722.png" alt="image.png"></p><blockquote><p><em>香农定理</em></p></blockquote><ul><li><em>是在带宽受限，且有噪声的信道中，规定的在该噪声条件下的，不影响码元判断的，极限数据传输速率</em></li><li><em>S/N是信噪比，常常用作10log10(S/N) 来进行转换，从而将单位记作dB,就是定义了一个转换数值的公式 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262108690.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262114311.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262115670.png" alt="image.png"></p><blockquote><p><em>香农和奈氏</em></p></blockquote><ul><li><em>奈氏准则：关注的是无噪声条件下，不会造成码间串扰的极限 数据传输速率</em></li><li><em>香农定理：关注的是在当前噪声条件下，不会导致数据码元判断失真的 数据极限传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262120589.png" alt="image.png"></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a><em>基带信号与宽带信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262222235.png" alt="image.png"></p><h4 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a><em>编码与调制</em></h4><p><em>将数据 编码 /调制 —&gt;信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262223896.png" alt="image.png"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a><em>数字数据编码为数字信号</em></h4><blockquote><p><em>非归零编码</em></p></blockquote><p><em>缺点是，需要额外的信道，传输时钟周期信号，告诉多久发一个bit信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271044394.png" alt="image.png"></p><blockquote><p><em>归零编码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262237642.png" alt="image.png"></p><blockquote><p><em>反向不归零编码</em></p></blockquote><ul><li><em>缺点是，对于发送全1的信号，无法判断，有多少个1，因为，高低电平都有可能是1</em></li><li><em>还有就是，缺点在全1，的时候，会出现长条，没有时钟周期，就无法得知发送了，多少个1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262234072.png" alt="image.png"></li></ul><blockquote><p><em>曼彻斯特编码</em></p></blockquote><ul><li><em>1bit数据，就是1码元，被调制成两段电平，所以数据传输速率只有调制速率的1/2</em></li><li><em>每个码元中间，有一次跳变，可以实现同步，可通过中间跳变反应时钟信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271051270.png" alt="image.png"></li></ul><blockquote><p><em>差分曼彻斯特编码</em></p></blockquote><ul><li><em>每个码元中间都有一次跳变，可以实现同步</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271059163.png" alt="image.png"></li></ul><blockquote><p><em>4B/5B编码</em></p></blockquote><ul><li><em>编码效率80%</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271101120.png" alt="image.png"></li></ul><h4 id="数字数据调制成模拟信号"><a href="#数字数据调制成模拟信号" class="headerlink" title="数字数据调制成模拟信号"></a><em>数字数据调制成模拟信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271105446.png" alt="image.png"></p><ul><li><em>采样频率要达到信号最高频率的2倍以上，以保证，可以在每一个最高频的信号峰之内都可以采样到2个信息，得到波峰图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271112992.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271114621.png" alt="image.png"></p><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271138465.png" alt="image.png"></p><blockquote><p><em>1.电路交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271319318.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320037.png" alt="image.png"></p><blockquote><p><em>2.报文交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320009.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320369.png" alt="image.png"></p><blockquote><p><em>3.分组交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321465.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321976.png" alt="image.png"></p><blockquote><p><em>数据交换方式的选择</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271324239.png" alt="image.png"></p><blockquote><p><em>3.1.分组交换—数据报方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271325439.png" alt="image.png"></p><p><em>无连接服务，就是事先不为分组确定传输路径，传输路径全靠路由选择</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326584.png" alt="image.png"></p><blockquote><p><em>3.2分组交换—虚电路方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326838.png" alt="image.png"></p><p><em>连接服务，就是事先要确定分组的传输路径，提前建立连接，然后再按照这个路径输送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327331.png" alt="image.png"></p><blockquote><p><em>虚电路与数据报方式的区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327057.png" alt="image.png"></p><h2 id="传输介质-信道"><a href="#传输介质-信道" class="headerlink" title="传输介质(信道)"></a>传输介质(信道)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271453976.png" alt="image.png"></p><ul><li><em>传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。</em></li><li><em>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了 电 气 特 性，因此能够识别所传送的比特流</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271431578.png" alt="image.png"></li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a><em>导向性传输介质</em></h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a><em>双绞线</em></h4><p><em>电流方向相反的铜线，绞合一起，磁感线相互抵消，减少相邻导线的电磁干扰</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271436145.png" alt="image.png"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><em>同轴电缆</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271440754.png" alt="image.png"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><em>光纤</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443295.png" alt="image.png"></p><blockquote><p><em>单模光纤和双模光纤</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271447411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443816.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271448705.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449288.png" alt="image.png"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a><em>非导向性传输介质</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449201.png" alt="image.png"></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><blockquote><p><em>中继器</em></p></blockquote><ul><li><em>中继器是对数字信号的再生(整形)</em></li><li><em>中继器是连接两个网段的桥梁，以助于数字信号的再生</em></li><li><em>中继器，只负责将数据发送到另一网段，不管数据中是否有错误</em></li><li><em>中继器两端可以连接相同传输介质，也可以不同传输介质</em></li><li><em>中继器两端网段一定要是统一协议</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271612539.png" alt="image.png"></p><blockquote><p><em>集线器</em></p></blockquote><p><em>集线器，可以连接多台主机，平分带宽，共享数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271616925.png" alt="image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="链路层的功能"><a href="#链路层的功能" class="headerlink" title="链路层的功能"></a>链路层的功能</h2><blockquote><p><em>数据链路层基本概念</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271636246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271637260.png" alt="image.png"></p><blockquote><p><em>功能概述</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639722.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639736.png" alt="image.png"></p><h3 id="封装成帧-amp-透明传输"><a href="#封装成帧-amp-透明传输" class="headerlink" title="封装成帧&amp;透明传输"></a><em>封装成帧&amp;透明传输</em></h3><blockquote><p><em>封装成帧</em></p></blockquote><p><em>在一段数据添加首部、尾部构成一个帧，接收端就能收到bit流后，能识别帧的开始和结束</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271708120.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271711174.png" alt="image.png"></p><blockquote><p><em>透明传输</em></p></blockquote><p><em>就是传输数据的bit组合不会影响，到帧开始和结束的判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271714311.png" alt="image.png"></p><blockquote><p><em>四种组帧的方法</em></p></blockquote><p><strong><em>1.字符计数法</em></strong></p><ul><li><em>帧的开始字符记录的是该帧的字符数(包括自己)</em></li><li><p><em>缺点是，当前面的字符出错，往后的全部会出错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271716399.png" alt="image.png"><br><strong><em>2.字符填充法</em></strong></p></li><li><p><em>传送文本，由于文本字符对应的ASCII码不会出现的bit组合充当帧头，帧尾，中间数据部分不会产生边界判定错误</em></p></li><li><em>如果传送的帧，由二进制程序，或图像等等非ASCII编码文本文件，数据内容有可能出现帧头，帧尾bit组合，导致中间穿插,帧边界判定错误</em></li><li><em>通过对数据部分 字节填充ESC转义字节 ，—&gt;使得特殊字符意义失效，实现干扰的解决</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271720950.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271724181.png" alt="image.png"></p><p><strong><em>3.零比特填充法</em></strong></p><p><em>以01111110 作为帧头和帧尾，发送端先将数据扫描，将所有连续的5个1 后都插入0，这样就不会出现6个1 ，再封装成帧；接收端，再逆过程去掉0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271726553.png" alt="image.png"></p><p><strong><em>4.违规编码法</em></strong></p><p><em>曼彻斯特编码中不会出现的状态(高-高/低-低)来表示帧头，帧尾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271729961.png" alt="image.png"></p><h3 id="差错控制—检错编码"><a href="#差错控制—检错编码" class="headerlink" title="差错控制—检错编码"></a><em>差错控制—检错编码</em></h3><blockquote><p><em>差错从何而来？</em></p></blockquote><ul><li><em>差错来源：随机噪声（线路本身电气特性产生）、冲击噪声（外界短暂原因）</em></li><li><p><em>差错：位错；帧错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271901773.png" alt="image.png"></p></li><li><p><em>链路层编码与物理层编码调制不同：链路层编码是用于<strong>一组比特</strong>，判断传输过程是否出现出错。物理层编码调制针对<strong>单个比特</strong>，解决的是传输过程中 比特同步的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271903232.png" alt="image.png"></p></li></ul><blockquote><p><em>差错控制—检错编码—奇偶校验码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271910981.png" alt="image.png"></p><blockquote><p><em>差错控制—检错编码—CRC循环冗余码</em></p></blockquote><p><em>接收结果作 余数为0，就无差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271911773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271912297.png" alt="image.png"></p><h3 id="差错控制—纠错编码"><a href="#差错控制—纠错编码" class="headerlink" title="差错控制—纠错编码"></a><em>差错控制—纠错编码</em></h3><blockquote><p><em>海明距离</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272215926.png" alt="image.png"></p><blockquote><p><em>海明码纠错步骤</em></p></blockquote><p><strong><em>1.确定校验码位数r</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217701.png" alt="image.png"></p><p><strong><em>2.确定校验码和数据的位置</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217078.png" alt="image.png"></p><p><strong><em>3.求出校验码的值</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272220510.png" alt="image.png"></p><p><strong><em>4.检错并纠错</em></strong><br><em>方式1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272228839.png" alt="image.png"></p><ul><li><em>先每个校验码对应一个大圆，分别填入器其校验码序号</em></li><li><em>交集部分，填入校验码负责校验的一组序号中重叠的序号数据</em></li><li><em>最中间是三个校验码负责的重叠序号</em></li><li><em>2号校验码负责的没有出错，1,4号出错，所以3，6,7，排除，只剩下5</em></li></ul><p><em>方式2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272242979.png" alt="image.png"></p><blockquote><p><em>海明码纠错演示</em></p></blockquote><p><strong><em>1．传输的数据：1101</em></strong></p><p><strong><em>2．校验位计算公式：</em></strong></p><p>2^k &gt;= k+n+1,n为数据位在本例中计算的k为3；</p><p>用P1,P2,P3,表示校验位，其中</p><p>P1,的位数2^0,P2,的位数2^1,P3,的位数2^2</p><p>则：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>1+2</th><th>4</th><th>1+4</th><th>2+4</th><th>1+2+4</th></tr></thead><tbody><tr><td>位数的二进制</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td></tr><tr><td>位数</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>数据位</td><td></td><td></td><td>1</td><td></td><td>1</td><td>0</td><td>1</td></tr><tr><td>校验位</td><td>P1,</td><td>P2,</td><td></td><td>P3</td><td></td><td></td></tr></tbody></table></div><p><strong><em>3.分组：</em></strong></p><div class="table-container"><table><thead><tr><th>校验位</th><th>位数分组</th></tr></thead><tbody><tr><td>P1,</td><td>1,3,5,7</td></tr><tr><td>P2,</td><td>2,3,6,7</td></tr><tr><td>P3</td><td>4,5,6,7</td></tr></tbody></table></div><p><strong><em>4.计算校验位值(异或运算)</em></strong></p><p>P1^1^1^1=0,得P1=1</p><p>P2^1^0^1=0,得P2=0</p><p>P3^1^0^1=0,得P3=0</p><p>最终传输的数据位：10101<code>0</code>1</p><p><strong><em>5,检验</em></strong><br>     如果接收端收到的是10101<code>1</code>1<br>     还是按照刚才的分组进行计算P1,P2P3每个分组的异或值，为零则无错，为1则有错。<br>     P1组 1^1^1^1=0<br>     P2组 0^1^1^1=1<br>     P3组 0^1^1^1=1</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a><em>流量控制与可靠传输机制</em></h3><div style="background-color: #fffacd;padding:20px;"> <font size="3"><mark>可靠传输机制</mark>是指在数据传输过程中,使用各种手段来确保数据能够完整、正确、按序到达目的地的传输机制。<br>主要的可靠传输机制包括:<br>1. 流量控制:发送方和接收方协调传输速率,防止接收缓冲区溢出。<br>2. 错误检测:对传输的数据进行校验,检查是否发生错误。常用奇偶校验、CRC校验等。<br>3. 确认和重传:接收方发回确认帧表示正确接收,发送方如果长时间收不到确认,会重传数据。<br>4. 序列号:对数据包进行编号,确保按序到达。<br>5. 连接管理:建立连接、维护连接状态、终止连接。<br>6. 滑动窗口协议:扩大序列号使用范围,通过窗口控制流量。<br>7. 网络拥塞控制:通过流量控制和拥塞控制技术确保网络稳定运行<br><br>在TCP/IP参考模型的五层网络结构中,主要是<mark>数据链路层</mark>和<mark>传输层</mark>提供可靠的数据传输机制。<br>1. 数据链路层<br>数据链路层通过以下手段提供尽力而为的可靠传输:<li>流量控制:防止接收端缓冲区溢出</li><li>差错检测:检测并纠正传输错误</li><li>确认重传机制:确认帧和重传机制</li><li>链路管理:管理物理链路连接</li><br>2. 传输层<br>传输层中的TCP协议提供面向连接、全双工、可靠的传输服务。主要机制有:<li>序列号和确认机制</li><li>滑动窗口协议</li><li>拥塞控制</li><li>连接管理</li></font></div><h4 id="流量控制与可靠传输的方法"><a href="#流量控制与可靠传输的方法" class="headerlink" title="流量控制与可靠传输的方法"></a><em>流量控制与可靠传输的方法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281155434.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157464.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157841.png" alt="image.png"></p><ul><li><em>停止-等待协议  ，发送窗口=1，接收窗口=1</em></li><li><em>后退N帧协议（GBN）发送窗口&gt;1,接收窗口=1</em></li><li><em>选择重传协议（SR）发送窗口&gt;1,接收窗口&gt;1</em></li></ul><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p><em>为什么要有停止等待协议？</em></p></blockquote><ul><li><em>为了解决流量控制的问题：互相的停止等待，使得不会传输太多的数据</em></li><li><em>为了解决可靠传输的问题：互相停止等待，接收确认帧，能保证能发现差错，以及处理差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281348782.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—无差错情况</em></p></blockquote><ul><li><em>ACK i 是接收方收到第 i 号帧之后，返回给发送方的确认帧</em></li><li><em>每次发送一个数据帧就停止等待，所以只需要1bit来对帧进行编号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352535.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—有差错情况</em></p></blockquote><p><strong><em>1.数据帧丢失或检测到帧出错</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352337.png" alt="image.png"></p><ul><li><em>超时计时器，当没有在设定时间内收到确认帧，发送方就重发一次</em></li><li><em>超时计时器设置的设定时间，要并RTT(往返传播时延)高一点，因为还有发送时延</em></li><li><em>发完一个帧之后，要保留这个帧的副本，用来重发</em></li><li><em>数据帧和确认帧必须编号，以确定确认帧确定的是哪一个数据帧</em></li></ul><p><strong><em>2.ACK丢失</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356757.png" alt="image.png"></p><p><strong><em>3.ACK迟到</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356868.png" alt="image.png"></p><blockquote><p><em>信道利用率</em></p></blockquote><ul><li><em>信道利用率就是发送方在一个发送周期内，有效的发送数据所需时间(发送时延)，占整个发送周期的比率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281403631.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281404211.png" alt="image.png"></p><blockquote><p><em>梳理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281406220.png" alt="image.png"></p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><blockquote><p>引入窗口概念的原因</p></blockquote><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p><p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p><p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052208457.png" alt="image.png"></p><p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052208945.png" alt="image.png"><br>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><blockquote><p>窗口大小由哪一方决定？</p></blockquote><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p><p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><h6 id="后退N帧协议GBN"><a href="#后退N帧协议GBN" class="headerlink" title="后退N帧协议GBN"></a><em>后退N帧协议GBN</em></h6><blockquote><p><em>停等协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281646729.png" alt="image.png"></p><blockquote><p><em>后退N帧协议中的滑动窗口</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281541947.png" alt="image.png"></p><blockquote><p><em>GBN发送方要响应的三件事</em></p></blockquote><ul><li><em>窗口已满是指，当前窗口的数据，在没有收到确认帧之前，不能往前移动，此时的状态就是窗口已满</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281539613.png" alt="image.png"></li></ul><blockquote><p><em>GBN接收方要做的事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281651074.png" alt="image.png"></p><blockquote><p><em>运行中的GBN</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281536912.png" alt="image.png"></p><blockquote><p><em>滑动窗口长度</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281559974.png" alt="image.png"></p><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281532640.png" alt="image.png"></p><ul><li><em>1000个窗口，所以发送方同时可以发1000个帧，每个帧1000个字节<br>所以一次右1000x1000x8 bit数据，<strong>受到信道带宽限制，所以发送延时=<br>1000x1000x8b/100Mb/s =80ms</strong></em></li><li><em>只有受到受到1号帧的确认帧，发送框才会开始移动一个，所以，<strong>在没有受到第一个确认帧之前，发送方不会发送新的数据</strong></em></li><li><em>所以计算，受到确认帧的时间=2x50ms + 1000x8b/100Mb/s =100.08ms &gt;80ms ,所以，信道会有20ms没有新数据推入，空闲，有100.08-80ms=20ms无输入，所以<strong>实际平均数据传输率=1000x1000x8b/100.08ms=80Mb/s</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281518658.png" alt="image.png"></li></ul><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281543131.png" alt="image.png"></p><h6 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a><em>选择重传协议SR</em></h6><blockquote><p><em>后退N帧协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281647073.png" alt="image.png"></p><blockquote><p><em>选择重传协议中的滑动窗口</em></p></blockquote><ul><li><em>发送窗口黄色部分是未被确认的帧，绿色部分是发送之后，收的确认帧的帧</em></li><li><em>接收窗口，紫色部分是收到的帧，灰色部分是<strong>希望收到</strong>的帧，发现，接收窗口可以在没有收到希望收到的帧前，接收其他序号的帧，这里不同于GBN协议，GBN协议在没有收到希望收到的帧之前，对其他发送过来的帧会全部丢弃</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281652798.png" alt="image.png"></li></ul><blockquote><p><em>SR 发送方必须响应的三件事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281659010.png" alt="image.png"></p><blockquote><p><em>SR接收方要做的事</em></p></blockquote><ul><li><em>接收窗口只有当接收到窗口下届的帧，才会将接收窗口往前移动，移动到最小的未接收的帧，并将接收到的这批帧，交付给网络层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705434.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705718.png" alt="image.png"></p><blockquote><p><em>运行中的SR</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281708817.png" alt="image.png"></p><blockquote><p><em>SR滑动窗口长度</em></p></blockquote><ul><li><em>发送窗口=接收窗口（防止溢出）</em></li><li><em>窗口长度=2^(n-1),n为帧的个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281711388.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281714834.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281713327.png" alt="image.png"></p><h3 id="信道划分介质访问控制-MAC协议"><a href="#信道划分介质访问控制-MAC协议" class="headerlink" title="信道划分介质访问控制(MAC协议)"></a><em>信道划分介质访问控制(MAC协议)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942630.png" alt="image.png"></p><ul><li><em>当一个对讲机讲话，其他对讲机就不能够进行讲话，否则会信号冲突</em></li><li><em>广播式链路，如何实现，两对节点之间通信不会互相干扰，就需要介质访问控制来实现</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942457.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291141124.png" alt="image.png"></p><h4 id="静态划分信道-信道划分介质访问控制"><a href="#静态划分信道-信道划分介质访问控制" class="headerlink" title="静态划分信道(信道划分介质访问控制)"></a><em>静态划分信道(信道划分介质访问控制)</em></h4><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a><em>频分多路复用FDM</em></h5><ul><li><em>不同用户同一时间占用不同的带宽(频率资源)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282109872.png" alt="image.png"></li></ul><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a><em>时分多路复用TDM</em></h5><ul><li><p><em>缺点是每个用户在每一个帧中占用固定的时隙，导致其他用户空闲时，不传送数据时，时隙被浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282111844.png" alt="image.png"></p></li><li><p><em>改进后的统一时分复用STDM,就解决了上面的问题，铜国集中器，将不同用户的数据，按照进入的先后，排列使得每一个STDM帧都排满</em></p></li><li><em>所以STDM帧的每个用户的时隙，不是固定的，是按照需要动态分配的时隙</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282112256.png" alt="image.png"></li></ul><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a><em>波分多路复用WDM</em></h5><ul><li><em>实际上就是光的频分多路复用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282115560.png" alt="image.png"></li></ul><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a><em>码分多路复用CDM</em></h5><ul><li><em>不太理解</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282116386.png" alt="image.png"></li></ul><h4 id="动态分配信道-随机访问介质访问控制"><a href="#动态分配信道-随机访问介质访问控制" class="headerlink" title="动态分配信道(随机访问介质访问控制)"></a><em>动态分配信道(随机访问介质访问控制)</em></h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><em>ALOHA协议</em></h5><blockquote><p><em>纯ALOHA协议</em></p></blockquote><ul><li><em>这里帧用T0表示，T0是一个帧从的 发送时间+传播时间 这所有过程，所耗费的时间，所以是在时间坐标上表示帧</em></li><li><em>ALOHA协议想发就发，多个站点，可以在任何时刻，发送数据帧，只是，如果有两个数据帧产生，时间重叠，那么就发生冲突，接收方会检测到差错，不返回确认，如此发送方就会等待一个随机的时刻再次发送数据帧</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282134246.png" alt="image.png"></li></ul><blockquote><p><em>时隙ALOHA协议</em></p></blockquote><ul><li><em>把时间分为若干相同的时间片段，所有用户只允许在<strong>开始时刻</strong>且 <strong>同步</strong>接入网络信道，这样所有用户拥有一个统一的时间划分，都只能在时间片开始时刻发送数据，若发生冲突，则等到下一个时间片开始时刻发送,大大降低了数据冲突问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282138877.png" alt="image.png"></li></ul><h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a><em>CSMA协议</em></h5><p><strong><em>载波监听多路访问协议</em></strong></p><ul><li><em>CS ：载波监听，每一个站发送数据前先检测总线上是否有其他计算机发送数据</em></li><li><em>当信道空闲：发送完整帧(具体发送看CSMA类型)</em></li><li><em>当信道忙：则等待一个随机时间再监听</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290953369.png" alt="image.png"></li></ul><blockquote><p><em>1-坚持CSMA</em></p></blockquote><ul><li><em>空闲直接传输，不等待；忙则一直监听，直到空闲马上传输</em></li><li><em>不是都是空闲的时候再传输吗？为什么会出现冲突？</em></li><li><em>因为，当有两个以上站，同时在等候监听时，由于信息在两台站之间有传播时延，即使是信道上已经存在数据传输，任然检测不出，所以就当做信道空闲，也把数据传输上去，这样就导致数据碰撞，造成冲突</em></li><li><em>优点：只要空闲就发送，媒体利用率最高</em></li><li><em>缺点：冲突概率高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290956924.png" alt="image.png"></li></ul><blockquote><p><em>非坚持CSMA</em></p></blockquote><ul><li><em>空闲则直接传输，不等待；忙则放弃监听，随机时间后再监听</em></li><li><em>优点：减少了当台站，同时监听到空闲直接发送数据，产生冲突的可能</em></li><li><em>缺点：媒体空闲无法迅速被利用起来，利用率低</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291000848.png" alt="image.png"></li></ul><blockquote><p><em>p-坚持CSMA</em></p></blockquote><ul><li><em>空闲时，概率p直接发送，概率1-p等待下一个时间槽传输。</em></li><li><em>忙则持续监听，直到信道空闲</em></li><li><em>冲突则等待下一个时间槽监听</em></li><li><em>优点：即减少了冲突发生，有能减少空间时间的浪费</em></li><li><em>缺点：冲突后还是会把数据帧发送完，造成浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291004905.png" alt="image.png"></li><li><strong><em>正确使用以上策略可以在一定程度上减少碰撞的发生，但无法彻底解决碰撞问题。</em></strong></li></ul><blockquote><p><em>比对</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291009309.png" alt="image.png"></p><h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><em>CSMA/CD协议</em></h5><blockquote><p><strong><em>强化CSMA协议，推出CSMA/CD协议</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034112.png" alt="image.png"></p><p><strong><em>载波监听多点接入/碰撞检测协议</em></strong></p><ul><li><em>CSMA/CD适用于半双工网络(也就是<strong>有线以太网</strong>)—就是不能一方发送还没发送完，另一方就发送，这样会造成数据在路上的碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034904.png" alt="image.png"></li></ul><blockquote><p><em>为什么先听后发会产生冲突</em></p></blockquote><ul><li><em>为什么先听后发还会产生冲突？</em></li><li><em>因为电磁波在总线上有传播时延，B暂时没有检测到A发送过来的数据</em></li><li><em>以A为基准，对于A来说，A检测到发生碰撞的最长时间=2τ</em></li><li><em>所以当发送数据之后过了2τ还没接受到碰撞，说明这次传输，不会产生碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291053463.png" alt="image.png"></li></ul><blockquote><p><em>如何确定碰撞后重传时机</em></p></blockquote><ul><li><em>碰撞之后如何重传，以及重传几次，通过以下方式**</em>截断二进制指数规避法<em>**</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291055125.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291057356.png" alt="image.png"></li></ul><blockquote><p><em>最小帧长</em></p></blockquote><ul><li><em>当检测到碰撞之后，应当立即停止继续发送帧，但是如果检测到碰撞之前就将帧发送完毕，就显得有些尴尬</em></li><li><em>为了避免检测到碰撞之前，就将帧发完，应该设置一个最小的帧长度，保证2τ(最大检测到碰撞时间)之内不会将帧传输完</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103100.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103689.png" alt="image.png"></p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><em>CSMA/CA协议</em></h5><blockquote><p><em>为什么要有CSMA/CA协议</em></p></blockquote><ul><li><em>无线局域网中无法辺全面的检测碰撞</em></li><li><em>并且当多台站点A,C检测到信道空闲，会同时向终端B发送数据帧，就会导致冲突</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134454.png" alt="image.png"></li></ul><blockquote><p><em>CSMA/CA协议工作原理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291133228.png" alt="image.png"></p><blockquote><p><em>CSMA/CA与CSMA/CD区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134135.png" alt="image.png"></p><h4 id="动态分配信道-轮询访问介质访问控制"><a href="#动态分配信道-轮询访问介质访问控制" class="headerlink" title="动态分配信道(轮询访问介质访问控制)"></a><em>动态分配信道(轮询访问介质访问控制)</em></h4><ul><li><strong><em>结合了静态划分信道的优点，不会产生冲突；又结合了随机访问协议的优点发送时能独占信道，占全部带宽</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291220580.png" alt="image.png"></li></ul><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><em>轮询协议</em></h5><ul><li><em>主节点，挨个轮流询问（实际就是以数据帧形式）下面的主机是否要发送数据</em></li><li><em>主节点故障，就无法询问，所有结点就无法传输数据—称为单点故障</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291214203.png" alt="image.png"></li></ul><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><em>令牌传递协议</em></h5><ul><li><em>令牌就是特殊格式的MAC协议控制帧，不包含任何信息</em></li><li><em>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291218760.png" alt="image.png"></li></ul><h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a><em>局域网基本概念和体系结构</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291600023.png" alt="image.png"></p><p><strong><em>决定局域网主要要素</em></strong></p><ul><li><em>网络拓扑</em></li><li><em>传输介质</em></li><li><em>介质访问控制方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291548371.png" alt="image.png"></li></ul><blockquote><p><em>局域网拓扑结构</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291550233.png" alt="image.png"></p><blockquote><p><em>局域网传输介质</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551105.png" alt="image.png"></p><blockquote><p><em>局域网介质访问控制方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551614.png" alt="image.png"></p><blockquote><p><em>局域网的分类</em></p></blockquote><p><em>以太网。是目前应用最广泛的局域网，逻辑拓扑是总线型，物理拓扑是星型。使用的是CSMA/CD 协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291554255.png" alt="image.png"></p><blockquote><p><em>IEEE 802标准</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291556090.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291555065.png" alt="image.png"></p><blockquote><p><em>LLC子层和MAC子层</em></p></blockquote><p><em>IEEE 802标准将局域网的数据链路层划分为：逻辑链路层LLC子层，和介质访问控制MAC子层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291559577.png" alt="image.png"></p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><em>以太网</em></h3><blockquote><p><em>以太网概述</em></p></blockquote><ul><li><em>以太网有两个标准，DIX Ethernet V2 和IEEE 802.3 ;两种标准的帧格式只有1点点的不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291654999.png" alt="image.png"></li></ul><blockquote><p><em>以太网提供无连接、不可靠服务</em></p></blockquote><ul><li><em>无连接：发送方接受方，之间通信前，不提前确立信道，无握手</em></li><li><em>不可靠：是指，不管接受数据帧是否乱序、差错、丢失</em></li><li><em>无差别接收：是指，在接收数据不会有意外，来什么收什么</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291655881.png" alt="image.png"></li></ul><blockquote><p><em>以太网传输介质与拓扑结构</em></p></blockquote><ul><li><em>现在以太网都是逻辑上总线型，物理上星型</em></li><li><em>传输介质采用双绞线+集线器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291658840.png" alt="image.png"></li></ul><blockquote><p><em>10BASE-T以太网</em></p></blockquote><ul><li><em>BASE 表示传输基带信号，也就是数字信号</em></li><li><em>T表示采用双绞线</em></li><li><em>采用曼彻斯特编码</em></li><li><em>采用CSMA/CD介质访问控制</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291700140.png" alt="image.png"></li></ul><blockquote><p><em>适配器与MAC地址</em></p></blockquote><ul><li><em>通信适配器，实现计算机与外界局域网的连接，也称网络接口板，或网卡NIC</em></li><li><em>现在计算机都嵌入了适配器，就无须单独使用网卡了</em></li><li><em>适配器上装有处理器和存储器(RAM,ROM)，ROM上存储了计算机硬件(网卡)地址MAC地址</em></li><li><em>MAC地址全球唯一，换网卡，MAC地址改变</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291704298.png" alt="image.png"></li></ul><blockquote><p><em>以太网MAC帧—V2格式</em></p></blockquote><ul><li>*为什么有帧开始定界符 ，却没有帧结尾定界符呢？</li><li><em>因为以太网编码采用的是曼彻斯特编码，一个bit内就有一个跳变，当这种形式消失，就说明帧结束，然后只需要往前推4bit就能找到数据位置</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291717806.png" alt="image.png"></li></ul><blockquote><p><em>高速以太网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292033086.png" alt="image.png"></p><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><em>无线局域网</em></h3><blockquote><p><em>802.11的MAC帧头格式</em></p></blockquote><ul><li><em>基站AP(也称无线接入点), 是主机通过连接无线网络连入有线网络（以太网）的设备</em></li><li><em>以下的场景：A 想要与B通信，由于距离太远，A要先通过无线网络将数据发送给Ap1,然后Ap1发送给AP2，最后由Ap2将数据发送给B</em></li><li><em>接收端—AP2的MAC地址 ；发送端—AP1的MAC地址；目的地址—B的MAC地址；源地址—A的MAC地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292038208.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292052190.png" alt="image.png"></p><blockquote><p><em>无线局域网的分类</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292053304.png" alt="image.png"></p><p><strong><em>1.有固定基础设施无线局域网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292055469.png" alt="image.png"></p><ul><li><em>一个基本服务集BSS内，的主机可以相互之间直接通过基站发送数据</em></li><li><em>不同基本服务集之间要进行远距离通信，需要借助基站与基站之间的互相通信来实现，称作“漫游”</em></li><li><em>wifi名称—就是服务集标识符</em></li></ul><p><strong><em>2.无固定基础设施无线局域网的自组织网络</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292101049.png" alt="image.png"></p><h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a><em>虚拟局域网VLAN</em></h3><blockquote><p><em>为什么提出虚拟局域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041734284.png" alt="image.png"></p><blockquote><p><em>VLAN基本概念</em></p></blockquote><ul><li><strong><em>就是将局域网内的设备，划分为不同的逻辑工作组，这种域与物理位置无关</em></strong></li><li><em>一个逻辑工作组，就是一个子网，一个广播域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041735592.png" alt="image.png"></li></ul><blockquote><p><em>VLAN实现</em></p></blockquote><ul><li><em>将一个交换机下的局域网，逻辑上划分为两个虚拟的不同的局域网，同时其他交换机下的也可以划分为同样的两个分组，这样相同的分组之间就是一个可以互相通信的虚拟局域网，而不同分组之间就不能互相通信</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041738107.png" alt="image.png"></li><li><em>按照交换机上的端口划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041740977.png" alt="image.png"></p><ul><li><em>按照接入的主机MAC地址划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041743116.png" alt="image.png"></p><ul><li><em>假如A要往E发送数据，A主机会先准备一个普通以太网帧，帧送往交换机，交换机会往帧上贴一个标签(标注VLAN1)，发往交换机2，然后交换机2会根据标签，知道这是发往虚拟局域网VLAN1的然后再根据一些其他标志，判断发往E </em></li></ul><blockquote><p><em>VLAN进行数据交换时，帧的格式变化</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041752990.png" alt="image.png"></p><blockquote><p><em>练习</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041753776.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041756089.png" alt="image.png"></p><h2 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a><em>广域网及相关协议</em></h2><blockquote><p><em>什么是广域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041719233.png" alt="image.png"></p><blockquote><p><em>PPP协议</em></p></blockquote><p><strong><em>PPP点对点协议，广域网使用的链路层协议，只支持全双工链路，用于用户使用拨号电话接入因特网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041721607.png" alt="image.png"></p><blockquote><p><em>PPP协议应该满足的要求/无需满足的要求</em></p></blockquote><ul><li><em>同步线路是逐个bit发送数据，异步线路是逐个字节或字符发送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726956.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726276.png" alt="image.png"></p><blockquote><p><em>PPP协议的是哪个组成部分</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727339.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727950.png" alt="image.png"></p><blockquote><p><em>PPP协议的帧格式</em></p></blockquote><ul><li><em>PPP协议的帧格式，最小单位是字节，所以是面向字节的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041731402.png" alt="image.png"></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><em>基本概念</em></h3><h4 id="网段"><a href="#网段" class="headerlink" title="网段"></a><em>网段</em></h4><ul><li><em>网段计算机网络中使用同一物理层设备，能够直接通讯的那一部分，同一个网段，会有冲突域，同一时间只能有一台设备占用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042038496.png" alt="image.png"><h4 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a><em>冲突域与广播域</em></h4></li></ul><p><strong><em>1.冲突域：</em></strong></p><ul><li><em>在以太网  中，如果某个CSMA/CD网络上的两台计算机在同时通信时<strong>会发生冲突</strong>，那么这个CSMA/CD网络就是一个<strong>冲突域</strong>（collision domain)。如果以太网中各个网段以<strong>集线器</strong>连接，因为不能避免冲突，所以它们仍然是一个冲突域</em></li><li><em>冲突域就是连接在<strong>同一导线</strong>上的所有工作站的集合，或者说<strong>是同一物理网段</strong>上所有节点的集合，或以太网上竞争<strong>同一带宽</strong>的节点集合.</em></li><li><em>集线器是一个标准的共享式设备，也就是<strong>同一时刻只有一个端口下联的设备可以发送数据。正常工作时，集线器随机选出某一端口设备并让它独占全部带宽与集线器上联设备（如交换机、路由器等）进行通信</strong>。因此，集线器设备的所有端口即形成了一个冲突域。</em></li><li><em>为了有效避免冲突，局域网中使用<strong>交换机</strong>（Switch）来分割冲突域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042041995.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042042138.png" alt="image.png"></p><p><strong><em>2.广播域：</em></strong></p><ul><li><em>广播是一种信息的<strong>传播方式</strong>，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>(Broadcast Domain)。</em></li></ul><p><strong><em>3.两者区别</em></strong></p><ul><li><em>冲突域是基于物理层</em></li><li><p><em>广播域是基于数据链路层</em></p></li><li><p><em>冲突域：竞争同一带宽的节点的集合</em></p></li><li><em>广播域：接收同样广播消息的节点的集合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042020764.png" alt="image.png"></li></ul><blockquote><p><em>练习加深了解</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042120355.png" alt="image.png"></p><h3 id="链路层的设备"><a href="#链路层的设备" class="headerlink" title="链路层的设备"></a><em>链路层的设备</em></h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a><em>网桥</em></h4><ul><li><em>网桥有左右两个端口，分别分割两个冲突域</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042049108.png" alt="image.png"></p><blockquote><p><em>透明网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045169.png" alt="image.png"></p><blockquote><p><em>源路由网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045552.png" alt="image.png"></p><blockquote><p><em>网桥的自学习功能</em></p></blockquote><ul><li><em>网桥只有左右两个端口，分别标记位1,2号</em></li><li><em>网桥自学习是指，网桥转发表一开始是空的，当A-&gt;B发送信息时，A会向所有主机发送，当经过第一个网桥时，由于网桥转发表没有对A的记录，所以当数据帧经过该网桥时，就会在转发表记录  A对应1端口位置；同时由于没有对B的记录，无法选择转发，所以只能一股脑转发出去，右边的网桥也经过一样的过程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042101488.png" alt="image.png"></li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><em>交换机</em></h4><blockquote><p><em>多接口网桥—交换机</em></p></blockquote><ul><li><em>集线器，也是多接口，集线器，会将每台计算机原有100MB/s带宽，平均为每台只有25MB/s ,同时会有冲突域，一台集线器下的计算机只能同时有一台发送数据，传输速率大大降低</em></li><li><em>交换机，就是一个多接口的网桥，可以隔绝冲突域，一台交换机下的每条信道都能占满带宽(独占媒体带宽)，维持原有的100MB/s,同时一台交换机之内的所有计算机都可以同时传输数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042110168.png" alt="image.png"></li></ul><blockquote><p><em>以太网交换机的两种交换方式</em></p></blockquote><ul><li><em>直通式交换机</em></li><li><em>存储转发式交换机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042121848.png" alt="image.png"></li></ul><blockquote><p><em>交换机的自学习功能</em></p></blockquote><ul><li><em>与网桥的自学习功能类似，只是多了几个端口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042114758.png" alt="image.png"></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051043362.png" alt="image.png"></p><p><strong><em>1.网络层功能</em></strong></p><ul><li><em>路由选择分组转发</em></li><li><em>异构网络互联：指的是传输介质、数据编码方式、链路控制协议以及不同的数据单元格式和转发机制的网络，也就是<strong>数据链路层和物理层协议不同</strong>的网络</em></li><li><em>拥塞控制：全局性的概念，是因为整个网络负载过重造成拥塞；而流量控制只是，发送方发送过快导致接收方接收不过来，所以需要流量控制</em></li></ul><p><strong><em>2.拥塞控制方法</em></strong></p><ul><li><em>WAY1开环控制：静态方法</em></li><li><em>WAY2闭环控制：动态方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051053599.png" alt="image.png"><h2 id="SDN基本概念"><a href="#SDN基本概念" class="headerlink" title="SDN基本概念"></a><em>SDN基本概念</em></h2></li></ul><blockquote><p><em>考察概念，主要是选择题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051308929.png" alt="image.png"></p><p><strong><em>1.网络层的关键功能</em></strong></p><ul><li><em>转发：将分组从路由器的输入端口，转发到合适的输出端口【局部的功能】【数据平面的部分】</em></li><li><em>路由：使用路由算法决定分组从发送主机到目标接收主机的路径【全局的功能】【控制平面的部分】</em></li></ul><p><strong><em>2.网络层：数据平面、控制平面</em></strong><br><code>数据平面：</code> </p><ul><li><em>路由器本地动作</em></li><li><em>根据路由表，将分组从输入端口转发到合适的输出端口【路由表和转发表是控制平面的路由选择协议实体算出来的】</em></li></ul><p><code>控制平面：</code></p><ul><li><em>网络范围内的逻辑</em></li><li><em>决定数据报从源到目标主机的端到端路径</em></li><li><em>2个控制平面方法：传统方法、SDN方法(software-define-networking)</em><ul><li><em>传统方法：运行在每一台路由器本地中</em></li><li><em>SDN方法：在远程服务器中实现</em></li></ul></li></ul><p><strong><em>3.控制平面两个方法</em></strong></p><blockquote><p><em>传统方式—每路由控制平面</em></p></blockquote><ul><li><em>传统方式下，每个路由器，即实现了控制平面功能，又实现了数据平面功能</em></li><li><em>每台路由器中的路由选择算法与其他路由器中的路由选择算法相互通信, <strong>计算出路由表和转发表</strong></em></li><li><em>这种方式使得路由器的控制平面与数据平面相互紧紧耦合，带来的问题是，改变路由运行逻辑变得非常困难</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051337186.png" alt="image.png"></li></ul><blockquote><p><em>SDN方式—集中逻辑的控制平面</em></p></blockquote><ul><li><em>将控制平面从路由器物理上剥离开，在远程服务器中集中实现。在远程控制器中计算和分发转发表，以提供给每台路由器</em></li><li><em>计算、转发、远程控制器，是由软件实现，所以是集中式，可编程的</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051345318.png" alt="image.png"></p><p><strong><em>4.SDN方式控制平面的组成</em></strong><br><em>远程控制器中包括：</em></p><ul><li><em>SDN控制器</em></li><li><em>网络控制应用程序</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051351391.png" alt="image.png"></li></ul><p><strong><em>5.SDN控制器的三个层次</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051357037.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051359025.png" alt="image.png"></p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a><em>IP数据报</em></h2><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a><em>IP数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071000263.png" alt="image.png"></p><ul><li><p><em>网络层的传输单位是数据报，，网络层主要用到的协议是IP协议，IP协议的数据报格式如下</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071001404.png" alt="image.png"></p></li><li><p><em>首部长度4bit,从 0011~1111(5~15)，单位是4B，也就是首部长度最小5x4B=20B,最大15x4B=60B</em></p></li><li><em>协议部分，字段值不同，代表不同数据部分协议【注意是数据部分协议，网络层之上的协议】【TCP协议：面向连接服务，字段值6；UDP：不面向连接服务，字段值17】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071013525.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071017094.png" alt="image.png"></p><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a><em>IP数据报分片</em></h3><blockquote><p><em>为什么要分片？</em></p></blockquote><ul><li><em>数据链路层是对IP数据报进行封装成帧，但是帧有最大传输单元MTU，如果IP数据报/分组，大于MTU,怎么办？</em><br><em>所以需要对IP数据报进行<strong>分片</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071038656.png" alt="image.png"></li></ul><blockquote><p><em>数据报分片例子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034403.png" alt="image.png"></p></blockquote><ul><li><em>最大数据报片&lt;=1420B </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034753.png" alt="image.png"></li></ul><h2 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a><em>IPV4地址</em></h2><ul><li><em>一个路由器会连接很多个主机，一个主机对应路由器一个接口(有线或无线接口)，每个接口都会分配一个唯一的ip地址</em></li><li><em>ip地址都是32bit的标识符，采用点分十进制，每一个字节，用点隔开，并且<br>每个字节的数字都是用十进制表示</em></li><li><em>IP 地址包括两部分：网络 ID（网络地址） + 主机 ID（主机地址）<br>网络 ID 用于不同网络寻址； 主机 ID 用于局域网内通讯</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071522558.png" alt="image.png"></li></ul><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a><em>IP地址的分类</em></h3><p><em>根据 IP 地址(二进制下)前缀数字的不同情况，划分为 A,B,C,D,E 5个类别，如下图  （本文我们主要介绍 A,B,C 三类）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt="image.png"></p><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a><em>A类地址</em></h4><ol><li>第 1 字节为网络地址，其他 3 字节为主机地址，第 1 个字节第一位固定为0    </li><li>网络号范围： 1.0.0.0 - 126.0.0.0</li><li>包含私有地址和保留地址<ul><li>私有网络号：10 （局域网中使用的网络地址）（网段1个）</li><li>保留地址：127.X.X.X</li></ul></li><li>主机数量：千万台</li></ol><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a><em>B类地址</em></h4><ol><li>第 1.2 字节为网络地址，其他为主机地址，第 1 个字节前两位固定为 10</li><li>网络号范围：128.0.0.0 - 191.255.0.0</li><li>包含私有地址和保留地址<ul><li>私有网络号：172.16—172.31 （网段16个）</li><li>保留地址：169.254.X.X （IP 地址为自动获取，且无可用 DHCP 服务时，分         配该地址）</li><li>广播地址：191.255.255.255</li></ul></li><li>主机数量：最大 65534 台</li></ol><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a><em>C类地址</em></h4><ol><li>第 1.2.3 字节为网络地址，第 4 字节为主机地址，第 1 个字节前三位固定110</li><li>网络号范围：192.0.0.0—223.255.255.0</li><li>包含私有地址和保留地址<ul><li>私有网络号 ：192.168.0~192.168.255 网段共255个</li></ul></li><li>主机数量：最大 254 台</li></ol><p><code>*网段个数，代表某类ip地址网络号有几种分法*</code></p><h4 id="特殊用途ip地址"><a href="#特殊用途ip地址" class="headerlink" title="特殊用途ip地址"></a><em>特殊用途ip地址</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630383.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131622431.png" alt="image.png"></p><ul><li><em>A类可用的网络号：1~126</em></li><li><em>B类可用的网络号：128.1~191.255</em></li><li><em>C类可用的网络号：192.0.1~223.255.255</em></li><li><em>主机号要减去全0，全1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630367.png" alt="image.png"></li></ul><h4 id="私有ip"><a href="#私有ip" class="headerlink" title="私有ip"></a>私有ip</h4><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="图片alt"> </p><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a><em>NAT网络地址转换</em></h2><blockquote><p><em>内网ip,不能直接与外网通信</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="image.png"></p><blockquote><p><em>NAT转换</em></p></blockquote><ul><li><em>需要通过NAT转换，将内网ip（专用网/私有ip地址）以及端口号，通过路由器 按照NAT转换表 转换为路由器的公网ip地址和端口号，才能与外部通信</em></li><li><em>NAT路由器一般只有1个公网ip，所以内网的主机公用一个公网ip</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071707488.png" alt="image.png"></li></ul><blockquote><p><em>什么时候需要NAT转发？什么时候不需要？</em></p></blockquote><ul><li><em>当申请的网络号是公网网络号，那么其下的ip都是公网ip，就不需要再对其NAT转换</em></li><li><em>当使用的都是专用网络，内网网络号，那么其下的都是私有ip，也就需要保证，路由器拥有至少一个公网ip，通过NAT转换与外部通信</em></li></ul><h2 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a><em>子网划分与子网掩码</em></h2><blockquote><p><em>什么是子网？</em></p></blockquote><p><strong><em>子网或子网络是大型网络内的较小网络。子网划分使网络路由更加高效。</em></strong></p><blockquote><p><em>为什么要划分子网？</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">详细概述：</span><br><span class="line">首先，先明白网络广播的基本概念，本网段向本网络的所有节点发送数据包，所有节点都会收到，但往往只有一个节点是需要这个数据包的，因此广播的过程会很浪费的占用一部分网络资源。因此划分子网的一个最为重要意义就在于减少网络广播所带来的负面影响，提高性能的整体性能。因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户数少了，当然所占用的资源也就少了。</span><br><span class="line"></span><br><span class="line">其次，这节省了IP地址的资源。这看似于前面介绍的连接主机数减少相矛盾，其实这要看具体的情况来定。对本省规模较大网络（200个用户以上），划分子网后，可用的IP地址数减少了。但如果是那些小型的企业网络来哦说，划分子网后又可以节省大量的IP地址资源。比如现在学校有四个机房，每个机房25台电脑，如果直接分配四个C类地址字段，每个机房一个。虽然这样做理论上没有错，但实际上你一共浪费了（254-25）*4=916个IP地址（全0全1不取,故256-2=254）。如果公用网络都这样分配IP地址，那么IP地址资源早就枯竭了。</span><br><span class="line"></span><br><span class="line">另外，不同的子网之间是不能直接通信的，需要借助路由器或网关。而且网络规模小了是相对较安全的，比如财政部门。而且较小的网络也比较容易部署特定的安全政策，而网络规模大了这些政策可能会影响到其他普通用户的工作。还有一个优点就是便于维护，当某个网点要查找故障的时候，网络规模小了，更容易查找到错误网络。</span><br><span class="line"></span><br><span class="line">需要注意的一点就是，划分子网也是有一些弊端的，一方面就是：可连接的主机数减少，这对于网络规模小的网点没有影响，但如果网络规模大，他们就必须划分为多个子网，如果它们需要进行频繁的通信的话就需要总是借助路由器或网关，会影响工作效率。另一方面就是：各个相对对立的网点，主机号0和1是不能取的，需要留给网络地址和广播地址。因此每多一个子网，就必须浪费两个IP地址（当然，这问题不大。）。</span><br><span class="line">总结：划分子网并不适用于所有网络，对于各部门间工作相对独立的企业或行业来说，划分子网还是可取的。而对于那些IP资源本来就不是很够，各部门间的联系又非常紧密的则最好不划分子网。</span><br></pre></td></tr></table></figure><blockquote><p><em>什么是子网掩码？</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071832869.png" alt="image.png"></p><blockquote><p><em>子网划分</em></p><ul><li><em>采用B类ip地址，该申请的网络号为145.13</em></li><li><em>由于</em></li><li><em>内部再划分子网，其中一个子网网络地址为145.13.3</em></li><li><em>这个子网里有多台主机，(子网网络地址+主机号)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071821362.png" alt="image.png"></li></ul></blockquote><ul><li><em>子网的划分实际上就是将<code>二级ip地址</code>,将原本主机号，借用若干位，作为子网号—&gt;<code>三级ip地址</code></em></li><li><em>在两级IP地址两个字段的基础上新增一个<code>子网号字段</code></em></li><li><em>划分子网纯属是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg.  对外表现ip为141.14.72.24【这是一个B类ip地址，网络地址为141.14.0.0,后面是主机号】</span><br><span class="line"></span><br><span class="line">假如子网掩码是：</span><br><span class="line">255.255.192.0</span><br><span class="line">11111111 11111111 11000000 00000000</span><br><span class="line">可以看出，该子网是借用了2bit作为子网号，后面14bit才是主机号 </span><br><span class="line"></span><br><span class="line">141.14.72.24</span><br><span class="line">10001101 00001110 01001000 00011000</span><br><span class="line">与子网掩码相与，得到的子网网络地址就是：</span><br><span class="line">141.14.64.0</span><br><span class="line">10001101 00001110 01000000 00000000</span><br><span class="line">主机号是子网号后面14bit：</span><br><span class="line">2072</span><br><span class="line">001000 00011000</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071834346.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071846600.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072115836.png" alt="image.png"></p><h2 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h2><p>CIDR（Classless Inter-Domain Routing）无分类域间路由选择</p><p>划分子网在一定程度上缓解了因特网发展中遇到的困难，但其仅仅是对分类编址方式的改进，A、B、C类IP网络号都为8的倍数，其划分不够精细，存在很大程度的浪费，基于此，无分类编址方式CIDR应运而生。</p><h3 id="分类编址的问题"><a href="#分类编址的问题" class="headerlink" title="分类编址的问题"></a>分类编址的问题</h3><p>1992年因特网面临三个必须尽早解决的问题</p><ol><li>B类地址在1992年分配了近一半，眼看很快就将全部分配完毕</li><li>因特网主干网上的路由表中的项目数急剧增长（由几千个增长至几万个）</li><li>整个IPV4的地址空间最终将全部耗尽，在2011年2越3日，IANA宣布IPV4地址已经耗尽了</li></ol><p>IETF研究采用无分类编址的方法来解决前两个问题，其认为第三个问题属于更加长远的问题，因此专门成立IPV6工作组负责研究新版本IP协议的问题</p><h3 id="CIDR最主要的两个特点"><a href="#CIDR最主要的两个特点" class="headerlink" title="CIDR最主要的两个特点"></a>CIDR最主要的两个特点</h3><ul><li><strong>CIDR消除了传统的A类、B类和C类地址及划分子网的概念</strong>，因此可以更加有效地分配IPv4的地址空间，并且在新的IPv6使用前容许因特网的规模继续增长</li></ul><blockquote><p>CIDR把32位的IP地址划分为两个部分，前面的部分是网络前缀，用来指明网络，后面的部分则用来指明主机，其与分类编址最大的不同，便是网络前缀不局限于8的倍数。因此CIDR使IP地址从三级编址（使用子网掩码）又回到两级地址，但这已经是无分类的两级编址。CIDR在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。<br>IP地址 :: = {&lt;网络前缀&gt;，&lt;主机号&gt;}</p></blockquote><ul><li><strong>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”</strong>。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（最小地址）和终止地址（最大地址），以及地址块中的地址数。</li></ul><blockquote><p>例如，已知IP地址为128.14.35.7/20是某CIDR地址块中的一个地址，现在把它写成二进制形式，其中前20位是网络前缀，而后面的12位是主机号：<br>128.14.35.7/20 = <strong>10000000 00001110 0010</strong>0011 00000111<br>这个地址块的最小地址为：<strong>10000000 00001110 0010</strong>0000 00000000<br>这个地址块的最大地址为：<strong>10000000 00001110 0010</strong>1111 11111111</p></blockquote><h3 id="CIDR的地址掩码"><a href="#CIDR的地址掩码" class="headerlink" title="CIDR的地址掩码"></a>CIDR的地址掩码</h3><p>为了更方便地进行路由选择，CIDR使用32位的地址掩码（address mask）。地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR不使用子网了，但由于目前一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码</p><blockquote><p>例如，/20地址块的地址掩码是：11111111 11111111 11110000 00000000（20个连续的1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数</p></blockquote><h3 id="CIDR不划分子网的理解"><a href="#CIDR不划分子网的理解" class="headerlink" title="CIDR不划分子网的理解"></a>CIDR不划分子网的理解</h3><p>另外，“CIDR不使用子网”，是指<strong>CIDR中并没有在32位地址中指明若干位作为子网字段。但分配到一个CIDR地址块的单位</strong>仍然可以在本单位内根据需要划分出一些子网。<strong>这些子网也都只有一个网络前缀和一个主机地址号，但子网的网络前缀比整个单位的网络前缀要长一些</strong></p><blockquote><p>例如，某单位分配到地址块/20，就可以继续划分为8个子网（即需要从主机号中借用3位来划分子网）。这时，每一个子网的网络前缀就变成23位（原来的20位加上主机号借来的3位），比该单位的网络前缀多了3位</p></blockquote><h3 id="路由聚合的概念"><a href="#路由聚合的概念" class="headerlink" title="路由聚合的概念"></a>路由聚合的概念</h3><p>由于一个CIDR地址块有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合（Route aggregation）,它使得路由表中的一个项目可以表示原来传统分类网络地址的很多个路由。路由聚合也称为构成<strong>超网（supernettig）</strong></p><blockquote><p>如果没有采用CIDR，则在1994年和1995年，因特网一个路由器就回超过7万个项目，而使用了CIDR以后，在1996年一个路由表的项目数菜只有3万多个。路由聚合有利于减少路由器之间的路由选择信息交换，提高整个网络性能</p></blockquote><p><img src="https://s1.ax1x.com/2018/11/19/FpQmUx.jpg#shadow" alt=""></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><h4 id="最长前缀匹配的概念"><a href="#最长前缀匹配的概念" class="headerlink" title="最长前缀匹配的概念"></a>最长前缀匹配的概念</h4><p>在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要做相应的改变。这时，每个项目由<br><strong>“网络前缀”  和  下一跳地址</strong>组成。但是在<strong>查找路由表时可能得到不止一个匹配结果</strong>。这样就带来一个问题：我们应当从这些匹配的结果中选择哪一条路由呢？</p><p>正确的答案是：<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫作最长前缀匹配（longest-prefix matching）,这时因为网络前缀越长，其地址块就越小（因为主机位数越少），因而路由就越具体。最长前缀匹配又称为<strong>最佳匹配或最长匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg.路由器接收到一个分组R0,它的目的ip地址是132.19.237.5</span><br><span class="line">路由器路由表包含5个目的网络号分别是</span><br><span class="line">132.0.0.0/8   </span><br><span class="line">【前8位是网络前缀，地址掩码11111111 000000000 00000000 00000000】 </span><br><span class="line">132.0.0.0/11</span><br><span class="line">【前11位是网络前缀，地址掩码11111111 11100000 00000000 00000000】</span><br><span class="line">132.19.232.0/22</span><br><span class="line">【前22位是网络前缀，地址掩码11111111 11111111 11111100 00000000】</span><br><span class="line">0.0.0.0/0</span><br><span class="line">【这是默认路由，所有目的网络都不匹配的时候走这里】</span><br><span class="line"></span><br><span class="line">目的ip地址是132.19.237.5</span><br><span class="line">10000100 00010011 11101001 00000101</span><br><span class="line">与上述子网掩码与运算后，匹配的网络地址是</span><br><span class="line">132.0.0.0/8  和 132.0.0.0/11</span><br><span class="line">但是按照最长路由前缀匹配，应该选择走132.0.0.0/11这个网络</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081951285.png" alt="image.png"></p><h4 id="依据地址位置划分地址快"><a href="#依据地址位置划分地址快" class="headerlink" title="依据地址位置划分地址快"></a>依据地址位置划分地址快</h4><p>如果IP地址的分配从一开始就采用CIDR，那么我们可以按网络所在的地理位置来分配地址块，这样就可以大大减少路由表中的项目数</p><blockquote><p>例如，可以将世界划分为四大地区，每一个地区分配一个CIDR地址块：<br>地址块194/7(194.0.0.0至195.255.255.255)分配给欧洲<br>地址块198/7(198.0.0.0至199.255.255.255)分配给北美洲<br>地址块200/7(200.0.0.0至201.255.255.255)分配给中美洲和南美洲<br>地址块202/7(202.0.0.0至203.255.255.255)分配给亚洲和太平洋地区</p></blockquote><p>上面一个地址块包含约3200万个地址($2^{32}-7$)。这种分配方法使得IP地址与地理位置关联，它的好处是可以大大压缩路由表中的项目数。例如从中国发往北美的数据报（不管它是地址块198/7中的哪一个地址）都先送到美国的一个路由器，因此在路由表中使用一个项目就行了。<br>  但是，在使用CIDR之前，因特网的地址管理机构并没有按照地理位置来分配IP，现在要把已分配的IP地址回收再重新分配是十分困难的事情，因为这牵涉很多正在工作的主机必须改变其IP地址。<strong>所以基于地址位置划分地址块仅仅停留在想法</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><mark>网络层协议</mark></p><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p>完成主机或路由器IP地址到MAC地址的映射，解决下一跳走哪的问题</p><blockquote><p><strong>*由于实际网络链路中，传送数据帧时，必须使用MAC地址</strong>，<br>例如：在一个局域网内，所有设备使用同一套链路，主机A想要向同一个网段下的主机B,在数据链路上发送数据帧，肯定需要在帧头加上源MAC地址和目的MAC地址，但是如果主机A不知道主机B的目的MAC地址怎么办？这就需要先检查<strong>ARP高速缓存</strong>，检查是否有主机B的IP地址与MAC地址的映射，如果有，则直接将主机B的MAC地址封装上数据帧，放到链路上传输；如果没有，那么就需要使用ARP协议，主机A向局域网内所有设备广播ARP请求的分组，<strong>同一局域网内所有主机收到该请求</strong>，当主机B收到这个请求分组，发现目的IP就是自己的IP地址，就会向主机A 单播返回一个 带有IP和MAC地址的分组，A得到B的响应，立刻将主机B的ip和MAC地址的映射项写入ARP缓存（<strong>10-20min更新一次</strong>），然后主机A就能向帧头加上目的MAC地址放到链路上传送了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082116250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082127346.png" alt="image.png"></p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p><mark>应用层协议</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt="image.png"></p><h3 id="主机如何获取ip地址？"><a href="#主机如何获取ip地址？" class="headerlink" title="主机如何获取ip地址？"></a><strong><em>主机如何获取ip地址？</em></strong></h3><ul><li><em>动态分配</em></li><li><em>静态分配</em></li></ul><h3 id="什么是动态分配DHCP协议？"><a href="#什么是动态分配DHCP协议？" class="headerlink" title="什么是动态分配DHCP协议？"></a><strong><em>什么是动态分配DHCP协议？</em></strong></h3><p><strong><em>DHCP协议是应用层协议，使用UDP传送</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091011931.png" alt="image.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><mark>网络层协议</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt=""></p><h3 id="什么是ICMP"><a href="#什么是ICMP" class="headerlink" title="什么是ICMP?"></a><em>什么是ICMP?</em></h3><p>ICMP，全称是 Internet Control Message Protocol，即互联网控制报文协议，所谓控制，就是通过下发指令来感知和控制网络环境，所以它一定是配合一个无法感知网络环境的协议来工作的，这个协议就是 IP(包括 IPv4 和 IPv6)。</p><p>所以，ICMP 通常被认为是 IP 协议的一部分，它封装在 IP 层中，使用 IP 协议进行传输。因此，严格来说，<strong><em>ICMP 既不是一个网络层协议，也不是一个传输层协议，而是介于两者之间的一个协议。但是一般认为属于网络层协议</em></strong></p><p>它的主要功能是传输网络诊断信息，信息主要包括两类：</p><ul><li>一类是 查询类报文 ：主要用于信息的查询和采集，比如采集传输路径上的每个路由器都是谁，本次传输的报文是否达到目的地等等。</li><li>另一类是 差错诊断类报文 ：主要用于诊断网络故障，比如传输报文被丢弃的原因是什么等等。</li></ul><h3 id="为什么需要ICMP？"><a href="#为什么需要ICMP？" class="headerlink" title="为什么需要ICMP？"></a><em>为什么需要ICMP？</em></h3><p>我们都知道，<strong><em>IP 协议是一个不可靠协议</em></strong>，如果 IP 包在传输过程中出现错误，比如 checksum 对不上，拥塞，超时等等，那么 IP 包是会直接被丢弃的，之后也不会有进一步的努力来修正。</p><p>这是 IP 协议的一个设计准则决定的，也就是 best effort，尽力而为，这样的好处是让 IP 协议尽量保持简单的形态，只负责有效率的数据传输，而更多的质量控制交给高层的协议去处理(比如 TCP)。</p><p>但高层能提供质量控制的协议毕竟在少数，所以就需要在下层有协议来辅助 IP 完成必要的网络质量管理。ICMP 协议自然就被提出来了。</p><p>通过 ICMP 协议，当 IP 包发生错误的时候，上层发送 IP 包的主机或路由器并不知道下层发生了错误，这个时候，下层的主机或路由器就可以通过发送 ICMP 包，将错误信息汇报给上层，从而让上层的主机或路由器进行调整。</p><p>不过需要注意的是，<strong><em>ICMP 仅仅只能提供某些特定类型的错误信息汇报，并不能帮助 IP 协议成为可靠的协议</em></strong>。它能做的事还是有限，但用于基本的网络质量管理是足够了。</p><h3 id="ICMP应用场景"><a href="#ICMP应用场景" class="headerlink" title="ICMP应用场景"></a><em>ICMP应用场景</em></h3><h4 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a><strong>错误报告</strong></h4><p>ICMP 错误消息报告网络错误，例如目的地不可达、超时或分段问题。这些消息对于具有无连接通信模型的用户数据报协议 (UDP) 尤其重要。</p><p>UDP 不提供可靠、有序的数据包传输。发送 UDP 数据包时，数据包可能会丢失，也可能在传送时出现校验和错误等故障。如果发生这种情况，接收方会将 ICMP 错误报告消息发回给发送方，以通知该问题。</p><h4 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a><strong>诊断</strong></h4><p>您可以使用 ICMP 进行网络诊断。它最常用于 <strong><em>ping 和 traceroute</em></strong> 命令。</p><ul><li><p><strong><em>ping 命令通过向目标设备发送 ICMP 回显请求数据包来测试网络设备的可访问性</em></strong>。如果设备可以访问，则会返回 ICMP 回显回复。它可以可靠地检查网络延迟并确保设备可用。</p></li><li><p><strong><em>traceroute 命令跟踪数据包从源到目的地所采用的路径</em></strong>。为此，该命令将回显请求和回显回复消息发送到预定目的地。</p></li></ul><blockquote><p>例如：回显请求包含一个生存时间 (TTL) 值，数据包每通过一个路由器，该值就会减 1。当数据包到达 TTL 为零的路由器时，路由器会向源端发送一条 ICMP 消息。该消息包含有关数据包所采用路由的信息。Traceroute 会显示数据包的确切路径，可以为您提供网络性能详情。</p></blockquote><h3 id="ICMP报文格式长啥样？"><a href="#ICMP报文格式长啥样？" class="headerlink" title="ICMP报文格式长啥样？"></a><em>ICMP报文格式长啥样？</em></h3><ul><li><em>【注意区分，报文是数据部分，报文在网络层封装成IP数据报】</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091035923.png" alt="image.png"></p><p>如下图所示，ICMP 报文是被封装在 IP 数据报中传输的。</p><p>IP 报头中的 Protocol 字段为 1 即表示该报文携带的是 ICMP 报文。(此处只是为了说明问题，因此 IP 报头是简化了的)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091057587.png" alt="image.png"></p><p>进一步看，ICMP 报头为 4 个字节：</p><ul><li>类型 type：占 1 个字节，表示较大范围类型分类的 ICMP 报文</li><li>代码 code：占 1 个字节，表示较小范围类型分类的 ICMP 报文(type的细分)</li><li>校验和 checksum：占 2 个字节，ICMP checksum 的计算方法类似于 IP checksum，但是不同的是 IP 只校验头部，ICMP 校验头部+数据部分</li></ul><p>后面紧接的 ICMP 数据部分，根据前面的类型和代码字段的不同，具有不同的内容。</p><h3 id="ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】"><a href="#ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】" class="headerlink" title="ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】"></a><em>ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】</em></h3><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a><em>ICMP差错报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091033395.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091104579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091105405.png" alt="image.png"></p><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a><em>ICMP询问报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091106410.png" alt="image.png"></p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="为什么需要IPV6？"><a href="#为什么需要IPV6？" class="headerlink" title="为什么需要IPV6？"></a><em>为什么需要IPV6？</em></h3><p><em>IPv4地址采用32比特标识，理论上能够提供的地址数量是43亿（由于地址分配的原因，实际可使用的数量不到43亿）。另外，IPv4地址的分配也很不均衡：美国占全球地址空间的一半左右，而欧洲则相对匮乏；亚太地区则更加匮乏。与此同时，移动IP和宽带技术的发展需要更多的IP地址。目前IPv4地址已经消耗殆尽。针对IPv4的地址短缺问题，也曾先后出现过几种解决方案。比较有代表性的是无类别域间路由CIDR（Classless Inter-Domain Routing）和网络地址转换NAT（Network Address Translator）。但是CIDR和NAT都有各自的弊端和不能解决的问题，由此推动了IPv6的发展。</em></p><p><strong><em>IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</em></strong></p><h3 id="IPV6地址表示方法"><a href="#IPV6地址表示方法" class="headerlink" title="IPV6地址表示方法"></a><em>IPV6地址表示方法</em></h3><ol><li><p><em>IPv6地址总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。例如：FC00:0000:130F:0000:0000:09C0:876A:130B，这是IPv6地址的首选格式。</em></p></li><li><p><em>为了书写方便，IPv6还提供了<strong>压缩格式</strong>，以上述IPv6地址为例，具体压缩规则为：</em></p><ul><li><em>每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876A:130B</em></li><li><em>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，所以上述地址又可以进一步简写为：FC00:0:130F::9C0:876A:130B。</em></li><li><em>需要注意的是，<strong>在一个IPv6地址中只能使用一次双冒号“::”</strong>，否则当计算机将压缩后的地址恢复成128位时，无法确定每个“::”代表0的个数</em></li></ul></li></ol><h3 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a><em>IPv6数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091306357.png" alt="image.png"></p><h3 id="IPV6与IPV4对比"><a href="#IPV6与IPV4对比" class="headerlink" title="IPV6与IPV4对比"></a><em>IPV6与IPV4对比</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091307625.png" alt="image.png"></p><h3 id="IPV4向IPV6过渡"><a href="#IPV4向IPV6过渡" class="headerlink" title="IPV4向IPV6过渡"></a><em>IPV4向IPV6过渡</em></h3><ul><li><strong>*双栈技术</strong>：主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。*</li></ul><blockquote><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p></blockquote><ul><li><strong>*隧道技术</strong>：在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。*</li></ul><blockquote><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091308688.png" alt="image.png"></p><h2 id="路由算法与路由选择协议概述"><a href="#路由算法与路由选择协议概述" class="headerlink" title="路由算法与路由选择协议概述"></a><em>路由算法与路由选择协议概述</em></h2><blockquote><p><em>路由算法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062114988.png" alt="image.png"></p><blockquote><p><em>路由算法分类</em></p></blockquote><ul><li><em>静态路由算法（非自适应路由算法）：管理员手动配置路由信息</em></li><li><em>动态路由算法（自适应路由算法）：路由器彼此交换信息，自行优化路由表</em><ul><li><em>全局性算法：链路状态路由算法OSPF</em><br>  <em>所有路由器掌握完整的网络拓扑和链路费用</em></li><li><em>分散性算法：距离向量路由算法RIP</em><br>  <em>路由器只掌握物理相连的邻居及链路费用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062115290.png" alt="image.png"></li></ul></li></ul><blockquote><p><em>分层次的路由选择协议</em></p></blockquote><ul><li><strong>*路由选择协议需要分层次</strong><br>1.因为因特网规模大 2.因为许多单位不想让外界知道自己的路由选择协议<em></em>所以就分为多个自治系统AS，并且将不同自治系统可以使用不同协议<em></em>一个AS内使用的RIP、OSPF协议；AS与AS之间使用的BGP协议*</li><li><strong>*自治系统AS</strong>：<br>是单一的技术管理下的一组路由器（这些路由器使用一种AS内部的路由选择协议）；互联网是一个由网络组成的网络。它由成千上万个被称为“自治系统”（autonomous system，AS）的更小网络组成。这些网络中的每一个实际上就是由单一组织运行的一个大型路由器池。如果我们继续将 BGP 比作互联网的邮政服务，那么自治系统就相当于各邮政分局。一个城镇可能有数百个邮箱，但邮箱中的所有邮件都必须先经过本地邮政分局，然后再运送到另一个目的地。自治系统中的内部路由器就好比邮箱。它们将出站流量路由到自治系统，然后使用 BGP 路由将这些流量传输到其目的地。*</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062122986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062126920.png" alt="image.png"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a><em>RIP协议及距离向量算法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835341.png" alt="image.png"></p><h4 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a><em>RIP协议报文格式</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议，使用UDP传输数据</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091945467.png" alt="image.png"></p><h4 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a><em>什么是RIP协议？</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议</strong>，是一种<strong>分布式的基于距离向量的路由选择协议</strong>适用于与比较小的网络</em></p></blockquote><p><em>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</em><br><em>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></em></p><p><em>路由表有三项：目的网络、距离、下一条路由器</em></p><ul><li><strong>*目的网络</strong>：通过该路由器能够到达的网络*</li><li><strong>*距离</strong>：该路由器到达目的网络的最佳距离（跳数）*</li><li><strong>*下一跳路由器</strong>：如果要走这样的最佳距离，需要走过的下一跳路由器<em></em>【直接交付，是指目的网络和该路由器直接相连的】*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091606961.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091718131.png" alt="image.png"></p><h4 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点"></a><em>RIP协议的特点</em></h4><ol><li><em>仅和<strong>相邻路由器</strong>交换信息。</em></li><li><em>交换的信息是当前本路由器所知道的全部信息，即<strong>自己的路由表。</strong></em></li><li><em>按固定的时间间隔交换路由信息，例如，<strong>每隔 30 秒</strong>。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息（当链路有变化，就不等30s了，比如某个网段不存在了，会立刻告诉。）</em></li></ol><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a><em>距离向量算法</em></h4><p><em>在RIP协议相邻路由器互相交换路由表之后，如何处理，才能得到到达某一个网络的最短距离？这就是距离向量算法所解决的问题</em></p><ol><li><em>修改相邻路由器发来的RIP报文中 <strong>所有表项。</strong><br> 对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离” 字段 +1。</em></li><li><em>对修改后的RIP报文中的每一个项目，进行以下步骤：</em><br> <em>（1）R1路由表中若没有Net3，则把该项目填入R1路由表</em><br> <em>（2）R1路由表中若有Net3，则查看下一跳路由器地址：</em><ul><li><em>若下一跳是X，则用收到的项目替换源路由表中的项目；</em></li><li><em>若下一跳不是X， 原来距离比从X走的距离远则更新，否则不作处理。</em></li></ul></li><li><em>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</em></li><li><em>返回</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091734766.png" alt="image.png"></li></ol><blockquote><p><em>距离向量算法例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091737534.png" alt="image.png"></p><p><strong><em>解析：</em></strong><br><em>来自B的向量为（5，0，8，12，6，2）；<br>其数字分别对应路由器C通过B 到达(A，B，C，D，E，F) 路由器的距离，<br>由于还有C到B的延迟6,所以每个分量还需要+6；其他的同理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091738922.png" alt="image.png"></p><h4 id="好消息穿的快，坏消息传的慢"><a href="#好消息穿的快，坏消息传的慢" class="headerlink" title="好消息穿的快，坏消息传的慢"></a><em>好消息穿的快，坏消息传的慢</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835185.png" alt="image.png"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><em>OSPF协议及链路状态算法</em></h3><h4 id="OSPF分组格式"><a href="#OSPF分组格式" class="headerlink" title="OSPF分组格式"></a><em>OSPF分组格式</em></h4><blockquote><p><em>注意：OSPF协议是<strong>网络层协议，使用IP数据报传输数据</strong>OSPF协议是不使用UDP数据报传送，而是直接使用IP数据报传送，因此OSPF是被划分到属于网络层协议-这一点考研党要以考纲为标准）<em>**</em></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091941328.png" alt="image.png"></p><h4 id="为什么会有OSPF协议？"><a href="#为什么会有OSPF协议？" class="headerlink" title="为什么会有OSPF协议？"></a><em>为什么会有OSPF协议？</em></h4><p><em>开放式最短路径优先OSPF（Open Shortest Path First）协议是IETF定义的一种<strong>基于链路状态的内部网关路由协议</strong>。</em></p><p><em>为什么会出现OSPF？:因为<strong>RIP是一种基于距离矢量算法的路由协议</strong>，存在着</em></p><ul><li><strong>收敛慢；</strong></li><li><strong>易产生路由环路；</strong></li><li><strong>可扩展性差，最大只能支持15跳。</strong></li></ul><p><em>OSPF的出现很好地解决了上述3个问题</em></p><h4 id="OSPF协议的特点"><a href="#OSPF协议的特点" class="headerlink" title="OSPF协议的特点"></a><em>OSPF协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091934529.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935354.png" alt="image.png"></p><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a><em>链路状态路由算法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935933.png" alt="image.png"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a><em>BGP协议</em></h3><h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a><em>BGP协议报文格式</em></h4><blockquote><p><em>注意：BGP协议是<strong>应用层协议，使用TCP传送</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091948118.png" alt="image.png"></p><h4 id="什么是BGP协议？"><a href="#什么是BGP协议？" class="headerlink" title="什么是BGP协议？"></a><em>什么是BGP协议？</em></h4><p><em>边界网关协议 (BGP) 就是互联网的邮政服务。当有人把一封信投进邮筒时，邮政服务就会处理这封邮件，并选择一条快速、高效的路线将这封信投递给收件人。同样地，当有人通过互联网提交数据时，BGP 负责寻找数据能传播的所有可用路径，并选择最佳的路由，这通常意味着在自治系统之间跳跃。</em></p><h4 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a><em>BGP协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092009810.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092010645.png" alt="image.png"></p><h4 id="BGP协议交换信息过程"><a href="#BGP协议交换信息过程" class="headerlink" title="BGP协议交换信息过程"></a><em>BGP协议交换信息过程</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011121.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011023.png" alt="image.png"></p><h4 id="BGP协议四种报文"><a href="#BGP协议四种报文" class="headerlink" title="BGP协议四种报文"></a><em>BGP协议四种报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092012373.png" alt="image.png"></p><h3 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a><em>三种路由协议的比较</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013263.png" alt="image.png"></p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a><em>IP组播</em></h2><h3 id="IP网络的3种数据传输方式"><a href="#IP网络的3种数据传输方式" class="headerlink" title="IP网络的3种数据传输方式"></a><em>IP网络的3种数据传输方式</em></h3><p><em>IPv4协议定义了三种IP数据包的传输方式：单播（unicast）、广播（broadcast）和组播（multicast）。通过对三种包传播方式比较式介绍，可以看到组播方式的优越性。</em><br><em>组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用。它是实现高效局域网组播的重要标识。</em></p><p><strong><em>1.单播方式</em></strong><br><em>单播（Unicast）是在一台源IP主机和一台目的IP主机之间进行。网络上绝大部分的数据都是以单播的形式传输的，例如电子邮件收发、网上银行都是采用单播实现的。</em></p><ul><li><em>一份单播报文，使用一个单播地址作为目的地址。Source向每个接收者发送一份独立的单播报文。如果网络中存在N个接收者，则Source需要发送N份单播报文</em></li><li><em>网络为每份单播报文执行独立的数据转发，形成一条独立的数据传送通路。N份单播报文形成N条相互独立的传输路径</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单播缺点：</span><br><span class="line">1.重复流量过多（每有一个用户就要发送一份同样的数据） </span><br><span class="line">2.消耗设备和链路带宽资源（假如有一百个用户，就要发送一百份数据） </span><br><span class="line">3.难以保证传输支质量（用户数量过大时，会造成发送端和链路上的网络设备因为流量过大以及负载过高而网络瘫痪或死机）</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122114438.png" alt="image.png"></li></ul><p><strong><em>2.广播方式</em></strong><br><em>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</em></p><ul><li><em>一份广播报文，使用一个广播地址作为目的地址。Source向本网段对应的广播地址发送且仅发送一份报文。</em></li><li><em>不管是否有需求，保证报文被网段中的所有用户主机接收。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">广播缺点：</span><br><span class="line">1.地域范围限制（广播报文被限制在一个共享网段中） </span><br><span class="line">2.安全性无法保障（在该网段中所有主机都接收的到广播报文，不管是否想要接收） </span><br><span class="line">3.有偿性无法保障（计费困难）</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>3.组播方式</em></strong><br><em>组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的交换机和路由器根据接收者的需要，有选择性地对数据进行复制和转发</em></p><ul><li><p><em>组播在点对多点的应用上，结合了单播和广播的优势。组播方式下，单一的信息流沿组播分发树被同时发送给一组用户，相同的组播数据流在每一条链路上最多仅有一份。</em></p></li><li><p><em>相比单播，由于被传递的信息在距信息源尽可能远的网络节点才开始被复制和分发，所以用户的增加不会导致信息源负载的加重以及网络资源消耗的显著增加。</em></p></li><li><p><em>相比广播，由于被传递的信息只会发送给需要该信息的接收者，所以不会造成网络资源的浪费，并能提高信息传输的安全性。另外，广播只能在同一网段中进行，而组播可以实现跨网段的传输。</em></p></li></ul><h3 id="组播IP"><a href="#组播IP" class="headerlink" title="组播IP"></a><em>组播IP</em></h3><p><em>组播不可能以某一个主机的IP作为自己的目的IP，但是以太网报文在封装时必须要填入目的IP</em></p><p><em>怎么办？</em></p><p><em>回想一下，组播IP不能以某个主机的IP作为自己的目的IP，换句话说，组播IP不需要考虑主机标识，哪个类型的IP地址没有主机标识，<strong>D类</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122208049.png" alt="image.png"></p><h3 id="组播MAC"><a href="#组播MAC" class="headerlink" title="组播MAC"></a><em>组播MAC</em></h3><p><em>同样地，组播报文在数据链路层需要填充目的MAC地址，如何填充正确的MAC地址呢？</em></p><p><em>单播报文在填入目的MAC时，会通过ARP协议根据目的IP询问目的主机的MAC地址，而组播由于目的IP并不是某个主机的IP，所有无法用ARP协议询问目的MAC。既然ARP寻址方式行不通，组播MAC地址有自己的转换方式</em></p><blockquote><p>*组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用, 比如：</p><ul><li><em>服务器/工作站 - 在进行组播通信时,服务器和工作站会作为发送端或接收端使用组播MAC地址。比如视频会议软件。</em></li><li><em>游戏主机 - 一些网络游戏主机和服务也可能使用组播MAC地址</em></li></ul></blockquote><p><em>这些实现组播的设备的MAC地址，被称为组播MAC地址，它与平时我们上网网卡的单播MAC地址不同，有以下区别</em></p><blockquote><p><strong>*MAC地址的唯一性只是在单播MAC地址而言</strong>。单播MAC地址用于唯一标识一台网络设备,确实要求全球唯一。但是组播MAC地址用于支持一对多的组播通信,其地址格式规定了前24位是固定值,后24位可以配置。组播MAC地址之所以可以在多台设备上取相同的值,*</p></blockquote><ol><li>组播MAC地址只需要在局域网内的设备上唯一即可,不需要全球唯一。</li><li>组播通信需要将报文复制给多个接收端,所以不能使用唯一的MAC地址。</li><li>通过配置组播MAC的后24位,可以生成多个相同的组播MAC地址。</li><li>不同网络接口可以配置相同的组播MAC地址,以接收同一多播流。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122144515.png" alt="image.png"></li></ol><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a><em>IGMP协议</em></h3><p><em>互联网组管理协议 (IGMP) 是允许多个设备共享一个 IP 地址以便它们可以接收相同数据的协议。IGMP 是一个网络层协议，用于在使用互联网协议版本 4 (IPv4) 的网络上设置多播。具体来说，IGMP 允许设备加入一个多播组。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122211412.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122214062.png" alt="image.png"></p><h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a><em>组播路由选择协议</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122216955.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122217429.png" alt="image.png"></p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><em>移动IP</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131124271.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131125560.png" alt="image.png"></p><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a><em>网络层设备</em></h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><em>路由器</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144391.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144007.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144035.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144550.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131145981.png" alt="image.png"></p><h2 id="多层次协议汇总"><a href="#多层次协议汇总" class="headerlink" title="多层次协议汇总"></a><em>多层次协议汇总</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131528802.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><em>习题</em></h2><h3 id="网络层的功能-1"><a href="#网络层的功能-1" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h3><blockquote><p><em>网络层数据报传输是否可靠，取决于协议；如果使用有连接，有确认的协议那就是可靠传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131150887.png" alt="image.png"></p><p><em>异构网络互联：中异构网络是指，数据链路层和物理层均不同的网络</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131157448.png" alt="image.png"></p><p><em>网络拥塞是指通信子网中负载增加，随着负载增加，越来越多分组由于等待，过长会被丢弃，所以导致虽然负载增加，但是吞吐率下降</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131159040.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131416251.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131418246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131420473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131422480.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131424547.png" alt="image.png"></p><p><em>中间路由器和源主机都不知道IP分组到达目的主机需要经过的完整路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131426158.png" alt="image.png"></p><p><em>各层常用协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131455900.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131458020.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131501758.png" alt="image.png"></p></blockquote><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><em>路由算法</em></h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131506707.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131513947.png" alt="image.png"></p><p><em>OSPF协议采用Dijstra最短路径算法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131516568.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131523233.png" alt="image.png"></p></blockquote><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a><em>IPV4</em></h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131535270.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131613278.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131616022.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131621255.png" alt="image.png"></p><p><em>127开头的表示环回地址，不分配给主机；<br>主机号全0，全1也不分配<br>主机号全0，表示本网络；全1表示所有主机</em><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131625892.png" alt="image.png"></p></blockquote><ul><li><em>在所有主机都是使用公网IP时，就<strong>不需要考虑NAT转换</strong>，主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和C目的IP地址；MAC帧额外信息部分，封装A源MAC地址和路由器的MAC地址。</li><li>接着由路由器向C发送：IP数据爆首部，封装路由器自己IP(源IP)，和C的IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(y源MAC)，和C的MAC地址(目的MAC)。</li></ol></li><li><em>当主机使用的内网IP时，多台主机共享路由器的一个公网IP，<strong>需要考虑NAT转换</strong>，(假设A是外网主机，BC是内网主机)主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和路由器的IP地址【因为C的局域网IP不能通信】；MAC帧额外信息部分，封装A源MAC地址和路由器MAC地址(目的)</li><li>路由器向C发送：IP数据报首部，封装路由器自己的IP地址(源IP)，和C的内网IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(源MAC)，和C的MAC地址(目的MAC)<br>&gt;<blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131638477.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131643347.png" alt="image.png"></p></blockquote></li></ol></li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131702214.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131728805.png" alt="image.png"></p><p><em>IPV4首部，比较重要的几个字段：首部长度，单位4B；总长度，单位1B<br>片偏移，单位8B；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142150490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142153044.png" alt="image.png"></p><p><em>IP分组自能在目的主机中重组</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161537864.png" alt="image.png"></p><p><em>路由聚合，构成超网</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161619359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161643795.png" alt="image.png"></p><p><em>内部网络ip地址范围</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161717209.png" alt="image.png"></p><p><em>NAT转换表，只有当源ip地址和源端口都对应，才能转换为公网地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161736068.png" alt="image.png"></p></blockquote><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301059261.png" alt="image.png"></p><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a><em>传输层概述</em></h2><h3 id="什么是传输层？"><a href="#什么是传输层？" class="headerlink" title="什么是传输层？"></a><em>什么是传输层？</em></h3><p>传输层是只有主机才有的层次。<br><strong>传输层的功能</strong>：</p><ol><li>传输层提供进程与进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li><li>传输层的两种协议<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301103467.png" alt="图片alt"> </p></li></ol><h3 id="传输层的两个协议TCP-amp-UDP"><a href="#传输层的两个协议TCP-amp-UDP" class="headerlink" title="传输层的两个协议TCP&amp;UDP"></a><em>传输层的两个协议TCP&amp;UDP</em></h3><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301105552.png" alt="图片alt"> </p><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><em>传输层的寻址与端口</em></h3><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。<br>分用：传输层从网络层收到数据后交付指明的应用进程</p><p><mark>端口</mark>：又称为逻辑端口/软件端口，用于标识主机中的应用进程，是传输层的SAP, 与交换机路由器的物理端口不同，是一种虚拟的逻辑端口。</p><p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。<br>端口号长度为16bit,能表示65536个不同的端口号。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301113972.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;"> 熟知端口号一般是固定的，以下是一些重要的熟知端口号<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301116873.png" alt="图片alt"></p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<center><mark>套接字Socket = (主机IP地址，端口号)</mark></center></div><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><em>UDP协议</em></h2><h3 id="用户数据报协议UDP特点"><a href="#用户数据报协议UDP特点" class="headerlink" title="用户数据报协议UDP特点"></a><em>用户数据报协议UDP特点</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154002.png" alt="image.png"></p><h3 id="UDP数据报首部格式"><a href="#UDP数据报首部格式" class="headerlink" title="UDP数据报首部格式"></a><em>UDP数据报首部格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154585.png" alt="image.png"></p><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a><em>UDP校验</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301155099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301156204.png" alt="image.png"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><em>TCP协议</em></h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a><em>TCP协议特点</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301511230.png" alt="image.png"></p><blockquote><p><em>TCP是面向字节流的，会对数据的每一个字节按序编号，一个字节占用一个序号，再由多个连续字节组成一个传输单位报文</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301539150.png" alt="image.png"></p></blockquote><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a><em>TCP报文段首部格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538164.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538754.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538099.png" alt="image.png"></p><h2 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h2><h3 id="TCP头格式有哪些"><a href="#TCP头格式有哪些" class="headerlink" title="TCP头格式有哪些"></a>TCP头格式有哪些</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061654644.png" alt="image.png"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h3 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a>为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061707068.png" alt="image.png"></p><ul><li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p></li></ul><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061709234.png" alt="image.png"></p><p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061710268.png" alt="image.png"></li></ul><p>TCP是面向连接的协议，TCP把连接作为最基本的抽象。每一条TCP连接唯一地被通信两端的两个端点所确定。那么，TCP连接的端点是什么呢？TCP连接的端点又叫套接字（socket），根据TCP协议的规定，端口号拼接到IP地址即构成了套接字，即.</p><div style="background-color: #fffacd;padding:20px;"> 套接字 socket = （IP地址：端口号） </div><p>这样一来，TCP连接可以以下式子表示</p><div style="background-color: #fffacd;padding:20px;"> TCP连接 ::= {socket1, socket2} = {（IP1: port1）,（IP2: port2）}</div><p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061712887.png" alt="image.png"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><blockquote><p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p>先说说 TCP 是如何计算负载数据长度：</p><p><img src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt=""></p><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><p>大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p><p>这么一问，确实感觉 UDP 的「包长度」是冗余的。</p><p>我查阅了很多资料，我觉得有两个比较靠谱的说法：</p><ul><li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li><li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li></ul><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p>答案：<strong>可以的</strong>。</p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061716478.png" alt="image.png"></p><p>因此，TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p><mark>图1.三次握手建立TCP连接</mark></p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301730864.png" alt="图1"> </p><br>图1画出了TCP连接建立的过程。假定图中左端是客户A，右端是服务器B，一开始时，两端都处于CLOSED（关闭）状态。图中的方框分别是端点所处的状态。</p><ol><li>服务器进程准备好接受外来的连接，这通常是通过调用<code>socket</code>，<code>bind</code>，<code>listen</code>这三个函数来完成，我们称之为被动打开（passive open）。然后服务器进程就处于LISTEN状态，等待客户的连接请求，如有，则作出响应。</li><li><p>客户通过调用<code>connect</code>发起主动打开（active open），向服务器发出连接请求报文段，请求中的首部的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能携带数据，则要消耗一个序号。这时，TCP客户进入SYN-SEND（同步已发送）状态。</p><div style="background-color: #fffacd;padding:20px;"> TCP规定，序号（seq）用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。</div></li><li><p>服务器收到客户端连接请求后，必须确认（ACK）客户的SYN报文段。在确认报文段中，把SYN和ACK位都置为1，确认号为ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP服务器进入SYN-RCVD（同步收到）状态。</p><div style="background-color: #fffacd;padding:20px;"> TCP规定，若确认号ack = N，则表明：到序号 N - 1为止的所有数据都已正确收到。</div></li><li><p>客户在收到服务器的确认后，还要向服务器进程给出确认。确认报文段的ACK置1，SYN=0，确认号ack = y + 1，而自己的序号seq = x + 1。TCP规定，这个报文段可以携带数据，也可以不携带数据，如果不携带数据，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，客户进入ESTABLISHED（已建立连接）状态。</p></li><li>服务器收到客户的确认后，也进入estab-listen状态。</li></ol><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>为什么客户在收到服务器的确认后，还要向服务器发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而发生错误。</p><p>考虑一种情况，客户发出连接请求后，但因连接请求报文丢失而未收到确认。于是客户再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器。没有“已失效的连接请求报文段”。<br>现假定一种异常情况。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求后，就误认为是客户又一次发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用三次握手，那么只要服务器发出确认，新的连接就建立了。</p><p>由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立了，并一直等待客户发送数据。服务器的许多资源就这样白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如刚才的情况下，客户不会向服务器的确认发出确认，由于服务器收不到确认，就知道客户并没有要求建立连接。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>TCP建立一个连接需要三个报文段，释放一个连接却需要四个报文段。<br>因此释放连接的过程也称之为四次握手。</p><p><mark>图2.TCP释放连接的过程</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301753176.png" alt="image.png"><br>数据传输结束后，通信的双方可以释放连接。数据传输结束后的客户A和服务器B都处于ESTABLISHED状态，然后进入释放连接的过程</p><ol><li>A的应用进程先发出释放连接报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部终止位FIN置1，其序号为seq = u。这时A进入FIN-WAIT-1（终止等待1）状态。</li><li>B收到连接释放报文段后即发出确认确认号为ack = u + 1，而自己的序号为seq = v。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍接收。</li><li>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li><li>若B已经没有要向A发送的数据，其应用进程就通知TCP释放 连接。这时B发出的连接释放报文段FIN = 1，还必须重复上次已发送过的确认号ack = u + 1。假定B的序号为w（在半关闭期间B可能又发送了一些数据）。这时B就进入了LAST-ACK（最后确认）状态，等待A的确认。</li><li>A收到了的连接释放报文段后，必须对此发出确认。其确认号为ack = w + 1，而自己的序号为seq = u + 1。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。</li><li>B只要收到A发出的确认，就进入CLOSED状态。我们注意到，B结束TCP连接的时间要比A早一些。</li></ol><h2 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a><em>TCP的可靠传输</em></h2><p><em>TCP实现可靠传输的机制：<strong>校验</strong>、<strong>序号</strong>、<strong>确认</strong>、<strong>重传</strong></em></p><ol><li>TCP 给发送的每一个字节进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052045835.png" alt="image.png"></p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>为每一个字节数据都编一个序号，报文段首部序号字段里的序号是该报文段第一个字节所占的序号编号<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052058473.png" alt="image.png"></p><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>TCP默认使用累计确认的方式，如果发送方发了包1，包2，包3，包4；接受方成功收到包1，包2，包3。那么接受方可以发回一个确认包，序号为4(4表示期望下一个收到的包的序号)，那么发送方就知道包1到包3都发送接收成功，必要时重发包4。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052057831.png" alt="image.png"></p><h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><ol><li>超时重传：确认重传不分家，TCP的发送方在规定的时间（重传时间）内没有收到确认就要重传已发送的报文段。TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）</li></ol><ol><li>快速重传：为了防止超时重传容易等太久，所以有了快速重传，快速重传采用冗余ACK（冗余确认）<br>每当比期望序号大的失序报文段到达时,发送一个冗余ACK,指明下一个期待字节的序号。<br>发送方已发送a,b,c,d,e报文段<br>接收方收到a，返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到b，仍返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到c，仍返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到d，仍返回给a的确认(确认号为b的第一个字节的序号)<br>发送方收到3个对于报文段a的冗余ACK→认为b报文段丢失，重传b号报文段</li></ol><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a><em>TCP流量控制</em></h2><p>流量控制：让发送方慢点，要让接收方来得及接收。<br>TCP利用滑动窗口机制实现流量控制。</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小,即接收窗口wd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052158671.png" alt="image.png"></p><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p><blockquote><p>窗口关闭潜在的危险！</p></blockquote><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p><blockquote><p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p></blockquote><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><em>TCP拥塞控制</em></h2><blockquote><p>为什么要有拥塞控制呀，不是有流量控制了吗？</p></blockquote><p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><blockquote><p>什么是拥塞窗口？和发送窗口有什么关系呢？</p></blockquote><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><blockquote><p>那么怎么知道当前网络是否出现了拥塞呢？</p></blockquote><p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><blockquote><p>拥塞控制有哪些控制算法？</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><em>慢启动</em></h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p><p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><p>慢启动算法的变化过程如下图：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052227147.png" alt="image.png"><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a><em>拥塞避免算法</em></h3><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p>拥塞避免算法的变化过程如下图：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052228261.png" alt="image.png"></p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」</p><h3 id="拥塞发生算法"><a href="#拥塞发生算法" class="headerlink" title="拥塞发生算法"></a><em>拥塞发生算法</em></h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p><blockquote><p>发生超时重传的拥塞发生算法</p></blockquote><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052230558.png" alt="image.png"><br>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</li></ul><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><em>快速恢复</em></h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p>快速恢复算法的变化过程如下图：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052232229.png" alt="image.png"><br>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>网络应用模型分为两类：客户/服务器模型(C/S) 、P2P模型</p><ol><li><p>客户/服务器模型(C/S模型)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061804479.png" alt="image.png"></p></li><li><p>P2P模型<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061804939.png" alt="image.png"></p></li></ol><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS（Domain Name System，域名系统），是用于实现域名和 IP 地址相互映射的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，得到该主机名对应的 IP 地址的过程叫做<strong>域名解析</strong>（或主机名解析）。</p><p>如果整个因特网都使用一个域名服务器，负荷太大， 所以 DNS 设计成一个分布式的数据库，即使单个主机出故障也不会妨碍整个 DNS 系统。另外 DNS 使得大多数域名都能在本地解析，仅少量解析需要在因特网上通信，因此 DNS 效率很高。</p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><blockquote><p>域名的分级结构是如何划分的？</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061735142.png" alt="image.png"></p><p><strong>域名结构</strong>：树状结构，树的最顶端代表根域名，下一层是 .com、.cn 等顶级域名，再下层就是二级、三级、四级域名。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061737113.png" alt="image.png"></p><blockquote><p>域名服务器分级结构</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061740051.png" alt="image.png"></p><ul><li><strong>根域名服务器</strong>：最高层次的域名服务器，根域名服务器知道所有顶级域名服务器的域名和IP地址。任何一个本地域名服务器要对互联网上的任何域名进行解析，只要自己无法解析，就会首先求助于根域名服务器。</li><li><strong>顶级域名服务器</strong>：管理在该顶级域名服务器下注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步需要去找的域名服务器的IP地址）。</li><li><strong>权限域名服务器</strong>（权威域名服务器）：负责一个区的域名服务器。当一个权威域名服务器不能给出最终的查询结果时，就会告诉发出请求方，下一步应该去找哪一个权威域名服务器。</li><li><strong>本地域名服务器</strong>（递归服务器）：主机发出 DNS 查询请求时，该请求首先会发给本地域名服务器。</li></ul><blockquote><p><em>域名解析的具体流程是怎样的呢？</em></p></blockquote><ol><li>在浏览器中输入<code>www.qq.com</code> 域名，浏览器先检查自身缓存中有没有被解析过的这个域名对应的 IP 地址，如果有，就调用这个 IP 映射，完成域名解析。</li><li>如果浏览器缓存中未命中，操作系统会检查本地的 hosts 文件是否有该域名和 IP 的映射，如果有，就调用这个IP地址映射，完成域名解析。</li><li>如果 hosts 里也没有这个域名的映射，则向本地域名服务器（LDNS）发送请求，看是否有这个域名的映射关系，如果有，直接返回，完成域名解析。（LDNS 一般在城市的某个角落，距离你不会很远，一般都会缓存域名解析结果，大约 80% 的域名解析到这里就完成了）</li><li>如果 LDNS 仍然未命中，LDNS 就向根服务器发送查询请求，根服务器里面记录的都是各个顶级域所在的服务器 IP，根服务器会根据域名后缀返回对应的顶级域名服务器位置。当向根请求<code>www.qq.com</code> 的时候，根服务器就会返回 <code>.com</code>服务器的位置信息。</li><li>LDNS 拿到<code>.com</code> 的权威服务器地址以后，就会询问<code>.com</code> 的权威服务器，知不知道<code>www.qq.com</code>的位置。这个时候 <code>.com</code>权威服务器查找并返回<code>www.qq.com</code>服务器的地址。LDNS 继续向<code>www.qq.com</code> 的权威服务器去查询这个地址，由<code>www.qq.com</code>的服务器给出了 IP 地址：202.173.11.10</li><li>LDNS 服务器得到了<code>www.qq.com</code> 对应的 IP 地址后以 DNS 应答包 的方式传递给客户机，并把域名和对应的 IP 地址在本地缓存下来。</li><li>客户机根据 IP 地址建立连接，并在客户端缓存域名/IP映射。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061745329.png" alt="image.png"></p><p>简单来说，其实只有四步：</p><ol><li>在本地缓存里找映射，未命中继续下一步</li><li>在本地域名服务器（LDNS）里找映射，未命中继续下一步</li><li>LDNS 向根域名服务器发送解析请求，期间迭代查询了顶级域名服务器和各权威域名服务器，LDNS 将解析结果 IP 返回给主机，并缓存域名-IP映射</li><li>主机在浏览器/OS缓存域名-IP映射，并建立连接</li></ol><p>ps.本地域名服务器 = 递归域名服务器，意思是它的查询方式是递归的，即返回的是最终的查询结果而不是可能的查询路径。</p><blockquote><p>前面知道了DNS解析的流程，但是DNS服务器的查询方式具体是怎样的呢？</p></blockquote><p><strong>迭代查询</strong>：DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。迭代查询返回的是最佳的查询点或者主机地址。本地域名服务器向根域名服务器的查询通常是采用迭代查询。</p><p><strong>递归查询</strong>：DNS 服务器必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询目标的 DNS 信息，那么该服务器会去询问其他服务器（即代替客户机去查询，而不是让客户机自己进行下一步查询），并将返回的查询结果提交给客户机。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错（表示无法查询到所需的 IP 地址）。主机向本地域名服务器的查询一般都是采用递归查询。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061748833.png" alt="image.png"></p><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h3 id="1-FTP协议"><a href="#1-FTP协议" class="headerlink" title="1.FTP协议"></a><strong>1.FTP协议</strong></h3><p>什么是FTP呢？FTP 是 TCP/IP 协议组中的协议之一，是英文File Transfer Protocol的缩写。</p><p>该协议是Internet文件传送的基础，它由一系列规格说明文档组成，目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。简单的说，FTP就是完成两台计算机之间的拷贝，从远程计算机拷贝文件至自己的计算机上，称之为“下载 （download）”文件。若将文件从自己计算机中拷贝至远程计算机上，则称之为“上载（upload）”文件。在TCP/IP协议中，FTP标准命令TCP端口号为21，Port方式数据端口为20。</p><h3 id="2-FTP服务端和客户端"><a href="#2-FTP服务端和客户端" class="headerlink" title="2.FTP服务端和客户端"></a><strong>2.FTP服务端和客户端</strong></h3><p>同大多数Internet服务一样，FTP也是一个客户/服务器系统。用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照 FTP 协议提供服务，进行文件传送的计算机就是 FTP 服务器，而连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。用户要连上 FTP 服务器，就要用到 FPT 的客户端软件，通常 Windows自带“ftp”命令，这是一个命令行的 FTP 客户程序</p><h3 id="3-FTP用户授权"><a href="#3-FTP用户授权" class="headerlink" title="3.FTP用户授权"></a><strong>3.FTP用户授权</strong></h3><p>  (1）用户授权</p><p>要连上 FTP 服务器（即“登陆”），必须要有该 FTP 服务器授权的帐号，也就是说你只有在有了一个用户标识和一个口令后才能登陆FTP服务器，享受FTP服务器提供的服务。</p><p>（2）FTP地址格式</p><p>FTP地址如下：<code>ftp://用户名：密码@FTP服务器IP或域名：FTP命令端口/路径/文件名</code></p><p>上面的参数除FTP服务器IP或域名为必要项外，其他都不是必须的。如以下地址都是有效FTP地址：</p><p><code>ftp://foolish.6600.org</code></p><p><code>ftp://list:list@foolish.6600.org</code></p><p><code>ftp://list:list@foolish.6600.org:2003</code></p><p><code>ftp://list:list@foolish.6600.org:2003/soft/list.txt</code></p><p>（3）匿名FTP</p><p>互连网中有很大一部分 FTP 服务器被称为“匿名”（Anonymous）FTP 服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous（匿名文件传输）能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。许多系统要求用户将Emai1地址作为口令，以便更好地对访问进行跟综。匿名FTP一直是Internet上获取信息资源的最主要方式，在Internet成千上万的匿名FTP主机中存储着无以计数的文件，这些文件包含了各种各样的信息，数据和软件。人们只要知道特定信息资源的主机地址，就可以用匿名FTP登录获取所需的信息资料。虽然目前使用WWW环境已取代匿名FTP成为最主要的信息查询方式，但是匿名FTP仍是 Internet上传输分发软件的一种基本方法。如red hat 、autodesk等公司的匿名站点。</p><h3 id="4-FTP传输模式"><a href="#4-FTP传输模式" class="headerlink" title="4.FTP传输模式"></a><strong>4.FTP传输模式</strong></h3><p>FTP协议的任务是从一台计算机将文件传送到另一台计算机，它与这两台计算机所处的位置、联接的方式、甚至是是否使用相同的操作系统无关。假设两台计算机通过ftp协议对话，并且能访问Internet，你可以用ftp命令来传输文件。每种操作系统使用上有某一些细微差别，但是每种协议基本的命令结构是相同的。</p><p>FTP的传输有两种方式：<strong>ASCII传输模式</strong>和<strong>二进制数据传输模式</strong>。</p><ol><li><p>ASCII传输方式：假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件（尽管字处理文件包含的大部分是文本，其中也包含有指示页尺寸，字库等信息的非打印符）。在拷贝任何非文本文件之前，用binary 命令告诉ftp逐字拷贝，不要对这些文件进行处理，这也是下面要讲的二进制传输。</p></li><li><p>二进制传输模式：在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。如果你在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢 ，也会损坏数据，使文件变得不能用。（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果你传输二进制文件，所有的位都是重要的。）如果你知道这两台机器是同样的，则二进制方式对文本文件和数据文件都是有效的。</p></li></ol><h3 id="5-FTP的工作方式"><a href="#5-FTP的工作方式" class="headerlink" title="5. FTP的工作方式"></a><strong>5. FTP的工作方式</strong></h3><p>FTP支持两种模式，一种方式叫做<strong>Standard (也就是 PORT方式，主动方式)</strong>，一种是 <strong>Passive (也就是PASV，被动方式)</strong>。 Standard模式 FTP的客户端发送 PORT 命令到FTP服务器。Passive模式FTP的客户端发送 PASV命令到 FTP Server。</p><p>下面介绍一个这两种方式的<strong>工作原理</strong>：</p><p>Port模式FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据。</p><p>Passive模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接。</p><p>很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071118927.png" alt="image.png"></p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><ol><li>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又<code>分为首部和主体</code>两部分。</li><li>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。</li><li>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。</li><li>邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject。</li><li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名<br><code>如abc@cskaoyan.com</code>其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。<code>这也就保证了abc@cskaoyan.com</code> 这个邮件地址在整个因特网上是唯一的。</li><li>还有一个必填的关键字是From,但它通常由邮件系统自动填入。</li><li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062026296.png" alt="image.png"></li></ol><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><ul><li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。</li><li><p>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062100264.png" alt="image.png"></p></li><li><p>电子邮件系统已改具有的三个最主要的组成部件：用户代理(User Agent)、邮件服务器、电子邮件使用的协议<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062103899.png" alt="image.png"></p></li></ul><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。<br>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器。<br>SMTP规定了14条命令（几个字母）和21种应答信息(三位数字代码+简单文字说明)。</p><blockquote><p>SMTP通信分为三个阶段，连接建立、邮件发送、连接释放</p></blockquote><p><strong>1.连接建立</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062140921.png" alt="image.png"></p><ul><li>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定 时间对邮件缓存扫描一次。</li><li>如发现有邮件，就使用SMTP的熟知端口号(25) 与接收方邮件服务器的SMTP服务器建立TCP连接。</li><li>连接建立后，接收方SMTP服务器发出220 Service ready (服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li><li>SMTP不使用中间邮件服务器。</li><li>TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。</li><li>接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。</li></ul><p><strong>2.邮件发送</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062142127.png" alt="image.png"></p><ul><li>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM:<code>hoopdog@hust.edu.cn。</code></li><li>若SMTP服务器已准备好接收邮件，则回答250 OK。</li><li>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPTTO: &lt;收件人地址&gt;。</li><li>每发送一个 RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK或550 No such user here (无此用户)。</li><li>RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。</li><li>获得0K的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。</li><li>正常情况下，SMTP服务器回复信息是354 Start mail input; end with . 。表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用. (两个回车，中间一个点)表示邮件内容的结束。</li></ul><p><strong>3.连接释放</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062143738.png" alt="image.png"></p><ul><li>邮件发送完毕后，SMTP客户应发送QUIT命令。</li><li>SMTP服务器返回的信息是221 (服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>字扩展与多模块存储器区别</title>
    <link href="https://fqzs.netlify.app/undefined/a9bcdbf2.html"/>
    <id>https://fqzs.netlify.app/undefined/a9bcdbf2.html</id>
    <published>2023-06-01T22:23:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于一个存储器的一部分，也就是说拥有同一个读写周期。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg&quot; alt=&quot;星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>哪些方法可以判断一个有向图是否有环</title>
    <link href="https://fqzs.netlify.app/undefined/d30215e4.html"/>
    <id>https://fqzs.netlify.app/undefined/d30215e4.html</id>
    <published>2023-05-24T22:03:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg&quot; alt=&quot;房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构" scheme="https://fqzs.netlify.app/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>模4补码与模2补码</title>
    <link href="https://fqzs.netlify.app/undefined/f711f08b.html"/>
    <id>https://fqzs.netlify.app/undefined/f711f08b.html</id>
    <published>2023-05-22T22:13:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg&quot; alt=&quot;女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;c</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码、模与运算</title>
    <link href="https://fqzs.netlify.app/undefined/b988fae0.html"/>
    <id>https://fqzs.netlify.app/undefined/b988fae0.html</id>
    <published>2023-05-22T16:32:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg&quot; alt=&quot;晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg&quot;&gt;&lt;/p&gt;
&lt;h3 id</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>补码的移位</title>
    <link href="https://fqzs.netlify.app/undefined/fe859f5c.html"/>
    <id>https://fqzs.netlify.app/undefined/fe859f5c.html</id>
    <published>2023-05-21T22:55:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;对补码左移运算&lt;/code&gt;&lt;br&gt;书里介绍的</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="补码" scheme="https://fqzs.netlify.app/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="https://fqzs.netlify.app/undefined/8d4b7ae1.html"/>
    <id>https://fqzs.netlify.app/undefined/8d4b7ae1.html</id>
    <published>2023-05-08T20:07:00.000Z</published>
    <updated>2023-09-10T03:27:41.781Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091313764.png" alt="image.png"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期=主频周期=节拍：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF-Overflow-Flag"><a href="#OF-Overflow-Flag" class="headerlink" title="OF:Overflow Flag"></a>OF:Overflow Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">1011 + 1001 = 1 0100 --&gt; 只有符号位进位 溢出</span><br><span class="line">0100 + 0100 =   1000 --&gt; 只有次高位进位 溢出</span><br><span class="line">1111 + 1100 = 1 1011 --&gt; 符号位和次高位都进位，不溢出</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF-Sign-Flag"><a href="#SF-Sign-Flag" class="headerlink" title="SF: Sign Flag"></a>SF: Sign Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF-Zero-Flag"><a href="#ZF-Zero-Flag" class="headerlink" title="ZF: Zero Flag"></a>ZF: Zero Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF-Carry-Flag"><a href="#CF-Carry-Flag" class="headerlink" title="CF: Carry Flag"></a>CF: Carry Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 进位/借位标志位，表示无符号数的加减法是否发生了进位或借位</span><br><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那</span><br><span class="line"> 就需要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10</span><br><span class="line"> 条字选线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内</span><br><span class="line">      全部刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期</span><br><span class="line">变为1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是</span><br><span class="line">  0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译</span><br><span class="line">码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列</span><br><span class="line">  地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功</span><br><span class="line">耗低价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache-缓存"><a href="#Cache-缓存" class="headerlink" title="Cache(缓存)"></a>Cache(缓存)</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><p><em>思考一个问题？如何确定将主存中的数据搬到Cache中后，数据在Cache中的存放位置？这就需要一个具体的映射方式来确定，一个主存地址中的数据在Cache中的存储位置</em></p><p><strong>*地址映射</strong>：地址映射是一种规则，它指明了把主存地址空间映射到Cache地址空间所用的规则，即把存放在主存中的程序按照某种规则装入Cache。，由Cache的块数比主存块数少得多，因此需要加入主存字块标记和字块内地址*</p><p><strong>*地址变换</strong>：地址变换是一个过程，它是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始</span><br><span class="line">都为0)如果不加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位</span><br><span class="line">表示块号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要</span><br><span class="line">6bit位表示--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221529841.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一快的副本。</em></li><li><em>字块内地址：由于Cachei块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit位就对应表示Cache中的块号</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221530376.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一块的副本。</em></li><li><em>Cache:字块地址：指明存放在Cache中的哪个Cache块。</em></li><li><em>字块内地址：由于Cache块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221531760.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中那一块的副本。</em></li><li><em>组地址：指明存放在Cache中的哪个Cache块的组。</em></li><li><em>字块内地址：由于Cche块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></li></ul><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">- 当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><ul><li><em>有效位：1bit 用于判断该数据是否有效</em></li><li><em>脏位：1bit 用于标记Cache中数据是否被修改过</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块</span><br><span class="line">中，因此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主</span><br><span class="line">存块大小相等)因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑页号对应，所以出现了一个映射表，存储</span><br><span class="line">块号与页号的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访</span><br><span class="line">  存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;10 转换地址 000001(操作码) 10(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺</span><br><span class="line"> 序编址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表是SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br><span class="line">&gt;快表TLB ,相当于主存与外存之间的&quot;Cache&quot;用于存放外存中页表的副本</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="全篇总结"><a href="#全篇总结" class="headerlink" title="全篇总结"></a>全篇总结</h2><blockquote><p>指令上的地址都是逻辑地址，经过查找页表/快表得到主存块号，拼接成物理地址，然后根据物理地址从Cache中寻找数据(根据Cache与主存的不同映射关系，结合物理地址寻找到对应的Cache块)，如果没找到就进入主存寻找。这就是完整的寻址过程</p></blockquote><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h3 id="高速缓冲存储器-Cache-习题"><a href="#高速缓冲存储器-Cache-习题" class="headerlink" title="高速缓冲存储器(Cache)习题"></a>高速缓冲存储器(Cache)习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221203457.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221209136.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221219813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221351133.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221353099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221455353.png" alt="image.png"></p><p>*128KB/16B = 8K(块)=2^13(块)，组相连映射，每组8块，所以2^13/8=2^10(组)，—&gt;10bit表示Cache内组号</p><p>主存地址1234567H —&gt;说明主存地址共4x7=28位，28-10-4=14(主存字块标记位数)*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221542461.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221604202.png" alt="image.png"></p><p><em>逻辑地址与物理地址区别就是页号不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221642813.png" alt="image.png"></p><p><em>Cache容量计算：数据部分+控制部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221650066.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222021823.png" alt="image.png"></p><p><em>没有告诉主存地址位数,只知道地址号数<br>通过逻辑右移·取余数得到低位部分数<br>就可得如组号是多少了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221659922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221710825.png" alt="image.png"></p><p><em>Cache一次缺失，就需要将一个主存块替换进Cache里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221701004.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221705615.png" alt="image.png"></p><p><em>1.做这题第一眼，忽略了写命中也要算进去<br>2.这里k=1000刚好是4的倍数，，因为一个块16B,可以存4个数组元素，所以替换到Cache中的数组都可以访问到不会遗漏，所以可以根据每8次缺失1次算<br>3.当k=10,时，只能访问到a[9],剩余替换到Cache块中的a[10],a[11]不会访问到，所以要按实际情况计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222004782.png" alt="image.png"></p><p>*时间局部性：一条指令一旦被执行，在不久的将来可能会再次执行<br>典型代表：循环指令</p><p>空间局部性：一旦一个存储单元被访问，那么它附近的存储单元也很快被访问典型代表：数组，顺序指令*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222013840.png" alt="image.png"></p><p><em>比较器的作用：用于判断需要取的数据是否在Cache中已存在<br>1.由于一次存取只能存取一个数据，故一次存取先根据主存地址中的Cache组号，确定数据所在Cache组（一组8个Cache块）<br>2.在根据主存地址标志位tag(用于确定对应的主存块号)，通过比较器将目的tag位，与该组中所有Cache块中存储的数据的tag位进行比对，如果匹配成功，说明Cache命中<br>3.所以比较器是用在确定组号之后，比较组内所有块的tag位，所以组内有8块，就需要8个比较器，tag位有20位，比较器位数就需要20位</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222036946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222048277.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222054958.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222059557.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222116123.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222121516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222132157.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154250.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154018.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222153389.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222208624.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217240.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222219607.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217728.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231216744.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231307226.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231314918.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231319447.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231321170.png" alt="image.png"><br><em>本题要点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231323044.png" alt="image.png"></p><p><em>(1)(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231339697.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231340569.png" alt="image.png"><br><em>(4)</em><br>*修改页面，是指改完主存中的内容后，再将主存中修改的内容写到辅存(外存)</p><p>Cache直写，是一并将修改写入Cache和主存，就是全写法，通过写缓冲实现*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231343247.png" alt="image.png"></p><p><em>LRU标记位需要3bit,用于标记各个块被访问的先后顺序，由于每个分组内只有8个块，先后顺序无非1~8，所以3bit位标记先后顺序即可</em><br><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231353841.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406025.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406198.png" alt="image.png"></p></blockquote><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><mark>大纲已删</mark></p><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码 </span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr><h3 id="汇编语言的考试要求"><a href="#汇编语言的考试要求" class="headerlink" title="汇编语言的考试要求"></a>汇编语言的考试要求</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111601729.png" alt="image.png"></p><h3 id="X86汇编语言基础"><a href="#X86汇编语言基础" class="headerlink" title="X86汇编语言基础"></a>X86汇编语言基础</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是X86?</span><br><span class="line">1978年Intel公司生产了一块CPU芯片代号8086，</span><br><span class="line">之后就出现了80286、80386等一系列86结尾的型号的CPU，都兼容之前的CPU，能够将程序</span><br><span class="line">移植到新的CPU执行。因此X86汇编语言指令，是指能够被这一系列CPU处理的汇编语言指</span><br><span class="line">令</span><br></pre></td></tr></table></figure><hr><h4 id="以mov指令为例"><a href="#以mov指令为例" class="headerlink" title="以mov指令为例"></a>以mov指令为例</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111617341.png" alt="image.png"><br>s-&gt;source-&gt;源操作数<br>d-&gt;destination-&gt;目标操作数<br><code>mov d , s</code>-&gt;将源操作数s复制到目的操作数d所指的位置</p><p>mov指令常用格式有一下几种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111619250.png" alt="image.png"><br>其中当指明的是内存地址的时候，通过dword ptr(双字)、word ptr(单字)、byte ptr(字节)<br>来指明需要读写的长度</p><hr><h4 id="X86CPU有哪些寄存器"><a href="#X86CPU有哪些寄存器" class="headerlink" title="X86CPU有哪些寄存器"></a>X86CPU有哪些寄存器</h4><ul><li>X 结尾：通用寄存器</li><li>I 结尾 ：变址寄存器</li><li>P结尾：堆栈寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111633315.png" alt="image.png"></li></ul><ul><li>寄存器都以E开头，E-&gt;Extenden=32bit，</li><li>对于通用寄存器而言如果指向使用低位的16bit，那么可将E 去掉</li><li>变地址寄存器和堆栈寄存器都不能去掉E ,只能固定使用32bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111638172.png" alt="image.png"></p><hr><h4 id="源、目的-操作数书写格式"><a href="#源、目的-操作数书写格式" class="headerlink" title="源、目的 操作数书写格式"></a>源、目的 操作数书写格式</h4><ul><li>[寄存器] 是指寄存器里所存的地址所指向的数据，相当于寄存器间接寻址</li><li>[地址/寄存器] 前没有指明读学长度时，默认32bit</li><li>[af996-12 h]-&gt;最后h表示16进制，这样写是指地址af886往前偏移12位地址所指数据</li><li>[abx +8]-&gt;是指该寄存器内地址往后+8的主存地址所指向的数据<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111642835.png" alt="image.png"></li></ul><hr><h4 id="常见的算数运算指令"><a href="#常见的算数运算指令" class="headerlink" title="常见的算数运算指令"></a>常见的算数运算指令</h4><ul><li>乘法 mul d,s -&gt; 表示无符号数d * s,乘积存入d</li><li>乘法 imul d,s -&gt; 表示有符号数d * s,乘积存入d</li><li>除法 div s -&gt;无符号数除法，被除数会提前存放在edx:eax中<br>  -&gt;edx:eax表示两个寄存器拼接将被除数从原来的32bit扩展为64bit ;<br>  -&gt;商存入eax,余数存入edx中</li><li>除法 idiv s -&gt;有符号数除法，被除数会提前存放在edx:eax中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111737632.png" alt="image.png"></li></ul><hr><h4 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111750543.png" alt="image.png"></p><hr><h4 id="s、d操作数"><a href="#s、d操作数" class="headerlink" title="s、d操作数"></a>s、d操作数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于X86系统，指令后面的两个操作数不允许两个都来自主存&lt;mem&gt;</span><br><span class="line">2.并且，目的操作数d 不能是常数&lt;con&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172215148.png" alt="image.png"></p><hr><h4 id="AT-amp-T格式指令与Intel格式指令区别"><a href="#AT-amp-T格式指令与Intel格式指令区别" class="headerlink" title="AT&amp;T格式指令与Intel格式指令区别"></a>AT&amp;T格式指令与Intel格式指令区别</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111800835.png" alt="image.png"></p><ul><li>基址+变址 <em> 比例因子+偏移量<br>用于结构体数组内信息的寻址<br>基地址-&gt;寻找数组起始地址<br>变址 </em> 比例因子-&gt;寻找目标元素在数组内的位置<br>偏移量-&gt;寻找目标信息在该元素内的具体位置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111806568.png" alt="Uploading file...npg0j"></li></ul><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><hr><h4 id="jmp指令与cmp指令"><a href="#jmp指令与cmp指令" class="headerlink" title="jmp指令与cmp指令"></a>jmp指令与cmp指令</h4><p><strong>1.程序中选择分支结构</strong></p><ul><li>程序计数器PC又被称为IP寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112305940.png" alt="image.png"></li></ul><hr><p><strong>2.无条件跳转指令—Jmp</strong></p><p>执行该条指令PC会无条件跳转到某个主存地址，执行那个地址的指令</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317121.png" alt="image.png"></p><p>无条件跳转指令格式 -&gt; jmp &lt;地址&gt; </p><ul><li>jmp 128 -&gt;跳转到地址128</li><li>jmp eax -&gt; 地址来自于寄存器</li><li>jmp [999] -&gt;地址来自于主存地址999中存的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317178.png" alt="image.png"></li></ul><hr><p><strong>3.jmp跳转标记位格式</strong></p><pre><code>因为写程序的时候，例如if-else分支语句的时候，通过条件判断决定跳转执行那一条程序语句，这样就有一个问题，如果都采用上面的三种jmp跳转指令--需要先知道需要跳转的程序的主存地址(jmp 116)，这样写死了地址，很不灵活，一旦程序的主存地址一改变，原有的jmp指令就会跳转错误位置，所以就可以通过对需要跳转的语句做标记NEXT ,通过jmp NEXT 的跳转方式实现跳转</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112330386.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112332972.png" alt="image.png"></p><hr><p><strong>4.条件转移指令-jxxx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112334438.png" alt="image.png"></p><p>通常使用条件跳转指令前，需要使用cmp指令。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336192.png" alt="image.png"></p><p>所以cmp指令经常和条件跳转指令搭配使用。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336184.png" alt="image.png"></p><hr><p><strong>5.cmp指令的底层原理</strong></p><p>本质上就是对a,b两个操作数镜像减法运算a-b,并生成了OF、ZF、CF、SF四个标志位信息<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112339041.png" alt="image.png"></p><p>ALU 每进行一次运算的标志位都会自动存入<br>PSW程序状态字寄存器中(Intel称它为“标志寄存器FR”)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112341179.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340390.png" alt="image.png"></p><p>jxxx指令，就是根据cmp指令得到的标志位，来判断是否= &lt;  &gt; ！=<br>进而决定进行跳转<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112345836.png" alt="image.png"></p><hr><h4 id="条件转移指令jmp实现循环"><a href="#条件转移指令jmp实现循环" class="headerlink" title="条件转移指令jmp实现循环"></a>条件转移指令jmp实现循环</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142216499.png" alt="image.png"></p><hr><h4 id="loop指令实现循环"><a href="#loop指令实现循环" class="headerlink" title="loop指令实现循环"></a>loop指令实现循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 指令：</span><br><span class="line">- 格式loop Looltop  // ecx-- ,若ecx!=0,跳转到Looptop</span><br><span class="line">- 只能用ecx作为循环计数器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142229529.png" alt="image.png"></p><hr><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><h4 id="call、leave、ret指令"><a href="#call、leave、ret指令" class="headerlink" title="call、leave、ret指令"></a>call、leave、ret指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call、leave、ret指令实现函数调用：</span><br><span class="line">call 指令 作用：</span><br><span class="line">1.将IP旧址压栈保存(保存在当前函数的栈帧顶部)</span><br><span class="line">2.设置新的IP值，无条件转移到被调用函数的第一条指令</span><br><span class="line">leave 指令 作用：</span><br><span class="line">1.将现在的函数的栈帧撤销，相当于将该函数弹栈</span><br><span class="line">ret 指令 作用：</span><br><span class="line">1.弹栈后，从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP原有的值指向回原来位</span><br><span class="line">置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142240959.png" alt="image.png"></p><hr><h4 id="如何访问栈帧里的数据？"><a href="#如何访问栈帧里的数据？" class="headerlink" title="如何访问栈帧里的数据？"></a>如何访问栈帧里的数据？</h4><h5 id="访问栈帧数据Push和Pop指令"><a href="#访问栈帧数据Push和Pop指令" class="headerlink" title="访问栈帧数据Push和Pop指令"></a>访问栈帧数据Push和Pop指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ebp和esp：</span><br><span class="line">ebp指向当前栈帧的底部，esp指向当前栈帧的顶部，两者标记了当前栈帧的一个范围</span><br><span class="line">ebp、esp存的是地址不是数据值，ebp和esp只是一个指针</span><br><span class="line"></span><br><span class="line">Push、Pop指令实现入栈出栈操作操作，X86默认以4字节为单位：</span><br><span class="line">格式:</span><br><span class="line">Push ?  //先让esp-4，在将数据压入</span><br><span class="line">Push eax   #将寄存器eax的值压栈</span><br><span class="line">Push 985   #将立即数985压入栈中</span><br><span class="line">Push [ebp+8] #将主存地址[ebp+8]的数据压栈</span><br><span class="line">(所谓压栈是指将esp里保存的地址，所指向的数据的值修改,然后esp-4)</span><br><span class="line">Pop ?  //栈顶元素出栈并写入&lt;寄存器/主存地址&gt;，在esp+4</span><br><span class="line">Pop eax   # 将栈顶元素出栈，写入寄存器eax</span><br><span class="line">Pop [ebp+8] # 将栈顶元素出栈，并写入主存地址[ebp+8]</span><br><span class="line">(所谓出栈是指,将esp保存的地址所指向的值写入?,然后esp+4)</span><br><span class="line">问题： </span><br><span class="line">这样访问栈帧数据不灵活，因为每次Push都只能往esp+4的位置Push(压入数据)</span><br><span class="line">每次Pop也只能一次弹出一个栈顶元素，并写入一个栈顶栈顶元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151025134.png" alt="image.png"></p><hr><h5 id="访问栈帧数据mov指令"><a href="#访问栈帧数据mov指令" class="headerlink" title="访问栈帧数据mov指令"></a>访问栈帧数据mov指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以直接对esp进行加减运算：</span><br><span class="line">可以使用减法/加法，即sub/add修改栈顶指针esp的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151046206.png" alt="image.png"></p><hr><h4 id="如何切换栈帧？"><a href="#如何切换栈帧？" class="headerlink" title="如何切换栈帧？"></a>如何切换栈帧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.先执行call指令：</span><br><span class="line">1.将当前IP(取出call之后自动指向下一条)值，相当于 Push IP</span><br><span class="line">2.将IP设置为被调用函数的第一条指令地址, 相当于jmp add</span><br><span class="line"></span><br><span class="line">2.进入目标函数后：&lt;保存上一个函数的栈帧，并设置当前函数栈帧&gt;</span><br><span class="line">1.Push ebp --&gt;将前一个函数的栈底地址保存入栈(先esp+4,然后将ebp值压入)</span><br><span class="line">2.mov ebp esp --&gt; 将esp的地址值复制给ebp,使ebp指向另一个函数的栈底地址</span><br><span class="line"> ==&gt; 1+2等价于enter指令</span><br><span class="line"> </span><br><span class="line">3.一系列逻辑处理</span><br><span class="line"></span><br><span class="line">4.恢复上一层函数的栈帧：</span><br><span class="line">1.mov esp ebp --&gt; 让esp指向当前函数栈底</span><br><span class="line">2.Pop ebp --&gt; 将栈顶元素出栈，并写入ebp(ebp重新指回上一个函数基底)</span><br><span class="line"> ==&gt; 等价于leave指令</span><br><span class="line">5.ret指令：</span><br><span class="line">从栈顶找到返回的地址(原来基础上继续执行)，出栈并将值写到IP寄存器中，使其继续执</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><code>调用函数</code></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151109099.png" alt="image.png"></p><p><code>函数返回</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151130458.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151214922.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151105535.png" alt="image.png"></p><hr><h4 id="如何传递参数和返回值？"><a href="#如何传递参数和返回值？" class="headerlink" title="如何传递参数和返回值？"></a>如何传递参数和返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈帧最底部(基址)一定是上一层栈帧的基址</span><br><span class="line"></span><br><span class="line">栈帧的最顶部，一定是IP的返回地址(当前栈帧除外)</span><br><span class="line"></span><br><span class="line">栈帧结构，分为以下几块区域，每块区域内同时越靠前定义的就越靠近栈顶:</span><br><span class="line">1.局部变量区域</span><br><span class="line"></span><br><span class="line">2.未使用区域</span><br><span class="line">为什么会有未使用区域？</span><br><span class="line">因为gcc编译器会将每个栈帧大小设置为16B的整数倍(当前函数栈帧除外)</span><br><span class="line">当局部变量和调用参数没有填满栈帧时，就会空出未使用的部分</span><br><span class="line">3.调用参数区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172225143.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172137430.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数，返回值</span><br><span class="line">传低参数：在call指令前，将调用参数写入栈帧顶部区域</span><br><span class="line">接收返回值：在执行ret指令前将函数返回值写入eax寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172234781.png" alt="image.png"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CISC: Complex Instruction Set Computer(复杂指令集)</span><br><span class="line">- 通过一条指令完成复杂的基本功能，所以，它的指令往往是变长的</span><br><span class="line">- 变长，这也决定了它的指令执行效率低，因为需要花时间判断该指令的长度</span><br><span class="line">- 像是前面提到的乘法指令 000100 0000000110 只通过乘法指令就可以进行访存，所以</span><br><span class="line">  CISC指令对指令的访存权限没有限制</span><br><span class="line">- 由于随着CISC指令变得越来越复杂，很难用一个专门的电路硬件来实现，所以&quot;存储程</span><br><span class="line">  序&quot;，就是事先将几条组合指令存储在某个地方，比如要实现矩阵的乘法--&gt;可以通过</span><br><span class="line">  矩阵的加法、减法;整数加法、减法、乘法，5个比较通用的电路之间配合使用来实现复</span><br><span class="line">  杂的矩阵乘法</span><br><span class="line">RISC: Reduced Instruction Set Computer(精简指令集)</span><br><span class="line">- 一条指令只完成一个基本动作，一条指令一个电路</span><br><span class="line">- 由于电路设计简单功耗更低，所以主要用于移动设备:手机、平板等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172336854.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSIC:</span><br><span class="line">1.寄存器数量少，因为可以访存的指令没有限制，可以直接从主存中存取，不会过多的占</span><br><span class="line">  用寄存器的数量</span><br><span class="line">2.难以用优化编译生成高效的目标代码程序，因为，CISC本身就是一个复杂体，又胖又无</span><br><span class="line"> 法切割重组，决定了其效率的上限很低</span><br><span class="line"></span><br><span class="line">RISC:</span><br><span class="line">1.寄存器数量多，因为，可以访存的指令只有Load/Stroe，所以进行计算等操作的时候，</span><br><span class="line">  只能通过寄存器来存放数据，最后再通过Load/Stroe指令来进行写入或删除</span><br><span class="line">2.指令精简，可以很大程度上重组功能，生成更高效的代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172340404.png" alt="image.png"></p><h1 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041138990.png" alt="image.png"></p><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a><em>CPU的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032012738.png" alt="image.png"></p><h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a><em>运算器和控制器的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032026718.png" alt="image.png"></p><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a><em>运算器的基本结构</em></h3><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个寄存器与ALU之间都有专门的单独的数据通路--&gt;称为专用数据通路</span><br><span class="line">下图所示，所有寄存器与ALU都直接相连，但是我们不需要同时有这么多寄存器同时输入数据</span><br><span class="line">以下有两种解决办法:1.多路选择器;2.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032116421.png" alt="image.png"></p><blockquote><p><em>多路选择器</em></p></blockquote><p><em>使用多路选择器根据控制信号选择一路输出</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032113430.png" alt="image.png"></p><blockquote><p><em>三态门</em></p></blockquote><p>计算机里面<strong>1 0</strong> 分别表示 <strong>是  非</strong> 两种逻辑，但是还不够，因此引入了一种新的状态——<strong>高阻态</strong>(相当于电阻无穷大，断路状态)。</p><p>三态：高电平、低电平、高阻态。</p><p>三态门主要与总线连接，因为总线在同一时间内只能对一个设备有效。<br>通常在数据总线上连接有<strong>多个器件</strong>。同一时刻只能有一个设备选通，用于数据传输；其他设备处于高阻态(断开)。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032142905.png" alt="image.png"></p><p>EN使能信号：<br>    EN是<strong>0信号</strong>表示数据从A-&gt;B ;<strong>1信号</strong>表示数据从B-&gt;A；当EN使能信号无效时(没有产生信号)处于高阻态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032148055.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032150494.png" alt="image.png"></p><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将所有寄存器的输入端和输出端都连接到一条公用的通路上(CPU内部总线)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032203518.png" alt="image.png"></p><p><strong>引入暂存寄存器</strong><br><em>从这开始内部总线就只能同时有一个输入信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032207030.png" alt="image.png"></p><p><strong>为了避免输入信号还没稳定的时候就发出输出信号，在ALU后面再引入一个暂存寄存器+一个三态门</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当输入信号稳定前，期间产生的输出信号被存放在暂存器中(此时三态门没有导通);</span><br><span class="line">当输入信号稳定之后，(三态门接通)最终产生的输出信号才传输到CPU内部总线</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032209466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032216449.png" alt="image.png"></p><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032229276.png" alt="image.png"></p><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041129708.png" alt="image.png"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041136632.png" alt="image.png"></p><hr><h2 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><strong>CPU从主存中每取出并执行一条指令所需的全部时间</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041154511.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041200018.png" alt="image.png"></p><h3 id="数据流-微操作-有效信号"><a href="#数据流-微操作-有效信号" class="headerlink" title="数据流(微操作+有效信号)"></a>数据流(微操作+有效信号)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041429770.png" alt="image.png"><br><strong>注意书写数据流的时候需要写出——&gt; 微操作 + 有效控制信号</strong></p><hr><blockquote><p><em>指令周期的数据流向-取指周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041216231.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-间址周期</em></p></blockquote><p><strong>Ad(MDR) -&gt; MAR</strong> 中Ad 表示的是将MDR数据(取得的指令)中的<code>地址码部分</code>放入MAR中<br><strong>Ad(IR) -&gt; MAR</strong> 中Ad表示的也是将IR数据(取得的指令)中的<code>地址码部分</code>放到MAR中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041238584.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-执行周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041412833.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-中断周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041428150.png" alt="image.png"></p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041435747.png" alt="image.png"></p><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041434691.png" alt="image.png"></p><h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据通路的基本结构有:</span><br><span class="line">1.CPU内部单总线方式</span><br><span class="line">所有CPU部件连接一根内部总线，同时只能一组部件数据交换(一个发出，一个接收)</span><br><span class="line">2.CPU内部多总线方式</span><br><span class="line">为了解决同时只能有一组部件进行数据交换，所以提出CPU内部多总线，所有部件与这些</span><br><span class="line">多根总线都有连接，同时可以支持n组部件数据交换(n是总线根数)</span><br><span class="line">3.专用数据通路方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041936960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041935158.png" alt="image.png"></p><h3 id="数据通路-CPU内部单总线方式"><a href="#数据通路-CPU内部单总线方式" class="headerlink" title="数据通路-CPU内部单总线方式"></a>数据通路-CPU内部单总线方式</h3><blockquote><p><em>完成一次加法运算，完整的数据通路(单总线方式)</em></p></blockquote><p>由于这是单总线方式，一次只能有一组部件传输数据(例如 (ACC)-&gt;Bus-&gt;ALU  实现ACC和ALU之间的 <strong>被加数</strong>传输，<strong>加数</strong>只能先通过MDR-&gt;Bus-&gt;Y 存放在暂存寄存器中)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042005863.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>取指周期过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042040431.png" alt="image.png"></p><p>间址周期过程(省略微操作)：<br>    1.R0out  ,MARin 控制信号有效 -&gt;R0内间接地址传送到MAR<br>    2.MemR ,MARout ,MDRinE 控制信号有效 -&gt; 根据间接地址得到的直接地址EA存入MDR<br>    3.MDRout ,MARin 控制信号有效 -&gt;EA传给MAR<br>    4.MARout ,MemR ,MDRinE 控制信号有效 -&gt; 根据EA找到的操作数()存入MDR<br>    5.MDRout ,Yin 控制信号有效 -&gt; 将目的操作数((R0))放入暂存寄存器Y中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137539.png" alt="image.png"></p><p>执行周期过程(省略微操作):<br>    1.R1out , ALUin ,CU向ALU发送加法操作信号, 控制信号有效 -&gt;将源操作数送入ALU运算(Y寄存器同时会将之前暂存的目的操作数通过专用数据通路送往ALU)<br>    2.Zout ,MDRin 控制信号有效 -&gt; 将计算结果送入MDR寄存器<br>    3.MemW ,MDRoutE ,MARout -&gt; MDR将计算结果送到主存，MAR目的操作数地址传给主存，主存根据MAR中已经存在的目的操作数的有效地址，将结果写回到目的操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137717.png" alt="image.png"></p><h3 id="数据通路-专用数据通路方式"><a href="#数据通路-专用数据通路方式" class="headerlink" title="数据通路-专用数据通路方式"></a>数据通路-专用数据通路方式</h3><blockquote><p><em>专用数据通路-取指周期</em></p></blockquote><p>取指周期数据流向:<br>    <em>1</em>. (PC)-&gt;MAR                 C0有效<br>    <em>2</em>. (MAR) -&gt;主存             C1有效<br>    <em>3</em>. 1-&gt;R                          控制单元向主存发送读命令<br>    <em>4</em>.  M(MAR) -&gt; MDR      C2有效<br>    <em>5.</em>  (MAR) -&gt; IR              C3有效<br>    <em>6.</em>  (PC)+1-&gt;PC<br>    <em>7.</em>  Op(IR) -&gt;CU             C4有效【Op是操作码，Ad是地址码；将操作码传给CU分析】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042219807.png" alt="image.png"></p><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="硬布线控制器（组合逻辑控制器）"><a href="#硬布线控制器（组合逻辑控制器）" class="headerlink" title="硬布线控制器（组合逻辑控制器）"></a>硬布线控制器（组合逻辑控制器）</h3><h4 id="什么是硬布线控制器？"><a href="#什么是硬布线控制器？" class="headerlink" title="什么是硬布线控制器？"></a><em>什么是硬布线控制器？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070922995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070924177.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070930551.png" alt="image.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a><em>硬布线控制器的设计</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070934082.png" alt="image.png"></p><blockquote><p><em>1.分析每个阶段的微操作序列</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070935646.png" alt="image.png"></p><p><em>2.选择CPU的控制方式</em><br><strong>这里采用同步控制方式(定长机器周期)—&gt;一个周期安排3个节拍</strong></p><p><em>3.安排微操作时序</em></p><p><strong>取指周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070943155.png" alt="image.png"><br><strong>间址周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070946256.png" alt="image.png"><br><strong>执行周期</strong><br><em>访存指令STA 、ADD 、LDA<br>非访存指令<br>转移指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070945614.png" alt="image.png"></p><p><em>4.电路设计</em><br><strong>a.列出操作时间表</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951515.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952398.png" alt="image.png"><br><strong>b.写出微操作命令的最简表达式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070948343.png" alt="image.png"><br><strong>c.画出逻辑图</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951629.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062351469.png" alt="image.png"></p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><h4 id="什么是微程序控制器？"><a href="#什么是微程序控制器？" class="headerlink" title="什么是微程序控制器？"></a>什么是微程序控制器？</h4><blockquote><p><em>为了方便修改和扩展，提出了微程序控制器</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071919688.png" alt="image.png"></p><ul><li>微命令是控制部件向执行部件发出的控制信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CPU内的控制器包含:CU IR PC</span><br><span class="line">CU控制单元用于实现微指令的执行</span><br><span class="line">1.由于CM内存储了多种指令 的 微程序,所以“微地址形成部件”需要根据IR内具体</span><br><span class="line">的指令的操作码，判断该指令对应CM内哪个微程序，以获得其&quot;起始微地址&quot;</span><br><span class="line">  (改正一下表述:所谓微程序既可以说是一条完整指令，包括取指周期、间址周</span><br><span class="line">  期、执行周期、中断周期的所有微指令的总和;也可以说单独的某个周期的微程</span><br><span class="line">  序，例如:取指周期微程序，这里“微地址形成部件，的作用是在根据IR中的操作</span><br><span class="line">  码特征，分析执行周期的微程序的微指令首地址，而不是取指周期微指令首地址</span><br><span class="line">  因为取指周期是通用的它的地址可以由执行周期中最末尾的微指令的下地址指</span><br><span class="line">  明，而执行周期的微指令不是通用的，所以需要单独通过“微地址形成部件”，来</span><br><span class="line">  获得首地址)</span><br><span class="line">2.再根据&quot;顺序逻辑&quot; 中&quot;标志&quot;信息判断下一步要执行微指令的存放地址(一般标志</span><br><span class="line">信息是根据指令地址码(IR中的地址码)的特征，判断是否要进行间址周期，无需间</span><br><span class="line">接寻址就跳过间址周期微指令;如果要间接寻址,那么按照“CMDR中的下地址”顺序执</span><br><span class="line">行下去)</span><br><span class="line">3.CMAR接收来自经过顺序逻辑处理后的“起始微地址”</span><br><span class="line">4.CMAR 将地址(微指令地址)送入地址译码器，找到地址对应的微指令在CM中的位</span><br><span class="line">置</span><br><span class="line">5.CM(控制存储器)根据位置取出该条微指令(操作控制+下地址) ,送到CMDR</span><br><span class="line">6.CMDR将微指令的操作控制信息 传至CPU内部和系统总线的控制信号</span><br><span class="line">7.CMDR 将下一条(相邻的)微指令地址传给顺序逻辑(顺序逻辑会根据之前获得的标</span><br><span class="line">志+CLK信息，如果当前执行到了间址周期微指令，会根据标志信息，判断是否跳过)</span><br><span class="line">8.重复这一循环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071924474.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071950460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个微程序包括一条指令的所有周期的微指令，所以一条指令的取指周期微程序+执行周期微程序，其实是一个微程序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071958856.png" alt="image.png"></p><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092240574.png" alt="image.png"></p><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><blockquote><p><em>水平型微指令、垂直型微指令、混合型微指令</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092245360.png" alt="image.png"></p><h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><blockquote><p><em>编码方式</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微指令编码主要方式分为3种</span><br><span class="line">直接编码: </span><br><span class="line">n个微命令-&gt;需要分别对应n个bit信号位</span><br><span class="line">字段直接编码: </span><br><span class="line">采用译码器，将控制字段分段,比如3bit为1段,能产生2^3种不同信号,</span><br><span class="line">这样就能用更少bit存储控制信号。</span><br><span class="line">这样实现，相同字段内的控制信息无法并行进行--&gt;所以互斥信号放在同一字段</span><br><span class="line">字段间接编码:</span><br><span class="line">译码器上加一层译码器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101035576.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101037705.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101047396.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><em>互斥的放在同一段内，控制字段，需要表示的状态数，需要预留一个全0,表示无操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101046382.png" alt="image.png"></p><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><blockquote><p><em>方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101050533.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101053029.png" alt="image.png"></p><h5 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h5><blockquote><p><em>微程序控制单元的设计</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141414952.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141419465.png" alt="image.png"></p><p><em>微程序设计的分类</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141420731.png" alt="image.png"></p><p><em>硬布线与微程序的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421167.png" alt="image.png"></p><p><em>微程序控制器回顾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421854.png" alt="image.png"></p></blockquote><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141625402.png" alt="image.png"></p><h3 id="指令流水线基本概念性能指标"><a href="#指令流水线基本概念性能指标" class="headerlink" title="指令流水线基本概念性能指标"></a>指令流水线基本概念性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141515119.png" alt="image.png"></p><h4 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a><em>指令流水的定义</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141632815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141501856.png" alt="image.png"></p></blockquote><h4 id="流水线表示方法"><a href="#流水线表示方法" class="headerlink" title="流水线表示方法"></a><em>流水线表示方法</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141500715.png" alt="image.png"></p></blockquote><h4 id="流水线的性能指标-—吞吐率、加速比、效率"><a href="#流水线的性能指标-—吞吐率、加速比、效率" class="headerlink" title="流水线的性能指标 —吞吐率、加速比、效率"></a><em>流水线的性能指标</em> —<strong>吞吐率、加速比、效率</strong></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513423.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513840.png" alt="image.png"></p></blockquote><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">完成一条指令，常分为五个阶段:</span><br><span class="line">IF(取指阶段)、ID(译码段)、EX(执行段)、M(访存)、WB(写回)</span><br><span class="line"></span><br><span class="line">由于每个功能段需要消耗时间不一致，为了统一方便指令流水线，以最长耗时为准这里就设为100ns</span><br><span class="line"></span><br><span class="line">同时就需要在每个功能段后面加一个缓冲寄存器--&gt;锁存器</span><br><span class="line">目的是为了保证执行更快的阶段，将数据存放，处于缓冲等待的状态，以维持统一</span><br><span class="line"></span><br><span class="line">Instruction Cache(指令Cache)--也就是Cache中存放指令的区域</span><br><span class="line">取指一般都是在指令Cache中取指</span><br><span class="line"></span><br><span class="line">Data Cache(数据Cache)--也就是Cache数据区域</span><br><span class="line">M访存，当Cache命中的情况下，直接访问数据Cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142119460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考试中常见的指令有五类(RSIC精简指令集)</span><br><span class="line">运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142127965.png" alt="image.png"></p><h4 id="各类指令的执行过程"><a href="#各类指令的执行过程" class="headerlink" title="各类指令的执行过程"></a>各类指令的执行过程</h4><h5 id="运算类指令执行过程"><a href="#运算类指令执行过程" class="headerlink" title="运算类指令执行过程"></a>运算类指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142135940.png" alt="image.png"></p><h5 id="LOAD指令执行过程"><a href="#LOAD指令执行过程" class="headerlink" title="LOAD指令执行过程"></a>LOAD指令执行过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD--取数指令，RSIC指令集中唯二可以访存的指令,作用是从主存取数到寄存器中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142144944.png" alt="image.png"></p><h5 id="STORE指令执行过程"><a href="#STORE指令执行过程" class="headerlink" title="STORE指令执行过程"></a>STORE指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142150614.png" alt="image.png"></p><h5 id="条件转移指令执行过程"><a href="#条件转移指令执行过程" class="headerlink" title="条件转移指令执行过程"></a>条件转移指令执行过程</h5><p><strong>WrPC逻辑上既不属于M段，也不属于WB段，只是因为WrPC所需要的功能部件与这5个阶段的功能部件是“相互独立的”，所以可以看做一个独立的阶段，可以自由安排</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142157041.png" alt="image.png"></p><h5 id="无条件转移指令执行过程"><a href="#无条件转移指令执行过程" class="headerlink" title="无条件转移指令执行过程"></a>无条件转移指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142205108.png" alt="image.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207049.png" alt="image.png"></p><h3 id="指令流水线的影响因素"><a href="#指令流水线的影响因素" class="headerlink" title="指令流水线的影响因素"></a>指令流水线的影响因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142243130.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142245235.png" alt="image.png"></p><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p><em>这里三地址指令的顺序搞错了，顺序应该是OP R1 R2 R3  —&gt; (R1)OP(R2)—&gt;R3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142254264.png" alt="image.png"></p><blockquote><p><em>硬件阻塞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142257185.png" alt="image.png"><br><em>NOP空操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142256095.png" alt="image.png"><br><em>数据旁路技术</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142308675.png" alt="image.png"></p></blockquote><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><em>由于指令会提前预取，如果到时候需要进行条件转移，那么之前预取的指令就不会执行，浪费导致阻塞</em><br><em>解决办法就是尽早的判别是否需要跳转</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151112357.png" alt="image.png"></p><h3 id="指令流水线分类"><a href="#指令流水线分类" class="headerlink" title="指令流水线分类"></a>指令流水线分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151115488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151120957.png" alt="image.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151125637.png" alt="image.png"></p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127336.png" alt="image.png"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127292.png" alt="image.png"></p><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151153767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151258121.png" alt="new.png"></p><blockquote><p><em>SISD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453525.png" alt="image.png"></p><p><em>SIMD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453930.png" alt="image.png"></p><p><em>MIMD</em></p><p><strong>共享存储多处理器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454475.png" alt="image.png"><br><strong>多计算机系统</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454095.png" alt="image.png"></p><p><em>向量处理器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151455393.png" alt="image.png"></p></blockquote><h2 id="硬件多线程的基本概念"><a href="#硬件多线程的基本概念" class="headerlink" title="硬件多线程的基本概念"></a>硬件多线程的基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504162.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504522.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151505623.png" alt="image.png"></p><h2 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h2><h3 id="CPU的功能与结构习题"><a href="#CPU的功能与结构习题" class="headerlink" title="CPU的功能与结构习题"></a>CPU的功能与结构习题</h3><blockquote><p><em>PSW属于运算器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161825605.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161834865.png" alt="image.png"></p><p><em>指令寄存器就是IR</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161835516.png" alt="image.png"></p><p><em><mark>操作系统位数是指操作系统可寻址的位数</mark></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161844725.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161846997.png" alt="image.png"></p><p><em>CPU中寄存器分为用户可见，和不可见</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161847536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161853622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161854165.png" alt="image.png"></p><p><em>存储字长—假如内存按照字节寻址，则内存中一个地址对应1byte,存储字长就是1byte</em><br><em>机器字长—CPU一次性能处理的数据的最大位数，往往等于运算器中寄存器的位数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161856909.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162105859.png" alt="image.png"></p><p><em>地址译码器属于主存，是将地址信号翻译成存储器的选通信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162111498.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162129014.png" alt="image.png"></p><p><em>如果指令字按字边界对齐，那么可以按一个机器字(这里是32bit=4B)，占一个地址。所以，本来按字节编址需要32位，那么按字编址，就只需30位</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162132028.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162201928.png" alt="image.png"></p></blockquote><h3 id="指令执行过程习题"><a href="#指令执行过程习题" class="headerlink" title="指令执行过程习题"></a>指令执行过程习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162204207.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162208016.png" alt="image.png"></p><p><em>需要存取的指令地址信息，追根究底来自于PC</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162215113.png" alt="image.png"></p><p><em>机器周期—取决于访存时间—&gt;存取周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172057737.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172103654.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172106455.png" alt="image.png"></p><p><em>1.取指操作是控制器固有的功能，不需要操作码控制</em><br><em>2.指令有长有短，当指令过长占两个存储字长时，就需要两次访存</em><br><em>3.中断周期，是在当前指令执行完之后才出现</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172110895.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172113362.png" alt="image.png"></p><p><em>冯诺依曼计算机—&gt;同时存储指令和数据，并且统一编址</em><br><em>那吗如何区分取得的二进制串是数据还是指令呢？</em><br><em>1.首先先规定一个指令入口地址，这个地址存放的必定是指令</em><br><em>2.从入口地址取指令，然后根据指令周期的阶段，当进行到执行周期，取的<br>一定是数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172122269.png" alt="image.png"></p><p><em>开中断是指 允许中断</em><br><em>取完空操作指令，PC照样会+1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172154839.png" alt="image.png"></p><p><em>中断周期的前一个周期—&gt;执行周期</em><br><em>中断周期的后一个周期—&gt;下一条指令的取指周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172159620.png" alt="image.png"></p></blockquote><h3 id="数据通路的功能和基本概念习题"><a href="#数据通路的功能和基本概念习题" class="headerlink" title="数据通路的功能和基本概念习题"></a>数据通路的功能和基本概念习题</h3><blockquote><p><em>数据通路是指数据不同功能部件之间传送的路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172205638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172227023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172232124.png" alt="image.png"></p><p><em>CPU内部单总线结构—由于只有一条数据总线，所以切换时钟周期T(节拍时)<br>就需要先释放上一个时钟周期里面微操作所占用的数据通路，才能开始下一个微操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181557135.png" alt="image.png"></p><p><em>举例：一整个完整管道系统(管道+阀门) ，就是一个数据通路(电路+部件)<br>水管就是电路，阀门就是部件(不能存储，是时序逻辑元件)</em><br><em>部件 分为 组合逻辑元件(不能存储，也称操作元件) 和 时序逻辑元件(能存储，也称状态元件)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181603679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181612657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181621484.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181630451.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181631386.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181716181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181719840.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181720622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182056692.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182057675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182058005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182102014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182117697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182112370.png" alt="image.png"></p><p><em>1.该指令，是变址寻址, X是变址寄存器XR ,D是形式地址，所以有效地址是(X)+D,那么，得到有效地址只有1个，也就意味着操作数只有一个，所以是隐含了一个操作数在ACC里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182129217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182147615.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182151182.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182158118.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191121774.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191123723.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191124619.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191128718.png" alt="image.png"></p><p><em>答题要爽快</em><br><em>1.题中M(MAR)-&gt;MDR ,外部总线数据输入到MDR控制信号MDRinE ,图中没有给出，可以不写<br>2.IR，FR(状态字寄存器)都与CU输入端相连<br>3.rd,目的寄存器，rs，源寄存器<br>4.题中声明了数据送到MDR需要5个时钟周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146369.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146756.png" alt="image.png"></p></blockquote><h3 id="控制器的功能和工作原理-1"><a href="#控制器的功能和工作原理-1" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191433576.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191444240.png" alt="image.png"></p><p><em>1.缩短微指令长度，自然可以减少从CM中取指的次数，加快速度</em><br><em>2.增大控制存储器CM容量，会增加对CPU占用率，所以应该是减少CM容量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191447484.png" alt="image.png"></p><p><em>1.控制存储器CM是用的ROM芯片，只读存储器，非易失性存储器，里面的微指令是出厂就设定好的</em><br><em>2.主存是用的DRAM芯片，易失性存储器，关机数据就清空</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191454136.png" alt="image.png"></p><p><em>访存延迟比电路延迟大很多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191502908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191504073.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191550336.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191556007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191627070.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191628996.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191633814.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191636725.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191923360.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191928517.png" alt="image.png"></p><p><em>对于汇编语言程序员可见的寄存器，即是在汇编语言中能出现的寄存器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191930184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191936535.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191952494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191958740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192104787.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192107103.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192115047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192116029.png" alt="image.png"></p></blockquote><h3 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192120189.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192123119.png" alt="image.png"></p></blockquote><h3 id="指令流水线习题"><a href="#指令流水线习题" class="headerlink" title="指令流水线习题"></a>指令流水线习题</h3><blockquote><p><em>流水CPU—时间并行技术<br>RSIC采用的一定是流水CPU，部分CSIC也采用流水CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202134527.png" alt="image.png"></p><p><em>超标量流水线—空间换时间，配置多个相同功能部件，同时处理相同任务</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202140283.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202147772.png" alt="image.png"></p><p><em>m段流水线稳定时，是指，第一条指令完全从头到尾执行完，之后，每隔一个时钟周期，都会有一条指令执行结束，这样的状态就是稳定状态<br>稳定状态平均下来，一个时钟周期，完成一条任务,CPU吞吐能力(单位时间内流水线完成的任务数量)=1条/T ; 等效于m个并行部件CPU吞吐能力</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211139928.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211150637.png" alt="image.png"><br><em>度为4，表示处理机能并行处理4条指令(超标量流水技术)，那么处理20条指令，相当于普通流水线处理20/4=5条指令，过程与上面一致</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211153372.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211200981.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211444035.png" alt="image.png"></p><p><em>1.加入空操作，可以解决所有类型的指令流水线影响因素(结构、数据、控制)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211450269.png" alt="image.png"></p><p><em>数据相关流水线冲突有:<br>RAW(写后读冲突)：在前一条指令还没有写回数据，后面就开始读取该数据<br>WAR(读后写冲突)：在前一条指令对数据还没有开始读，后一条指令就开始写<br>WAW(写后写冲突)：后续指令比前面的指令先进行写数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211512534.png" alt="image.png"></p><p><em>要实现流水线必须将每个功能段时间取为一样长,且按照最长的功能段为标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211513312.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211529027.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211532867.png" alt="image.png"></p><p><em>动态调度技术，就是将能够并行执行，不会造成数据冲突的指令安排调度在同一个周期内完成</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211540142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211603920.png" alt="image.png"></p><p><em>流水段寄存器延时—指令功能段与段(部件与部件)之间需要通过将之前的数据放到寄存器里，传递给后面的功能段(部件)，这里存在一些时间延迟，所以考虑CPU时钟周期，不仅要以最长时间为标准，还需要加上寄存器延时</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211606983.png" alt="image.png"></p><p><em>1.单周期CPU—指令周期不细化分为取指、间址、执行、等等周期，理想状态1个时钟周期就可执行一条指令<br>2.多周期CPU—指令周期细分为取指、间址、执行、中断等多个机器周期，每个机器周期都需要多个时钟周期<br>3.基本流水线—理想状态下，稳定后，隔1个时钟周期就能完成一条指令<br>4.超标量流水线—理想状态下，稳定后，隔一个时钟周期，能完成多条指令，CPI&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211617413.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211635734.png" alt="image.png"></p><p><em>画出流水线时空图、非流水线时空图、指令周期流程图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211700005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211644593.png" alt="image.png"></p><p><em>画出流水线功能段结构图、指令执行过程流水线的时空图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211658332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211659606.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211942581.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211944729.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211948548.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211951115.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212046439.png" alt="image.png"></p><p><em>（1）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212115428.png" alt="image.png"><br><em>（2）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212123922.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212120953.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212127310.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212150355.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159175.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159029.png" alt="image.png"><br><em>（3）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212206954.png" alt="image.png"></p></blockquote><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151633335.png" alt="image.png"></p><h2 id="总线的概念与分类"><a href="#总线的概念与分类" class="headerlink" title="总线的概念与分类"></a>总线的概念与分类</h2><h3 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151634177.png" alt="image.png"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151641836.png" alt="image.png"></p><h4 id="按数据传输格式"><a href="#按数据传输格式" class="headerlink" title="按数据传输格式"></a>按数据传输格式</h4><p><em>并行总线由与传输速率过快，容易产生电磁干扰，所以，并行总线不一定比串行总线传输速度快</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151644599.png" alt="image.png"></p><h4 id="按总线功能"><a href="#按总线功能" class="headerlink" title="按总线功能"></a>按总线功能</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151646654.png" alt="image.png"></p><blockquote><p><em>重点介绍系统总线- 单总线结构</em></p><p><em>1.单总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151655545.png" alt="image.png"><br><em>2.双总线结构</em><br><em>【突发传输+通道】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151701271.png" alt="image.png"><br><em>3.三总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151821115.png" alt="image.png"><br><em>4.四总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151822640.png" alt="image.png"></p></blockquote><h4 id="按时序控制方式"><a href="#按时序控制方式" class="headerlink" title="按时序控制方式"></a>按时序控制方式</h4><blockquote><p><em>略</em></p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151648934.png" alt="image.png"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p>&gt;<br><em>1.总线的传输周期（总线周期）<br>2.总线时钟周期<br>3.总线的工作频率<br>4.总线的时钟频率<br>5.总线宽度<br>6.总线带宽<br>7.总线复用<br>8.信号线数</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151833607.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834590.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834082.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151838059.png" alt="image.png"><br><em>地址/数据总线复用，使得使用较少的线传输更多信息，但是这样，数据地址就只能交替进行输送，不能同时进行，会降低数据传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151844178.png" alt="image.png"></p><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><h2 id="习题-7"><a href="#习题-7" class="headerlink" title="习题"></a>习题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121248608.png" alt="image.png"></p><p><em>1.总线同一时刻只能有一个设备发送数据，但可以有越多台设备接收数据</em><br><em>2.总线同一时刻只能有一个主设备控制总线传输操作，主设备可以要求从设备发送数据，也可以自己发送数据给从设备，这个控制权在主设备手中</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121332574.png" alt="image.png"></p><p><em>1.系统总线有多种总线结构，其中单总线结构(不止只有一条总线，包含数据、地址、控制总线)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121341960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121347353.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121349253.png" alt="image.png"></p><p><em>1.一次间接寻址获得的数据是操作数的有效地址</em><br><em>2.其实这个有效地址还是经过数据总线传送给CPU的</em><br><em>3.地址总线只能是单向的从CPU到主存，不能从主存到CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121350811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121359492.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121426426.png" alt="image.png"></p><p><em>1.CPU从主存获得的数据都是从数据总线送过来的；对于CPU识别从主存取的数据是<strong>地址</strong>还是<strong>操作数</strong>，是通过当前处于指令周期的那个阶段来判断，具体通过控制单元，识别状态触发器的二进制位信息</em><br><em>2.主存则通过，送过来的数据是通过数据总线还是地址总线，来确定是数据还是地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121431767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121427891.png" alt="image.png"></p><p><em>总线带宽，计算练习</em><br><em>注意区分：时钟频率与总线频率的区别</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121434319.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121439770.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121442220.png" alt="image.png"></p><p><em>分辨率：代表一个图中总共有多少<strong>单元</strong>构成</em><br><em>颜色：每个单元内有多少种颜色</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121436770.png" alt="image.png"></p><p><em>总线标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121445379.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121624261.png" alt="image.png"></p><p><em>突发传输方式：是指，往主存送入一个块的首地址，那么就可以连续的读写后面后面一连串地址的数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121628976.png" alt="image.png"></p><p><em>USB又称通用串行总线，只能单个bit传输数据，但是传输路很高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121631356.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121634840.png" alt="image.png"></p><p><em>同步通信方式，同步时钟信号，必须要同一设备给出，以保证统一<br>同步通信方式，要求时钟信号保持一致，但是如果有的设备离的比较远，时钟信号传输中会有延迟，所有会导致时钟信号不统一，所以同步通信方式只适合设备距离较近的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121644500.png" alt="image.png"></p><p><em>1.并行总线速度过快会有干扰，串行则不会，所以串行并不一定比并行慢<br>2.突发传输：送入一个首地址，能连续读或写一连串数据<br>普通传输：送入一个地址，读或写一个数据；<br>由于传输地址信息需要占用总线，读取数据也需要占用总线，所以突发传输提高了总线利用率，更少的用来传输地址信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121650695.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121651874.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121703663.png" alt="image.png"></p><p><em>三通道总线，可以三个通道互相独立工作，那就要x3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121705356.png" alt="image.png"></p><p><em>总线一般被设计来传输固定大小的一块数据，这块数据被称为字(word),一个字包含的字节数(即字的大小)是各种计算机系统里面的基本参数，而且这个参数在不同的系统里通常是不同的。 大多数的现代计算机系统里面，<strong>一个字要么是4个字节（32位），要么是8个字节（64位）</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121713698.png" alt="image.png"></p><p><em>70%数据用于读，30%数据用于写；由于读的速度慢，写的速度快，所以读的时间&gt;70%总时间，写的时间&lt;30%总时间；故应该按照数据量去算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121718898.png" alt="image.png"></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091313764.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;计算机系统概述&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="计算机组成原理" scheme="https://fqzs.netlify.app/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Telegram</title>
    <link href="https://fqzs.netlify.app/undefined/fd45428c.html"/>
    <id>https://fqzs.netlify.app/undefined/fd45428c.html</id>
    <published>2023-04-28T18:47:00.000Z</published>
    <updated>2023-09-10T03:27:41.777Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091314351.png" alt="image.png"></p><h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309091314351.png&quot; alt=&quot;image.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;常用bot&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
</feed>
