<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>计算机网络 | 风起之时</title><meta name="author" content="风起之时"><meta name="copyright" content="风起之时"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络体系结构认识计算机网络1计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 12ip池由因特网管理机构管理	ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户   计算机网络的组成与分类组成 组成成分  硬件 软件 协议   1协议是规定这些数据如何封装、打包、传输    工作方式"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络"><meta property="og:url" content="https://fqzs.netlify.app/undefined/e255a10a.html"><meta property="og:site_name" content="风起之时"><meta property="og:description" content="计算机网络体系结构认识计算机网络1计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统 12ip池由因特网管理机构管理	ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户   计算机网络的组成与分类组成 组成成分  硬件 软件 协议   1协议是规定这些数据如何封装、打包、传输    工作方式"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png"><meta property="article:published_time" content="2023-06-03T17:23:00.000Z"><meta property="article:modified_time" content="2023-09-08T15:04:20.108Z"><meta property="article:author" content="风起之时"><meta property="article:tag" content="风起之时，有趣的博客"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png"><link rel="shortcut icon" href="https://s1.ax1x.com/2023/04/01/ppWVscq.png"><link rel="canonical" href="https://fqzs.netlify.app/undefined/e255a10a.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/manifest.json"><meta name="msapplication-TileColor" content="#3b70fc"><link rel="apple-touch-icon" sizes="180x180" href="/img/siteicon/128.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/siteicon/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/siteicon/16.png"><link rel="mask-icon" href="/img/siteicon/128.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"计算机网络",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-08 15:04:20"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/readPercent.css"><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="/css/custom.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/css/runtime/runtime.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload='this.media="all"'><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload='this.media="all"'><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="风起之时" type="application/atom+xml"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s1.ax1x.com/2023/04/01/ppWEUY9.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-home"></i> <span>追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="风起之时"><span class="site-name">风起之时</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>Home</span></a></div><div class="menus_item"><a class="site-page" href="/bangumis/"><i class="fa-fw fas fa-home"></i> <span>追番</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">计算机网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-03T17:23:00.000Z" title="发表于 2023-06-03 17:23:00">2023-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-08T15:04:20.108Z" title="更新于 2023-09-08 15:04:20">2023-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">37.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>114分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="计算机网络"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" alt="image.png"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">	ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">	- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">	- C/S: </span><br><span class="line">		Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被</span><br><span class="line">		服务的关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资</span><br><span class="line">		源有限同时发消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">	- B/S</span><br><span class="line">		Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主</span><br><span class="line">		要指下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上</span><br><span class="line">		与服务端进行通信</span><br><span class="line">	- P2P</span><br><span class="line">		pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服</span><br><span class="line">		务端又是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境</span><br><span class="line">		当中，下载的主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">	- 物理层: 集线器、中继器</span><br><span class="line">	- 数据链路层: 交换机、网桥</span><br><span class="line">	- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">	- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一</span><br><span class="line">	       点点交换出去.</span><br><span class="line">	- MAN :城域网</span><br><span class="line">	- LAN :局域网 --&gt;广播技术 </span><br><span class="line">	- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">	- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">	- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">	- 电路交换：</span><br><span class="line">		就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电</span><br><span class="line">		话(释放链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">	- 报文交换：</span><br><span class="line">		 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，</span><br><span class="line">		 然后再由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段</span><br><span class="line">		 的占用链路，不像电路交换持续占用着链路资源</span><br><span class="line">	- 分组交换</span><br><span class="line">		与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">	- 总线型</span><br><span class="line">	- 星型</span><br><span class="line">	- 环型</span><br><span class="line">	- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">	- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机</span><br><span class="line">	  发出报文分组其他计算机都能收到报文分组</span><br><span class="line">	- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">	1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">	1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">	比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">	但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">	不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">	--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">	- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入</span><br><span class="line">	10bit信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">	- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">	取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">	一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间</span><br><span class="line">	被称为排队时延</span><br><span class="line">处理时延：</span><br><span class="line">	当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被</span><br><span class="line">	称为处理时延</span><br><span class="line">	</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">	描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">	- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">		ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">	- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">	- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line">	</span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line">	</span><br><span class="line">服务：</span><br><span class="line">	</span><br><span class="line">接口：</span><br><span class="line">	</span><br><span class="line">SDU：服务数据单元</span><br><span class="line">	</span><br><span class="line">PCI：协议控制信息</span><br><span class="line">	</span><br><span class="line">PDU：协议数据单元</span><br><span class="line">	上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">	- 7层OSI参考模型</span><br><span class="line">		法定标准</span><br><span class="line">	- 4层TCP/IP参考模型</span><br><span class="line">		事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">		事实标准</span><br><span class="line">	- 5层体系结构：</span><br><span class="line">		这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">	起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">	出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">	因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">	- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">	但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">	- 应用层常见服务：</span><br><span class="line">		1.文件传输(FTP)</span><br><span class="line">		2.电子邮件(SMTP)</span><br><span class="line">		3.万维网(HTTP)</span><br><span class="line">		...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">	- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">	- 主要功能：</span><br><span class="line">		1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">		2.数据加密通信</span><br><span class="line">		3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">	- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步</span><br><span class="line">	  (SYN)</span><br><span class="line">	- 主要功能：</span><br><span class="line">		1.建立、管理、终止会话</span><br><span class="line">		2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载</span><br><span class="line">		app，网络断开，重新连接上后能继续从断点处下载)</span><br><span class="line">		</span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">	- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用</span><br><span class="line">	  户数据报</span><br><span class="line">	- 主要功能：</span><br><span class="line">		1.可靠传输、不可靠传输</span><br><span class="line">			- 可靠传输：</span><br><span class="line">				传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返</span><br><span class="line">				回确认信息后，才会发送下一段内容；如果没有接收到确认信息，那</span><br><span class="line">				么会一直发送当前段消息，直到接收到确认信息。</span><br><span class="line">			- 不可靠传输：</span><br><span class="line">				传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无</span><br><span class="line">				需确认这样可以节约时间</span><br><span class="line">		2.差错控制:位错、帧错控制校验</span><br><span class="line">		3.流量控制</span><br><span class="line">			控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速</span><br><span class="line">			度</span><br><span class="line">		4.复用分用</span><br><span class="line">			- 复用：</span><br><span class="line">				是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发</span><br><span class="line">				消息，qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">			- 分用：</span><br><span class="line">				混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进</span><br><span class="line">				行区分，例如请qq的消息端口号是1，接收方端口号1的进程(qq)接</span><br><span class="line">				收该条消息；微信端口号2，接收方端口号2的进程(微信)接受该条消</span><br><span class="line">				息</span><br><span class="line">		5.拥塞控制</span><br><span class="line">	       - 传输层协议</span><br><span class="line">		       1.TCP</span><br><span class="line">		       2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">	- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服</span><br><span class="line">	   务，网络层传输单位是&quot;数据报&quot; </span><br><span class="line">	- 分组与数据报的关系？</span><br><span class="line">		当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">	- 主要功能：</span><br><span class="line">		1.路由选择：</span><br><span class="line">			选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">		2.流量控制：</span><br><span class="line">			协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">		3.差错控制：</span><br><span class="line">			通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则</span><br><span class="line">			进行对分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制</span><br><span class="line">			校验)</span><br><span class="line">		4.拥塞控制：是一种全局的调控，与流量控制不同(只是控制收发方的流量速</span><br><span class="line">		度)，而拥塞控制，是对所有线路可能产生的拥塞进行控制</span><br><span class="line">			</span><br><span class="line">	</span><br><span class="line">数据链路层: </span><br><span class="line">	- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">	- 主要功能：</span><br><span class="line">		1.成帧(定义帧的开始和结束)</span><br><span class="line">			对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里</span><br><span class="line">			开始，到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和</span><br><span class="line">			解封装</span><br><span class="line">		2.差错控制:位错、帧错控制校验</span><br><span class="line">		3.流量控制：发送方速度过快或过慢，可以减慢或加速发送速度</span><br><span class="line">		4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">	- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合</span><br><span class="line">	都可在链路上传输</span><br></pre></td></tr></table></figure><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"><p></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">	该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">	相同点：</span><br><span class="line">		1.都分层</span><br><span class="line">		2.基于独立的协议栈的概念</span><br><span class="line">		3.可以实现异构网络互连</span><br><span class="line">	不同点：</span><br><span class="line">		1.OSI定义三点：服务、协议、接口</span><br><span class="line">		2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">		3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">		4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">			- TCP/IP：</span><br><span class="line">				- 网络层：无连接</span><br><span class="line">				- 传输层：无连接+面向连接</span><br><span class="line">			- IOS/OSI：</span><br><span class="line">				- 网络层：无连接+面向连接</span><br><span class="line">				- 传输层：面向连接</span><br><span class="line">	什么是无连接和面向连接？</span><br><span class="line">		</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="计算机网络结构分层汇总"><a href="#计算机网络结构分层汇总" class="headerlink" title="计算机网络结构分层汇总"></a>计算机网络结构分层汇总</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><nobr><font size="2">OSI七层模型</font></nobr></th><th style="text-align:center"><nobr><font size="2">TCP/IP概念模型</font></nobr></th><th style="text-align:center"><font size="2">功能</font></th><th style="text-align:center"><font size="2"><nobr>TCP/IP协议族</nobr></font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">应用层</font></td><td rowspan="3"><font size="2"><center>应用层</center></font></td><td style="text-align:center"><font size="2"><nobr>文件传输、电子邮件、文件服务、虚拟终端</nobr></font></td><td style="text-align:center"><font size="2"><nobr>TFTP，HTTP，SNMP，FTP，SMTP，POP3，DNS，RIP，BGP，DHCP</nobr></font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">表示层</font></td><td style="text-align:center"><font size="2"><nobr>数据格式化、代码转换、数据加密</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">会话层</font></td><td style="text-align:center"><font size="2"><nobr>解除或建立与别的接电的联系</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">提供端对端接口</font></td><td style="text-align:center"><font size="2">TCP，UDP</font></td></tr><tr><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">为数据报选择路由</font></td><td style="text-align:center"><font size="2">IP，ICMP，OSPF，ARP，IGMP</font></td></tr><tr><td style="text-align:center"><font size="2">数据链路层</font></td><td rowspan="2"><center><font size="2">链路层</font></center></td><td style="text-align:center"><font size="2">传输有地址的帧以及错误检测功能</font></td><td style="text-align:center"><font size="2">SLIP，CSLIP，PPP，ARP，RARP，NTU</font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">物理层</font></td><td style="text-align:center"><font size="2">以二进制数据形式在物理媒体上传输数据</font></td><td style="text-align:center"><font size="2">IS02110，IEEE802，IEEE802.2</font></td></tr></tbody></table></div><div style="background-color:#fffacd;padding:20px"><mark>什么是协议？</mark><li><font size="2">实体：每层要进行处理的数据单元</font></li><li><font size="2">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</font></li><br><mark>如何判断协议属于哪一层？</mark><br>答：根据封装关系；例如：<font color="#FF0000" size="3">BGP协议是应用层的协议使用UDP封装（使用的传输层的封装和传输服务），所以根据下层为上层提供服务的原则，判断该协议属于哪一层</font></div><div style="background-color:#fffacd;padding:20px"><mark>数据报与报文的区别？</mark><br>1.数据报(Datagram)<font size="3"><li>网络层的数据传输单位,由源地址、目的地址、数据等组成。</li><li>使用不可靠的网络层服务,以独立的形式传输。</li><li>每个数据报都独立路由转发,不需要建立连接。</li><li>使用的数据报协议典型如IP协议。</li><br></font>2. 报文(Message)<font size="3"><li>传输层的数据传输单位,由报头、正文组成。</li><li>使用面向连接的传输层服务,需要建立连接</li><li>对于同一连接的报文,必须按顺序逐一传输</li><li>使用的报文协议典型如TCP协议。</li></font><br><br><mark>为什么传输层UPP协议的数据传输单位也是数据报？</mark><br><font size="3">数据报(Datagram)是网络层的传输单位,但UDP作为一种无连接的传输层协议,其传输特性类似网络层,所以其数据传输单位也采用了数据报的形式。UDP和网络层都使用数据报作为传输单位,但UDP还有一些传输层的特性,如端口号、校验等。所以UDP使用数据报只是因为其无连接的传输特性类似网络层,但UDP仍属于传输层协议。</font></div><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">	- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">	- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line">	</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">	带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">	(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">	带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">	1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">		- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">		- 缺点：速度慢，需要分割和拼接</span><br><span class="line">	2.第二种一次性传输</span><br><span class="line">		- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">		- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">	建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">		发送时延=x/b</span><br><span class="line">		传播时延=kd</span><br><span class="line">		建立交换电路的时间=s</span><br><span class="line">		=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">	分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">	发送时延:</span><br><span class="line">		第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">		因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">		=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">	以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">	2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">	以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">	上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">	ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">	约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">	下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">	就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">	- 传输层: TCP头</span><br><span class="line">	- 网络层: IP头</span><br><span class="line">	- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"><p></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">	应用层SAP:用户界面</span><br><span class="line">	传输层SAP:端口号</span><br><span class="line">	网络层SAP:IP地址</span><br><span class="line">	数据链路层SAP:MAC地址</span><br><span class="line">	物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基础知识1"><a href="#数据通信基础知识1" class="headerlink" title="数据通信基础知识1"></a>数据通信基础知识1</h3><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>单、半、全三种通信方式</em></p></blockquote><p><em>单工通信：一条单向的信道(一条信道同一时刻要么接收，要么发送)<br>半双工通信：两条单向的信道<br>全双工通信：两条双向的信道(一条信道同一时刻，可以同时发送和接收)</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>串行与并行传输方式</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261729820.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输通信方式</em></p></blockquote><p><em>同步传输：传输数据是连续传输<br>异步传输：数据间间断断，传输</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261735457.png" alt="image.png"></p><h3 id="数据通信基础知识2"><a href="#数据通信基础知识2" class="headerlink" title="数据通信基础知识2"></a>数据通信基础知识2</h3><blockquote><p><em>码元</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261959550.png" alt="image.png"></p><blockquote><p><em>速率、波特</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001116.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001158.png" alt="image.png"></p><blockquote><p><em>带宽</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001622.png" alt="image.png"></p><h3 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h3><blockquote><p><em>奈氏准则</em></p></blockquote><ul><li><em>是在理想低通(无噪声、带宽受到限制)条件下，避免 <strong>码间串扰</strong> 确定的极限的码元的传输速率=2W Baud，所以极限 信息传输速率=2W ×n （n是码元bit数，就是n进制码元）</em></li><li><em>W 表示带宽，单位Hz</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262100499.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262104722.png" alt="image.png"></p><blockquote><p><em>香农定理</em></p></blockquote><ul><li><em>是在带宽受限，且有噪声的信道中，规定的在该噪声条件下的，不影响码元判断的，极限数据传输速率</em></li><li><em>S/N是信噪比，常常用作10log10(S/N) 来进行转换，从而将单位记作dB,就是定义了一个转换数值的公式</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262108690.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262114311.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262115670.png" alt="image.png"></p><blockquote><p><em>香农和奈氏</em></p></blockquote><ul><li><em>奈氏准则：关注的是无噪声条件下，不会造成码间串扰的极限 数据传输速率</em></li><li><em>香农定理：关注的是在当前噪声条件下，不会导致数据码元判断失真的 数据极限传输速率</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262120589.png" alt="image.png"></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a><em>基带信号与宽带信号</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262222235.png" alt="image.png"></p><h4 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a><em>编码与调制</em></h4><p><em>将数据 编码 /调制 —&gt;信号</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262223896.png" alt="image.png"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a><em>数字数据编码为数字信号</em></h4><blockquote><p><em>非归零编码</em></p></blockquote><p><em>缺点是，需要额外的信道，传输时钟周期信号，告诉多久发一个bit信息</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271044394.png" alt="image.png"></p><blockquote><p><em>归零编码</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262237642.png" alt="image.png"></p><blockquote><p><em>反向不归零编码</em></p></blockquote><ul><li><em>缺点是，对于发送全1的信号，无法判断，有多少个1，因为，高低电平都有可能是1</em></li><li><em>还有就是，缺点在全1，的时候，会出现长条，没有时钟周期，就无法得知发送了，多少个1</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262234072.png" alt="image.png"></li></ul><blockquote><p><em>曼彻斯特编码</em></p></blockquote><ul><li><em>1bit数据，就是1码元，被调制成两段电平，所以数据传输速率只有调制速率的1/2</em></li><li><em>每个码元中间，有一次跳变，可以实现同步，可通过中间跳变反应时钟信号</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271051270.png" alt="image.png"></li></ul><blockquote><p><em>差分曼彻斯特编码</em></p></blockquote><ul><li><em>每个码元中间都有一次跳变，可以实现同步</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271059163.png" alt="image.png"></li></ul><blockquote><p><em>4B/5B编码</em></p></blockquote><ul><li><em>编码效率80%</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271101120.png" alt="image.png"></li></ul><h4 id="数字数据调制成模拟信号"><a href="#数字数据调制成模拟信号" class="headerlink" title="数字数据调制成模拟信号"></a><em>数字数据调制成模拟信号</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271105446.png" alt="image.png"></p><ul><li><em>采样频率要达到信号最高频率的2倍以上，以保证，可以在每一个最高频的信号峰之内都可以采样到2个信息，得到波峰图</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271112992.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271114621.png" alt="image.png"></p><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271138465.png" alt="image.png"></p><blockquote><p><em>1.电路交换</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271319318.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320037.png" alt="image.png"></p><blockquote><p><em>2.报文交换</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320009.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320369.png" alt="image.png"></p><blockquote><p><em>3.分组交换</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321465.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321976.png" alt="image.png"></p><blockquote><p><em>数据交换方式的选择</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271324239.png" alt="image.png"></p><blockquote><p><em>3.1.分组交换—数据报方式</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271325439.png" alt="image.png"></p><p><em>无连接服务，就是事先不为分组确定传输路径，传输路径全靠路由选择</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326584.png" alt="image.png"></p><blockquote><p><em>3.2分组交换—虚电路方式</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326838.png" alt="image.png"></p><p><em>连接服务，就是事先要确定分组的传输路径，提前建立连接，然后再按照这个路径输送数据</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327331.png" alt="image.png"></p><blockquote><p><em>虚电路与数据报方式的区别</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327057.png" alt="image.png"></p><h2 id="传输介质-信道"><a href="#传输介质-信道" class="headerlink" title="传输介质(信道)"></a>传输介质(信道)</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271453976.png" alt="image.png"></p><ul><li><em>传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。</em></li><li><em>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了 电 气 特 性，因此能够识别所传送的比特流</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271431578.png" alt="image.png"></li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a><em>导向性传输介质</em></h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a><em>双绞线</em></h4><p><em>电流方向相反的铜线，绞合一起，磁感线相互抵消，减少相邻导线的电磁干扰</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271436145.png" alt="image.png"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><em>同轴电缆</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271440754.png" alt="image.png"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><em>光纤</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443295.png" alt="image.png"></p><blockquote><p><em>单模光纤和双模光纤</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271447411.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443816.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271448705.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449288.png" alt="image.png"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a><em>非导向性传输介质</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449201.png" alt="image.png"></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><blockquote><p><em>中继器</em></p></blockquote><ul><li><em>中继器是对数字信号的再生(整形)</em></li><li><em>中继器是连接两个网段的桥梁，以助于数字信号的再生</em></li><li><em>中继器，只负责将数据发送到另一网段，不管数据中是否有错误</em></li><li><em>中继器两端可以连接相同传输介质，也可以不同传输介质</em></li><li><em>中继器两端网段一定要是统一协议</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271612539.png" alt="image.png"></p><blockquote><p><em>集线器</em></p></blockquote><p><em>集线器，可以连接多台主机，平分带宽，共享数据</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271616925.png" alt="image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="链路层的功能"><a href="#链路层的功能" class="headerlink" title="链路层的功能"></a>链路层的功能</h2><blockquote><p><em>数据链路层基本概念</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271636246.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271637260.png" alt="image.png"></p><blockquote><p><em>功能概述</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639722.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639736.png" alt="image.png"></p><h3 id="封装成帧-amp-透明传输"><a href="#封装成帧-amp-透明传输" class="headerlink" title="封装成帧&amp;透明传输"></a><em>封装成帧&amp;透明传输</em></h3><blockquote><p><em>封装成帧</em></p></blockquote><p><em>在一段数据添加首部、尾部构成一个帧，接收端就能收到bit流后，能识别帧的开始和结束</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271708120.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271711174.png" alt="image.png"></p><blockquote><p><em>透明传输</em></p></blockquote><p><em>就是传输数据的bit组合不会影响，到帧开始和结束的判定</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271714311.png" alt="image.png"></p><blockquote><p><em>四种组帧的方法</em></p></blockquote><p><strong><em>1.字符计数法</em></strong></p><ul><li><em>帧的开始字符记录的是该帧的字符数(包括自己)</em></li><li><p><em>缺点是，当前面的字符出错，往后的全部会出错</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271716399.png" alt="image.png"><br><strong><em>2.字符填充法</em></strong></p></li><li><p><em>传送文本，由于文本字符对应的ASCII码不会出现的bit组合充当帧头，帧尾，中间数据部分不会产生边界判定错误</em></p></li><li><em>如果传送的帧，由二进制程序，或图像等等非ASCII编码文本文件，数据内容有可能出现帧头，帧尾bit组合，导致中间穿插,帧边界判定错误</em></li><li><em>通过对数据部分 字节填充ESC转义字节 ，—&gt;使得特殊字符意义失效，实现干扰的解决</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271720950.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271724181.png" alt="image.png"></p><p><strong><em>3.零比特填充法</em></strong></p><p><em>以01111110 作为帧头和帧尾，发送端先将数据扫描，将所有连续的5个1 后都插入0，这样就不会出现6个1 ，再封装成帧；接收端，再逆过程去掉0</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271726553.png" alt="image.png"></p><p><strong><em>4.违规编码法</em></strong></p><p><em>曼彻斯特编码中不会出现的状态(高-高/低-低)来表示帧头，帧尾</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271729961.png" alt="image.png"></p><h3 id="差错控制—检错编码"><a href="#差错控制—检错编码" class="headerlink" title="差错控制—检错编码"></a><em>差错控制—检错编码</em></h3><blockquote><p><em>差错从何而来？</em></p></blockquote><ul><li><em>差错来源：随机噪声（线路本身电气特性产生）、冲击噪声（外界短暂原因）</em></li><li><p><em>差错：位错；帧错</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271901773.png" alt="image.png"></p></li><li><p><em>链路层编码与物理层编码调制不同：链路层编码是用于<strong>一组比特</strong>，判断传输过程是否出现出错。物理层编码调制针对<strong>单个比特</strong>，解决的是传输过程中 比特同步的问题</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271903232.png" alt="image.png"></p></li></ul><blockquote><p><em>差错控制—检错编码—奇偶校验码</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271910981.png" alt="image.png"></p><blockquote><p><em>差错控制—检错编码—CRC循环冗余码</em></p></blockquote><p><em>接收结果作 余数为0，就无差错</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271911773.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271912297.png" alt="image.png"></p><h3 id="差错控制—纠错编码"><a href="#差错控制—纠错编码" class="headerlink" title="差错控制—纠错编码"></a><em>差错控制—纠错编码</em></h3><blockquote><p><em>海明距离</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272215926.png" alt="image.png"></p><blockquote><p><em>海明码纠错步骤</em></p></blockquote><p><strong><em>1.确定校验码位数r</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217701.png" alt="image.png"></p><p><strong><em>2.确定校验码和数据的位置</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217078.png" alt="image.png"></p><p><strong><em>3.求出校验码的值</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272220510.png" alt="image.png"></p><p><strong><em>4.检错并纠错</em></strong><br><em>方式1</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272228839.png" alt="image.png"></p><ul><li><em>先每个校验码对应一个大圆，分别填入器其校验码序号</em></li><li><em>交集部分，填入校验码负责校验的一组序号中重叠的序号数据</em></li><li><em>最中间是三个校验码负责的重叠序号</em></li><li><em>2号校验码负责的没有出错，1,4号出错，所以3，6,7，排除，只剩下5</em></li></ul><p><em>方式2</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272242979.png" alt="image.png"></p><blockquote><p><em>海明码纠错演示</em></p></blockquote><p><strong><em>1．传输的数据：1101</em></strong></p><p><strong><em>2．校验位计算公式：</em></strong></p><p>2^k &gt;= k+n+1,n为数据位在本例中计算的k为3；</p><p>用P1,P2,P3,表示校验位，其中</p><p>P1,的位数2^0,P2,的位数2^1,P3,的位数2^2</p><p>则：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>1+2</th><th>4</th><th>1+4</th><th>2+4</th><th>1+2+4</th></tr></thead><tbody><tr><td>位数的二进制</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td></tr><tr><td>位数</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>数据位</td><td></td><td></td><td>1</td><td></td><td>1</td><td>0</td><td>1</td></tr><tr><td>校验位</td><td>P1,</td><td>P2,</td><td></td><td>P3</td><td></td><td></td></tr></tbody></table></div><p><strong><em>3.分组：</em></strong></p><div class="table-container"><table><thead><tr><th>校验位</th><th>位数分组</th></tr></thead><tbody><tr><td>P1,</td><td>1,3,5,7</td></tr><tr><td>P2,</td><td>2,3,6,7</td></tr><tr><td>P3</td><td>4,5,6,7</td></tr></tbody></table></div><p><strong><em>4.计算校验位值(异或运算)</em></strong></p><p>P1^1^1^1=0,得P1=1</p><p>P2^1^0^1=0,得P2=0</p><p>P3^1^0^1=0,得P3=0</p><p>最终传输的数据位：10101<code>0</code>1</p><p><strong><em>5,检验</em></strong><br>如果接收端收到的是10101<code>1</code>1<br>还是按照刚才的分组进行计算P1,P2P3每个分组的异或值，为零则无错，为1则有错。<br>P1组 1^1^1^1=0<br>P2组 0^1^1^1=1<br>P3组 0^1^1^1=1</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a><em>流量控制与可靠传输机制</em></h3><div style="background-color:#fffacd;padding:20px"><font size="3"><mark>可靠传输机制</mark>是指在数据传输过程中,使用各种手段来确保数据能够完整、正确、按序到达目的地的传输机制。<br>主要的可靠传输机制包括:<br>1. 流量控制:发送方和接收方协调传输速率,防止接收缓冲区溢出。<br>2. 错误检测:对传输的数据进行校验,检查是否发生错误。常用奇偶校验、CRC校验等。<br>3. 确认和重传:接收方发回确认帧表示正确接收,发送方如果长时间收不到确认,会重传数据。<br>4. 序列号:对数据包进行编号,确保按序到达。<br>5. 连接管理:建立连接、维护连接状态、终止连接。<br>6. 滑动窗口协议:扩大序列号使用范围,通过窗口控制流量。<br>7. 网络拥塞控制:通过流量控制和拥塞控制技术确保网络稳定运行<br><br>在TCP/IP参考模型的五层网络结构中,主要是<mark>数据链路层</mark>和<mark>传输层</mark>提供可靠的数据传输机制。<br>1. 数据链路层<br>数据链路层通过以下手段提供尽力而为的可靠传输:<li>流量控制:防止接收端缓冲区溢出</li><li>差错检测:检测并纠正传输错误</li><li>确认重传机制:确认帧和重传机制</li><li>链路管理:管理物理链路连接</li><br>2. 传输层<br>传输层中的TCP协议提供面向连接、全双工、可靠的传输服务。主要机制有:<li>序列号和确认机制</li><li>滑动窗口协议</li><li>拥塞控制</li><li>连接管理</li></font></div><h4 id="流量控制与可靠传输的方法"><a href="#流量控制与可靠传输的方法" class="headerlink" title="流量控制与可靠传输的方法"></a><em>流量控制与可靠传输的方法</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281155434.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157929.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157464.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157841.png" alt="image.png"></p><ul><li><em>停止-等待协议 ，发送窗口=1，接收窗口=1</em></li><li><em>后退N帧协议（GBN）发送窗口&gt;1,接收窗口=1</em></li><li><em>选择重传协议（SR）发送窗口&gt;1,接收窗口&gt;1</em></li></ul><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p><em>为什么要有停止等待协议？</em></p></blockquote><ul><li><em>为了解决流量控制的问题：互相的停止等待，使得不会传输太多的数据</em></li><li><em>为了解决可靠传输的问题：互相停止等待，接收确认帧，能保证能发现差错，以及处理差错</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281348782.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—无差错情况</em></p></blockquote><ul><li><em>ACK i 是接收方收到第 i 号帧之后，返回给发送方的确认帧</em></li><li><em>每次发送一个数据帧就停止等待，所以只需要1bit来对帧进行编号</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352535.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—有差错情况</em></p></blockquote><p><strong><em>1.数据帧丢失或检测到帧出错</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352337.png" alt="image.png"></p><ul><li><em>超时计时器，当没有在设定时间内收到确认帧，发送方就重发一次</em></li><li><em>超时计时器设置的设定时间，要并RTT(往返传播时延)高一点，因为还有发送时延</em></li><li><em>发完一个帧之后，要保留这个帧的副本，用来重发</em></li><li><em>数据帧和确认帧必须编号，以确定确认帧确定的是哪一个数据帧</em></li></ul><p><strong><em>2.ACK丢失</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356757.png" alt="image.png"></p><p><strong><em>3.ACK迟到</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356868.png" alt="image.png"></p><blockquote><p><em>信道利用率</em></p></blockquote><ul><li><em>信道利用率就是发送方在一个发送周期内，有效的发送数据所需时间(发送时延)，占整个发送周期的比率</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281403631.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281404211.png" alt="image.png"></p><blockquote><p><em>梳理</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281406220.png" alt="image.png"></p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><blockquote><p>引入窗口概念的原因</p></blockquote><p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。</p><p>这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。</p><p>如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052208457.png" alt="image.png"></p><p>所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p><p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。</p><p>那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。</p><p>窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p><p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。如下图：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052208945.png" alt="image.png"><br>图中的 ACK 600 确认应答报文丢失，也没关系，因为可以通过下一个确认应答进行确认，只要发送方收到了 ACK 700 确认应答，就意味着 700 之前的所有数据「接收方」都收到了。这个模式就叫<strong>累计确认</strong>或者<strong>累计应答</strong>。</p><blockquote><p>窗口大小由哪一方决定？</p></blockquote><p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。</p><p><strong>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</strong></p><p>所以，通常窗口的大小是由接收方的窗口大小来决定的。</p><p>发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p><h6 id="后退N帧协议GBN"><a href="#后退N帧协议GBN" class="headerlink" title="后退N帧协议GBN"></a><em>后退N帧协议GBN</em></h6><blockquote><p><em>停等协议的弊端</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281646729.png" alt="image.png"></p><blockquote><p><em>后退N帧协议中的滑动窗口</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281541947.png" alt="image.png"></p><blockquote><p><em>GBN发送方要响应的三件事</em></p></blockquote><ul><li><em>窗口已满是指，当前窗口的数据，在没有收到确认帧之前，不能往前移动，此时的状态就是窗口已满</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281539613.png" alt="image.png"></li></ul><blockquote><p><em>GBN接收方要做的事</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281651074.png" alt="image.png"></p><blockquote><p><em>运行中的GBN</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281536912.png" alt="image.png"></p><blockquote><p><em>滑动窗口长度</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281559974.png" alt="image.png"></p><blockquote><p><em>习题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281532640.png" alt="image.png"></p><ul><li><em>1000个窗口，所以发送方同时可以发1000个帧，每个帧1000个字节<br>所以一次右1000x1000x8 bit数据，<strong>受到信道带宽限制，所以发送延时=<br>1000x1000x8b/100Mb/s =80ms</strong></em></li><li><em>只有受到受到1号帧的确认帧，发送框才会开始移动一个，所以，<strong>在没有受到第一个确认帧之前，发送方不会发送新的数据</strong></em></li><li><em>所以计算，受到确认帧的时间=2x50ms + 1000x8b/100Mb/s =100.08ms &gt;80ms ,所以，信道会有20ms没有新数据推入，空闲，有100.08-80ms=20ms无输入，所以<strong>实际平均数据传输率=1000x1000x8b/100.08ms=80Mb/s</strong></em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281518658.png" alt="image.png"></li></ul><blockquote><p><em>总结</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281543131.png" alt="image.png"></p><h6 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a><em>选择重传协议SR</em></h6><blockquote><p><em>后退N帧协议的弊端</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281647073.png" alt="image.png"></p><blockquote><p><em>选择重传协议中的滑动窗口</em></p></blockquote><ul><li><em>发送窗口黄色部分是未被确认的帧，绿色部分是发送之后，收的确认帧的帧</em></li><li><em>接收窗口，紫色部分是收到的帧，灰色部分是<strong>希望收到</strong>的帧，发现，接收窗口可以在没有收到希望收到的帧前，接收其他序号的帧，这里不同于GBN协议，GBN协议在没有收到希望收到的帧之前，对其他发送过来的帧会全部丢弃</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281652798.png" alt="image.png"></li></ul><blockquote><p><em>SR 发送方必须响应的三件事</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281659010.png" alt="image.png"></p><blockquote><p><em>SR接收方要做的事</em></p></blockquote><ul><li><em>接收窗口只有当接收到窗口下届的帧，才会将接收窗口往前移动，移动到最小的未接收的帧，并将接收到的这批帧，交付给网络层</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705434.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705216.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705718.png" alt="image.png"></p><blockquote><p><em>运行中的SR</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281708817.png" alt="image.png"></p><blockquote><p><em>SR滑动窗口长度</em></p></blockquote><ul><li><em>发送窗口=接收窗口（防止溢出）</em></li><li><em>窗口长度=2^(n-1),n为帧的个数</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281711388.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281714834.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281713327.png" alt="image.png"></p><h3 id="信道划分介质访问控制-MAC协议"><a href="#信道划分介质访问控制-MAC协议" class="headerlink" title="信道划分介质访问控制(MAC协议)"></a><em>信道划分介质访问控制(MAC协议)</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942630.png" alt="image.png"></p><ul><li><em>当一个对讲机讲话，其他对讲机就不能够进行讲话，否则会信号冲突</em></li><li><em>广播式链路，如何实现，两对节点之间通信不会互相干扰，就需要介质访问控制来实现</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942457.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291141124.png" alt="image.png"></p><h4 id="静态划分信道-信道划分介质访问控制"><a href="#静态划分信道-信道划分介质访问控制" class="headerlink" title="静态划分信道(信道划分介质访问控制)"></a><em>静态划分信道(信道划分介质访问控制)</em></h4><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a><em>频分多路复用FDM</em></h5><ul><li><em>不同用户同一时间占用不同的带宽(频率资源)</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282109872.png" alt="image.png"></li></ul><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a><em>时分多路复用TDM</em></h5><ul><li><p><em>缺点是每个用户在每一个帧中占用固定的时隙，导致其他用户空闲时，不传送数据时，时隙被浪费</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282111844.png" alt="image.png"></p></li><li><p><em>改进后的统一时分复用STDM,就解决了上面的问题，铜国集中器，将不同用户的数据，按照进入的先后，排列使得每一个STDM帧都排满</em></p></li><li><em>所以STDM帧的每个用户的时隙，不是固定的，是按照需要动态分配的时隙</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282112256.png" alt="image.png"></li></ul><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a><em>波分多路复用WDM</em></h5><ul><li><em>实际上就是光的频分多路复用</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282115560.png" alt="image.png"></li></ul><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a><em>码分多路复用CDM</em></h5><ul><li><em>不太理解</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282116386.png" alt="image.png"></li></ul><h4 id="动态分配信道-随机访问介质访问控制"><a href="#动态分配信道-随机访问介质访问控制" class="headerlink" title="动态分配信道(随机访问介质访问控制)"></a><em>动态分配信道(随机访问介质访问控制)</em></h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><em>ALOHA协议</em></h5><blockquote><p><em>纯ALOHA协议</em></p></blockquote><ul><li><em>这里帧用T0表示，T0是一个帧从的 发送时间+传播时间 这所有过程，所耗费的时间，所以是在时间坐标上表示帧</em></li><li><em>ALOHA协议想发就发，多个站点，可以在任何时刻，发送数据帧，只是，如果有两个数据帧产生，时间重叠，那么就发生冲突，接收方会检测到差错，不返回确认，如此发送方就会等待一个随机的时刻再次发送数据帧</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282134246.png" alt="image.png"></li></ul><blockquote><p><em>时隙ALOHA协议</em></p></blockquote><ul><li><em>把时间分为若干相同的时间片段，所有用户只允许在<strong>开始时刻</strong>且 <strong>同步</strong>接入网络信道，这样所有用户拥有一个统一的时间划分，都只能在时间片开始时刻发送数据，若发生冲突，则等到下一个时间片开始时刻发送,大大降低了数据冲突问题</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282138877.png" alt="image.png"></li></ul><h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a><em>CSMA协议</em></h5><p><strong><em>载波监听多路访问协议</em></strong></p><ul><li><em>CS ：载波监听，每一个站发送数据前先检测总线上是否有其他计算机发送数据</em></li><li><em>当信道空闲：发送完整帧(具体发送看CSMA类型)</em></li><li><em>当信道忙：则等待一个随机时间再监听</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290953369.png" alt="image.png"></li></ul><blockquote><p><em>1-坚持CSMA</em></p></blockquote><ul><li><em>空闲直接传输，不等待；忙则一直监听，直到空闲马上传输</em></li><li><em>不是都是空闲的时候再传输吗？为什么会出现冲突？</em></li><li><em>因为，当有两个以上站，同时在等候监听时，由于信息在两台站之间有传播时延，即使是信道上已经存在数据传输，任然检测不出，所以就当做信道空闲，也把数据传输上去，这样就导致数据碰撞，造成冲突</em></li><li><em>优点：只要空闲就发送，媒体利用率最高</em></li><li><em>缺点：冲突概率高</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290956924.png" alt="image.png"></li></ul><blockquote><p><em>非坚持CSMA</em></p></blockquote><ul><li><em>空闲则直接传输，不等待；忙则放弃监听，随机时间后再监听</em></li><li><em>优点：减少了当台站，同时监听到空闲直接发送数据，产生冲突的可能</em></li><li><em>缺点：媒体空闲无法迅速被利用起来，利用率低</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291000848.png" alt="image.png"></li></ul><blockquote><p><em>p-坚持CSMA</em></p></blockquote><ul><li><em>空闲时，概率p直接发送，概率1-p等待下一个时间槽传输。</em></li><li><em>忙则持续监听，直到信道空闲</em></li><li><em>冲突则等待下一个时间槽监听</em></li><li><em>优点：即减少了冲突发生，有能减少空间时间的浪费</em></li><li><em>缺点：冲突后还是会把数据帧发送完，造成浪费</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291004905.png" alt="image.png"></li><li><strong><em>正确使用以上策略可以在一定程度上减少碰撞的发生，但无法彻底解决碰撞问题。</em></strong></li></ul><blockquote><p><em>比对</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291009309.png" alt="image.png"></p><h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><em>CSMA/CD协议</em></h5><blockquote><p><strong><em>强化CSMA协议，推出CSMA/CD协议</em></strong></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034112.png" alt="image.png"></p><p><strong><em>载波监听多点接入/碰撞检测协议</em></strong></p><ul><li><em>CSMA/CD适用于半双工网络(也就是<strong>有线以太网</strong>)—就是不能一方发送还没发送完，另一方就发送，这样会造成数据在路上的碰撞</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034904.png" alt="image.png"></li></ul><blockquote><p><em>为什么先听后发会产生冲突</em></p></blockquote><ul><li><em>为什么先听后发还会产生冲突？</em></li><li><em>因为电磁波在总线上有传播时延，B暂时没有检测到A发送过来的数据</em></li><li><em>以A为基准，对于A来说，A检测到发生碰撞的最长时间=2τ</em></li><li><em>所以当发送数据之后过了2τ还没接受到碰撞，说明这次传输，不会产生碰撞</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291053463.png" alt="image.png"></li></ul><blockquote><p><em>如何确定碰撞后重传时机</em></p></blockquote><ul><li><em>碰撞之后如何重传，以及重传几次，通过以下方式**</em>截断二进制指数规避法<em>**</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291055125.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291057356.png" alt="image.png"></li></ul><blockquote><p><em>最小帧长</em></p></blockquote><ul><li><em>当检测到碰撞之后，应当立即停止继续发送帧，但是如果检测到碰撞之前就将帧发送完毕，就显得有些尴尬</em></li><li><em>为了避免检测到碰撞之前，就将帧发完，应该设置一个最小的帧长度，保证2τ(最大检测到碰撞时间)之内不会将帧传输完</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103100.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103689.png" alt="image.png"></p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><em>CSMA/CA协议</em></h5><blockquote><p><em>为什么要有CSMA/CA协议</em></p></blockquote><ul><li><em>无线局域网中无法辺全面的检测碰撞</em></li><li><em>并且当多台站点A,C检测到信道空闲，会同时向终端B发送数据帧，就会导致冲突</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134454.png" alt="image.png"></li></ul><blockquote><p><em>CSMA/CA协议工作原理</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291133228.png" alt="image.png"></p><blockquote><p><em>CSMA/CA与CSMA/CD区别</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134135.png" alt="image.png"></p><h4 id="动态分配信道-轮询访问介质访问控制"><a href="#动态分配信道-轮询访问介质访问控制" class="headerlink" title="动态分配信道(轮询访问介质访问控制)"></a><em>动态分配信道(轮询访问介质访问控制)</em></h4><ul><li><strong><em>结合了静态划分信道的优点，不会产生冲突；又结合了随机访问协议的优点发送时能独占信道，占全部带宽</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291220580.png" alt="image.png"></li></ul><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><em>轮询协议</em></h5><ul><li><em>主节点，挨个轮流询问（实际就是以数据帧形式）下面的主机是否要发送数据</em></li><li><em>主节点故障，就无法询问，所有结点就无法传输数据—称为单点故障</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291214203.png" alt="image.png"></li></ul><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><em>令牌传递协议</em></h5><ul><li><em>令牌就是特殊格式的MAC协议控制帧，不包含任何信息</em></li><li><em>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291218760.png" alt="image.png"></li></ul><h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a><em>局域网基本概念和体系结构</em></h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291600023.png" alt="image.png"></p><p><strong><em>决定局域网主要要素</em></strong></p><ul><li><em>网络拓扑</em></li><li><em>传输介质</em></li><li><em>介质访问控制方法</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291548371.png" alt="image.png"></li></ul><blockquote><p><em>局域网拓扑结构</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291550233.png" alt="image.png"></p><blockquote><p><em>局域网传输介质</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551105.png" alt="image.png"></p><blockquote><p><em>局域网介质访问控制方法</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551614.png" alt="image.png"></p><blockquote><p><em>局域网的分类</em></p></blockquote><p><em>以太网。是目前应用最广泛的局域网，逻辑拓扑是总线型，物理拓扑是星型。使用的是CSMA/CD 协议</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291554255.png" alt="image.png"></p><blockquote><p><em>IEEE 802标准</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291556090.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291555065.png" alt="image.png"></p><blockquote><p><em>LLC子层和MAC子层</em></p></blockquote><p><em>IEEE 802标准将局域网的数据链路层划分为：逻辑链路层LLC子层，和介质访问控制MAC子层</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291559577.png" alt="image.png"></p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><em>以太网</em></h3><blockquote><p><em>以太网概述</em></p></blockquote><ul><li><em>以太网有两个标准，DIX Ethernet V2 和IEEE 802.3 ;两种标准的帧格式只有1点点的不同</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291654999.png" alt="image.png"></li></ul><blockquote><p><em>以太网提供无连接、不可靠服务</em></p></blockquote><ul><li><em>无连接：发送方接受方，之间通信前，不提前确立信道，无握手</em></li><li><em>不可靠：是指，不管接受数据帧是否乱序、差错、丢失</em></li><li><em>无差别接收：是指，在接收数据不会有意外，来什么收什么</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291655881.png" alt="image.png"></li></ul><blockquote><p><em>以太网传输介质与拓扑结构</em></p></blockquote><ul><li><em>现在以太网都是逻辑上总线型，物理上星型</em></li><li><em>传输介质采用双绞线+集线器</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291658840.png" alt="image.png"></li></ul><blockquote><p><em>10BASE-T以太网</em></p></blockquote><ul><li><em>BASE 表示传输基带信号，也就是数字信号</em></li><li><em>T表示采用双绞线</em></li><li><em>采用曼彻斯特编码</em></li><li><em>采用CSMA/CD介质访问控制</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291700140.png" alt="image.png"></li></ul><blockquote><p><em>适配器与MAC地址</em></p></blockquote><ul><li><em>通信适配器，实现计算机与外界局域网的连接，也称网络接口板，或网卡NIC</em></li><li><em>现在计算机都嵌入了适配器，就无须单独使用网卡了</em></li><li><em>适配器上装有处理器和存储器(RAM,ROM)，ROM上存储了计算机硬件(网卡)地址MAC地址</em></li><li><em>MAC地址全球唯一，换网卡，MAC地址改变</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291704298.png" alt="image.png"></li></ul><blockquote><p><em>以太网MAC帧—V2格式</em></p></blockquote><ul><li>*为什么有帧开始定界符 ，却没有帧结尾定界符呢？</li><li><em>因为以太网编码采用的是曼彻斯特编码，一个bit内就有一个跳变，当这种形式消失，就说明帧结束，然后只需要往前推4bit就能找到数据位置</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291717806.png" alt="image.png"></li></ul><blockquote><p><em>高速以太网</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292033086.png" alt="image.png"></p><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><em>无线局域网</em></h3><blockquote><p><em>802.11的MAC帧头格式</em></p></blockquote><ul><li><em>基站AP(也称无线接入点), 是主机通过连接无线网络连入有线网络（以太网）的设备</em></li><li><em>以下的场景：A 想要与B通信，由于距离太远，A要先通过无线网络将数据发送给Ap1,然后Ap1发送给AP2，最后由Ap2将数据发送给B</em></li><li><em>接收端—AP2的MAC地址 ；发送端—AP1的MAC地址；目的地址—B的MAC地址；源地址—A的MAC地址</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292038208.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292052190.png" alt="image.png"></p><blockquote><p><em>无线局域网的分类</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292053304.png" alt="image.png"></p><p><strong><em>1.有固定基础设施无线局域网</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292055469.png" alt="image.png"></p><ul><li><em>一个基本服务集BSS内，的主机可以相互之间直接通过基站发送数据</em></li><li><em>不同基本服务集之间要进行远距离通信，需要借助基站与基站之间的互相通信来实现，称作“漫游”</em></li><li><em>wifi名称—就是服务集标识符</em></li></ul><p><strong><em>2.无固定基础设施无线局域网的自组织网络</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292101049.png" alt="image.png"></p><h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a><em>虚拟局域网VLAN</em></h3><blockquote><p><em>为什么提出虚拟局域网</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041734284.png" alt="image.png"></p><blockquote><p><em>VLAN基本概念</em></p></blockquote><ul><li><strong><em>就是将局域网内的设备，划分为不同的逻辑工作组，这种域与物理位置无关</em></strong></li><li><em>一个逻辑工作组，就是一个子网，一个广播域</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041735592.png" alt="image.png"></li></ul><blockquote><p><em>VLAN实现</em></p></blockquote><ul><li><em>将一个交换机下的局域网，逻辑上划分为两个虚拟的不同的局域网，同时其他交换机下的也可以划分为同样的两个分组，这样相同的分组之间就是一个可以互相通信的虚拟局域网，而不同分组之间就不能互相通信</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041738107.png" alt="image.png"></li><li><em>按照交换机上的端口划分</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041740977.png" alt="image.png"></p><ul><li><em>按照接入的主机MAC地址划分</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041743116.png" alt="image.png"></p><ul><li><em>假如A要往E发送数据，A主机会先准备一个普通以太网帧，帧送往交换机，交换机会往帧上贴一个标签(标注VLAN1)，发往交换机2，然后交换机2会根据标签，知道这是发往虚拟局域网VLAN1的然后再根据一些其他标志，判断发往E</em></li></ul><blockquote><p><em>VLAN进行数据交换时，帧的格式变化</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041752990.png" alt="image.png"></p><blockquote><p><em>练习</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041753776.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041756089.png" alt="image.png"></p><h2 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a><em>广域网及相关协议</em></h2><blockquote><p><em>什么是广域网</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041719233.png" alt="image.png"></p><blockquote><p><em>PPP协议</em></p></blockquote><p><strong><em>PPP点对点协议，广域网使用的链路层协议，只支持全双工链路，用于用户使用拨号电话接入因特网</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041721607.png" alt="image.png"></p><blockquote><p><em>PPP协议应该满足的要求/无需满足的要求</em></p></blockquote><ul><li><em>同步线路是逐个bit发送数据，异步线路是逐个字节或字符发送数据</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726956.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726276.png" alt="image.png"></p><blockquote><p><em>PPP协议的是哪个组成部分</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727339.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727950.png" alt="image.png"></p><blockquote><p><em>PPP协议的帧格式</em></p></blockquote><ul><li><em>PPP协议的帧格式，最小单位是字节，所以是面向字节的</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041731402.png" alt="image.png"></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><em>基本概念</em></h3><h4 id="网段"><a href="#网段" class="headerlink" title="网段"></a><em>网段</em></h4><ul><li><em>网段计算机网络中使用同一物理层设备，能够直接通讯的那一部分，同一个网段，会有冲突域，同一时间只能有一台设备占用</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042038496.png" alt="image.png"><h4 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a><em>冲突域与广播域</em></h4></li></ul><p><strong><em>1.冲突域：</em></strong></p><ul><li><em>在以太网 中，如果某个CSMA/CD网络上的两台计算机在同时通信时<strong>会发生冲突</strong>，那么这个CSMA/CD网络就是一个<strong>冲突域</strong>（collision domain)。如果以太网中各个网段以<strong>集线器</strong>连接，因为不能避免冲突，所以它们仍然是一个冲突域</em></li><li><em>冲突域就是连接在<strong>同一导线</strong>上的所有工作站的集合，或者说<strong>是同一物理网段</strong>上所有节点的集合，或以太网上竞争<strong>同一带宽</strong>的节点集合.</em></li><li><em>集线器是一个标准的共享式设备，也就是<strong>同一时刻只有一个端口下联的设备可以发送数据。正常工作时，集线器随机选出某一端口设备并让它独占全部带宽与集线器上联设备（如交换机、路由器等）进行通信</strong>。因此，集线器设备的所有端口即形成了一个冲突域。</em></li><li><em>为了有效避免冲突，局域网中使用<strong>交换机</strong>（Switch）来分割冲突域</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042041995.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042042138.png" alt="image.png"></p><p><strong><em>2.广播域：</em></strong></p><ul><li><em>广播是一种信息的<strong>传播方式</strong>，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>(Broadcast Domain)。</em></li></ul><p><strong><em>3.两者区别</em></strong></p><ul><li><em>冲突域是基于物理层</em></li><li><p><em>广播域是基于数据链路层</em></p></li><li><p><em>冲突域：竞争同一带宽的节点的集合</em></p></li><li><em>广播域：接收同样广播消息的节点的集合</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042020764.png" alt="image.png"></li></ul><blockquote><p><em>练习加深了解</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042120355.png" alt="image.png"></p><h3 id="链路层的设备"><a href="#链路层的设备" class="headerlink" title="链路层的设备"></a><em>链路层的设备</em></h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a><em>网桥</em></h4><ul><li><em>网桥有左右两个端口，分别分割两个冲突域</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042049108.png" alt="image.png"></p><blockquote><p><em>透明网桥</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045169.png" alt="image.png"></p><blockquote><p><em>源路由网桥</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045552.png" alt="image.png"></p><blockquote><p><em>网桥的自学习功能</em></p></blockquote><ul><li><em>网桥只有左右两个端口，分别标记位1,2号</em></li><li><em>网桥自学习是指，网桥转发表一开始是空的，当A-&gt;B发送信息时，A会向所有主机发送，当经过第一个网桥时，由于网桥转发表没有对A的记录，所以当数据帧经过该网桥时，就会在转发表记录 A对应1端口位置；同时由于没有对B的记录，无法选择转发，所以只能一股脑转发出去，右边的网桥也经过一样的过程</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042101488.png" alt="image.png"></li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><em>交换机</em></h4><blockquote><p><em>多接口网桥—交换机</em></p></blockquote><ul><li><em>集线器，也是多接口，集线器，会将每台计算机原有100MB/s带宽，平均为每台只有25MB/s ,同时会有冲突域，一台集线器下的计算机只能同时有一台发送数据，传输速率大大降低</em></li><li><em>交换机，就是一个多接口的网桥，可以隔绝冲突域，一台交换机下的每条信道都能占满带宽(独占媒体带宽)，维持原有的100MB/s,同时一台交换机之内的所有计算机都可以同时传输数据</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042110168.png" alt="image.png"></li></ul><blockquote><p><em>以太网交换机的两种交换方式</em></p></blockquote><ul><li><em>直通式交换机</em></li><li><em>存储转发式交换机</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042121848.png" alt="image.png"></li></ul><blockquote><p><em>交换机的自学习功能</em></p></blockquote><ul><li><em>与网桥的自学习功能类似，只是多了几个端口</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042114758.png" alt="image.png"></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051043362.png" alt="image.png"></p><p><strong><em>1.网络层功能</em></strong></p><ul><li><em>路由选择分组转发</em></li><li><em>异构网络互联：指的是传输介质、数据编码方式、链路控制协议以及不同的数据单元格式和转发机制的网络，也就是<strong>数据链路层和物理层协议不同</strong>的网络</em></li><li><em>拥塞控制：全局性的概念，是因为整个网络负载过重造成拥塞；而流量控制只是，发送方发送过快导致接收方接收不过来，所以需要流量控制</em></li></ul><p><strong><em>2.拥塞控制方法</em></strong></p><ul><li><em>WAY1开环控制：静态方法</em></li><li><em>WAY2闭环控制：动态方法</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051053599.png" alt="image.png"><h2 id="SDN基本概念"><a href="#SDN基本概念" class="headerlink" title="SDN基本概念"></a><em>SDN基本概念</em></h2></li></ul><blockquote><p><em>考察概念，主要是选择题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051308929.png" alt="image.png"></p><p><strong><em>1.网络层的关键功能</em></strong></p><ul><li><em>转发：将分组从路由器的输入端口，转发到合适的输出端口【局部的功能】【数据平面的部分】</em></li><li><em>路由：使用路由算法决定分组从发送主机到目标接收主机的路径【全局的功能】【控制平面的部分】</em></li></ul><p><strong><em>2.网络层：数据平面、控制平面</em></strong><br><code>数据平面：</code></p><ul><li><em>路由器本地动作</em></li><li><em>根据路由表，将分组从输入端口转发到合适的输出端口【路由表和转发表是控制平面的路由选择协议实体算出来的】</em></li></ul><p><code>控制平面：</code></p><ul><li><em>网络范围内的逻辑</em></li><li><em>决定数据报从源到目标主机的端到端路径</em></li><li><em>2个控制平面方法：传统方法、SDN方法(software-define-networking)</em><ul><li><em>传统方法：运行在每一台路由器本地中</em></li><li><em>SDN方法：在远程服务器中实现</em></li></ul></li></ul><p><strong><em>3.控制平面两个方法</em></strong></p><blockquote><p><em>传统方式—每路由控制平面</em></p></blockquote><ul><li><em>传统方式下，每个路由器，即实现了控制平面功能，又实现了数据平面功能</em></li><li><em>每台路由器中的路由选择算法与其他路由器中的路由选择算法相互通信, <strong>计算出路由表和转发表</strong></em></li><li><em>这种方式使得路由器的控制平面与数据平面相互紧紧耦合，带来的问题是，改变路由运行逻辑变得非常困难</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051337186.png" alt="image.png"></li></ul><blockquote><p><em>SDN方式—集中逻辑的控制平面</em></p></blockquote><ul><li><em>将控制平面从路由器物理上剥离开，在远程服务器中集中实现。在远程控制器中计算和分发转发表，以提供给每台路由器</em></li><li><em>计算、转发、远程控制器，是由软件实现，所以是集中式，可编程的</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051345318.png" alt="image.png"></p><p><strong><em>4.SDN方式控制平面的组成</em></strong><br><em>远程控制器中包括：</em></p><ul><li><em>SDN控制器</em></li><li><em>网络控制应用程序</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051351391.png" alt="image.png"></li></ul><p><strong><em>5.SDN控制器的三个层次</em></strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051357037.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051359025.png" alt="image.png"></p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a><em>IP数据报</em></h2><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a><em>IP数据报格式</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071000263.png" alt="image.png"></p><ul><li><p><em>网络层的传输单位是数据报，，网络层主要用到的协议是IP协议，IP协议的数据报格式如下</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071001404.png" alt="image.png"></p></li><li><p><em>首部长度4bit,从 0011~1111(5~15)，单位是4B，也就是首部长度最小5x4B=20B,最大15x4B=60B</em></p></li><li><em>协议部分，字段值不同，代表不同数据部分协议【注意是数据部分协议，网络层之上的协议】【TCP协议：面向连接服务，字段值6；UDP：不面向连接服务，字段值17】</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071013525.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071017094.png" alt="image.png"></p><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a><em>IP数据报分片</em></h3><blockquote><p><em>为什么要分片？</em></p></blockquote><ul><li><em>数据链路层是对IP数据报进行封装成帧，但是帧有最大传输单元MTU，如果IP数据报/分组，大于MTU,怎么办？</em><br><em>所以需要对IP数据报进行<strong>分片</strong></em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071038656.png" alt="image.png"></li></ul><blockquote><p><em>数据报分片例子</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034403.png" alt="image.png"></p></blockquote><ul><li><em>最大数据报片&lt;=1420B</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034753.png" alt="image.png"></li></ul><h2 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a><em>IPV4地址</em></h2><ul><li><em>一个路由器会连接很多个主机，一个主机对应路由器一个接口(有线或无线接口)，每个接口都会分配一个唯一的ip地址</em></li><li><em>ip地址都是32bit的标识符，采用点分十进制，每一个字节，用点隔开，并且<br>每个字节的数字都是用十进制表示</em></li><li><em>IP 地址包括两部分：网络 ID（网络地址） + 主机 ID（主机地址）<br>网络 ID 用于不同网络寻址； 主机 ID 用于局域网内通讯</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071522558.png" alt="image.png"></li></ul><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a><em>IP地址的分类</em></h3><p><em>根据 IP 地址(二进制下)前缀数字的不同情况，划分为 A,B,C,D,E 5个类别，如下图 （本文我们主要介绍 A,B,C 三类）</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt="image.png"></p><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a><em>A类地址</em></h4><ol><li>第 1 字节为网络地址，其他 3 字节为主机地址，第 1 个字节第一位固定为0</li><li>网络号范围： 1.0.0.0 - 126.0.0.0</li><li>包含私有地址和保留地址<ul><li>私有网络号：10 （局域网中使用的网络地址）（网段1个）</li><li>保留地址：127.X.X.X</li></ul></li><li>主机数量：千万台</li></ol><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a><em>B类地址</em></h4><ol><li>第 1.2 字节为网络地址，其他为主机地址，第 1 个字节前两位固定为 10</li><li>网络号范围：128.0.0.0 - 191.255.0.0</li><li>包含私有地址和保留地址<ul><li>私有网络号：172.16—172.31 （网段16个）</li><li>保留地址：169.254.X.X （IP 地址为自动获取，且无可用 DHCP 服务时，分 配该地址）</li><li>广播地址：191.255.255.255</li></ul></li><li>主机数量：最大 65534 台</li></ol><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a><em>C类地址</em></h4><ol><li>第 1.2.3 字节为网络地址，第 4 字节为主机地址，第 1 个字节前三位固定110</li><li>网络号范围：192.0.0.0—223.255.255.0</li><li>包含私有地址和保留地址<ul><li>私有网络号 ：192.168.0~192.168.255 网段共255个</li></ul></li><li>主机数量：最大 254 台</li></ol><p><code>*网段个数，代表某类ip地址网络号有几种分法*</code></p><h4 id="特殊用途ip地址"><a href="#特殊用途ip地址" class="headerlink" title="特殊用途ip地址"></a><em>特殊用途ip地址</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630383.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131622431.png" alt="image.png"></p><ul><li><em>A类可用的网络号：1~126</em></li><li><em>B类可用的网络号：128.1~191.255</em></li><li><em>C类可用的网络号：192.0.1~223.255.255</em></li><li><em>主机号要减去全0，全1</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630367.png" alt="image.png"></li></ul><h4 id="私有ip"><a href="#私有ip" class="headerlink" title="私有ip"></a>私有ip</h4><p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="图片alt"></p><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a><em>NAT网络地址转换</em></h2><blockquote><p><em>内网ip,不能直接与外网通信</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="image.png"></p><blockquote><p><em>NAT转换</em></p></blockquote><ul><li><em>需要通过NAT转换，将内网ip（专用网/私有ip地址）以及端口号，通过路由器 按照NAT转换表 转换为路由器的公网ip地址和端口号，才能与外部通信</em></li><li><em>NAT路由器一般只有1个公网ip，所以内网的主机公用一个公网ip</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071707488.png" alt="image.png"></li></ul><blockquote><p><em>什么时候需要NAT转发？什么时候不需要？</em></p></blockquote><ul><li><em>当申请的网络号是公网网络号，那么其下的ip都是公网ip，就不需要再对其NAT转换</em></li><li><em>当使用的都是专用网络，内网网络号，那么其下的都是私有ip，也就需要保证，路由器拥有至少一个公网ip，通过NAT转换与外部通信</em></li></ul><h2 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a><em>子网划分与子网掩码</em></h2><blockquote><p><em>什么是子网？</em></p></blockquote><p><strong><em>子网或子网络是大型网络内的较小网络。子网划分使网络路由更加高效。</em></strong></p><blockquote><p><em>为什么要划分子网？</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">详细概述：</span><br><span class="line">首先，先明白网络广播的基本概念，本网段向本网络的所有节点发送数据包，所有节点都会收到，但往往只有一个节点是需要这个数据包的，因此广播的过程会很浪费的占用一部分网络资源。因此划分子网的一个最为重要意义就在于减少网络广播所带来的负面影响，提高性能的整体性能。因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户数少了，当然所占用的资源也就少了。</span><br><span class="line"></span><br><span class="line">其次，这节省了IP地址的资源。这看似于前面介绍的连接主机数减少相矛盾，其实这要看具体的情况来定。对本省规模较大网络（200个用户以上），划分子网后，可用的IP地址数减少了。但如果是那些小型的企业网络来哦说，划分子网后又可以节省大量的IP地址资源。比如现在学校有四个机房，每个机房25台电脑，如果直接分配四个C类地址字段，每个机房一个。虽然这样做理论上没有错，但实际上你一共浪费了（254-25）*4=916个IP地址（全0全1不取,故256-2=254）。如果公用网络都这样分配IP地址，那么IP地址资源早就枯竭了。</span><br><span class="line"></span><br><span class="line">另外，不同的子网之间是不能直接通信的，需要借助路由器或网关。而且网络规模小了是相对较安全的，比如财政部门。而且较小的网络也比较容易部署特定的安全政策，而网络规模大了这些政策可能会影响到其他普通用户的工作。还有一个优点就是便于维护，当某个网点要查找故障的时候，网络规模小了，更容易查找到错误网络。</span><br><span class="line"></span><br><span class="line">需要注意的一点就是，划分子网也是有一些弊端的，一方面就是：可连接的主机数减少，这对于网络规模小的网点没有影响，但如果网络规模大，他们就必须划分为多个子网，如果它们需要进行频繁的通信的话就需要总是借助路由器或网关，会影响工作效率。另一方面就是：各个相对对立的网点，主机号0和1是不能取的，需要留给网络地址和广播地址。因此每多一个子网，就必须浪费两个IP地址（当然，这问题不大。）。</span><br><span class="line">总结：划分子网并不适用于所有网络，对于各部门间工作相对独立的企业或行业来说，划分子网还是可取的。而对于那些IP资源本来就不是很够，各部门间的联系又非常紧密的则最好不划分子网。</span><br></pre></td></tr></table></figure><blockquote><p><em>什么是子网掩码？</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071832869.png" alt="image.png"></p><blockquote><p><em>子网划分</em></p><ul><li><em>采用B类ip地址，该申请的网络号为145.13</em></li><li><em>由于</em></li><li><em>内部再划分子网，其中一个子网网络地址为145.13.3</em></li><li><em>这个子网里有多台主机，(子网网络地址+主机号)</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071821362.png" alt="image.png"></li></ul></blockquote><ul><li><em>子网的划分实际上就是将<code>二级ip地址</code>,将原本主机号，借用若干位，作为子网号—&gt;<code>三级ip地址</code></em></li><li><em>在两级IP地址两个字段的基础上新增一个<code>子网号字段</code></em></li><li><em>划分子网纯属是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg.  对外表现ip为141.14.72.24【这是一个B类ip地址，网络地址为141.14.0.0,后面是主机号】</span><br><span class="line"></span><br><span class="line">假如子网掩码是：</span><br><span class="line">255.255.192.0</span><br><span class="line">11111111 11111111 11000000 00000000</span><br><span class="line">可以看出，该子网是借用了2bit作为子网号，后面14bit才是主机号 </span><br><span class="line"></span><br><span class="line">141.14.72.24</span><br><span class="line">10001101 00001110 01001000 00011000</span><br><span class="line">与子网掩码相与，得到的子网网络地址就是：</span><br><span class="line">141.14.64.0</span><br><span class="line">10001101 00001110 01000000 00000000</span><br><span class="line">主机号是子网号后面14bit：</span><br><span class="line">2072</span><br><span class="line">001000 00011000</span><br></pre></td></tr></table></figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071834346.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071846600.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072115836.png" alt="image.png"></p><h2 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h2><p>CIDR（Classless Inter-Domain Routing）无分类域间路由选择</p><p>划分子网在一定程度上缓解了因特网发展中遇到的困难，但其仅仅是对分类编址方式的改进，A、B、C类IP网络号都为8的倍数，其划分不够精细，存在很大程度的浪费，基于此，无分类编址方式CIDR应运而生。</p><h3 id="分类编址的问题"><a href="#分类编址的问题" class="headerlink" title="分类编址的问题"></a>分类编址的问题</h3><p>1992年因特网面临三个必须尽早解决的问题</p><ol><li>B类地址在1992年分配了近一半，眼看很快就将全部分配完毕</li><li>因特网主干网上的路由表中的项目数急剧增长（由几千个增长至几万个）</li><li>整个IPV4的地址空间最终将全部耗尽，在2011年2越3日，IANA宣布IPV4地址已经耗尽了</li></ol><p>IETF研究采用无分类编址的方法来解决前两个问题，其认为第三个问题属于更加长远的问题，因此专门成立IPV6工作组负责研究新版本IP协议的问题</p><h3 id="CIDR最主要的两个特点"><a href="#CIDR最主要的两个特点" class="headerlink" title="CIDR最主要的两个特点"></a>CIDR最主要的两个特点</h3><ul><li><strong>CIDR消除了传统的A类、B类和C类地址及划分子网的概念</strong>，因此可以更加有效地分配IPv4的地址空间，并且在新的IPv6使用前容许因特网的规模继续增长</li></ul><blockquote><p>CIDR把32位的IP地址划分为两个部分，前面的部分是网络前缀，用来指明网络，后面的部分则用来指明主机，其与分类编址最大的不同，便是网络前缀不局限于8的倍数。因此CIDR使IP地址从三级编址（使用子网掩码）又回到两级地址，但这已经是无分类的两级编址。CIDR在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。<br>IP地址 :: = {&lt;网络前缀&gt;，&lt;主机号&gt;}</p></blockquote><ul><li><strong>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”</strong>。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（最小地址）和终止地址（最大地址），以及地址块中的地址数。</li></ul><blockquote><p>例如，已知IP地址为128.14.35.7/20是某CIDR地址块中的一个地址，现在把它写成二进制形式，其中前20位是网络前缀，而后面的12位是主机号：<br>128.14.35.7/20 = <strong>10000000 00001110 0010</strong>0011 00000111<br>这个地址块的最小地址为：<strong>10000000 00001110 0010</strong>0000 00000000<br>这个地址块的最大地址为：<strong>10000000 00001110 0010</strong>1111 11111111</p></blockquote><h3 id="CIDR的地址掩码"><a href="#CIDR的地址掩码" class="headerlink" title="CIDR的地址掩码"></a>CIDR的地址掩码</h3><p>为了更方便地进行路由选择，CIDR使用32位的地址掩码（address mask）。地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR不使用子网了，但由于目前一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码</p><blockquote><p>例如，/20地址块的地址掩码是：11111111 11111111 11110000 00000000（20个连续的1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数</p></blockquote><h3 id="CIDR不划分子网的理解"><a href="#CIDR不划分子网的理解" class="headerlink" title="CIDR不划分子网的理解"></a>CIDR不划分子网的理解</h3><p>另外，“CIDR不使用子网”，是指<strong>CIDR中并没有在32位地址中指明若干位作为子网字段。但分配到一个CIDR地址块的单位</strong>仍然可以在本单位内根据需要划分出一些子网。<strong>这些子网也都只有一个网络前缀和一个主机地址号，但子网的网络前缀比整个单位的网络前缀要长一些</strong></p><blockquote><p>例如，某单位分配到地址块/20，就可以继续划分为8个子网（即需要从主机号中借用3位来划分子网）。这时，每一个子网的网络前缀就变成23位（原来的20位加上主机号借来的3位），比该单位的网络前缀多了3位</p></blockquote><h3 id="路由聚合的概念"><a href="#路由聚合的概念" class="headerlink" title="路由聚合的概念"></a>路由聚合的概念</h3><p>由于一个CIDR地址块有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合（Route aggregation）,它使得路由表中的一个项目可以表示原来传统分类网络地址的很多个路由。路由聚合也称为构成<strong>超网（supernettig）</strong></p><blockquote><p>如果没有采用CIDR，则在1994年和1995年，因特网一个路由器就回超过7万个项目，而使用了CIDR以后，在1996年一个路由表的项目数菜只有3万多个。路由聚合有利于减少路由器之间的路由选择信息交换，提高整个网络性能</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s1.ax1x.com/2018/11/19/FpQmUx.jpg#shadow" alt=""></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><h4 id="最长前缀匹配的概念"><a href="#最长前缀匹配的概念" class="headerlink" title="最长前缀匹配的概念"></a>最长前缀匹配的概念</h4><p>在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要做相应的改变。这时，每个项目由<br><strong>“网络前缀” 和 下一跳地址</strong>组成。但是在<strong>查找路由表时可能得到不止一个匹配结果</strong>。这样就带来一个问题：我们应当从这些匹配的结果中选择哪一条路由呢？</p><p>正确的答案是：<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫作最长前缀匹配（longest-prefix matching）,这时因为网络前缀越长，其地址块就越小（因为主机位数越少），因而路由就越具体。最长前缀匹配又称为<strong>最佳匹配或最长匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg.路由器接收到一个分组R0,它的目的ip地址是132.19.237.5</span><br><span class="line">路由器路由表包含5个目的网络号分别是</span><br><span class="line">132.0.0.0/8   </span><br><span class="line">【前8位是网络前缀，地址掩码11111111 000000000 00000000 00000000】 </span><br><span class="line">132.0.0.0/11</span><br><span class="line">【前11位是网络前缀，地址掩码11111111 11100000 00000000 00000000】</span><br><span class="line">132.19.232.0/22</span><br><span class="line">【前22位是网络前缀，地址掩码11111111 11111111 11111100 00000000】</span><br><span class="line">0.0.0.0/0</span><br><span class="line">【这是默认路由，所有目的网络都不匹配的时候走这里】</span><br><span class="line"></span><br><span class="line">目的ip地址是132.19.237.5</span><br><span class="line">10000100 00010011 11101001 00000101</span><br><span class="line">与上述子网掩码与运算后，匹配的网络地址是</span><br><span class="line">132.0.0.0/8  和 132.0.0.0/11</span><br><span class="line">但是按照最长路由前缀匹配，应该选择走132.0.0.0/11这个网络</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081951285.png" alt="image.png"></p><h4 id="依据地址位置划分地址快"><a href="#依据地址位置划分地址快" class="headerlink" title="依据地址位置划分地址快"></a>依据地址位置划分地址快</h4><p>如果IP地址的分配从一开始就采用CIDR，那么我们可以按网络所在的地理位置来分配地址块，这样就可以大大减少路由表中的项目数</p><blockquote><p>例如，可以将世界划分为四大地区，每一个地区分配一个CIDR地址块：<br>地址块194/7(194.0.0.0至195.255.255.255)分配给欧洲<br>地址块198/7(198.0.0.0至199.255.255.255)分配给北美洲<br>地址块200/7(200.0.0.0至201.255.255.255)分配给中美洲和南美洲<br>地址块202/7(202.0.0.0至203.255.255.255)分配给亚洲和太平洋地区</p></blockquote><p>上面一个地址块包含约3200万个地址($2^{32}-7$)。这种分配方法使得IP地址与地理位置关联，它的好处是可以大大压缩路由表中的项目数。例如从中国发往北美的数据报（不管它是地址块198/7中的哪一个地址）都先送到美国的一个路由器，因此在路由表中使用一个项目就行了。<br>  但是，在使用CIDR之前，因特网的地址管理机构并没有按照地理位置来分配IP，现在要把已分配的IP地址回收再重新分配是十分困难的事情，因为这牵涉很多正在工作的主机必须改变其IP地址。<strong>所以基于地址位置划分地址块仅仅停留在想法</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><mark>网络层协议</mark></p><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p>完成主机或路由器IP地址到MAC地址的映射，解决下一跳走哪的问题</p><blockquote><p><strong>*由于实际网络链路中，传送数据帧时，必须使用MAC地址</strong>，<br>例如：在一个局域网内，所有设备使用同一套链路，主机A想要向同一个网段下的主机B,在数据链路上发送数据帧，肯定需要在帧头加上源MAC地址和目的MAC地址，但是如果主机A不知道主机B的目的MAC地址怎么办？这就需要先检查<strong>ARP高速缓存</strong>，检查是否有主机B的IP地址与MAC地址的映射，如果有，则直接将主机B的MAC地址封装上数据帧，放到链路上传输；如果没有，那么就需要使用ARP协议，主机A向局域网内所有设备广播ARP请求的分组，<strong>同一局域网内所有主机收到该请求</strong>，当主机B收到这个请求分组，发现目的IP就是自己的IP地址，就会向主机A 单播返回一个 带有IP和MAC地址的分组，A得到B的响应，立刻将主机B的ip和MAC地址的映射项写入ARP缓存（<strong>10-20min更新一次</strong>），然后主机A就能向帧头加上目的MAC地址放到链路上传送了</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082116250.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082127346.png" alt="image.png"></p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p><mark>应用层协议</mark></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt="image.png"></p><h3 id="主机如何获取ip地址？"><a href="#主机如何获取ip地址？" class="headerlink" title="主机如何获取ip地址？"></a><strong><em>主机如何获取ip地址？</em></strong></h3><ul><li><em>动态分配</em></li><li><em>静态分配</em></li></ul><h3 id="什么是动态分配DHCP协议？"><a href="#什么是动态分配DHCP协议？" class="headerlink" title="什么是动态分配DHCP协议？"></a><strong><em>什么是动态分配DHCP协议？</em></strong></h3><p><strong><em>DHCP协议是应用层协议，使用UDP传送</em></strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091011931.png" alt="image.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><mark>网络层协议</mark><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt=""></p><h3 id="什么是ICMP"><a href="#什么是ICMP" class="headerlink" title="什么是ICMP?"></a><em>什么是ICMP?</em></h3><p>ICMP，全称是 Internet Control Message Protocol，即互联网控制报文协议，所谓控制，就是通过下发指令来感知和控制网络环境，所以它一定是配合一个无法感知网络环境的协议来工作的，这个协议就是 IP(包括 IPv4 和 IPv6)。</p><p>所以，ICMP 通常被认为是 IP 协议的一部分，它封装在 IP 层中，使用 IP 协议进行传输。因此，严格来说，<strong><em>ICMP 既不是一个网络层协议，也不是一个传输层协议，而是介于两者之间的一个协议。但是一般认为属于网络层协议</em></strong></p><p>它的主要功能是传输网络诊断信息，信息主要包括两类：</p><ul><li>一类是 查询类报文 ：主要用于信息的查询和采集，比如采集传输路径上的每个路由器都是谁，本次传输的报文是否达到目的地等等。</li><li>另一类是 差错诊断类报文 ：主要用于诊断网络故障，比如传输报文被丢弃的原因是什么等等。</li></ul><h3 id="为什么需要ICMP？"><a href="#为什么需要ICMP？" class="headerlink" title="为什么需要ICMP？"></a><em>为什么需要ICMP？</em></h3><p>我们都知道，<strong><em>IP 协议是一个不可靠协议</em></strong>，如果 IP 包在传输过程中出现错误，比如 checksum 对不上，拥塞，超时等等，那么 IP 包是会直接被丢弃的，之后也不会有进一步的努力来修正。</p><p>这是 IP 协议的一个设计准则决定的，也就是 best effort，尽力而为，这样的好处是让 IP 协议尽量保持简单的形态，只负责有效率的数据传输，而更多的质量控制交给高层的协议去处理(比如 TCP)。</p><p>但高层能提供质量控制的协议毕竟在少数，所以就需要在下层有协议来辅助 IP 完成必要的网络质量管理。ICMP 协议自然就被提出来了。</p><p>通过 ICMP 协议，当 IP 包发生错误的时候，上层发送 IP 包的主机或路由器并不知道下层发生了错误，这个时候，下层的主机或路由器就可以通过发送 ICMP 包，将错误信息汇报给上层，从而让上层的主机或路由器进行调整。</p><p>不过需要注意的是，<strong><em>ICMP 仅仅只能提供某些特定类型的错误信息汇报，并不能帮助 IP 协议成为可靠的协议</em></strong>。它能做的事还是有限，但用于基本的网络质量管理是足够了。</p><h3 id="ICMP应用场景"><a href="#ICMP应用场景" class="headerlink" title="ICMP应用场景"></a><em>ICMP应用场景</em></h3><h4 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a><strong>错误报告</strong></h4><p>ICMP 错误消息报告网络错误，例如目的地不可达、超时或分段问题。这些消息对于具有无连接通信模型的用户数据报协议 (UDP) 尤其重要。</p><p>UDP 不提供可靠、有序的数据包传输。发送 UDP 数据包时，数据包可能会丢失，也可能在传送时出现校验和错误等故障。如果发生这种情况，接收方会将 ICMP 错误报告消息发回给发送方，以通知该问题。</p><h4 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a><strong>诊断</strong></h4><p>您可以使用 ICMP 进行网络诊断。它最常用于 <strong><em>ping 和 traceroute</em></strong> 命令。</p><ul><li><p><strong><em>ping 命令通过向目标设备发送 ICMP 回显请求数据包来测试网络设备的可访问性</em></strong>。如果设备可以访问，则会返回 ICMP 回显回复。它可以可靠地检查网络延迟并确保设备可用。</p></li><li><p><strong><em>traceroute 命令跟踪数据包从源到目的地所采用的路径</em></strong>。为此，该命令将回显请求和回显回复消息发送到预定目的地。</p></li></ul><blockquote><p>例如：回显请求包含一个生存时间 (TTL) 值，数据包每通过一个路由器，该值就会减 1。当数据包到达 TTL 为零的路由器时，路由器会向源端发送一条 ICMP 消息。该消息包含有关数据包所采用路由的信息。Traceroute 会显示数据包的确切路径，可以为您提供网络性能详情。</p></blockquote><h3 id="ICMP报文格式长啥样？"><a href="#ICMP报文格式长啥样？" class="headerlink" title="ICMP报文格式长啥样？"></a><em>ICMP报文格式长啥样？</em></h3><ul><li><em>【注意区分，报文是数据部分，报文在网络层封装成IP数据报】</em></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091035923.png" alt="image.png"></p><p>如下图所示，ICMP 报文是被封装在 IP 数据报中传输的。</p><p>IP 报头中的 Protocol 字段为 1 即表示该报文携带的是 ICMP 报文。(此处只是为了说明问题，因此 IP 报头是简化了的)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091057587.png" alt="image.png"></p><p>进一步看，ICMP 报头为 4 个字节：</p><ul><li>类型 type：占 1 个字节，表示较大范围类型分类的 ICMP 报文</li><li>代码 code：占 1 个字节，表示较小范围类型分类的 ICMP 报文(type的细分)</li><li>校验和 checksum：占 2 个字节，ICMP checksum 的计算方法类似于 IP checksum，但是不同的是 IP 只校验头部，ICMP 校验头部+数据部分</li></ul><p>后面紧接的 ICMP 数据部分，根据前面的类型和代码字段的不同，具有不同的内容。</p><h3 id="ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】"><a href="#ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】" class="headerlink" title="ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】"></a><em>ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】</em></h3><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a><em>ICMP差错报文</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091033395.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091104579.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091105405.png" alt="image.png"></p><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a><em>ICMP询问报文</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091106410.png" alt="image.png"></p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="为什么需要IPV6？"><a href="#为什么需要IPV6？" class="headerlink" title="为什么需要IPV6？"></a><em>为什么需要IPV6？</em></h3><p><em>IPv4地址采用32比特标识，理论上能够提供的地址数量是43亿（由于地址分配的原因，实际可使用的数量不到43亿）。另外，IPv4地址的分配也很不均衡：美国占全球地址空间的一半左右，而欧洲则相对匮乏；亚太地区则更加匮乏。与此同时，移动IP和宽带技术的发展需要更多的IP地址。目前IPv4地址已经消耗殆尽。针对IPv4的地址短缺问题，也曾先后出现过几种解决方案。比较有代表性的是无类别域间路由CIDR（Classless Inter-Domain Routing）和网络地址转换NAT（Network Address Translator）。但是CIDR和NAT都有各自的弊端和不能解决的问题，由此推动了IPv6的发展。</em></p><p><strong><em>IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</em></strong></p><h3 id="IPV6地址表示方法"><a href="#IPV6地址表示方法" class="headerlink" title="IPV6地址表示方法"></a><em>IPV6地址表示方法</em></h3><ol><li><p><em>IPv6地址总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。例如：FC00:0000:130F:0000:0000:09C0:876A:130B，这是IPv6地址的首选格式。</em></p></li><li><p><em>为了书写方便，IPv6还提供了<strong>压缩格式</strong>，以上述IPv6地址为例，具体压缩规则为：</em></p><ul><li><em>每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876A:130B</em></li><li><em>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，所以上述地址又可以进一步简写为：FC00:0:130F::9C0:876A:130B。</em></li><li><em>需要注意的是，<strong>在一个IPv6地址中只能使用一次双冒号“::”</strong>，否则当计算机将压缩后的地址恢复成128位时，无法确定每个“::”代表0的个数</em></li></ul></li></ol><h3 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a><em>IPv6数据报格式</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091306357.png" alt="image.png"></p><h3 id="IPV6与IPV4对比"><a href="#IPV6与IPV4对比" class="headerlink" title="IPV6与IPV4对比"></a><em>IPV6与IPV4对比</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091307625.png" alt="image.png"></p><h3 id="IPV4向IPV6过渡"><a href="#IPV4向IPV6过渡" class="headerlink" title="IPV4向IPV6过渡"></a><em>IPV4向IPV6过渡</em></h3><ul><li><strong>*双栈技术</strong>：主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。*</li></ul><blockquote><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p></blockquote><ul><li><strong>*隧道技术</strong>：在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。*</li></ul><blockquote><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091308688.png" alt="image.png"></p><h2 id="路由算法与路由选择协议概述"><a href="#路由算法与路由选择协议概述" class="headerlink" title="路由算法与路由选择协议概述"></a><em>路由算法与路由选择协议概述</em></h2><blockquote><p><em>路由算法</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062114988.png" alt="image.png"></p><blockquote><p><em>路由算法分类</em></p></blockquote><ul><li><em>静态路由算法（非自适应路由算法）：管理员手动配置路由信息</em></li><li><em>动态路由算法（自适应路由算法）：路由器彼此交换信息，自行优化路由表</em><ul><li><em>全局性算法：链路状态路由算法OSPF</em><br><em>所有路由器掌握完整的网络拓扑和链路费用</em></li><li><em>分散性算法：距离向量路由算法RIP</em><br><em>路由器只掌握物理相连的邻居及链路费用</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062115290.png" alt="image.png"></li></ul></li></ul><blockquote><p><em>分层次的路由选择协议</em></p></blockquote><ul><li><strong>*路由选择协议需要分层次</strong><br>1.因为因特网规模大 2.因为许多单位不想让外界知道自己的路由选择协议<em></em> 所以就分为多个自治系统AS，并且将不同自治系统可以使用不同协议<em></em> 一个AS内使用的RIP、OSPF协议；AS与AS之间使用的BGP协议*</li><li><strong>*自治系统AS</strong>：<br>是单一的技术管理下的一组路由器（这些路由器使用一种AS内部的路由选择协议）；互联网是一个由网络组成的网络。它由成千上万个被称为“自治系统”（autonomous system，AS）的更小网络组成。这些网络中的每一个实际上就是由单一组织运行的一个大型路由器池。如果我们继续将 BGP 比作互联网的邮政服务，那么自治系统就相当于各邮政分局。一个城镇可能有数百个邮箱，但邮箱中的所有邮件都必须先经过本地邮政分局，然后再运送到另一个目的地。自治系统中的内部路由器就好比邮箱。它们将出站流量路由到自治系统，然后使用 BGP 路由将这些流量传输到其目的地。*</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062122986.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062126920.png" alt="image.png"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a><em>RIP协议及距离向量算法</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835341.png" alt="image.png"></p><h4 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a><em>RIP协议报文格式</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议，使用UDP传输数据</strong></em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091945467.png" alt="image.png"></p><h4 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a><em>什么是RIP协议？</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议</strong>，是一种<strong>分布式的基于距离向量的路由选择协议</strong>适用于与比较小的网络</em></p></blockquote><p><em>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</em><br><em>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></em></p><p><em>路由表有三项：目的网络、距离、下一条路由器</em></p><ul><li><strong>*目的网络</strong>：通过该路由器能够到达的网络*</li><li><strong>*距离</strong>：该路由器到达目的网络的最佳距离（跳数）*</li><li><strong>*下一跳路由器</strong>：如果要走这样的最佳距离，需要走过的下一跳路由器<em></em> 【直接交付，是指目的网络和该路由器直接相连的】*<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091606961.png" alt="image.png"></li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091718131.png" alt="image.png"></p><h4 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点"></a><em>RIP协议的特点</em></h4><ol><li><em>仅和<strong>相邻路由器</strong>交换信息。</em></li><li><em>交换的信息是当前本路由器所知道的全部信息，即<strong>自己的路由表。</strong></em></li><li><em>按固定的时间间隔交换路由信息，例如，<strong>每隔 30 秒</strong>。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息（当链路有变化，就不等30s了，比如某个网段不存在了，会立刻告诉。）</em></li></ol><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a><em>距离向量算法</em></h4><p><em>在RIP协议相邻路由器互相交换路由表之后，如何处理，才能得到到达某一个网络的最短距离？这就是距离向量算法所解决的问题</em></p><ol><li><em>修改相邻路由器发来的RIP报文中 <strong>所有表项。</strong><br>对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离” 字段 +1。</em></li><li><em>对修改后的RIP报文中的每一个项目，进行以下步骤：</em><br><em>（1）R1路由表中若没有Net3，则把该项目填入R1路由表</em><br><em>（2）R1路由表中若有Net3，则查看下一跳路由器地址：</em><ul><li><em>若下一跳是X，则用收到的项目替换源路由表中的项目；</em></li><li><em>若下一跳不是X， 原来距离比从X走的距离远则更新，否则不作处理。</em></li></ul></li><li><em>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</em></li><li><em>返回</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091734766.png" alt="image.png"></li></ol><blockquote><p><em>距离向量算法例题</em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091737534.png" alt="image.png"></p><p><strong><em>解析：</em></strong><br><em>来自B的向量为（5，0，8，12，6，2）；<br>其数字分别对应路由器C通过B 到达(A，B，C，D，E，F) 路由器的距离，<br>由于还有C到B的延迟6,所以每个分量还需要+6；其他的同理</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091738922.png" alt="image.png"></p><h4 id="好消息穿的快，坏消息传的慢"><a href="#好消息穿的快，坏消息传的慢" class="headerlink" title="好消息穿的快，坏消息传的慢"></a><em>好消息穿的快，坏消息传的慢</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835185.png" alt="image.png"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><em>OSPF协议及链路状态算法</em></h3><h4 id="OSPF分组格式"><a href="#OSPF分组格式" class="headerlink" title="OSPF分组格式"></a><em>OSPF分组格式</em></h4><blockquote><p><em>注意：OSPF协议是<strong>网络层协议，使用IP数据报传输数据</strong>OSPF协议是不使用UDP数据报传送，而是直接使用IP数据报传送，因此OSPF是被划分到属于网络层协议-这一点考研党要以考纲为标准）<em>**</em></em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091941328.png" alt="image.png"></p><h4 id="为什么会有OSPF协议？"><a href="#为什么会有OSPF协议？" class="headerlink" title="为什么会有OSPF协议？"></a><em>为什么会有OSPF协议？</em></h4><p><em>开放式最短路径优先OSPF（Open Shortest Path First）协议是IETF定义的一种<strong>基于链路状态的内部网关路由协议</strong>。</em></p><p><em>为什么会出现OSPF？:因为<strong>RIP是一种基于距离矢量算法的路由协议</strong>，存在着</em></p><ul><li><strong>收敛慢；</strong></li><li><strong>易产生路由环路；</strong></li><li><strong>可扩展性差，最大只能支持15跳。</strong></li></ul><p><em>OSPF的出现很好地解决了上述3个问题</em></p><h4 id="OSPF协议的特点"><a href="#OSPF协议的特点" class="headerlink" title="OSPF协议的特点"></a><em>OSPF协议的特点</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091934529.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935354.png" alt="image.png"></p><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a><em>链路状态路由算法</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935933.png" alt="image.png"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a><em>BGP协议</em></h3><h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a><em>BGP协议报文格式</em></h4><blockquote><p><em>注意：BGP协议是<strong>应用层协议，使用TCP传送</strong></em></p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091948118.png" alt="image.png"></p><h4 id="什么是BGP协议？"><a href="#什么是BGP协议？" class="headerlink" title="什么是BGP协议？"></a><em>什么是BGP协议？</em></h4><p><em>边界网关协议 (BGP) 就是互联网的邮政服务。当有人把一封信投进邮筒时，邮政服务就会处理这封邮件，并选择一条快速、高效的路线将这封信投递给收件人。同样地，当有人通过互联网提交数据时，BGP 负责寻找数据能传播的所有可用路径，并选择最佳的路由，这通常意味着在自治系统之间跳跃。</em></p><h4 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a><em>BGP协议的特点</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092009810.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092010645.png" alt="image.png"></p><h4 id="BGP协议交换信息过程"><a href="#BGP协议交换信息过程" class="headerlink" title="BGP协议交换信息过程"></a><em>BGP协议交换信息过程</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011121.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011516.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011023.png" alt="image.png"></p><h4 id="BGP协议四种报文"><a href="#BGP协议四种报文" class="headerlink" title="BGP协议四种报文"></a><em>BGP协议四种报文</em></h4><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092012373.png" alt="image.png"></p><h3 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a><em>三种路由协议的比较</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013543.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013263.png" alt="image.png"></p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a><em>IP组播</em></h2><h3 id="IP网络的3种数据传输方式"><a href="#IP网络的3种数据传输方式" class="headerlink" title="IP网络的3种数据传输方式"></a><em>IP网络的3种数据传输方式</em></h3><p><em>IPv4协议定义了三种IP数据包的传输方式：单播（unicast）、广播（broadcast）和组播（multicast）。通过对三种包传播方式比较式介绍，可以看到组播方式的优越性。</em><br><em>组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用。它是实现高效局域网组播的重要标识。</em></p><p><strong><em>1.单播方式</em></strong><br><em>单播（Unicast）是在一台源IP主机和一台目的IP主机之间进行。网络上绝大部分的数据都是以单播的形式传输的，例如电子邮件收发、网上银行都是采用单播实现的。</em></p><ul><li><em>一份单播报文，使用一个单播地址作为目的地址。Source向每个接收者发送一份独立的单播报文。如果网络中存在N个接收者，则Source需要发送N份单播报文</em></li><li><em>网络为每份单播报文执行独立的数据转发，形成一条独立的数据传送通路。N份单播报文形成N条相互独立的传输路径</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单播缺点：</span><br><span class="line">1.重复流量过多（每有一个用户就要发送一份同样的数据） </span><br><span class="line">2.消耗设备和链路带宽资源（假如有一百个用户，就要发送一百份数据） </span><br><span class="line">3.难以保证传输支质量（用户数量过大时，会造成发送端和链路上的网络设备因为流量过大以及负载过高而网络瘫痪或死机）</span><br></pre></td></tr></table></figure><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122114438.png" alt="image.png"></li></ul><p><strong><em>2.广播方式</em></strong><br><em>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</em></p><ul><li><em>一份广播报文，使用一个广播地址作为目的地址。Source向本网段对应的广播地址发送且仅发送一份报文。</em></li><li><em>不管是否有需求，保证报文被网段中的所有用户主机接收。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">广播缺点：</span><br><span class="line">1.地域范围限制（广播报文被限制在一个共享网段中） </span><br><span class="line">2.安全性无法保障（在该网段中所有主机都接收的到广播报文，不管是否想要接收） </span><br><span class="line">3.有偿性无法保障（计费困难）</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>3.组播方式</em></strong><br><em>组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的交换机和路由器根据接收者的需要，有选择性地对数据进行复制和转发</em></p><ul><li><p><em>组播在点对多点的应用上，结合了单播和广播的优势。组播方式下，单一的信息流沿组播分发树被同时发送给一组用户，相同的组播数据流在每一条链路上最多仅有一份。</em></p></li><li><p><em>相比单播，由于被传递的信息在距信息源尽可能远的网络节点才开始被复制和分发，所以用户的增加不会导致信息源负载的加重以及网络资源消耗的显著增加。</em></p></li><li><p><em>相比广播，由于被传递的信息只会发送给需要该信息的接收者，所以不会造成网络资源的浪费，并能提高信息传输的安全性。另外，广播只能在同一网段中进行，而组播可以实现跨网段的传输。</em></p></li></ul><h3 id="组播IP"><a href="#组播IP" class="headerlink" title="组播IP"></a><em>组播IP</em></h3><p><em>组播不可能以某一个主机的IP作为自己的目的IP，但是以太网报文在封装时必须要填入目的IP</em></p><p><em>怎么办？</em></p><p><em>回想一下，组播IP不能以某个主机的IP作为自己的目的IP，换句话说，组播IP不需要考虑主机标识，哪个类型的IP地址没有主机标识，<strong>D类</strong></em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt=""></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122208049.png" alt="image.png"></p><h3 id="组播MAC"><a href="#组播MAC" class="headerlink" title="组播MAC"></a><em>组播MAC</em></h3><p><em>同样地，组播报文在数据链路层需要填充目的MAC地址，如何填充正确的MAC地址呢？</em></p><p><em>单播报文在填入目的MAC时，会通过ARP协议根据目的IP询问目的主机的MAC地址，而组播由于目的IP并不是某个主机的IP，所有无法用ARP协议询问目的MAC。既然ARP寻址方式行不通，组播MAC地址有自己的转换方式</em></p><blockquote><p>*组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用, 比如：</p><ul><li><em>服务器/工作站 - 在进行组播通信时,服务器和工作站会作为发送端或接收端使用组播MAC地址。比如视频会议软件。</em></li><li><em>游戏主机 - 一些网络游戏主机和服务也可能使用组播MAC地址</em></li></ul></blockquote><p><em>这些实现组播的设备的MAC地址，被称为组播MAC地址，它与平时我们上网网卡的单播MAC地址不同，有以下区别</em></p><blockquote><p><strong>*MAC地址的唯一性只是在单播MAC地址而言</strong>。单播MAC地址用于唯一标识一台网络设备,确实要求全球唯一。但是组播MAC地址用于支持一对多的组播通信,其地址格式规定了前24位是固定值,后24位可以配置。组播MAC地址之所以可以在多台设备上取相同的值,*</p></blockquote><ol><li>组播MAC地址只需要在局域网内的设备上唯一即可,不需要全球唯一。</li><li>组播通信需要将报文复制给多个接收端,所以不能使用唯一的MAC地址。</li><li>通过配置组播MAC的后24位,可以生成多个相同的组播MAC地址。</li><li>不同网络接口可以配置相同的组播MAC地址,以接收同一多播流。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122144515.png" alt="image.png"></li></ol><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a><em>IGMP协议</em></h3><p><em>互联网组管理协议 (IGMP) 是允许多个设备共享一个 IP 地址以便它们可以接收相同数据的协议。IGMP 是一个网络层协议，用于在使用互联网协议版本 4 (IPv4) 的网络上设置多播。具体来说，IGMP 允许设备加入一个多播组。</em></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122211412.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122214062.png" alt="image.png"></p><h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a><em>组播路由选择协议</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122216955.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122217429.png" alt="image.png"></p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><em>移动IP</em></h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131124271.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131125560.png" alt="image.png"></p><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a><em>网络层设备</em></h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><em>路由器</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144391.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144007.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144035.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144550.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131145981.png" alt="image.png"></p><h2 id="多层次协议汇总"><a href="#多层次协议汇总" class="headerlink" title="多层次协议汇总"></a><em>多层次协议汇总</em></h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131528802.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><em>习题</em></h2><h3 id="网络层的功能-1"><a href="#网络层的功能-1" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h3><blockquote><p><em>网络层数据报传输是否可靠，取决于协议；如果使用有连接，有确认的协议那就是可靠传输</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131150887.png" alt="image.png"></p><p><em>异构网络互联：中异构网络是指，数据链路层和物理层均不同的网络</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131157448.png" alt="image.png"></p><p><em>网络拥塞是指通信子网中负载增加，随着负载增加，越来越多分组由于等待，过长会被丢弃，所以导致虽然负载增加，但是吞吐率下降</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131159040.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131416251.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131418246.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131420473.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131422480.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131424547.png" alt="image.png"></p><p><em>中间路由器和源主机都不知道IP分组到达目的主机需要经过的完整路径</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131426158.png" alt="image.png"></p><p><em>各层常用协议</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131455900.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131458020.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131501758.png" alt="image.png"></p></blockquote><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><em>路由算法</em></h3><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131506707.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131513947.png" alt="image.png"></p><p><em>OSPF协议采用Dijstra最短路径算法</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131516568.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131523233.png" alt="image.png"></p></blockquote><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a><em>IPV4</em></h3><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131535270.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131613278.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131616022.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131621255.png" alt="image.png"></p><p><em>127开头的表示环回地址，不分配给主机；<br>主机号全0，全1也不分配<br>主机号全0，表示本网络；全1表示所有主机</em><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131625892.png" alt="image.png"></p></blockquote><ul><li><em>在所有主机都是使用公网IP时，就<strong>不需要考虑NAT转换</strong>，主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和C目的IP地址；MAC帧额外信息部分，封装A源MAC地址和路由器的MAC地址。</li><li>接着由路由器向C发送：IP数据爆首部，封装路由器自己IP(源IP)，和C的IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(y源MAC)，和C的MAC地址(目的MAC)。</li></ol></li><li><em>当主机使用的内网IP时，多台主机共享路由器的一个公网IP，<strong>需要考虑NAT转换</strong>，(假设A是外网主机，BC是内网主机)主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和路由器的IP地址【因为C的局域网IP不能通信】；MAC帧额外信息部分，封装A源MAC地址和路由器MAC地址(目的)</li><li>路由器向C发送：IP数据报首部，封装路由器自己的IP地址(源IP)，和C的内网IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(源MAC)，和C的MAC地址(目的MAC)<br>&gt;<blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131638477.png" alt="image.png"><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131643347.png" alt="image.png"></p></blockquote></li></ol></li></ul><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131702214.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131728805.png" alt="image.png"></p><p><em>IPV4首部，比较重要的几个字段：首部长度，单位4B；总长度，单位1B<br>片偏移，单位8B；</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142150490.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142153044.png" alt="image.png"></p><p><em>IP分组自能在目的主机中重组</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161537864.png" alt="image.png"></p><p><em>路由聚合，构成超网</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161619359.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161643795.png" alt="image.png"></p><p><em>内部网络ip地址范围</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161717209.png" alt="image.png"></p><p><em>NAT转换表，只有当源ip地址和源端口都对应，才能转换为公网地址</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161736068.png" alt="image.png"></p></blockquote><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301059261.png" alt="image.png"></p><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a><em>传输层概述</em></h2><h3 id="什么是传输层？"><a href="#什么是传输层？" class="headerlink" title="什么是传输层？"></a><em>什么是传输层？</em></h3><p>传输层是只有主机才有的层次。<br><strong>传输层的功能</strong>：</p><ol><li>传输层提供进程与进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li><li>传输层的两种协议<p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301103467.png" alt="图片alt"></p></li></ol><h3 id="传输层的两个协议TCP-amp-UDP"><a href="#传输层的两个协议TCP-amp-UDP" class="headerlink" title="传输层的两个协议TCP&amp;UDP"></a><em>传输层的两个协议TCP&amp;UDP</em></h3><p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301105552.png" alt="图片alt"></p><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><em>传输层的寻址与端口</em></h3><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。<br>分用：传输层从网络层收到数据后交付指明的应用进程</p><p><mark>端口</mark>：又称为逻辑端口/软件端口，用于标识主机中的应用进程，是传输层的SAP, 与交换机路由器的物理端口不同，是一种虚拟的逻辑端口。</p><p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。<br>端口号长度为16bit,能表示65536个不同的端口号。</p><p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301113972.png" alt="图片alt"></p><div style="background-color:#fffacd;padding:20px">熟知端口号一般是固定的，以下是一些重要的熟知端口号<p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301116873.png" alt="图片alt"></p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<center><mark>套接字Socket = (主机IP地址，端口号)</mark></center></div><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><em>UDP协议</em></h2><h3 id="用户数据报协议UDP特点"><a href="#用户数据报协议UDP特点" class="headerlink" title="用户数据报协议UDP特点"></a><em>用户数据报协议UDP特点</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154002.png" alt="image.png"></p><h3 id="UDP数据报首部格式"><a href="#UDP数据报首部格式" class="headerlink" title="UDP数据报首部格式"></a><em>UDP数据报首部格式</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154585.png" alt="image.png"></p><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a><em>UDP校验</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301155099.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301156204.png" alt="image.png"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><em>TCP协议</em></h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a><em>TCP协议特点</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301511230.png" alt="image.png"></p><blockquote><p><em>TCP是面向字节流的，会对数据的每一个字节按序编号，一个字节占用一个序号，再由多个连续字节组成一个传输单位报文</em><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301539150.png" alt="image.png"></p></blockquote><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a><em>TCP报文段首部格式</em></h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538164.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538754.png" alt="image.png"></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538099.png" alt="image.png"></p><h2 id="TCP基本认识"><a href="#TCP基本认识" class="headerlink" title="TCP基本认识"></a>TCP基本认识</h2><h3 id="TCP头格式有哪些"><a href="#TCP头格式有哪些" class="headerlink" title="TCP头格式有哪些"></a>TCP头格式有哪些</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061654644.png" alt="image.png"></p><p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p><p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p><p><strong>控制位：</strong></p><ul><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul><h3 id="为什么需要-TCP-协议？-TCP-工作在哪一层？"><a href="#为什么需要-TCP-协议？-TCP-工作在哪一层？" class="headerlink" title="为什么需要 TCP 协议？ TCP 工作在哪一层？"></a>为什么需要 TCP 协议？ TCP 工作在哪一层？</h3><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p><p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p><p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p><h3 id="什么是-TCP-？"><a href="#什么是-TCP-？" class="headerlink" title="什么是 TCP ？"></a>什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061707068.png" alt="image.png"></p><ul><li><p><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</p></li><li><p><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</p></li><li><p><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</p></li></ul><h3 id="什么是-TCP-连接？"><a href="#什么是-TCP-连接？" class="headerlink" title="什么是 TCP 连接？"></a>什么是 TCP 连接？</h3><p><strong>用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小称为连接。</strong></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061709234.png" alt="image.png"></p><p>所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识。</p><ul><li><strong>Socket</strong>：由 IP 地址和端口号组成</li><li><strong>序列号</strong>：用来解决乱序问题等</li><li><strong>窗口大小</strong>：用来做流量控制<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061710268.png" alt="image.png"></li></ul><p>TCP是面向连接的协议，TCP把连接作为最基本的抽象。每一条TCP连接唯一地被通信两端的两个端点所确定。那么，TCP连接的端点是什么呢？TCP连接的端点又叫套接字（socket），根据TCP协议的规定，端口号拼接到IP地址即构成了套接字，即.</p><div style="background-color:#fffacd;padding:20px">套接字 socket = （IP地址：端口号）</div><p>这样一来，TCP连接可以以下式子表示</p><div style="background-color:#fffacd;padding:20px">TCP连接 ::= {socket1, socket2} = {（IP1: port1）,（IP2: port2）}</div><p>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。</p><p>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。</p><h3 id="UDP-和-TCP-有什么区别呢？分别的应用场景是？"><a href="#UDP-和-TCP-有什么区别呢？分别的应用场景是？" class="headerlink" title="UDP 和 TCP 有什么区别呢？分别的应用场景是？"></a>UDP 和 TCP 有什么区别呢？分别的应用场景是？</h3><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。</p><p>UDP 协议真的非常简，头部只有 <code>8</code> 个字节（64 位），UDP 的头部格式如下：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061712887.png" alt="image.png"></p><ul><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和。</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。</li></ul><p><strong>TCP 和 UDP 区别：</strong></p><p><em>1. 连接</em></p><ul><li>TCP 是面向连接的传输层协议，传输数据前先要建立连接。</li><li>UDP 是不需要连接，即刻传输数据。</li></ul><p><em>2. 服务对象</em></p><ul><li>TCP 是一对一的两点服务，即一条连接只有两个端点。</li><li>UDP 支持一对一、一对多、多对多的交互通信</li></ul><p><em>3. 可靠性</em></p><ul><li>TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP 是尽最大努力交付，不保证可靠交付数据。但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/quic.html">如何基于 UDP 协议实现可靠传输？(opens new window)</a></li></ul><p><em>4. 拥塞控制、流量控制</em></p><ul><li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li><li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li></ul><p><em>5. 首部开销</em></p><ul><li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的。</li><li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li></ul><p><em>6. 传输方式</em></p><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p><em>7. 分片不同</em></p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><blockquote><p>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？</p></blockquote><p>原因是 TCP 有<strong>可变长</strong>的「选项」字段，而 UDP 头部长度则是<strong>不会变化</strong>的，无需多一个字段去记录 UDP 的首部长度。</p><blockquote><p>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？</p></blockquote><p>先说说 TCP 是如何计算负载数据长度：</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230445811.png" alt=""></p><p>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的。TCP 首部长度，则是在 TCP 首部格式已知的，所以就可以求得 TCP 数据的长度。</p><p>大家这时就奇怪了问：“UDP 也是基于 IP 层的呀，那 UDP 的数据长度也可以通过这个公式计算呀？ 为何还要有「包长度」呢？”</p><p>这么一问，确实感觉 UDP 的「包长度」是冗余的。</p><p>我查阅了很多资料，我觉得有两个比较靠谱的说法：</p><ul><li>第一种说法：因为为了网络设备硬件设计和处理方便，首部长度需要是 <code>4</code> 字节的整数倍。如果去掉 UDP 的「包长度」字段，那 UDP 首部长度就不是 <code>4</code> 字节的整数倍了，所以我觉得这可能是为了补全 UDP 首部长度是 <code>4</code> 字节的整数倍，才补充了「包长度」字段。</li><li>第二种说法：如今的 UDP 协议是基于 IP 协议发展的，而当年可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络层协议，因此 UDP 报文首部需要有长度字段以供计算。</li></ul><h3 id="TCP-和-UDP-可以使用同一个端口吗？"><a href="#TCP-和-UDP-可以使用同一个端口吗？" class="headerlink" title="TCP 和 UDP 可以使用同一个端口吗？"></a>TCP 和 UDP 可以使用同一个端口吗？</h3><p>答案：<strong>可以的</strong>。</p><p>在数据链路层中，通过 MAC 地址来寻找局域网中的主机。在网际层中，通过 IP 地址来寻找网络中互连的主机或路由器。在传输层中，需要通过端口进行寻址，来识别同一计算机中同时通信的不同应用程序。</p><p>所以，传输层的「端口号」的作用，是为了区分同一个主机上不同应用程序的数据包。</p><p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p><p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061716478.png" alt="image.png"></p><p>因此，TCP/UDP 各自的端口号也相互独立，如 TCP 有一个 80 号端口，UDP 也可以有一个 80 号端口，二者并不冲突。</p><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a>TCP的连接管理</h2><h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p><mark>图1.三次握手建立TCP连接</mark></p><p></p><p align="center"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301730864.png" alt="图1"></p><br>图1画出了TCP连接建立的过程。假定图中左端是客户A，右端是服务器B，一开始时，两端都处于CLOSED（关闭）状态。图中的方框分别是端点所处的状态。<p></p><ol><li>服务器进程准备好接受外来的连接，这通常是通过调用<code>socket</code>，<code>bind</code>，<code>listen</code>这三个函数来完成，我们称之为被动打开（passive open）。然后服务器进程就处于LISTEN状态，等待客户的连接请求，如有，则作出响应。</li><li><p>客户通过调用<code>connect</code>发起主动打开（active open），向服务器发出连接请求报文段，请求中的首部的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能携带数据，则要消耗一个序号。这时，TCP客户进入SYN-SEND（同步已发送）状态。</p><div style="background-color:#fffacd;padding:20px">TCP规定，序号（seq）用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。</div></li><li><p>服务器收到客户端连接请求后，必须确认（ACK）客户的SYN报文段。在确认报文段中，把SYN和ACK位都置为1，确认号为ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP服务器进入SYN-RCVD（同步收到）状态。</p><div style="background-color:#fffacd;padding:20px">TCP规定，若确认号ack = N，则表明：到序号 N - 1为止的所有数据都已正确收到。</div></li><li><p>客户在收到服务器的确认后，还要向服务器进程给出确认。确认报文段的ACK置1，SYN=0，确认号ack = y + 1，而自己的序号seq = x + 1。TCP规定，这个报文段可以携带数据，也可以不携带数据，如果不携带数据，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，客户进入ESTABLISHED（已建立连接）状态。</p></li><li>服务器收到客户的确认后，也进入estab-listen状态。</li></ol><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>为什么客户在收到服务器的确认后，还要向服务器发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而发生错误。</p><p>考虑一种情况，客户发出连接请求后，但因连接请求报文丢失而未收到确认。于是客户再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器。没有“已失效的连接请求报文段”。<br>现假定一种异常情况。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求后，就误认为是客户又一次发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用三次握手，那么只要服务器发出确认，新的连接就建立了。</p><p>由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立了，并一直等待客户发送数据。服务器的许多资源就这样白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如刚才的情况下，客户不会向服务器的确认发出确认，由于服务器收不到确认，就知道客户并没有要求建立连接。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>TCP建立一个连接需要三个报文段，释放一个连接却需要四个报文段。<br>因此释放连接的过程也称之为四次握手。</p><p><mark>图2.TCP释放连接的过程</mark><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301753176.png" alt="image.png"><br>数据传输结束后，通信的双方可以释放连接。数据传输结束后的客户A和服务器B都处于ESTABLISHED状态，然后进入释放连接的过程</p><ol><li>A的应用进程先发出释放连接报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部终止位FIN置1，其序号为seq = u。这时A进入FIN-WAIT-1（终止等待1）状态。</li><li>B收到连接释放报文段后即发出确认确认号为ack = u + 1，而自己的序号为seq = v。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍接收。</li><li>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li><li>若B已经没有要向A发送的数据，其应用进程就通知TCP释放 连接。这时B发出的连接释放报文段FIN = 1，还必须重复上次已发送过的确认号ack = u + 1。假定B的序号为w（在半关闭期间B可能又发送了一些数据）。这时B就进入了LAST-ACK（最后确认）状态，等待A的确认。</li><li>A收到了的连接释放报文段后，必须对此发出确认。其确认号为ack = w + 1，而自己的序号为seq = u + 1。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。</li><li>B只要收到A发出的确认，就进入CLOSED状态。我们注意到，B结束TCP连接的时间要比A早一些。</li></ol><h2 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a><em>TCP的可靠传输</em></h2><p><em>TCP实现可靠传输的机制：<strong>校验</strong>、<strong>序号</strong>、<strong>确认</strong>、<strong>重传</strong></em></p><ol><li>TCP 给发送的每一个字节进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和</strong>：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议</strong>：也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="校验"><a href="#校验" class="headerlink" title="校验"></a>校验</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052045835.png" alt="image.png"></p><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p>为每一个字节数据都编一个序号，报文段首部序号字段里的序号是该报文段第一个字节所占的序号编号<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052058473.png" alt="image.png"></p><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>TCP默认使用累计确认的方式，如果发送方发了包1，包2，包3，包4；接受方成功收到包1，包2，包3。那么接受方可以发回一个确认包，序号为4(4表示期望下一个收到的包的序号)，那么发送方就知道包1到包3都发送接收成功，必要时重发包4。一个确认包确认了累积到某一序号的所有包，而不是对每个序号都发确认包。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052057831.png" alt="image.png"></p><h3 id="重传"><a href="#重传" class="headerlink" title="重传"></a>重传</h3><ol><li>超时重传：确认重传不分家，TCP的发送方在规定的时间（重传时间）内没有收到确认就要重传已发送的报文段。TCP采用自适应算法，动态改变重传时间RTTs（加权平均往返时间）</li></ol><ol><li>快速重传：为了防止超时重传容易等太久，所以有了快速重传，快速重传采用冗余ACK（冗余确认）<br>每当比期望序号大的失序报文段到达时,发送一个冗余ACK,指明下一个期待字节的序号。<br>发送方已发送a,b,c,d,e报文段<br>接收方收到a，返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到b，仍返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到c，仍返回给a的确认(确认号为b的第一个字节的序号)<br>接收方收到d，仍返回给a的确认(确认号为b的第一个字节的序号)<br>发送方收到3个对于报文段a的冗余ACK→认为b报文段丢失，重传b号报文段</li></ol><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a><em>TCP流量控制</em></h2><p>流量控制：让发送方慢点，要让接收方来得及接收。<br>TCP利用滑动窗口机制实现流量控制。</p><p>在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小,即接收窗口wd(接收方设置确认报文段的窗口字段来将rwnd通知给发送方），发送方的发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052158671.png" alt="image.png"></p><p>在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。</p><p><strong>如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。</strong></p><blockquote><p>窗口关闭潜在的危险！</p></blockquote><p>接收方向发送方通告窗口大小时，是通过 <code>ACK</code> 报文来通告的。</p><p>那么，当发生窗口关闭时，接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。</p><p>这会导致发送方一直等待接收方的非 0 窗口通知，接收方也一直等待发送方的数据，如不采取措施，这种相互等待的过程，会造成了死锁的现象。</p><blockquote><p>TCP 是如何解决窗口关闭时，潜在的死锁现象呢？</p></blockquote><p>为了解决这个问题，TCP 为每个连接设有一个持续定时器，<strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong></p><p>如果持续计时器超时，就会发送<strong>窗口探测 ( Window probe ) 报文</strong>，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p><ul><li>如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；</li><li>如果接收窗口不是 0，那么死锁的局面就可以被打破了。</li></ul><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a><em>TCP拥塞控制</em></h2><blockquote><p>为什么要有拥塞控制呀，不是有流量控制了吗？</p></blockquote><p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><blockquote><p>什么是拥塞窗口？和发送窗口有什么关系呢？</p></blockquote><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><blockquote><p>那么怎么知道当前网络是否出现了拥塞呢？</p></blockquote><p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><blockquote><p>拥塞控制有哪些控制算法？</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a><em>慢启动</em></h3><p>TCP 在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量，如果一上来就发大量的数据，这不是给网络添堵吗？</p><p>慢启动的算法记住一个规则就行：<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><p>这里假定拥塞窗口 <code>cwnd</code> 和发送窗口 <code>swnd</code> 相等，下面举个栗子：</p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><p>慢启动算法的变化过程如下图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052227147.png" alt="image.png"><br>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h3 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a><em>拥塞避免算法</em></h3><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p>拥塞避免算法的变化过程如下图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052228261.png" alt="image.png"></p><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」</p><h3 id="拥塞发生算法"><a href="#拥塞发生算法" class="headerlink" title="拥塞发生算法"></a><em>拥塞发生算法</em></h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p><blockquote><p>发生超时重传的拥塞发生算法</p></blockquote><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052230558.png" alt="image.png"><br>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</li></ul><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a><em>快速恢复</em></h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p>快速恢复算法的变化过程如下图：<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309052232229.png" alt="image.png"><br>也就是没有像「超时重传」一夜回到解放前，而是还在比较高的值，后续呈线性增长。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>网络应用模型分为两类：客户/服务器模型(C/S) 、P2P模型</p><ol><li><p>客户/服务器模型(C/S模型)<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061804479.png" alt="image.png"></p></li><li><p>P2P模型<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061804939.png" alt="image.png"></p></li></ol><h2 id="DNS域名系统"><a href="#DNS域名系统" class="headerlink" title="DNS域名系统"></a>DNS域名系统</h2><p>DNS（Domain Name System，域名系统），是用于实现域名和 IP 地址相互映射的一个<strong>分布式数据库</strong>，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。通过主机名，得到该主机名对应的 IP 地址的过程叫做<strong>域名解析</strong>（或主机名解析）。</p><p>如果整个因特网都使用一个域名服务器，负荷太大， 所以 DNS 设计成一个分布式的数据库，即使单个主机出故障也不会妨碍整个 DNS 系统。另外 DNS 使得大多数域名都能在本地解析，仅少量解析需要在因特网上通信，因此 DNS 效率很高。</p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><blockquote><p>域名的分级结构是如何划分的？</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061735142.png" alt="image.png"></p><p><strong>域名结构</strong>：树状结构，树的最顶端代表根域名，下一层是 .com、.cn 等顶级域名，再下层就是二级、三级、四级域名。</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061737113.png" alt="image.png"></p><blockquote><p>域名服务器分级结构</p></blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061740051.png" alt="image.png"></p><ul><li><strong>根域名服务器</strong>：最高层次的域名服务器，根域名服务器知道所有顶级域名服务器的域名和IP地址。任何一个本地域名服务器要对互联网上的任何域名进行解析，只要自己无法解析，就会首先求助于根域名服务器。</li><li><strong>顶级域名服务器</strong>：管理在该顶级域名服务器下注册的所有二级域名。当收到DNS查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步需要去找的域名服务器的IP地址）。</li><li><strong>权限域名服务器</strong>（权威域名服务器）：负责一个区的域名服务器。当一个权威域名服务器不能给出最终的查询结果时，就会告诉发出请求方，下一步应该去找哪一个权威域名服务器。</li><li><strong>本地域名服务器</strong>（递归服务器）：主机发出 DNS 查询请求时，该请求首先会发给本地域名服务器。</li></ul><blockquote><p><em>域名解析的具体流程是怎样的呢？</em></p></blockquote><ol><li>在浏览器中输入<code>www.qq.com</code> 域名，浏览器先检查自身缓存中有没有被解析过的这个域名对应的 IP 地址，如果有，就调用这个 IP 映射，完成域名解析。</li><li>如果浏览器缓存中未命中，操作系统会检查本地的 hosts 文件是否有该域名和 IP 的映射，如果有，就调用这个IP地址映射，完成域名解析。</li><li>如果 hosts 里也没有这个域名的映射，则向本地域名服务器（LDNS）发送请求，看是否有这个域名的映射关系，如果有，直接返回，完成域名解析。（LDNS 一般在城市的某个角落，距离你不会很远，一般都会缓存域名解析结果，大约 80% 的域名解析到这里就完成了）</li><li>如果 LDNS 仍然未命中，LDNS 就向根服务器发送查询请求，根服务器里面记录的都是各个顶级域所在的服务器 IP，根服务器会根据域名后缀返回对应的顶级域名服务器位置。当向根请求<code>www.qq.com</code> 的时候，根服务器就会返回 <code>.com</code>服务器的位置信息。</li><li>LDNS 拿到<code>.com</code> 的权威服务器地址以后，就会询问<code>.com</code> 的权威服务器，知不知道<code>www.qq.com</code>的位置。这个时候 <code>.com</code>权威服务器查找并返回<code>www.qq.com</code>服务器的地址。LDNS 继续向<code>www.qq.com</code> 的权威服务器去查询这个地址，由<code>www.qq.com</code>的服务器给出了 IP 地址：202.173.11.10</li><li>LDNS 服务器得到了<code>www.qq.com</code> 对应的 IP 地址后以 DNS 应答包 的方式传递给客户机，并把域名和对应的 IP 地址在本地缓存下来。</li><li>客户机根据 IP 地址建立连接，并在客户端缓存域名/IP映射。</li></ol><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061745329.png" alt="image.png"></p><p>简单来说，其实只有四步：</p><ol><li>在本地缓存里找映射，未命中继续下一步</li><li>在本地域名服务器（LDNS）里找映射，未命中继续下一步</li><li>LDNS 向根域名服务器发送解析请求，期间迭代查询了顶级域名服务器和各权威域名服务器，LDNS 将解析结果 IP 返回给主机，并缓存域名-IP映射</li><li>主机在浏览器/OS缓存域名-IP映射，并建立连接</li></ol><p>ps.本地域名服务器 = 递归域名服务器，意思是它的查询方式是递归的，即返回的是最终的查询结果而不是可能的查询路径。</p><blockquote><p>前面知道了DNS解析的流程，但是DNS服务器的查询方式具体是怎样的呢？</p></blockquote><p><strong>迭代查询</strong>：DNS 服务器会向客户机提供其他能够解析查询请求的 DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台 DNS 服务器地址，客户机再向这台 DNS 服务器提交请求，依次循环直到返回查询的结果为止。迭代查询返回的是最佳的查询点或者主机地址。本地域名服务器向根域名服务器的查询通常是采用迭代查询。</p><p><strong>递归查询</strong>：DNS 服务器必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询目标的 DNS 信息，那么该服务器会去询问其他服务器（即代替客户机去查询，而不是让客户机自己进行下一步查询），并将返回的查询结果提交给客户机。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错（表示无法查询到所需的 IP 地址）。主机向本地域名服务器的查询一般都是采用递归查询。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309061748833.png" alt="image.png"></p><h2 id="文件传输协议FTP"><a href="#文件传输协议FTP" class="headerlink" title="文件传输协议FTP"></a>文件传输协议FTP</h2><h3 id="1-FTP协议"><a href="#1-FTP协议" class="headerlink" title="1.FTP协议"></a><strong>1.FTP协议</strong></h3><p>什么是FTP呢？FTP 是 TCP/IP 协议组中的协议之一，是英文File Transfer Protocol的缩写。</p><p>该协议是Internet文件传送的基础，它由一系列规格说明文档组成，目标是提高文件的共享性，提供非直接使用远程计算机，使存储介质对用户透明和可靠高效地传送数据。简单的说，FTP就是完成两台计算机之间的拷贝，从远程计算机拷贝文件至自己的计算机上，称之为“下载 （download）”文件。若将文件从自己计算机中拷贝至远程计算机上，则称之为“上载（upload）”文件。在TCP/IP协议中，FTP标准命令TCP端口号为21，Port方式数据端口为20。</p><h3 id="2-FTP服务端和客户端"><a href="#2-FTP服务端和客户端" class="headerlink" title="2.FTP服务端和客户端"></a><strong>2.FTP服务端和客户端</strong></h3><p>同大多数Internet服务一样，FTP也是一个客户/服务器系统。用户通过一个客户机程序连接至在远程计算机上运行的服务器程序。依照 FTP 协议提供服务，进行文件传送的计算机就是 FTP 服务器，而连接FTP服务器，遵循FTP协议与服务器传送文件的电脑就是FTP客户端。用户要连上 FTP 服务器，就要用到 FPT 的客户端软件，通常 Windows自带“ftp”命令，这是一个命令行的 FTP 客户程序</p><h3 id="3-FTP用户授权"><a href="#3-FTP用户授权" class="headerlink" title="3.FTP用户授权"></a><strong>3.FTP用户授权</strong></h3><p>(1）用户授权</p><p>要连上 FTP 服务器（即“登陆”），必须要有该 FTP 服务器授权的帐号，也就是说你只有在有了一个用户标识和一个口令后才能登陆FTP服务器，享受FTP服务器提供的服务。</p><p>（2）FTP地址格式</p><p>FTP地址如下：<code>ftp://用户名：密码@FTP服务器IP或域名：FTP命令端口/路径/文件名</code></p><p>上面的参数除FTP服务器IP或域名为必要项外，其他都不是必须的。如以下地址都是有效FTP地址：</p><p><code>ftp://foolish.6600.org</code></p><p><code>ftp://list:list@foolish.6600.org</code></p><p><code>ftp://list:list@foolish.6600.org:2003</code></p><p><code>ftp://list:list@foolish.6600.org:2003/soft/list.txt</code></p><p>（3）匿名FTP</p><p>互连网中有很大一部分 FTP 服务器被称为“匿名”（Anonymous）FTP 服务器。这类服务器的目的是向公众提供文件拷贝服务，不要求用户事先在该服务器进行登记注册，也不用取得FTP服务器的授权。Anonymous（匿名文件传输）能够使用户与远程主机建立连接并以匿名身份从远程主机上拷贝文件，而不必是该远程主机的注册用户。用户使用特殊的用户名“anonymous”登陆FTP服务，就可访问远程主机上公开的文件。许多系统要求用户将Emai1地址作为口令，以便更好地对访问进行跟综。匿名FTP一直是Internet上获取信息资源的最主要方式，在Internet成千上万的匿名FTP主机中存储着无以计数的文件，这些文件包含了各种各样的信息，数据和软件。人们只要知道特定信息资源的主机地址，就可以用匿名FTP登录获取所需的信息资料。虽然目前使用WWW环境已取代匿名FTP成为最主要的信息查询方式，但是匿名FTP仍是 Internet上传输分发软件的一种基本方法。如red hat 、autodesk等公司的匿名站点。</p><h3 id="4-FTP传输模式"><a href="#4-FTP传输模式" class="headerlink" title="4.FTP传输模式"></a><strong>4.FTP传输模式</strong></h3><p>FTP协议的任务是从一台计算机将文件传送到另一台计算机，它与这两台计算机所处的位置、联接的方式、甚至是是否使用相同的操作系统无关。假设两台计算机通过ftp协议对话，并且能访问Internet，你可以用ftp命令来传输文件。每种操作系统使用上有某一些细微差别，但是每种协议基本的命令结构是相同的。</p><p>FTP的传输有两种方式：<strong>ASCII传输模式</strong>和<strong>二进制数据传输模式</strong>。</p><ol><li><p>ASCII传输方式：假定用户正在拷贝的文件包含的简单ASCII码文本，如果在远程机器上运行的不是UNIX，当文件传输时ftp通常会自动地调整文件的内容以便于把文件解释成另外那台计算机存储文本文件的格式。但是常常有这样的情况，用户正在传输的文件包含的不是文本文件，它们可能是程序，数据库，字处理文件或者压缩文件（尽管字处理文件包含的大部分是文本，其中也包含有指示页尺寸，字库等信息的非打印符）。在拷贝任何非文本文件之前，用binary 命令告诉ftp逐字拷贝，不要对这些文件进行处理，这也是下面要讲的二进制传输。</p></li><li><p>二进制传输模式：在二进制传输中，保存文件的位序，以便原始和拷贝的是逐位一一对应的。即使目的地机器上包含位序列的文件是没意义的。例如，macintosh以二进制方式传送可执行文件到Windows系统，在对方系统上，此文件不能执行。如果你在ASCII方式下传输二进制文件，即使不需要也仍会转译。这会使传输稍微变慢 ，也会损坏数据，使文件变得不能用。（在大多数计算机上，ASCII方式一般假设每一字符的第一有效位无意义，因为ASCII字符组合不使用它。如果你传输二进制文件，所有的位都是重要的。）如果你知道这两台机器是同样的，则二进制方式对文本文件和数据文件都是有效的。</p></li></ol><h3 id="5-FTP的工作方式"><a href="#5-FTP的工作方式" class="headerlink" title="5. FTP的工作方式"></a><strong>5. FTP的工作方式</strong></h3><p>FTP支持两种模式，一种方式叫做<strong>Standard (也就是 PORT方式，主动方式)</strong>，一种是 <strong>Passive (也就是PASV，被动方式)</strong>。 Standard模式 FTP的客户端发送 PORT 命令到FTP服务器。Passive模式FTP的客户端发送 PASV命令到 FTP Server。</p><p>下面介绍一个这两种方式的<strong>工作原理</strong>：</p><p>Port模式FTP 客户端首先和FTP服务器的TCP 21端口建立连接，通过这个通道发送命令，客户端需要接收数据的时候在这个通道上发送PORT命令。 PORT命令包含了客户端用什么端口接收数据。在传送数据的时候，服务器端通过自己的TCP 20端口连接至客户端的指定端口发送数据。 FTP server必须和客户端建立一个新的连接用来传送数据。</p><p>Passive模式在建立控制通道的时候和Standard模式类似，但建立连接后发送的不是Port命令，而是Pasv命令。FTP服务器收到Pasv命令后，随机打开一个高端端口（端口号大于1024）并且通知客户端在这个端口上传送数据的请求，客户端连接FTP服务器此端口，然后FTP服务器将通过这个端口进行数据的传送，这个时候FTP server不再需要建立一个新的和客户端之间的连接。</p><p>很多防火墙在设置的时候都是不允许接受外部发起的连接的，所以许多位于防火墙后或内网的FTP服务器不支持PASV模式，因为客户端无法穿过防火墙打开FTP服务器的高端端口；而许多内网的客户端不能用PORT模式登陆FTP服务器，因为从服务器的TCP 20无法和内部网络的客户端建立一个新的连接，造成无法工作。</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309071118927.png" alt="image.png"></p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><ol><li>一个电子邮件分为<code>信封和内容</code>两大部分，邮件<code>内容</code>又<code>分为首部和主体</code>两部分。</li><li>RFC 822规定了邮件的首部格式，而邮件的主体部分则让用户自由撰写。</li><li>用户写好首部后，邮件系统自动地将信封所需的信息提取出来并写在信封上，用户不需要亲自填写信封上的信息。</li><li>邮件内容的首部包含一些首部行，每个首部行由一个关键字后跟冒号再后跟值组成。有些关键字是必需的，有些则是可选的。最重要的关键字是To:和Subject。</li><li>To是必需的关键字，后面填入一个或多个收件人的电子邮件地址。<br>电子邮件地址的规定格式为:收件人邮箱名@邮箱所在主机的域名<br><code>如abc@cskaoyan.com</code>其中收信人邮箱名即用户名，abc在cskaoyan.com这个邮件服务器上必须是唯一的 。<code>这也就保证了abc@cskaoyan.com</code> 这个邮件地址在整个因特网上是唯一的。</li><li>还有一个必填的关键字是From,但它通常由邮件系统自动填入。</li><li>Subject是可选关键字，是邮件的主题，反映了邮件的主要内容。<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062026296.png" alt="image.png"></li></ol><h3 id="电子邮件系统的组成结构"><a href="#电子邮件系统的组成结构" class="headerlink" title="电子邮件系统的组成结构"></a>电子邮件系统的组成结构</h3><ul><li>电子邮件是一种异步通信方式，通信时不需要双方同时在场。</li><li><p>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可以随时上网到自己使用的邮件服务器进行读取<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062100264.png" alt="image.png"></p></li><li><p>电子邮件系统已改具有的三个最主要的组成部件：用户代理(User Agent)、邮件服务器、电子邮件使用的协议<br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062103899.png" alt="image.png"></p></li></ul><h3 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h3><h4 id="SMTP协议"><a href="#SMTP协议" class="headerlink" title="SMTP协议"></a>SMTP协议</h4><p>SMTP规定了在两个相互通信的SMTP进程之间应如何交换信息。<br>负责发送邮件的SMTP进程就是SMTP客户，负责接收邮件的进程就是SMTP服务器。<br>SMTP规定了14条命令（几个字母）和21种应答信息(三位数字代码+简单文字说明)。</p><blockquote><p>SMTP通信分为三个阶段，连接建立、邮件发送、连接释放</p></blockquote><p><strong>1.连接建立</strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062140921.png" alt="image.png"></p><ul><li>发件人的邮件发送到发送方邮件服务器的邮件缓存中后，SMTP客户就每隔一定 时间对邮件缓存扫描一次。</li><li>如发现有邮件，就使用SMTP的熟知端口号(25) 与接收方邮件服务器的SMTP服务器建立TCP连接。</li><li>连接建立后，接收方SMTP服务器发出220 Service ready (服务就绪)。然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。</li><li>SMTP不使用中间邮件服务器。</li><li>TCP连接总是在发送方和接收方这两个邮件服务器之间直接建立，而不管它们相隔多远。</li><li>接收方的邮件服务器因故障暂时不能建立连接时，发送方的邮件服务器只能等待一段时间后再次尝试连接。</li></ul><p><strong>2.邮件发送</strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062142127.png" alt="image.png"></p><ul><li>连接建立后，就可开始传送邮件。邮件的传送从MAIL命令开始，MAIL 命令后面有发件人的地址。如MAIL FROM:<code>hoopdog@hust.edu.cn。</code></li><li>若SMTP服务器已准备好接收邮件，则回答250 OK。</li><li>接着SMTP客户端发送一个或多个RCPT (收件人recipient的缩写)命令，格式为RCPTTO: &lt;收件人地址&gt;。</li><li>每发送一个 RCPT命令，都应有相应的信息从SMTP服务器返回，如250 OK或550 No such user here (无此用户)。</li><li>RCPT命令的作用是，先弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件，以便不至于发送了很长的邮件后才知道地址错误，进而避免浪费通信资源。</li><li>获得0K的回答后，客户端就使用DATA命令，表示要开始传输邮件的内容。</li><li>正常情况下，SMTP服务器回复信息是354 Start mail input; end with . 。表示回车换行。此时SMTP客户端就可开始传送邮件内容，并用. (两个回车，中间一个点)表示邮件内容的结束。</li></ul><p><strong>3.连接释放</strong><br><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309062143738.png" alt="image.png"></p><ul><li>邮件发送完毕后，SMTP客户应发送QUIT命令。</li><li>SMTP服务器返回的信息是221 (服务关闭)，表示SMTP同意释放TCP连接。邮件传送的全部过程就此结束。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://fqzs.netlify.app">风起之时</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://fqzs.netlify.app/undefined/e255a10a.html">https://fqzs.netlify.app/undefined/e255a10a.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fqzs.netlify.app" target="_blank">风起之时</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/undefined/6ca9ded9.html" title="acdemic_gpt添加slack-Claude模型"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">acdemic_gpt添加slack-Claude模型</div></div></a></div><div class="next-post pull-right"><a href="/undefined/a9bcdbf2.html" title="字扩展与多模块存储器区别"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">字扩展与多模块存储器区别</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s1.ax1x.com/2023/04/01/ppWEUY9.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">风起之时</div><div class="author-info__description">风起之时，快乐的博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/whu1233334"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><b>--- 主域名 ---<br><a href="https://fqzs.netlify.app"><font color="#5ea6e5">fqzs.netlify.app</font></a><br>--- 备用域名 ---<br><a target="_blank" rel="noopener" href="https://whu1233334githubio.fqzs.repl.co/"><font color="#5ea6e5">whu1233334githubio.fqzs.repl.co/</font><br></a><a target="_blank" rel="noopener" href="https://fqzs.pages.dev"><font color="#5ea6e5">fqzs.pages.dev</font></a><br></b></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">计算机网络体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.1.</span> <span class="toc-text">认识计算机网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">计算机网络的组成与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%88%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.3.</span> <span class="toc-text">性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9F%E7%8E%87"><span class="toc-number">1.3.1.</span> <span class="toc-text">速率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%AE%BD"><span class="toc-number">1.3.2.</span> <span class="toc-text">带宽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.4.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6"><span class="toc-number">1.3.5.</span> <span class="toc-text">时延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E5%BB%B6%E5%B8%A6%E5%AE%BD%E7%A7%AF"><span class="toc-number">1.3.6.</span> <span class="toc-text">时延带宽积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RTT%E5%BE%80%E8%BF%94%E6%97%B6%E5%BB%B6"><span class="toc-number">1.3.7.</span> <span class="toc-text">RTT往返时延</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%8E%87"><span class="toc-number">1.3.8.</span> <span class="toc-text">利用率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84-%E5%8D%8F%E8%AE%AE-%E6%8E%A5%E5%8F%A3-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">分层结构-协议-接口-服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">为什么要分层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%86%E5%B1%82%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">怎么分层？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">计算机网络分层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ISO-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">ISO&#x2F;OSI参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ISO-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E7%94%B1%E6%9D%A5"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">ISO&#x2F;OSI参考模型由来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ISO-OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E8%A7%A3%E9%87%8A%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">ISO&#x2F;OSI参考模型解释通信过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ISO-OSI%E5%90%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">ISO&#x2F;OSI各分层结构及其协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">TCP&#x2F;IP参考模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B8%8EOSI%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">TCP&#x2F;IP参考模型与OSI的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E5%B1%82%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">5层参考模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%88%86%E5%B1%82%E6%B1%87%E6%80%BB"><span class="toc-number">1.6.</span> <span class="toc-text">计算机网络结构分层汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E4%B9%A0%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">课后习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E8%B7%AF%E6%A6%82%E8%BF%B0%E4%B9%A0%E9%A2%98"><span class="toc-number">1.7.1.</span> <span class="toc-text">计算机网路概述习题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E4%B9%A0%E9%A2%98"><span class="toc-number">1.7.2.</span> <span class="toc-text">计算机网络体系及参考模型习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82"><span class="toc-number">2.</span> <span class="toc-text">物理层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.</span> <span class="toc-text">物理层基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.</span> <span class="toc-text">数据通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%861"><span class="toc-number">2.2.1.</span> <span class="toc-text">数据通信基础知识1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据通信基础知识2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%88%E6%B0%8F%E5%87%86%E5%88%99%E3%80%81%E9%A6%99%E5%86%9C%E5%AE%9A%E7%90%86"><span class="toc-number">2.2.3.</span> <span class="toc-text">奈氏准则、香农定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">编码与调制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%B8%A6%E4%BF%A1%E5%8F%B7%E4%B8%8E%E5%AE%BD%E5%B8%A6%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">基带信号与宽带信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B0%83%E5%88%B6-1"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">编码与调制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81%E4%B8%BA%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">数字数据编码为数字信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%95%B0%E6%8D%AE%E8%B0%83%E5%88%B6%E6%88%90%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.2.4.4.</span> <span class="toc-text">数字数据调制成模拟信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.4.5.</span> <span class="toc-text">数据交换方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8-%E4%BF%A1%E9%81%93"><span class="toc-number">2.3.</span> <span class="toc-text">传输介质(信道)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">导向性传输介质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E7%BB%9E%E7%BA%BF"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">双绞线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E8%BD%B4%E7%94%B5%E7%BC%86"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">同轴电缆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E7%BA%A4"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">光纤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%AF%BC%E5%90%91%E6%80%A7%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">非导向性传输介质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">2.4.</span> <span class="toc-text">物理层设备</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">3.</span> <span class="toc-text">数据链路层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.1.</span> <span class="toc-text">链路层的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7-amp-%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93"><span class="toc-number">3.1.1.</span> <span class="toc-text">封装成帧&amp;透明传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E2%80%94%E6%A3%80%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">差错控制—检错编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E2%80%94%E7%BA%A0%E9%94%99%E7%BC%96%E7%A0%81"><span class="toc-number">3.1.3.</span> <span class="toc-text">差错控制—纠错编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.4.</span> <span class="toc-text">流量控制与可靠传输机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">流量控制与可靠传输的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.4.1.1.</span> <span class="toc-text">停止等待协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.4.1.2.</span> <span class="toc-text">滑动窗口协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E9%80%80N%E5%B8%A7%E5%8D%8F%E8%AE%AEGBN"><span class="toc-number">3.1.4.1.2.1.</span> <span class="toc-text">后退N帧协议GBN</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%87%8D%E4%BC%A0%E5%8D%8F%E8%AE%AESR"><span class="toc-number">3.1.4.1.2.2.</span> <span class="toc-text">选择重传协议SR</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6-MAC%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.</span> <span class="toc-text">信道划分介质访问控制(MAC协议)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%88%92%E5%88%86%E4%BF%A1%E9%81%93-%E4%BF%A1%E9%81%93%E5%88%92%E5%88%86%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">静态划分信道(信道划分介质访问控制)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%91%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8FDM"><span class="toc-number">3.1.5.1.1.</span> <span class="toc-text">频分多路复用FDM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8TDM"><span class="toc-number">3.1.5.1.2.</span> <span class="toc-text">时分多路复用TDM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A2%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8WDM"><span class="toc-number">3.1.5.1.3.</span> <span class="toc-text">波分多路复用WDM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A0%81%E5%88%86%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8CDM"><span class="toc-number">3.1.5.1.4.</span> <span class="toc-text">码分多路复用CDM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%BF%A1%E9%81%93-%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.2.</span> <span class="toc-text">动态分配信道(随机访问介质访问控制)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ALOHA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.1.</span> <span class="toc-text">ALOHA协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSMA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.2.</span> <span class="toc-text">CSMA协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSMA-CD%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.3.</span> <span class="toc-text">CSMA&#x2F;CD协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CSMA-CA%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.2.4.</span> <span class="toc-text">CSMA&#x2F;CA协议</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E4%BF%A1%E9%81%93-%E8%BD%AE%E8%AF%A2%E8%AE%BF%E9%97%AE%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">3.1.5.3.</span> <span class="toc-text">动态分配信道(轮询访问介质访问控制)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.3.1.</span> <span class="toc-text">轮询协议</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E4%BC%A0%E9%80%92%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.5.3.2.</span> <span class="toc-text">令牌传递协议</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E5%9F%9F%E7%BD%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">局域网基本概念和体系结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E7%BD%91"><span class="toc-number">3.2.1.</span> <span class="toc-text">以太网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91"><span class="toc-number">3.2.2.</span> <span class="toc-text">无线局域网</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91VLAN"><span class="toc-number">3.2.3.</span> <span class="toc-text">虚拟局域网VLAN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%BF%E5%9F%9F%E7%BD%91%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.3.</span> <span class="toc-text">广域网及相关协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">3.4.</span> <span class="toc-text">链路层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.4.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%AE%B5"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">网段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%9F%9F%E4%B8%8E%E5%B9%BF%E6%92%AD%E5%9F%9F"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">冲突域与广播域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82%E7%9A%84%E8%AE%BE%E5%A4%87"><span class="toc-number">3.4.2.</span> <span class="toc-text">链路层的设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E6%A1%A5"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">网桥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">交换机</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">4.</span> <span class="toc-text">网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">4.1.</span> <span class="toc-text">网络层的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SDN%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">SDN基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5"><span class="toc-number">4.3.</span> <span class="toc-text">IP数据报</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">IP数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87"><span class="toc-number">4.3.2.</span> <span class="toc-text">IP数据报分片</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPV4%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.</span> <span class="toc-text">IPV4地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.4.1.</span> <span class="toc-text">IP地址的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.1.</span> <span class="toc-text">A类地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.2.</span> <span class="toc-text">B类地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E7%B1%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.3.</span> <span class="toc-text">C类地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94ip%E5%9C%B0%E5%9D%80"><span class="toc-number">4.4.1.4.</span> <span class="toc-text">特殊用途ip地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%81%E6%9C%89ip"><span class="toc-number">4.4.1.5.</span> <span class="toc-text">私有ip</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NAT%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.5.</span> <span class="toc-text">NAT网络地址转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%8E%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81"><span class="toc-number">4.6.</span> <span class="toc-text">子网划分与子网掩码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CIDR%E6%97%A0%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80"><span class="toc-number">4.7.</span> <span class="toc-text">CIDR无分类编址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E7%BC%96%E5%9D%80%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.7.1.</span> <span class="toc-text">分类编址的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CIDR%E6%9C%80%E4%B8%BB%E8%A6%81%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%89%B9%E7%82%B9"><span class="toc-number">4.7.2.</span> <span class="toc-text">CIDR最主要的两个特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CIDR%E7%9A%84%E5%9C%B0%E5%9D%80%E6%8E%A9%E7%A0%81"><span class="toc-number">4.7.3.</span> <span class="toc-text">CIDR的地址掩码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CIDR%E4%B8%8D%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.7.4.</span> <span class="toc-text">CIDR不划分子网的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.7.5.</span> <span class="toc-text">路由聚合的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D"><span class="toc-number">4.7.6.</span> <span class="toc-text">最长前缀匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.7.6.1.</span> <span class="toc-text">最长前缀匹配的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E6%8D%AE%E5%9C%B0%E5%9D%80%E4%BD%8D%E7%BD%AE%E5%88%92%E5%88%86%E5%9C%B0%E5%9D%80%E5%BF%AB"><span class="toc-number">4.7.6.2.</span> <span class="toc-text">依据地址位置划分地址快</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.8.</span> <span class="toc-text">ARP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.8.1.</span> <span class="toc-text">ARP协议的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DHCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.9.</span> <span class="toc-text">DHCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96ip%E5%9C%B0%E5%9D%80%EF%BC%9F"><span class="toc-number">4.9.1.</span> <span class="toc-text">主机如何获取ip地址？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8DDHCP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">4.9.2.</span> <span class="toc-text">什么是动态分配DHCP协议？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ICMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.10.</span> <span class="toc-text">ICMP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFICMP"><span class="toc-number">4.10.1.</span> <span class="toc-text">什么是ICMP?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81ICMP%EF%BC%9F"><span class="toc-number">4.10.2.</span> <span class="toc-text">为什么需要ICMP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.10.3.</span> <span class="toc-text">ICMP应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8A%A5%E5%91%8A"><span class="toc-number">4.10.3.1.</span> <span class="toc-text">错误报告</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD"><span class="toc-number">4.10.3.2.</span> <span class="toc-text">诊断</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%E9%95%BF%E5%95%A5%E6%A0%B7%EF%BC%9F"><span class="toc-number">4.10.4.</span> <span class="toc-text">ICMP报文格式长啥样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ICMP%E6%8A%A5%E6%96%87%E5%88%86%E4%B8%BA-%E3%80%90ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87%E3%80%91%E5%92%8C%E3%80%90ICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87%E3%80%91"><span class="toc-number">4.10.5.</span> <span class="toc-text">ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E6%96%87"><span class="toc-number">4.10.5.1.</span> <span class="toc-text">ICMP差错报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E8%AF%A2%E9%97%AE%E6%8A%A5%E6%96%87"><span class="toc-number">4.10.5.2.</span> <span class="toc-text">ICMP询问报文</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IPV6"><span class="toc-number">4.11.</span> <span class="toc-text">IPV6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81IPV6%EF%BC%9F"><span class="toc-number">4.11.1.</span> <span class="toc-text">为什么需要IPV6？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV6%E5%9C%B0%E5%9D%80%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.2.</span> <span class="toc-text">IPV6地址表示方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.11.3.</span> <span class="toc-text">IPv6数据报格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV6%E4%B8%8EIPV4%E5%AF%B9%E6%AF%94"><span class="toc-number">4.11.4.</span> <span class="toc-text">IPV6与IPV4对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV4%E5%90%91IPV6%E8%BF%87%E6%B8%A1"><span class="toc-number">4.11.5.</span> <span class="toc-text">IPV4向IPV6过渡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95%E4%B8%8E%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0"><span class="toc-number">4.12.</span> <span class="toc-text">路由算法与路由选择协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E5%8F%8A%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.1.</span> <span class="toc-text">RIP协议及距离向量算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.12.1.1.</span> <span class="toc-text">RIP协议报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRIP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">4.12.1.2.</span> <span class="toc-text">什么是RIP协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RIP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.12.1.3.</span> <span class="toc-text">RIP协议的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.1.4.</span> <span class="toc-text">距离向量算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E6%B6%88%E6%81%AF%E7%A9%BF%E7%9A%84%E5%BF%AB%EF%BC%8C%E5%9D%8F%E6%B6%88%E6%81%AF%E4%BC%A0%E7%9A%84%E6%85%A2"><span class="toc-number">4.12.1.5.</span> <span class="toc-text">好消息穿的快，坏消息传的慢</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF%E5%8D%8F%E8%AE%AE%E5%8F%8A%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.2.</span> <span class="toc-text">OSPF协议及链路状态算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E5%88%86%E7%BB%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.12.2.1.</span> <span class="toc-text">OSPF分组格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89OSPF%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">4.12.2.2.</span> <span class="toc-text">为什么会有OSPF协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OSPF%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.12.2.3.</span> <span class="toc-text">OSPF协议的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">4.12.2.4.</span> <span class="toc-text">链路状态路由算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.12.3.</span> <span class="toc-text">BGP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.12.3.1.</span> <span class="toc-text">BGP协议报文格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFBGP%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">4.12.3.2.</span> <span class="toc-text">什么是BGP协议？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">4.12.3.3.</span> <span class="toc-text">BGP协议的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E4%BA%A4%E6%8D%A2%E4%BF%A1%E6%81%AF%E8%BF%87%E7%A8%8B"><span class="toc-number">4.12.3.4.</span> <span class="toc-text">BGP协议交换信息过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BGP%E5%8D%8F%E8%AE%AE%E5%9B%9B%E7%A7%8D%E6%8A%A5%E6%96%87"><span class="toc-number">4.12.3.5.</span> <span class="toc-text">BGP协议四种报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.12.4.</span> <span class="toc-text">三种路由协议的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E7%BB%84%E6%92%AD"><span class="toc-number">4.13.</span> <span class="toc-text">IP组播</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E7%BD%91%E7%BB%9C%E7%9A%843%E7%A7%8D%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">4.13.1.</span> <span class="toc-text">IP网络的3种数据传输方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%92%ADIP"><span class="toc-number">4.13.2.</span> <span class="toc-text">组播IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%92%ADMAC"><span class="toc-number">4.13.3.</span> <span class="toc-text">组播MAC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.13.4.</span> <span class="toc-text">IGMP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.13.5.</span> <span class="toc-text">组播路由选择协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8IP"><span class="toc-number">4.14.</span> <span class="toc-text">移动IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E8%AE%BE%E5%A4%87"><span class="toc-number">4.15.</span> <span class="toc-text">网络层设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-number">4.15.1.</span> <span class="toc-text">路由器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%B1%82%E6%AC%A1%E5%8D%8F%E8%AE%AE%E6%B1%87%E6%80%BB"><span class="toc-number">4.16.</span> <span class="toc-text">多层次协议汇总</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">4.17.</span> <span class="toc-text">习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E7%9A%84%E5%8A%9F%E8%83%BD-1"><span class="toc-number">4.17.1.</span> <span class="toc-text">网络层的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95"><span class="toc-number">4.17.2.</span> <span class="toc-text">路由算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPV4"><span class="toc-number">4.17.3.</span> <span class="toc-text">IPV4</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">5.</span> <span class="toc-text">传输层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">传输层概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%9F"><span class="toc-number">5.1.1.</span> <span class="toc-text">什么是传输层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%8D%8F%E8%AE%AETCP-amp-UDP"><span class="toc-number">5.1.2.</span> <span class="toc-text">传输层的两个协议TCP&amp;UDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E5%AF%BB%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">5.1.3.</span> <span class="toc-text">传输层的寻址与端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.</span> <span class="toc-text">UDP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEUDP%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">用户数据报协议UDP特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">UDP数据报首部格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.2.3.</span> <span class="toc-text">UDP校验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.3.</span> <span class="toc-text">TCP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%89%B9%E7%82%B9"><span class="toc-number">5.3.1.</span> <span class="toc-text">TCP协议特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">TCP报文段首部格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">5.4.</span> <span class="toc-text">TCP基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">5.4.1.</span> <span class="toc-text">TCP头格式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TCP-%E5%8D%8F%E8%AE%AE%EF%BC%9F-TCP-%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">为什么需要 TCP 协议？ TCP 工作在哪一层？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%EF%BC%9F"><span class="toc-number">5.4.3.</span> <span class="toc-text">什么是 TCP ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">5.4.4.</span> <span class="toc-text">什么是 TCP 连接？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP-%E5%92%8C-TCP-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%EF%BC%9F"><span class="toc-number">5.4.5.</span> <span class="toc-text">UDP 和 TCP 有什么区别呢？分别的应用场景是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.6.</span> <span class="toc-text">TCP 和 UDP 可以使用同一个端口吗？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86"><span class="toc-number">5.5.</span> <span class="toc-text">TCP的连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">5.5.1.</span> <span class="toc-text">TCP连接的建立</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.5.1.1.</span> <span class="toc-text">为什么需要三次握手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-number">5.5.2.</span> <span class="toc-text">TCP的连接释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="toc-number">5.6.</span> <span class="toc-text">TCP的可靠传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.6.1.</span> <span class="toc-text">校验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%8F%B7"><span class="toc-number">5.6.2.</span> <span class="toc-text">序号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AE%E8%AE%A4"><span class="toc-number">5.6.3.</span> <span class="toc-text">确认</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E4%BC%A0"><span class="toc-number">5.6.4.</span> <span class="toc-text">重传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">5.7.</span> <span class="toc-text">TCP流量控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">5.8.</span> <span class="toc-text">TCP拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">5.8.1.</span> <span class="toc-text">慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.2.</span> <span class="toc-text">拥塞避免算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F%E7%AE%97%E6%B3%95"><span class="toc-number">5.8.3.</span> <span class="toc-text">拥塞发生算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">5.8.4.</span> <span class="toc-text">快速恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">6.</span> <span class="toc-text">应用层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">网络应用模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.2.</span> <span class="toc-text">DNS域名系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">域名解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AEFTP"><span class="toc-number">6.3.</span> <span class="toc-text">文件传输协议FTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-FTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.FTP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-FTP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.FTP服务端和客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-FTP%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.FTP用户授权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-FTP%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.3.4.</span> <span class="toc-text">4.FTP传输模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-FTP%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">6.3.5.</span> <span class="toc-text">5. FTP的工作方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6"><span class="toc-number">6.4.</span> <span class="toc-text">电子邮件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%9A%84%E4%BF%A1%E6%81%AF%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.4.1.</span> <span class="toc-text">电子邮件的信息格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84"><span class="toc-number">6.4.2.</span> <span class="toc-text">电子邮件系统的组成结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.4.3.</span> <span class="toc-text">电子邮件协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SMTP%E5%8D%8F%E8%AE%AE"><span class="toc-number">6.4.3.1.</span> <span class="toc-text">SMTP协议</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/10a45d8c.html" title="关于一阶线性微分方程绝对值问题">关于一阶线性微分方程绝对值问题</a><time datetime="2023-09-02T17:58:00.000Z" title="发表于 2023-09-02 17:58:00">2023-09-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/df063bf9.html" title="线代强化">线代强化</a><time datetime="2023-08-24T10:41:00.000Z" title="发表于 2023-08-24 10:41:00">2023-08-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined/11e6645a.html" title="数据结构打卡">数据结构打卡</a><time datetime="2023-08-24T00:09:00.000Z" title="发表于 2023-08-24 00:09:00">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/undefined/d04bd5bc.html" title="操作系统"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171023019.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="操作系统"></a><div class="content"><a class="title" href="/undefined/d04bd5bc.html" title="操作系统">操作系统</a><time datetime="2023-08-17T10:19:00.000Z" title="发表于 2023-08-17 10:19:00">2023-08-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/undefined/c037e1e7.html" title="高数严选题"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="高数严选题"></a><div class="content"><a class="title" href="/undefined/c037e1e7.html" title="高数严选题">高数严选题</a><time datetime="2023-07-20T10:44:00.000Z" title="发表于 2023-07-20 10:44:00">2023-07-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 风起之时</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"><span id="percent">0<span>%</span></span></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script defer data-pjax src="/js/readPercent.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div class="app-refresh" id="app-refresh" style="position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease"><div class="app-refresh-wrap" style="display:flex;color:#fff;height:100%;align-items:center;justify-content:center"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color:#fff;text-decoration:underline;cursor:pointer">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#3b70fc' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><script data-pjax>function butterfly_footer_beautify_injector_config(){var A=document.getElementById("footer-wrap");console.log("已挂载butterfly_footer_beautify"),A.insertAdjacentHTML("beforeend",'<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.2.2" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" data-title="本站使用JsDelivr为静态资源提供CDN加速" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",flag=0,i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_footer_beautify_injector_config():epage===cpage&&butterfly_footer_beautify_injector_config()</script><script async src="/js/runtime/runtime.js"></script><script async src="/js/ali_font.js"></script><div class="js-pjax"><script async>for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration","2s"),arr[i].setAttribute("data-wow-delay","400ms"),arr[i].setAttribute("data-wow-offset","40"),arr[i].setAttribute("data-wow-iteration","1")</script><script async>for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay","200ms"),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("flink-list-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInRight"),arr[i].setAttribute("data-wow-duration","1.5s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async>for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__animated"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script></body></html>