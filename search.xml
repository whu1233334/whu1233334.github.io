<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高数严选题</title>
      <link href="/undefined/c037e1e7.html"/>
      <url>/undefined/c037e1e7.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png" alt="image.png"></p><h1 id="1-函数极限连续"><a href="#1-函数极限连续" class="headerlink" title="1.函数极限连续"></a>1.函数极限连续</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>开区间连续，两端点单侧极限存在，是函数有界的充分条件，而不是必要条件</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201100161.png" alt="image.png"></p><p><em>相乘的极限存在，不想代表，各自都有极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201114713.png" alt="image.png"></p><p><em>利用夹逼定理，单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201121973.png" alt="image.png"></p><p><em>极限要求趋向于0，但不等于0，没有说明φ(x)不等于0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201126863.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201131884.png" alt="image.png"></p><p><em>1.注意加减关系不能直接等价代换，等价代换实质上是一种精度不太高的泰勒展开(低阶展开)，当f(x)与g(x)存在加减关系时，例如这题是相加关系，如果f(x)与g(x)的低阶无穷小相互抵消(limf(x)/g(x)=-1),那么就需要比较高阶的无穷小；但是等价代换就没有高阶项，所以精度丢失- - -&gt;</em><br><em>2.拆成两项极限求和的前提是—&gt;两项极限都存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201145234.png" alt="image.png"></p><p><em>确定变上限积分函数，无穷小的阶数—&gt;N(M+1)原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201358107.png" alt="image.png"></p><p><em>1.当a=2,arctanx-sin2x可以分别等价代换，为什么？不是说加减不能等价代换吗？ —&gt;等价代换实质就是一次低阶泰勒展开，当展开之后，最低阶的无穷小两者不相等时，意味着相减，不会消去这个低阶无穷小，就不需要比较高阶无穷小，那么就可以直接等价代换 ；arctanx-sin2x ~ x-2x</em></p><p><em>2.当a=1时，arctanx-sinx不能分别等价为x-x，因为低阶无穷小项，互相消去，需要比较高阶无穷小，但是arctanx的泰勒展开不熟悉，只能通过arctanx-x~-1/3 x³  ,sinx-x~ -1/6 x³  ;</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201404411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201415098.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201424934.png" alt="image.png"></p><p><em>极限x-&gt;1不需要讨论1+,1-，因为极限保号性；同理x-&gt; -1; 但是x-&gt;0,时，考虑0+,0-,因为两侧正负不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201429124.png" alt="image.png"></p><p><em>最关键的还是，幂指函数指数化 来处理幂指函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201454848.png" alt="image.png"></p><p><em>考察了基本极限x^n ,e^nx</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201505101.png" alt="image.png"></p></blockquote><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>对于这种分母中含有两根号相减的，—&gt;1.是有理化  2.是拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201511419.png" alt="image.png"></p><p><em>考察知识点很综合<br>1.导数几何意义<br>2.基本极限求极限1^∞型<br>3.洛必达法则<br>4.变上限积分求导<br>5.导数的定义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201528282.png" alt="image.png"></p><p><em>ln(x+√1+x²) ~ x</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201543906.png" alt="image.png"></p><p><em>1.利用到了ln(x+√1+x²) ~ x,判断时1^∞型<br>2.写基本极限标准型lim (1+a(x))^β(x) =e^ a(x)β(x)</em><br><em>3.利用等价代换(1+a(x))^β(x) -1 ~ a(x)β(x) </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201549785.png" alt="image.png"></p><p><em>1.n项连乘 直接夹逼不出来，化为对数<br>2.关键再利用基本常用不等式<br>3.再夹逼</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201602526.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201607237.png" alt="image.png"></p></blockquote><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>0/0型</em><br><em>1)洛必达法则<br>2)等价无穷小代换<br>3)泰勒公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201614121.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201620034.png" alt="image.png"></p><p><em>1.第一眼看，我想用1^∞型极限，但是这里不能拆开求极限因为，右半部分的极限不存在，所以不能1^∞极限直接做<br>2.正确的做法是将幂指函数，化为指数，然后将整个分子，e^x -1 ~ x等价代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201708362.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201735817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201754350.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201801518.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201900306.png" alt="image.png"><br><em>用到拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201903837.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201909167.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915159.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915846.png" alt="image.png"></p><p><em>1.自平方项，前n项和，公式要记住<br>2.到底是选择夹逼，还是定积分定义，看每一项变化的那个地方，看是占大头(同量级，选择定积分定义)，还是小头(变化对分母整体量影响不大，用夹逼)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201920638.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201925221.png" alt="image.png"></p><p><em>分子变化部分相对于主体是次量级，用夹逼；分母变化部分相对于主体是同量级，用定积分定义</em><br><em>对分子放大—&gt;所有项分子=n+1/n;  缩小—&gt;所有项分子=n+1</em><br><em>对分母提出1/n，可爱因子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201932498.png" alt="image.png"></p><p><em>经典的找间断点，和类型题目</em><br><em>在求间断点的极限时，是否要分开考虑左右极限，是根据，左右会不会对函数正负性有影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201938018.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201944583.png" alt="image.png"></p><p><em>极限存在一般根据极限存在准则：<br>1.夹逼定理<br>2.单调有界准则<br>该题只需要证明极限存在，只需单调有界就可证明极限存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202046598.png" alt="image.png"></p><p><em>1.先看递推式函数是否单调增<br>2.函数单调增说明数列有单调性，再根据x1,x2判断数列单调增还是减<br>3.假设极限=A，根据递推式代入A求出A<br>5.再证明有界且界限=A</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202055627.png" alt="image.png"></p><p><em>1.先看递推式函数，是否单调增,如果单调减则数列没有单调性<br>2.接着没有单调性则，直接证明xn-√2的极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202103715.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202114022.png" alt="image.png"></p><p><em>零点定理—证明区间两端点异号，则区间内必有一点=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202123672.png" alt="image.png"></p><p><em>介值定理—函数值介于最大与最小之间，必有一点,f(β)=该值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202128724.png" alt="image.png"></p></blockquote><h1 id="2-一元函数微分"><a href="#2-一元函数微分" class="headerlink" title="2.一元函数微分"></a>2.一元函数微分</h1><h2 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>既要趋近于0，又要同时趋近0+,0-，才能判定该点导数存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231415896.png" alt="image.png"></p><p><em>考察连续的概念、导数的概念、导函数连续的概念</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231422649.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231431041.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231509976.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231525936.png" alt="image.png"></p><p><em>1.拆开求导。2.求得导数等于0的点，用二阶导数判定是极小还是极大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231553956.png" alt="image.png"></p><p><em>求得二阶导数=0，继续代入求三阶导数，看二阶导数是否单调，如果单调，那么该点就是拐点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231627232.png" alt="image.png"></p><p><em>求斜或水平渐近线，直接将原式改写，为y=ax+b形式，利用x-&gt;∞极限求出a,b</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231643077.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231648475.png" alt="image.png"></p></blockquote><h2 id="填空题-2"><a href="#填空题-2" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>不能用洛必达，没有一阶可导条件，并且数列不是函数，不连续</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231657600.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231701991.png" alt="image.png"></p><p><em>利用链导法，而不是将所有表达式求出来，再求导，那样太麻烦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231726425.png" alt="image.png"></p><p><em>反函数的导数，注意反函数是对y求导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231735491.png" alt="image.png"></p><p><em>高阶导数具体点导数—用泰勒展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232115462.png" alt="image.png"></p><p><em>求高阶导数—总结规律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232114368.png" alt="image.png"></p><p><em>根据罗尔定律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232121848.png" alt="image.png"></p><p><em>解一元三次方程=0，一般方法，凑1,2,3,4…整数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232146981.png" alt="image.png"></p></blockquote><h2 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232220253.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241057847.png" alt="image.png"></p><p><em>1.积分上限用变量代换<br>2.定积分定义求0点导数<br>3.求x-&gt;0，导数极限看是否=0点导数<br>4.运用到了积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241123900.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141774.png" alt="image.png"></p><p><em>这种参数方程求积分问题，要注意变换积分上下限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241347626.png" alt="image.png"></p><p><em>单中值—微分中值定理证明题，主要是微分中值定理的构造</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241611635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241626811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241829186.png" alt="image.png"></p><p><em>运用柯西定理、拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241854086.png" alt="image.png"></p><p><em>双中值—两中值点没有要求不同<br>分开两部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242018794.png" alt="image.png"></p><p><em>双中值—要求中值点不同<br>1.先将【0,1】段用c分开，假设存在一点c，使得…</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242027225.png" alt="image.png"></p><p><em>证明中值，含有高阶导数—泰勒展开，在给出信息最多的那一点展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242131657.png" alt="Uploading file...swyug"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242134232.png" alt="image.png"></p></blockquote><h1 id="3-一元函数积分学"><a href="#3-一元函数积分学" class="headerlink" title="3.一元函数积分学"></a>3.一元函数积分学</h1><h2 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>原函数是否存在判定<br>1.函数连续，一定存在原函数<br>2.函数有第一类间断点，就一定没有原函数（证明：通过原函数的定义或者导函数的介值定理，F(X)在a,b可导，则其导数在[a，b]内不会有第一类间断。）<br>3.有第二类间断点，可能有原函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242146129.png" alt="image.png"></p><p><em>直接判断导函数是否连续，如果有第一类间断点，那么原函数必定不可导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242237240.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251023049.png" alt="image.png"></p><p><em>积分区域相同，比较被积函数，被积函数大，积分就大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251028390.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251033971.png" alt="image.png"></p><p><em>旋转体体积问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251046107.png" alt="image.png"></p></blockquote><h2 id="填空题-3"><a href="#填空题-3" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>简单有理函数积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251137183.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251151287.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251249954.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251433037.png" alt="image.png"></p><p><em>对称区间，奇偶性判断</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251449741.png" alt="image.png"></p><p><em>1.取根号，要注意加绝对值，分区间计算<br>2.善用结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251458855.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251631501.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251642326.png" alt="image.png"></p><p><em>1.利用定积分定义，转化为定积分的计算<br>2.利用几何意义，想象为，一个半圆的面积的积分，直接求面积<br>3.也可以将x=sint，左变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251651125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251707587.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251718611.png" alt="image.png"></p><p><em>多项式分数，根式里面一次，一般变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251906680.png" alt="image.png"></p><p><em>根式含有平方项，三角代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251907971.png" alt="image.png"></p><p><em>边界曲线，用极坐标给出，求面积的问题<br>可以直接套公式，<br>任然还有问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251922342.png" alt="image.png"><br><em>对比着看</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261610407.png" alt="image.png"></p><p><em>运用弧长积分公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251926365.png" alt="image.png"></p><p><em>通过分部积分法，将f(x)写成导数计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252055735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252126968.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252153239.png" alt="image.png"></p></blockquote><h2 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261042264.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261116190.png" alt="image.png"></p><p><em>积分中值定理+介值定理+两次罗尔定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261131711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261205973.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261235506.png" alt="image.png"></p><p><em>方法1.利用介值定理，介于最大最小值之间</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261329751.png" alt="image.png"><br><em>方法2.利用构造辅助函数，常规方法，然后再说明有两个点，辅助函数值相等(罗尔定理)，就证明等式成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261334817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261400953.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261417494.png" alt="image.png"></p><p><em>难题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261443061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261446496.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261506664.png" alt="image.png"></p><p><em>长条中质心的积分计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261509020.png" alt="image.png"></p><p><em>典型，积分求旋转体体积</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261604721.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261607358.png" alt="image.png"></p></blockquote><h1 id="4-常微分方程"><a href="#4-常微分方程" class="headerlink" title="4.常微分方程"></a>4.常微分方程</h1><h2 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292225471.png" alt="image.png"></p><blockquote><p><em>直到三阶常系数齐次线性微分方程的特解，直接从特解中看出特征根，然后根据特征根写出特征方程，即可</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292150830.png" alt="image.png"></p><p><em>非齐次解具有叠加性，可以拆开分析</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292154652.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292200338.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292214416.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线代</title>
      <link href="/undefined/43e039bd.html"/>
      <url>/undefined/43e039bd.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png" alt="image.png"></p><h1 id="01-行列式的定义与性质"><a href="#01-行列式的定义与性质" class="headerlink" title="01-行列式的定义与性质"></a>01-行列式的定义与性质</h1><h2 id="行列式背景"><a href="#行列式背景" class="headerlink" title="行列式背景"></a>行列式背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于一个二元方程组，每次都要求解就特别麻烦。</span><br><span class="line">为了更加快速的找到方程的解，人们寻找规律，发现解的通式如下</span><br><span class="line">但是通式难以记忆，所以将这种计算规律用行列式表示，规定行列式计算方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301231233.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301500559.png" alt="image.png"></p><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论:一个排列中任意的两个元素对换，排列的奇偶性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301509795.png" alt="image.png"></p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行列式是一个数</span><br><span class="line">行列式计算方法是：</span><br><span class="line">1.取数相乘: 取n个不同行不同列的数 相乘 --&gt; 所以n!种取法，就有n!项</span><br><span class="line">2.冠以符号: 每一项(n个数相乘),将里面的元素，按列排好，然后数 列序号的逆序数τ，</span><br><span class="line">-(1)^τ</span><br><span class="line">3.全部相加: 将所有项n!项相加   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301521315.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按照行列式定义，因为行列式的每一项都是有不同行不同列的n个数相乘</span><br><span class="line">假如取1行1列的数--&gt;x</span><br><span class="line">那么画个十字线，十字线上的数都不能再取</span><br><span class="line">题目要求行列式结果中x^3的系数</span><br><span class="line"></span><br><span class="line">排除法:</span><br><span class="line">假如先取1，画十字线，发现其他行最多只能取到两个x，构不成x^3</span><br><span class="line">假如先取2，同理不行</span><br><span class="line">所以只能取x或x+3</span><br><span class="line"> 取x+3,只有一种情况，可行</span><br><span class="line"> 取x,第二行只能取x,第三行只能取x,第四行只能取x，那么x^4不符合。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301535080.png" alt="image.png"></p><blockquote><p>重要的特殊行列式</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt="image.png"></p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a><em>转置</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301557471.png" alt="image.png"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><em>交换</em></h3><p><strong>交换一行实际上是对每一项的逆序数发生改变，导致全部项的正负性改变</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301600178.png" alt="image.png"></p><h3 id="倍乘"><a href="#倍乘" class="headerlink" title="倍乘"></a><em>倍乘</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301619501.png" alt="image.png"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a><em>拆分</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301620199.png" alt="image.png"></p><blockquote><p><em>倍加</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301623438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301627820.png" alt="image.png"></p><hr><h1 id="02-行列式的计算与代数余子式"><a href="#02-行列式的计算与代数余子式" class="headerlink" title="02-行列式的计算与代数余子式"></a>02-行列式的计算与代数余子式</h1><h2 id="分块矩阵的行列式计算"><a href="#分块矩阵的行列式计算" class="headerlink" title="分块矩阵的行列式计算"></a>分块矩阵的行列式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301645404.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301654171.png" alt="image.png"></p><h2 id="行列式按行-列-展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h2><h3 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">余子式M 是特殊的情况，恰好第一行第一个数不是0,该行其余都是0,行列式的值=a11xM11。</span><br><span class="line">代数余子式A是讨论,不是特殊情况时，要考虑符号问题。</span><br><span class="line">就是不断的交换将aij逐行逐列的移到第一个的位置(交换一次改变一次正负号),aij列需要j次</span><br><span class="line">交换，行需要i次交换。所以符号-(1)^i+j x Mij = Aij </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301724746.png" alt="image.png"></p><blockquote><p><em>“么”型通法，按横展开</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301750483.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302120137.png" alt="Uploading file...havyy"></p><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302138234.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302217822.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302141433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302143275.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302148080.png" alt="image.png"></p><h2 id="范德门行列式"><a href="#范德门行列式" class="headerlink" title="范德门行列式"></a>范德门行列式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像这种第一行(或列)是1，第二行(列)是x1,x2..xn;第三行(列)是x1^2,x2^2..xn^2;...第n行(列)是...</span><br><span class="line">这种形式的就是范德蒙行列式，它的值有如下规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302222870.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.加边法</span><br><span class="line">与范德蒙行列式相似的，可以加边使其成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302228111.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.提公因子</span><br><span class="line">每一行提一个公因子，使得第一列的全为1，成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302230815.png" alt="image.png"></p><hr><h1 id="03矩阵及其运算"><a href="#03矩阵及其运算" class="headerlink" title="03矩阵及其运算"></a>03矩阵及其运算</h1><h2 id="矩阵及分块的概念"><a href="#矩阵及分块的概念" class="headerlink" title="矩阵及分块的概念"></a>矩阵及分块的概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矩阵的提出主要源自于数学中的三个问题:</span><br><span class="line">1.线性变换:用于表示未知数的变换关系</span><br><span class="line">2.线性方程组:用于表示方程组各个未知数的系数</span><br><span class="line">3.二次型:方便表示二次型，x^2,y^2,xy,出现的个数</span><br></pre></td></tr></table></figure><blockquote><p><em>数表来源</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302253439.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302255227.png" alt="image.png"></p><blockquote><p><em>特殊矩阵及分块矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302314484.png" alt="image.png"></p><h2 id="矩阵及分块矩阵的计算"><a href="#矩阵及分块矩阵的计算" class="headerlink" title="矩阵及分块矩阵的计算"></a>矩阵及分块矩阵的计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">矩阵加减法要求</span><br><span class="line">1.同型矩阵，m,n相同</span><br><span class="line">2.对应每个元素相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302321222.png" alt="image.png"></p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302346561.png" alt="image.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵乘法，实质是将由x-&gt;y的线性变换通过y-&gt;z的变化 转到x-&gt;z的线性变换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302349135.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011521217.png" alt="image.png"></p><hr><blockquote><p><em>对角矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011524350.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011527225.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵练习</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排列与组合区别在于，组合不要求内部顺序，所以要除以顺序个数</span><br><span class="line"></span><br><span class="line">将A矩阵拆分为--&gt; 单位E矩阵 + “坍缩矩阵”B </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011532335.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011534905.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011535161.png" alt="image.png"></p><blockquote><p><em>成比例矩阵的幂</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每行成比例的矩阵，可以写为如下</span><br><span class="line">成比例矩阵n次幂就可以拆为如下</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011559846.png" alt="image.png"></p><blockquote><p><em>与伴随矩阵相乘</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AxA* --&gt; 乘错行导致只有对应行的与其对应的代数余子式相乘结果才为|A|--&gt;也就是只有对角线上是|A| </span><br><span class="line"></span><br><span class="line">为什么代数余子式，乘错行会=0？ </span><br><span class="line">因为,乘错行，可以看做求一个具有两行相元素的行列式的值--&gt;两行相同元素的行列式=0</span><br><span class="line"></span><br><span class="line">为什么两行相同元素的行列式值是0?</span><br><span class="line">因为，利用交换一次行,矩阵正负性改变,两行相同交换后不变，但正负性改变，那么只能是0</span><br><span class="line"></span><br><span class="line">为什么交换两行元素，矩阵正负性要改变?</span><br><span class="line">因为，交换两行之后，导致每一项列排序发生一次交换--&gt;逆序数奇偶性变化--&gt;正负性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011615201.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011741250.png" alt="image.png"></p><hr><h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011730342.png" alt="image.png"></p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743537.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743180.png" alt="image.png"></p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵定义"><a href="#逆矩阵定义" class="headerlink" title="逆矩阵定义"></a><em>逆矩阵定义</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011859511.png" alt="image.png"></p><h3 id="逆矩阵充要条件"><a href="#逆矩阵充要条件" class="headerlink" title="逆矩阵充要条件"></a><em>逆矩阵充要条件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011901315.png" alt="image.png"></p><blockquote><p><em>原矩阵行列式=0 =&gt;伴随矩阵行列式=0</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011907635.png" alt="image.png"></p><blockquote><p><em>求二阶矩阵的逆矩阵方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011939266.png" alt="image.png"></p><blockquote><p><em>分块矩阵求逆矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011948103.png" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012256386.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求可对角化的矩阵的幂--&gt;先将矩阵写为下列形式，然后相乘，中间可以相互抵消为E(单位矩阵)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012257657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012300822.png" alt="image.png"></p><h2 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012305438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012312191.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012314168.png" alt="image.png"></p><hr><h1 id="04初等变换与初等矩阵"><a href="#04初等变换与初等矩阵" class="headerlink" title="04初等变换与初等矩阵"></a>04初等变换与初等矩阵</h1><h2 id="初等变换、矩阵的行阶梯、行最简、标准形"><a href="#初等变换、矩阵的行阶梯、行最简、标准形" class="headerlink" title="初等变换、矩阵的行阶梯、行最简、标准形"></a>初等变换、矩阵的行阶梯、行最简、标准形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">化为行阶梯型矩阵--&gt;自上而下化简</span><br><span class="line">化为最简型矩阵--&gt;自下而上化简</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012324531.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">矩阵A只进行行变换到B,称A与B 行等价</span><br><span class="line">矩阵A只进行列变换到B,称A与B 列等价</span><br><span class="line">如果即行又列，称A与B 等价 </span><br><span class="line"></span><br><span class="line">不管行等价，列等价，等价 --&gt;其秩都相等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012335843.png" alt="image.png"></p><h2 id="初等矩阵的定义性质"><a href="#初等矩阵的定义性质" class="headerlink" title="初等矩阵的定义性质"></a>初等矩阵的定义性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初等矩阵可以传递三种操作:</span><br><span class="line">1.交换: 左行右列 Eij --&gt;交换第i、j行(列)</span><br><span class="line">2.倍乘: 左行右列 Ei(k) --&gt; 第i行(列) 乘k倍</span><br><span class="line">3.倍加: 左行由列 Eij(k) --&gt; (左)将第i行加上j行的k倍;(右)将第j列加上第i行的k倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012358129.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307020005020.png" alt="image.png"></p><h2 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031442490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031446780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031452285.png" alt="image.png"></p><h2 id="可逆矩阵都可初等变换化为单位阵"><a href="#可逆矩阵都可初等变换化为单位阵" class="headerlink" title="可逆矩阵都可初等变换化为单位阵"></a>可逆矩阵都可初等变换化为单位阵</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031514917.png" alt="image.png"></p><h2 id="初等变换求逆矩阵-解可逆矩阵方程"><a href="#初等变换求逆矩阵-解可逆矩阵方程" class="headerlink" title="初等变换求逆矩阵-解可逆矩阵方程"></a>初等变换求逆矩阵-解可逆矩阵方程</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031520619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.A逆在左，行变换，所以可逆矩阵方程A,B要行摆放</span><br><span class="line">2.A逆在右，列变换，所以可逆矩阵方程A,B要列摆放</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031537723.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031547781.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031553549.png" alt="image.png"></p><hr><h1 id="05-矩阵的秩与线性方程组"><a href="#05-矩阵的秩与线性方程组" class="headerlink" title="05-矩阵的秩与线性方程组"></a>05-矩阵的秩与线性方程组</h1><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="矩阵的秩的定义"><a href="#矩阵的秩的定义" class="headerlink" title="矩阵的秩的定义"></a>矩阵的秩的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初等变换不会改变秩的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031709329.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031717376.png" alt="image.png"></p><h3 id="行阶形求秩"><a href="#行阶形求秩" class="headerlink" title="行阶形求秩"></a>行阶形求秩</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031713196.png" alt="image.png"></p><h3 id="秩的结论"><a href="#秩的结论" class="headerlink" title="秩的结论"></a>秩的结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.矩阵的秩不会超过行数也不会超过列数，因为逆矩阵的秩就是阶梯个数，阶梯怎么画都不会   超过行和列</span><br><span class="line">2.转置矩阵的秩不变很好理解</span><br><span class="line">3.等价的矩阵秩一定相等--&gt;等价的矩阵实际就是在一个矩阵基础上经过若干初等变换得到的   两个矩阵，初等变换不会影响秩的大小</span><br><span class="line">4.P,Q可逆--&gt;P,Q是若干初等矩阵的乘积--&gt;相当于对A经过若干初等行变换+列变换--&gt;秩不变</span><br><span class="line">5.(A,B)矩阵的秩R(A,B)min/max --&gt; A,B都化为标准型之后，看斜对角线</span><br><span class="line">6.矩阵相加的秩，化标准型理解</span><br><span class="line">7.矩阵相乘的秩，化标准型理解(特殊:矩阵与其转置矩阵相乘，秩不变)</span><br><span class="line">8.两矩阵相乘为0矩阵--&gt;标准型中1刚好错开，那么R(A)+R(B)&lt;=n</span><br><span class="line">9....</span><br><span class="line">10....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031725785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031745903.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031749579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031751055.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031755979.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.R(Amxn) =n --&gt;列满秩 ;所以A的标准型是上面E,下面O ; --&gt; 标准型左边乘以可逆矩阵P(等效为若干初等变换) 得到A --&gt; A标准型=PA ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031800370.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031819833.png" alt="image.png"></p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><h3 id="解的判定"><a href="#解的判定" class="headerlink" title="解的判定"></a>解的判定</h3><blockquote><p><em>齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031839448.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031838230.png" alt="image.png"></p><hr><blockquote><p><em>非齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031850780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031852539.png" alt="image.png"></p><h3 id="具体方程组的求解"><a href="#具体方程组的求解" class="headerlink" title="具体方程组的求解"></a>具体方程组的求解</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031859530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031900387.png" alt="image.png"></p><h1 id="06-向量组的线性相关性"><a href="#06-向量组的线性相关性" class="headerlink" title="06-向量组的线性相关性"></a>06-向量组的线性相关性</h1><h2 id="向量及向量空间"><a href="#向量及向量空间" class="headerlink" title="向量及向量空间"></a>向量及向量空间</h2>]]></content>
      
      
      <categories>
          
          <category> 线代 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘不限速下载</title>
      <link href="/undefined/d1267184.html"/>
      <url>/undefined/d1267184.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png" alt="image_2022-11-16_11-48-14.png"></p><h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181136945.png" alt="image.png"></p><h2 id="打开解析网站"><a href="#打开解析网站" class="headerlink" title="打开解析网站"></a>打开解析网站</h2><p><a href="https://pan.qsbaidu.com/">点击跳转解析网站</a>（<a href="https://pan.qsbaidu.com/）。">https://pan.qsbaidu.com/）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181139806.png" alt="image.png"></p><p>点击解析分享链接后跳转该界面，点击下载按钮。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181141184.png" alt="image.png"></p><p>之后跳转该界面，推荐使用NDM下载器下载。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181142387.png" alt="image.png"></p><h2 id="NDM下载及配置"><a href="#NDM下载及配置" class="headerlink" title="NDM下载及配置"></a>NDM下载及配置</h2><p>1.官网<a href="http://www.neatdownloadmanager.com/index.php/en/">下载链接</a>（<a href="http://www.neatdownloadmanager.com/index.php/en/）">http://www.neatdownloadmanager.com/index.php/en/）</a></p><ol><li>初次使用要先配置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181147528.png" alt="image.png"></li></ol><p>3.复制上述用户代理名，打开NDM点击设置，将用户代理名填入默认用户代理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181148592.png" alt="image.png"></p><p>4.配置好后，点击新建，将之前的下载链接复制粘贴下载即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181150249.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 百度网盘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈为什么从高地址往低地址分配内存</title>
      <link href="/undefined/e44ea15d.html"/>
      <url>/undefined/e44ea15d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png" alt="image.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？</p><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>程序计数器(<code>Program Counter</code>，简称<code>PC</code>)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。</p><p>因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；</p><p>heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142320352.png" alt="image.png"></p><hr><h2 id="栈由高地址向低地址扩展的优点"><a href="#栈由高地址向低地址扩展的优点" class="headerlink" title="栈由高地址向低地址扩展的优点"></a>栈由高地址向低地址扩展的优点</h2><p><code>stack</code>从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142351623.png" alt="image.png"></p><p>并且<strong>这样设计可以使得堆和栈能够充分利用空闲的地址空间。</strong>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化</p><hr><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：x86，MIPS</li><li>主流2：自由选择：Arm（但个别指令仅支持向低）</li><li>罕见：向高地址扩展：PA-RISC，操作系统Multics</li><li>非主流：System z，栈是个链表[2]</li></ul><hr><h2 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h2><p><strong>1.栈内内存是连续分配</strong></p><pre><code>因位栈空间内存分配连续，如果给一个数组或对象分配内存，栈会优先选择还没有分配的最小的内存地址给数组，数组中的地址是从低地址到高地址依次分配。所以数组的第一个元素的起始地址就是给数组分配的最低地址</code></pre><p><strong>2.栈的栈顶指针ESP默认指向栈顶</strong></p><pre><code>对数组的访问一般都是对一个数组的起始地址进行操作，也就是说我们需要的是数组的起始地址-&gt;也就是低地址，由于栈顶指针默认指向的是栈顶元素，那么只能是栈顶指针指向低地址值--&gt;这样便于对数组的访问。如果栈还是采用从低地址到高地址的扩展，那么就不会默认指向数组的起始地址(数组指针)，不便于访问。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTaX语言</title>
      <link href="/undefined/31c326ac.html"/>
      <url>/undefined/31c326ac.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png" alt="image.png"></p><p><code>1.求和表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;n=0&#125;^&#123;\infty&#125;n$$</span><br><span class="line"></span><br><span class="line">其中，\sum表示求和符号，n表示要累加的变量，0表示起始索引，\infty表示末尾索引。所以，上述表达式表示了从0开始到正无穷的所有整数之和。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}n</script><hr><p><code>2.积分表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\int_&#123;-\pi&#125;^&#123;\pi&#125;f(x)dx$$</span><br><span class="line"></span><br><span class="line">其中，$\int$ 表示积分符号，$f(x)$ 表示要积分的函数，$dx$ 表示积分的变量（即积分变量），$-\pi$ 和 $\pi$ 分别表示积分的下限和上限。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(x)dx</script><hr><p><code>3.分式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;a&#125;&#123;b&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$a$ 表示分子，$b$ 表示分母。它表示了 $a$ 与 $b$ 之间的比率关系，也可以理解为 $a$ 中包含了 $b$ 的多少倍。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\frac{a}{b}</script><hr><p><code>4.下标</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$a_i$$</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$$x_&#123;i,j&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$i$ 和 $j$ 是变量的下标，它们用于表示该变量的某个特定元素。在第一个例子中，$a$ 中的 $i$ 表示 $a$ 数组中的第 $i$ 个元素；在第二个例子中，$x$ 中的 $i$ 和 $j$ 分别表示一个二维数组 $x$ 中的第 $i$ 行第 $j$ 列的元素。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">a_i</script><script type="math/tex; mode=display">x_{i,j}</script><hr><p><code>5.向量</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$\vec&#123;v&#125;$ 表示向量，“$$\begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$” 表示以列的形式表示的向量，$v_1$、$v_2$、$\ldots$、$v_n$ 是向量中的元素。如果向量是一个二维向量，那么它还可以写成如下形式：</span><br><span class="line"></span><br><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; x \\ y \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$x$ 和 $y$ 分别是二维向量 $\vec&#123;v&#125;$ 的 $x$ 和 $y$ 分量</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n\end{pmatrix}</script><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}</script><hr><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号``，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\&#123; \&#125;</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum<em>{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A</em>{k<em>0}A</em>{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li><li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li><li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> LaTax </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多地址指令实际访存次数</title>
      <link href="/undefined/7566551b.html"/>
      <url>/undefined/7566551b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png" alt="image.png"></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>english</title>
      <link href="/undefined/2c830200.html"/>
      <url>/undefined/2c830200.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png" alt="image.png"></p><h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a><strong>定语</strong></h2><p><em>hypocritical虚伪的、spectacle壮观的场面、intense激烈的、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a><strong>状语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a><strong>同位语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a><strong>插入语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p><h1 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conmence 毕业典礼、开始</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162327530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162328895.png" alt="image.png"></p><h2 id="句子之间的连接方式"><a href="#句子之间的连接方式" class="headerlink" title="句子之间的连接方式"></a>句子之间的连接方式</h2><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162329883.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162349412.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306170009789.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162352377.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162354284.png" alt="image.png"></p><h3 id="主从复合句"><a href="#主从复合句" class="headerlink" title="主从复合句"></a>主从复合句</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207495.png" alt="image.png"></p><h4 id="状语从句-副词性从句"><a href="#状语从句-副词性从句" class="headerlink" title="状语从句(副词性从句)"></a>状语从句(副词性从句)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207245.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181217682.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.It doesn&#x27;t feel like a human or democratic relationship,even if both sides</span><br><span class="line">benefit.</span><br><span class="line">即使双方都受益，也不是人与人之间平等的关系</span><br><span class="line"></span><br><span class="line">2.As the cost to everyone else has become clearer,politicians have begun to</span><br><span class="line">clamp down.</span><br><span class="line">因为每个人所承受的代价变得显而易见了，政客们已经开始施压了</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181225896.png" alt="image.png"></p><h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><h5 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">That the seas are being over fished has been known for years--&gt;主语从句</span><br><span class="line"></span><br><span class="line">--&gt;一般会改写为形式主语--&gt; it has been knows for years that...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181304536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181305134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181306845.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181312445.png" alt="image.png"></p><h5 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181441584.png" alt="image.png"></p><h5 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181444199.png" alt="image.png"></p><h5 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181449900.png" alt="image.png"></p><h5 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181601408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181608655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181612050.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181613273.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181619664.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181620104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181625756.png" alt="image.png"></p><h1 id="层次化阅读和主干隔离"><a href="#层次化阅读和主干隔离" class="headerlink" title="层次化阅读和主干隔离"></a>层次化阅读和主干隔离</h1><h2 id="层次化阅读法"><a href="#层次化阅读法" class="headerlink" title="层次化阅读法"></a>层次化阅读法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052224384.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042239593.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042240478.png" alt="image.png"></p><p><em>substance 物质  、clinical nutirtion 临床营养学 、utilize 利用 、distinct 明显的、essential 必要的 、agent 介质、constituent 组成部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042245516.png" alt="image.png"></p><h2 id="主干隔离法"><a href="#主干隔离法" class="headerlink" title="主干隔离法"></a>主干隔离法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052225973.png" alt="image.png"></p><blockquote><p><em>将主语与谓语连在一起读，中间部分调整语序</em></p></blockquote><p>*artisans 工匠、artists 艺术家、machanic 技工、establishment 机构、组织</p><p>The notion - 这个观念、这个想法</p><p>that learning should have in it an element of inspired play - 观念认为学习应该融入受启发的游戏元素</p><p>would seem - 似乎</p><p>to the greater part of the academic establishment - 对大部分有学术性的机构或组织(如学校、大学等)</p><p>merely silly - 只是一个愚蠢的想法*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052227844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052229938.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052236404.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052237748.png" alt="image.png"></p><h1 id="非谓语动词和独立主格结构"><a href="#非谓语动词和独立主格结构" class="headerlink" title="非谓语动词和独立主格结构"></a>非谓语动词和独立主格结构</h1><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060933764.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060942180.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060946157.png" alt="image.png"></p><h2 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h2><p><em>带有主语的非谓语动词</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060953217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060956043.png" alt="image.png"><br><em>Media 媒体 、epidemic 流行病、cigarette 香烟、liken 比作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061003195.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061007239.png" alt="image.png"></p><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061012037.png" alt="image.png"></p><blockquote><p><em>部分倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061019182.png" alt="image.png"></p><blockquote><p><em>完全倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061023671.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061046014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061049074.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061050328.png" alt="image.png"></p><h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061056945.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061107064.png" alt="image.png"></p><p><em>individual 个体 、maximaize 最大化、profits利润、coupled with 以及(相等于and)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061121649.png" alt="image.png"></p><h1 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061131321.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061130607.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061140766.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061141718.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061142254.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061148829.png" alt="image.png"></p><h1 id="实战解析"><a href="#实战解析" class="headerlink" title="实战解析"></a>实战解析</h1><p><em>cognitive认知 、caregiver看护者</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061158889.png" alt="image.png"></p><p><em>imposter 冒牌者   、file(ing) cabinet  文件柜、 fraught 充满 、reconcile 调和、和解 、<br>designate 指定、指派(职务)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071032339.png" alt="image.png"></p><p><em>overwhelming 巨大到无法应付的。指某事物之多、之严重以至于无法有效应对。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071556623.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071614505.png" alt="image.png"></p><p><em>Come to a halt的含义是停止;停顿下来。<br>它表示某物停止了运动或工作。强调运动或行为的终止。<br>例句:<br>The car came to a sudden halt.<br>那辆车突然停了下来 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071621176.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071625167.png" alt="image.png"></p><p><em>quantum computers 量子计算机 、crack 破解、encryption加密</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071639372.png" alt="image.png"></p><p><em>mutually 互相、composed of 由..组成  、composed 镇定的，有条理的、simulate模拟<br>interactions 相互影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071727387.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071728023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071804873.png" alt="image.png"></p><hr><blockquote><p>!!!</p></blockquote><p>proportion 的意思是:</p><p>比例,部分,成比例</p><ol><li>proportion 指在整体中所占的百分比或比例。例如:</li></ol><ul><li><p>What proportion of your income do you spend on rent? 你的收入中有多大比例用于支付房租?</p></li><li><p>Only a small proportion of applicants are admitted to this school. 只有一小部分申请者能被这所学校录取。</p></li></ul><ol><li>proportion 也可以表示一个量与另一个量之间的比较关系,指成比例。例如:</li></ol><ul><li><p>Mix the ingredients in the proper proportion. 按正确的比例混合这些材料。</p></li><li><p>The model was built in exact proportion to the original building. 这个模型按原建筑的精确比例建造的。</p></li></ul><ol><li>proportion 还可以指大小、范围或重要性的程度。例如:</li></ol><ul><li><p>The cost overrun was of massive proportion. 造价超支的规模巨大。</p></li><li><p>An issue of such proportion requires careful thought. 这么重大的问题需要慎重考虑。</p></li></ul><p><strong>literacy 的意思是:</strong></p><p>识字能力,读写能力</p><p>literacy 指一个人阅读和写作的基本能力,特别是在 mother tongue(母语)中的读写能力。</p><p>一些关于literacy的例子:</p><ul><li><p>Improving literacy is a priority, as it helps break the cycle of poverty. 提高识字率是优先事项,这有助于打破贫困循环。</p></li><li><p>The government has launched a campaign to boost literacy among adults. 政府启动了一个运动来提高成人的读写能力。</p></li><li><p>Children’s literacy skills develop through reading books and stories. 儿童的读写能力通过读书和故事得到发展。</p></li><li><p>Digital literacy is increasingly important in the internet age. 在互联网时代,数字读写能力越来越重要。</p></li><li><p>Functional literacy refers to the basic skills needed to function in society. 功能性识字能力是指一个人在社会中基本需求的读写能力。</p></li></ul><p><em>institution 机构、制度、组织  ， soild 坚固的、扎实的、牢固的，souvenir 纪念品<br>quill 鹅毛笔</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091525945.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>fitigue 的意思是疲劳,疲惫。</p><p>它是一个来自法语的英语词汇,常见的用法有:</p><ol><li><p>身体上的疲劳,疲惫 例句:After a long run, I felt fatigue in my legs. 长时间跑步后,我腿感到了疲劳。</p></li><li><p>精神上的疲惫 例句:Mental fatigue built up after hours of study. 坐了几个小时后精神上感到了疲惫。</p></li><li><p>金属疲劳 例句:The metal wing suffered fatigue after many flights. 金属机翼在多次飞行后出现了金属疲劳。</p></li><li><p>造成疲劳的因素或过程 例句:Sleep deprivation leads to increased fatigue. 睡眠不足会导致疲劳加剧。</p></li></ol><p>poll 有以下几层常见意思:</p><ol><li>民意调查;选举投票</li></ol><p>例句:The latest polls show he has a slim lead over his opponent. 最新民调显示他比对手略占优势。</p><ol><li>票数;票汇总</li></ol><p>例句:After the polls closed, vote counting began immediately. 在投票结束后,票票汇总工作立即开始。</p><ol><li>投票站;选区</li></ol><p>例句:There were long lines at the polls this morning. 今天早晨投票站前有长长的队伍。</p><ol><li>票选,投票</li></ol><p>例句:About 60% of voters polled today. 大约有60%的选民今天参与了投票。</p><ol><li>统计,调查</li></ol><p>例句:Let’s take a poll of everyone’s opinion on this matter. 让我们统计一下每个人对这个问题的看法。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152210940.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217622.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217842.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>acknowledge 的意思是:</p><ol><li>承认,认可</li></ol><p>例句:He acknowledged that he had made a mistake. 他承认了自己犯了一个错误。</p><ol><li>感谢,表达谢意</li></ol><p>例句:I acknowledge all the staff for their hard work. 我对全体员工的辛勤工作表示感谢。</p><ol><li>回复,对…作出响应</li></ol><p>例句:She acknowledged my email with a quick reply. 她很快回复了我的电子邮件。</p><ol><li>收到,收悉</li></ol><p>例句:Please acknowledge receipt of this document. 收到此文件请回执。</p><p><em>cut adrift 被抛弃、sector行业，领域、self-critical自我批判、landlord房东</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152225925.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>dynamic 的常见意思有:</p><ol><li>动态的,不断变化的</li></ol><p>例句:a dynamic economy 动态变化的经济</p><ol><li>积极有活力的</li></ol><p>例句:a dynamic young leader 一个精力充沛的年轻领导者</p><ol><li>(音量)强弱变化的</li></ol><p>例句:the dynamic range of the music 音乐的动态范围</p><ol><li>(力学术语)动力学的</li></ol><p>例句:dynamic equilibrium 动态平衡</p><ol><li>动力的,与动力相关的</li></ol><p>例句:a dynamic microphone 动力麦克风</p><p>所以,dynamic的意思是“动态的、变化的”,强调不断变化和活力,与“static”相对。可以广泛地应用于许多领域</p><p><em>publishing industry出版行业</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161009103.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>casino 是赌场的意思。</p><p>例句:</p><ol><li><p>There are many large casinos in Las Vegas. 拉斯维加斯有许多大型赌场。</p></li><li><p>He lost a lot of money gambling in the casino. 他在赌场赌博损失了很多钱。</p></li><li><p>The new casino brought in tourism revenue for the city. 新的赌场为这座城市带来了旅游收入。</p></li><li><p>She always plays blackjack when she visits casinos. 她每次去赌场都会玩二十一点。</p></li><li><p>The casino was open 24 hours and full of slot machines. 这个赌场24小时营业,里面满是老虎机。</p></li></ol><p>综上所述,casino 代表赌场这个场所,里面有各种赌博游戏,例如扑克、轮盘、老虎机等。赌场主要为赌博提供场所,通常还有酒店、餐厅、商场等设施和娱乐活动。</p><hr><p>gambling 的意思是赌博、赌钱。</p><p>常见的词义包括:</p><ol><li><p>赌博活动 例句:Gambling is illegal in some countries. 在一些国家赌博是非法的。</p></li><li><p>赌钱 例句:Many people lose a lot of money through gambling. 很多人通过赌博损失了大量金钱。</p></li><li><p>冒险 例句:Changing jobs now would be a gamble. 现在换工作将是一次冒险。</p></li><li><p>对…抱有希望 例句:I’m gambling that the weather will be nice tomorrow. 我抱着明天天气会好的希望。</p></li><li><p>孜孜不倦地追求 例句:He is gambling for fame and reputation. 他孜孜不倦地追求名誉和声望。</p></li></ol><p>综上所述,gambling 意思是赌博、赌钱,通常涉及金钱的风险投机。延伸意思是冒险以及抱有希望。</p><hr><p>coasting on 意思是“依靠,利用(之前的成就或努力)”。</p><p>这是一个常见的英语习语,意思是指一个人或组织停止努力,而是依靠或利用过去的成就和努力来维持当前的状态或成功。</p><p>例句:</p><ol><li><p>After the company’s initial success, the CEO has just been coasting on its reputation rather than innovating. 在公司最初成功之后,CEO一直依靠其声誉,而不是创新。</p></li><li><p>The actor admitted to coasting on his previous roles and hasn’t taken up new challenges lately. 这位演员承认自己近期沿用老角色,没有接受新挑战。</p></li><li><p>The professor seems to be coasting on her book’s popularity rather than producing new research. 这位教授似乎依靠她书籍的畅销,而不是进一步研究。</p></li><li><p>Successful entrepreneurs cannot afford to coast on past achievements. 成功的企业家不能依赖过去的成就。</p></li></ol><p>综上所述,coasting on 意味着依靠过去努力的成果,而不是继续付出努力。通常有负面的含义,意味着一个人或组织变得自满和懒惰。</p><hr><p>pan out 是一个英语习语,意思是“结果变成,发展成”。</p><p>例句:</p><ol><li><p>His business idea didn’t pan out as he had hoped. 他的商业想法结果没有如他所愿。</p></li><li><p>We’re still waiting to see how this new project pans out. 我们仍在观望这个新项目的发展。</p></li><li><p>I don’t think this relationship is going to pan out after all. 我认为这段关系结果不会太理想。</p></li><li><p>If their date pans out, they might start a relationship. 如果他们的约会进展顺利,他们可能会开始一段关系。</p></li><li><p>His career as a musician never really panned out. 他作为音乐家的职业生涯结果并不成功。</p></li></ol><p>综上所述,pan out 意思是经过发展或等待结果后,事情的结果最后如何,是否成功或达到预期。也可以表示事情最终结果的好坏。</p><p><em>enormous revenues 意思是“巨大的收入”或“极高的营收”、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161019158.png" alt="image.png"><br><em>big advance 巨额预付金、preexisting先前存在的、frenzy狂热、疯狂失控</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161025712.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>contexts 是名词,复数形式,主要有以下几层含义:</p><ol><li>文章或谈话中的语言环境,提供理解词语或行为的额外信息。<br>例句:You can’t understand what he meant without looking at the wider context of the conversation. 如果不考虑谈话的更广泛语境,你就无法理解他的意思。</li><li>事件或行为发生的背景情况。<br>例句:In the context of high unemployment, the policy makes sense. 在高失业率的背景下,这项政策有意义。</li><li>程序运行或操作的环境。<br>例句:This function behaves differently depending on the software context. 这个功能的运行取决于软件环境的不同而有区别。</li><li>论证或思考的前提条件或框架。<br>例句:Examine the problem in the context of the limitations we face. 在我们面临的限制条件下审视这个问题。</li></ol><hr><p>constraining 的意思是“限制的、约束的”。它来源于动词constrain,意为“限制、抑制”。</p><p>constraining 作为形容词,常用于以下场合:</p><ol><li>限制行为或活动的规则或条件。</li></ol><p>例句:The new policy imposes constraining regulations on business. 新政策对企业施加了限制性规定。</p><ol><li>限制思维或创造力的框架或因素。</li></ol><p>例句:We need to think outside constraining traditional paradigms. 我们需要跳出限制思维的传统模式。</p><ol><li>限制行动或发展的不利环境或因素。</li></ol><p>例句:Poverty is a constraining factor that traps people in disadvantage. 贫穷是一个制约因素,让人们无法摆脱劣势。</p><ol><li>紧缚的、禁锢的衣物或配饰。</li></ol><p>例句:She refused to wear constraining clothes that restricted her movement. 她拒绝穿会限制行动的紧身衣服。</p><hr><p>pertaining 的意思是“关于”,“与…有关”。它是一个正式用语,通常用于描述某人或某事与特定主题、事件或情况有关。</p><p>例句:</p><ol><li><p>All documents pertaining to the legal case must be submitted to the court. 所有与此法律案件有关的文件都必须提交给法院。</p></li><li><p>The police asked questions pertaining to the accident. 警察问了一些关于这起事故的问题。</p></li><li><p>The manager sent a memo pertaining to the new company policy. 经理发了一则与新公司政策相关的备忘录。</p></li><li><p>The museum has a collection of artifacts pertaining to ancient Egypt. 博物馆有一个关于古埃及的藏品收集。</p></li><li><p>I need some advice pertaining to filing my taxes this year. 我需要一些建议,关于今年报税的事宜。</p></li></ol><hr><p>labor 的意思是“劳动,劳力”。它是一个常用词,主要有以下几层含义:</p><ol><li>工作,尤其是体力劳动。</li></ol><p>例句:Farming is hard labor. 农活是体力劳动。</p><ol><li>工人阶级,劳动者。</li></ol><p>例句:The new policy protects the rights of labor. 这项新政策保护劳动者的权益。</p><ol><li>分娩的努力和痛苦,即生产过程。</li></ol><p>例句:The mother was in labor for 10 hours. 这位母亲经历了10小时的分娩过程。</p><ol><li>工作结果,劳动成果。</li></ol><p>例句:The Pyramids are an amazing labor of ancient Egyptians. 金字塔是古埃及人惊人的劳动成果。</p><ol><li>具有特定功能的工作或任务。</li></ol><p>例句:Every part has its own labor in the workings of a machine. 在机器运转中,每个部件都有其特定的功能。</p><p><em>curtail 削弱、缩短、限制、 seek 寻找、pursue追求、 oppressive压迫的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161034961.png" alt="image.png"></p><p><em>vaccine 疫苗、corporate regulation企业监管、 labor劳工、劳动力、civil民事的、公民的 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161043329.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>extract 的意思是“提取;摘录”,是个常用词,主要有以下几层含义:</p><ol><li>从某物中提取或分离出某个成分、物质等。</li></ol><p>例句:extract oil from coal 从煤中提取油</p><ol><li>摘录,选取某文献中的段落或内容。</li></ol><p>例句:extract key passages from the book 从书中摘录主要段落</p><ol><li>获取、套取(信息等)。</li></ol><p>例句:extract a confession from him 从他那里套取口供</p><ol><li>引出,推断出(结论等)。</li></ol><p>例句:extract meaning from the data 从数据中推断出意义</p><ol><li>移去,拔出(牙齿等)。</li></ol><p>例句:The dentist extracted two teeth. 牙医拔除了两颗牙。</p><p>所以,extract 的基本意思是从某物中提取出某部分或物质;也可以指获取一些隐藏或不容易觉察的信息。</p><hr><p>vantage</p><ol><li>有利条件,优势。</li></ol><p>例句:a good vantage point to watch birds 观察鸟类的有利位置</p><ol><li>视野,视力范围。</li></ol><p>例句:Beyond my vantage, I could see the lake. 在我的视野范围之外,我可以看到湖泊。</p><ol><li>预见,预知。</li></ol><p>例句:He plans with vantage for the future. 他预见未来做计划。</p><ol><li>利益,好处。</li></ol><p>例句:I have no personal vantage in this. 这对我没有任何个人利益。</p><hr><p><em>scramble 的基本意思是匆忙或火急火燎的样子、crucial至关重要的、fossil fuels化石燃料、 tear up 撕碎的弄破的、plants植物、工厂、设备、 rural农村的、urban城市的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161330773.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331524.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>dwell 停留、居住、 atmosphere大气、气氛、环境、plain平坦的、平淡的、 dull迟钝的、无聊的·、 version版本 、notification通知、通告、storm风暴</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422007.png" alt="image.png"><br>￼<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422229.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>critics 评论家、 stand as is 保持原样、penguin企鹅</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432549.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432535.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>reframe 的意思是“重新塑造,重构”,reframe 是由前缀 re- (再次)和 frame(框架)组合而成的词。</p><p>reframe 作为动词,主要有以下含义:</p><ol><li>重新组织,调整结构或框架。</li></ol><p>例句:We need to reframe our business strategy. 我们需要重新组织我们的商业战略。</p><ol><li>以新的观点或角度重新审视。</li></ol><p>例句:Let’s reframe this issue in a more positive light. 让我们以更正面的视角来重新审视这个问题。</p><ol><li>重新描绘,重述。</li></ol><p>例句:He reframed his experiences more constructively. 他以更建设的方式重述了他的经历。</p><ol><li>调整态度,换种思维方式。</li></ol><p>例句:Reframing problems as opportunities. 将问题重塑为机遇。</p><p>所以,reframe 意思是把事情放在一个新的框架或视角中进行重新思考,以产生新的结构、见解或态度。</p><hr><p>spectrum 的意思是“范围, 光谱”。主要有以下几层含义:</p><ol><li>范围,系列,一系列邻接的事物。</li></ol><p>例句:There is a wide spectrum of opinions on the issue. 这个问题有广泛的观点范围。</p><ol><li>光谱,按波长顺序排列的电磁波颜色范围。</li></ol><p>例句:Sunlight contains all the wavelengths of the visible light spectrum. 阳光包含了可见光谱中所有的波长。</p><ol><li>分类,按顺序或级别排列的系统。</li></ol><p>例句:the whole political spectrum from left to right 政治光谱上的全部派别</p><ol><li>范围,多种选择或可能性。</li></ol><p>例句:We offer a spectrum of investment options. 我们提供一系列投资选择。</p><ol><li>范畴,领域。</li></ol><p>例句:The issue falls outside the spectrum of this committee. 这个问题超出了委员会的范畴。</p><p><em>beaming面带灿烂笑容、scrolling 滚动、浏览</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161442818.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>physician 的意思是“医生”,尤其是指正式的医学执业医师。</p><p>一些关键点:</p><ol><li><p>physician 指经过长时间医学训练和执业资格认证的医生。</p></li><li><p>它与 doctor 的含义基本相同,但physician 表示更专业和正式的医生身份。</p></li><li><p>physician 通常需要接受8年以上的医学院教育和临床实习。</p></li><li><p>主治医生(attending physician)和内科医生(physician)是两种常见的physician。</p></li><li><p>physician可以自主开业,也可以在医院、诊所、学术机构等工作。</p></li><li><p>与physician对应的是医疗助理职业,如护士、技师等。</p></li><li><p>按专业领域又可细分为儿科医生、外科医生、心理医生等。</p></li><li><p>口语中更常用doctor,但是正式场合仍使用physician。</p></li></ol><p>所以,physician指经过系统医学训练和考核,获得医生资格并执业的医疗专业人士。是医疗保健领域的核心职业之一。</p><hr><p>procedures 的意思是“程序;步骤”,表示完成某项工作或任务所需遵循的一系列步骤或流程。</p><p>些关键点:</p><ol><li><p>procedure 强调按照规定的顺序和方法来进行。</p></li><li><p>医疗程序(medical procedures)指进行疾病治疗或身体检查的标准步骤。</p></li><li><p>行政程序(administrative procedures)指在政府、公司或组织内部的官方工作流程。</p></li><li><p>程序也可以是规范某项活动的准则或方针。</p></li><li><p>程序的目的是提高工作效率、减少错误。</p></li><li><p>遵守程序意味着按照特定顺序执行每一步。</p></li><li><p>程序可能需要书面文档,以方便培训和规范操作。</p></li><li><p>如果情况失控,也可主动终止程序。</p></li><li><p>相比过程(process),程序更加规范化和固定化</p></li></ol><hr><p>strain 的意思有以下几个:</p><ol><li>拉、绷紧</li></ol><p>例句:Strain the rope tightly. 把绳子用力拉紧。</p><ol><li>扭伤;拉伤</li></ol><p>例句:I strained my back lifting those heavy boxes. 我搬动那些重箱子时扭伤了背。</p><ol><li>过度使用;损伤</li></ol><p>例句:Don’t strain your eyes watching TV in the dark. 别在暗处看电视伤眼睛。</p><ol><li>压力;负荷过重</li></ol><p>例句:The recent difficulties have put a strain on their relationship. 近来的困难给他们的关系造成了压力。</p><ol><li>过滤;过滤掉</li></ol><p>例句:Strain the noodles and run them under cold water.过滤面条并在冷水下冲洗。</p><ol><li>费力;竭力</li></ol><p>例句:She strained to hear what they were saying. 她竭力去听他们在说什么。</p><ol><li>(微生物的)菌株</li></ol><p><em>physicians 执业医师、procedures程序步骤、squeeze积压、挤出、incentivize激励</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161454669.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>are only as good as  ..的好坏取决于..  、precisely精确地· 正是、 metabolism新陈代谢<br>commerical 商业的、贸易的、盈利性质的  、variables变量   、dizzying令人头晕目眩的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161530860.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161541216.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>critical 的意思有以下几个方面:</p><ol><li>批评的;批判的</li></ol><p>例句:She has a very critical attitude toward modern art. 她对现代艺术持非常批判的态度。</p><ol><li>关键的;决定性的</li></ol><p>例句:Proper hydration is critical for athletes. 适当的水化对运动员来说非常关键。</p><ol><li>危急的;危重的</li></ol><p>例句:The patient’s condition was listed as critical after the accident. 事故后,病人的情况被列为危重。</p><ol><li>批评;批评意见</li></ol><p>例句:The film received excellent critical reviews. 这部电影获得了极好的评价。</p><ol><li>关键时刻;危急关头</li></ol><p>例句:We made it through the critical moment.我们挺过了最危急的时刻。</p><ol><li>临界;最高点</li></ol><p>例句:The reactor was close to its critical temperature.反应堆的温度接近临界点。</p><p>综上所述,critical 既可形容事物的重要性,也可表示对事物的批判分析,或描述达到极限的状态</p><hr><p>slash 的常见意思有:</p><ol><li>削减;打折</li></ol><p>例句:The store slashed prices for its end-of-season sale. 商店为季末销售大幅削减了价格。</p><ol><li>砍;割</li></ol><p>例句: He slashed through the vines with his machete. 他用大砍刀砍开藤蔓.</p><ol><li>猛砍;乱砍</li></ol><p>例句: The maniac slashed the victim repeatedly with a knife. 那个疯子用刀猛砍受害者。</p><ol><li>斜线</li></ol><p>例句: Write the date using slashes: mm/dd/yy. 用斜线表示日期:月/日/年。</p><ol><li>(在计算机字段中用于表示)一种选择或替代</li></ol><p>例句: Choose A/B/C. 选择A/B/C。</p><ol><li>(音乐样式)迷幻摇滚</li></ol><p>例句: Guns N’ Roses started as an LA slash metal band. 枪与玫瑰乐队最初是洛杉矶的卷舌摇滚乐队。</p><p>综上所述,slash 的意思与切、砍、削减、选择等相关,可以作为动词或名词使用。</p><hr><p>drilling 有以下几层含义:</p><ol><li><p>钻孔 - Drilling a hole into the wall to hang a picture. 为了挂画在墙上钻孔。</p></li><li><p>练习 - Repeatedly drilling math problems to memorize formulas. 重复训练数学题以记住公式。</p></li><li><p>军事训练 - Soldiers drilling every morning on the parade ground. 士兵每天早晨在操场进行军事训练。</p></li><li><p>疾行 - Drilling through the crowded sidewalk. 穿过拥挤的人行道疾行。</p></li><li><p>严格训斥 - The coach kept drilling the players on minor mistakes. 教练一直严厉指责球员的小错误。</p></li><li><p>开采;钻探 - An oil company is drilling for petroleum in the ocean. 石油公司在海洋钻探石油。</p></li><li><p>牙科钻孔 - The dentist will be drilling several cavities today. 今天牙医要钻几个蛀牙。</p></li></ol><p>所以,drilling 的基本意思是通过钻孔或重复性训练来获得或加强某项技能。</p><hr><p><em>methane甲烷  、 emissions排放、 drilling 钻探、maintained保持维持、dramatically显著的</em>、<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161551101.png" alt="image.png"></p><p><em>A risks B —&gt;A有可能导致B</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162306630.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>rage 的常见意思有:</p><ol><li>激怒;狂怒</li></ol><p>例句:Seeing the mess, he flew into a rage. 看到一团糟,他暴怒起来。</p><ol><li>激烈的情感;狂暴</li></ol><p>例句:a poem full of rage and passion 一首充满激愤与激情的诗歌</p><ol><li>风靡;盛行</li></ol><p>例句:A new dance craze is all the rage right now. 一个新的舞蹈热潮现在正风靡一时。</p><ol><li>激烈的争论或斗争</li></ol><p>例句:a philosophical rage 在哲学上的激烈争论</p><ol><li>精力旺盛;热情</li></ol><p>例句:Quitting smoking has filled me with a rage to live. 戒烟让我热情高涨,对生活充满了激情。</p><ol><li>暴力;激烈</li></ol><p>例句:the rage of war 战争的暴力</p><ol><li>(疾病的)流行</li></ol><p>例句:a flu rage 流感的流行</p><p>综上所述,rage 表示强烈愤怒或热情,也可指某事物的风靡或某情绪的强烈爆发。</p><hr><blockquote><p>!!!</p></blockquote><p><em>strategy战略、策略； uncovered揭露，揭示、confession坦白、忏悔、认罪</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171222257.png" alt="image.png"></p><p><em>protest抗议、抗议活动；sin罪行，罪恶；proactive积极主动地&lt;-反-&gt;passive消极的；<br>reputation名誉，声誉；massive大规模的，大量的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171327987.png" alt="image.png"></p><p><em>approach方法；statement声明</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171329142.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>consolidation 的意思是“巩固,加强”。它的常见含义有:</p><ol><li>巩固,加强已获得的地位或者优势。</li></ol><p>例句:The company is seeking to consolidate its dominant position in the market. 该公司正寻求巩固其在市场的主导地位。</p><ol><li>合并,将多个事物整合在一起。</li></ol><p>例句:There was a wave of consolidation among major banks. 主要银行进行了一波合并潮。</p><ol><li>使更加稳固、坚实。</li></ol><p>例句:The new evidence helped consolidate the argument. 新的证据帮助加强了这个论点。</p><ol><li>统一,整合(权力、资源等)。</li></ol><p>例句:The king consolidated his rule over the empire. 国王统一了他对帝国的统治。</p><ol><li>使(知识等)牢固。</li></ol><p>例句:We need to consolidate what we learned in class today. 我们需要巩固今天课堂上学到的知识。</p><ol><li>合并(财务账目等)。</li></ol><p>例句:All the subsidiaries report to HQ for financial consolidation. 所有子公司汇报给总部进行财务合并。</p><hr><p><em>trade-off 取舍、权衡 ；consolidation合并，加强；instance实例，情况</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171333756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171338448.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171343874.png" alt="image.png"></p><p><em>appropriate恰当的，适当的； collective集体的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171345209.png" alt="image.png"></p><hr><p>quo 的常见意思有:</p><ol><li>status quo</li></ol><p>这个词组表示“现状,原状”。</p><p>例句:We cannot continue with the status quo. We need changes. 我们不能维持现状。我们需要改变。</p><ol><li>pro quo</li></ol><p>这个词组表示“交换,回报”。</p><p>例句:Quid pro quo refers to an exchange of goods or services. Quid pro quo 指商品或服务的交换。</p><hr><p><em>is anything but simple不是容易的；pre-pandemic前疫情的  </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171348681.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>episode 的常见意思有:</p><ol><li>事件,故事的一个章节或阶段</li></ol><p>例句:The latest episode of the drama was very moving. 这部电视剧的最新一集非常动人。</p><ol><li>一段经历,一个阶段</li></ol><p>例句:That was an unfortunate episode in my life. 那是我一生中一段不幸的经历。</p><ol><li>发作,发病</li></ol><p>例句:The patient had a sudden episode of chest pain. 这个病人突然胸痛发作。</p><ol><li>一集电视节目</li></ol><p>例句:I missed the first episode of this TV series. 我错过了这个电视剧的第一集。</p><ol><li>情节中的一个片段</li></ol><p>例句:There are several funny episodes in the movie. 这部电影有几个搞笑的片段。</p><ol><li>事件,事变</li></ol><p>例句:The bombing was just one episode in the long conflict. 这次轰炸只是长期冲突中的一个事件。</p><p>所以,episode 指故事、事件发展中的一个阶段或段落,也可以指电视节目中的一集、或病人的一场发作。</p><hr><p>count 的常见意思有:</p><ol><li>计算;数数</li></ol><p>例句:Let me count the coins in my pocket. 让我数数口袋里的硬币。</p><ol><li>计数;计数值</li></ol><p>例句:What was the final count of votes? 最后的投票计数是多少?</p><ol><li>计数单位;数目</li></ol><p>例句:A vast count of stars are visible in the night sky. 夜空中可见无数的星星。</p><ol><li>重要;有影响力</li></ol><p>例句:Your opinion counts. 你的观点很重要。</p><ol><li>认为;视为</li></ol><p>例句:She counted him as one of her closest friends. 她视他为自己最亲密的朋友之一。</p><ol><li>依靠;信赖</li></ol><p>例句:You can always count on him for help. 对于寻求帮助你总能依靠他。</p><ol><li>控诉;指控</li></ol><p>例句:He was accused on five counts of fraud. 他被控五项诈骗罪。</p><ol><li>回数;节拍</li></ol><p>例句:The dancer kept perfect count throughout the performance. 舞者在整场表演中拍子始终正确。</p><hr><p><em>privileged有特权的；implicitly隐含的，默认的；class阶级；administration行政部门，政府机构；rescue营救，解救，脱困；uninsured没有保险的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171402709.png" alt="image.png"></p><p><em>crisis危机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171411443.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>just as significantly同样重要的是；industry行业； precedent先例</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171425766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171429332.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>contrast with与…形成对比 ；stark明显的，极端，荒凉;  elementary基础性的；element 元素，成分，要素</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171450834.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171458497.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>systematically 的意思是“有系统地”,是个副词。其含义是:</p><ol><li>按照系统或方法进行</li></ol><p>例句:We need to systematically analyze all the data. 我们需要系统地分析所有数据。</p><ol><li>有条理地,有步骤地</li></ol><p>例句:He systematically went through all the possible solutions. 他有条不紊地检查了所有可能的解决方案。</p><ol><li>有计划地,有组织地</li></ol><p>例句: The manager systematically arranged all the tasks. 经理有组织地安排了所有任务。</p><ol><li>从根本上,彻底地</li></ol><p>例句: We must systematically change how things are done. 我们必须从根本上改变做事的方式。</p><ol><li>不断重复地,习以为常地</li></ol><p>例句: She was systematically abused by her partner. 她不断遭到伴侣的虐待。</p><p>综上,systematically 意思是按照预定的系统、计划或方法进行,做事有条理和组织,而不是碎片化和随意进行。</p><hr><p><em>bias偏见,偏心，倾斜；pernicious有害的，具有负面破坏性的；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171503468.png" alt="image.png"></p><p><em>strikes 击中，罢工，罢课；health care 医疗保健；pension退休金，养老金<br>median中位数，中线，中间值；household家庭，户，住户</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171558168.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>endure忍受；agency机构；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171614940.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>essence 的意思是:</p><ol><li>本质;实质;真谛<br>例句:The essence of his argument is that we need to focus on education. 他论点的真谛是我们需要关注教育。</li><li>精华;精髓;灵魂<br>例句:She has captured the essence of the book in her summary. 她在摘要中抓住了这本书的精髓。</li><li>(植物、化学品等的)香精;香料;香气<br>例句:This perfume contains floral essences. 这种香水含有花香精华。</li></ol><p>essential 的意思是:</p><ol><li>基本的;本质的;必不可少的<br>例句:Water is essential to human life. 水对人类生命至关重要。</li><li>不可或缺的;必需的<br>例句:An engineer needs an essential understanding of math. 工程师需要必不可少的数学知识。</li><li>香精;香精油</li></ol><hr><p><em>race种族；admission 接纳，录取；essential基本的，本质的；recrut招聘，征招 ；surrogates替代品；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171638065.png" alt="image.png"></p><h1 id="阅读强化"><a href="#阅读强化" class="headerlink" title="阅读强化"></a>阅读强化</h1><h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p><em><code>词汇体现观点</code></em></p><p><em>词汇体现观点、态度<br>stand in favor of sth 支持某事<br>Unfavorable 不支持<br>Lame 跛脚的<br>Ignore 忽视<br>Ignorant 无知的<br>sustainable 可持续的  sustain持续，连续不断<br>alleviate 缓解<br>aggravate 恶化<br>Lost 失去</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181112122.png" alt="image.png"><br><em>the Federal Court 联邦法院 、annually每年的、 is overturned 被推翻、<br>the supreme court 最高法院、 profit利润</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181117962.png" alt="image.png"></p><hr><p><em><code>如何寻找文章的中心对象？</code></em></p><p><em>题目一定是围绕中心对象展开—&gt;所以，找题目中心对象</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181126215.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181127934.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>rail 铁路、fare票价，车票、nationalizaion 国有化、revenue收入、ever-rising</em><br><em>ever-rising 在句子中的意思是“不断上升的;持续增长的”。它由ever和rising两个词组成。<br>ever 有“永远地”的意思。<br>rising 的现在分词形式,有“上升的;增长的”的意思。<br>将ever和rising组合起来,ever-rising就是一个复合形容词,表示某人或某事“不断上升;持续增长”的状态或趋势。</em><br><em>inflation膨胀、通货膨胀</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181145002.png" alt="image.png"></p><p>*collapse 的常见意思有:</p><ol><li>崩溃,倒塌<br>例句:The old building collapsed after the earthquake.<br>这座老房子在地震后倒塌了。</li><li>衰竭,崩溃<br>例句:The company is in danger of financial collapse.<br>这家公司有财务崩溃的危险。</li><li>折叠,收拢<br>例句:The chair can collapse for easy storage.<br>这把椅子可以折叠起来以便储存。</li><li>体力衰竭<br>例句:The runner collapsed from exhaustion midway through the race.<br>这位运动员在比赛中途由于体力透支而倒下。</li><li>瓦解,分崩离析<br>例句:The alliance between the two countries collapsed.<br>两个国家之间的联盟已瓦解。<br>综上所述,collapse 表示由于各种原因导致的崩溃、倒塌或瓦解的状态。*</li></ol><p><em>commuter 乘务员、compensation补偿，赔偿</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181149134.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>townsfolk 城市里的居民、 imitate模仿、tourism旅游业、Cadtle城堡</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181204822.png" alt="image.png"></p><h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p><em>discrimination歧视、condemn谴责、insidious隐藏的，潜在的、alphabetism字母表主义、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181347279.png" alt="image.png"></p><p>overlooked 的意思是“忽视,疏忽”。它是动词 overlook 的过去分词和过去式。<br>下面几个例句可以帮助理解它的意思:</p><ol><li>The teacher overlooked several mistakes in my essay.<br>老师在我的文章中忽视了几处错误。</li><li>Sorry, I overlooked your text message yesterday.<br>不好意思,我昨天忽略了你的短信。</li><li>The security guard overlooked the suspicious person entering the building.<br>安保人员疏忽了那个可疑人物进入大楼。</li><li>Her contributions were often overlooked by her colleagues.<br>她的贡献常常被同事们忽视。</li><li>In his haste, he overlooked a few important details.<br>他匆忙中忽略了几个重要细节。</li><li>The producer apologized for having overlooked the young actor’s talent.<br>制片人为忽视了那位年轻演员的天赋而道歉。<br>综上所述,overlooked 表示注意力不集中导致未注意或忽略某事物、某人的状态或行为,常与动词忽视、疏忽、未注意等意思相对应。</li></ol><p><em>conspicuous 明显的，引人注目的 、prejudice偏见，成见</em></p><p><strong>出现illustrate，is mentioned等等都是举例说明，不是对中心对象的说明 </strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181352977.png" alt="image.png"></p><p><em>subtle微妙的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181357709.png" alt="image.png"></p><p><em>ill-treated虐待</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181401359.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>is comparable to相当于…  、legitimate合法的、正当的、<br>illegal, illegitimate不合法的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181421451.png" alt="image.png"></p><p><em>is quoted to被引用来说明…  、Constitution宪法、interpretation解释，阐释<br>alter 改变，更改 、implement执行、实施、实现、violate违反规则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181426235.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p>diminishing 的意思是“逐渐减少的”,是动词diminish的进行时和过去分词形式。<br>下面几个例句可以帮助理解diminishing的意思:</p><ol><li>The diminishing food supplies posed a threat to the shipwrecked sailors.<br>不断减少的食物供应给那些遇难船员带来了威胁。</li><li>There has been a diminishing number of wildlife in the area due to habitat loss.<br>由于栖息地丧失,该地区的野生动物数量在不断减少。</li><li>His diminishing eyesight made it difficult for him to read.<br>他逐渐衰弱的视力使阅读变得艰难。</li><li>The diminishing sunlight signaled the coming of winter.<br>阳光逐渐减弱,标志着冬季的到来。</li><li>She felt a diminishing desire to socialize with friends.<br>她感到社交的欲望在不断减退。<br>综上所述,diminishing 指 etwas在不断减少或缩小,表示从更多到更少的过程或趋势。与increase, enhance等词义相反。</li></ol><p><em>asset资产财产 、deminish逐渐减少</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181434016.png" alt="image.png"></p><p><em>evade 逃避 、peer同龄人、reform改革、misinterpreted曲解、neglect忽略，忽视 、skepticism怀疑态度、怀疑主义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181435621.png" alt="image.png"></p><h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><blockquote><p><em>细节题，注意词，细节</em></p></blockquote><p><em>partly 部分地、construction建设，构建、transparancy透明度、公开性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192245188.png" alt="image.png"></p><hr><blockquote><p><em>态度题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192251461.png" alt="image.png"></p><blockquote><p><em>例证题</em></p></blockquote><p><em>Toyota Motor 丰田汽车 、demonstrate展示，证明</em></p><p><em>limbic 的意思是“边缘的,边界的”,来源于解剖学术语,常用来形容脑内负责情绪和记忆的结构区域。<br>limbic system 边缘系统,指大脑内边缘部位的一组核团和神经纤维,控制情感反应和本能行为。<br>limbic cortex 边缘皮层,大脑边缘区域的组织。<br>limbic lobe 边缘小叶,位于大脑半球内侧的一部分,与情绪和记忆相关。<br>limbic brain 边缘脑,主管情感反应和本能的脑区。<br>综上所述,limbic 在解剖学上专门用来指代大脑内与情绪和本能相关的结构,因为这些结构位于大脑的边缘区域。它与理性思考和认知判断相对,更多与情感和直觉相关。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192253419.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192258586.png" alt="image.png"></p><blockquote><p><em>词汇题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211010386.png" alt="image.png"></p><blockquote><p><em>推理题</em></p></blockquote><p><em>当题目中没有给出定位信息的时候，，需要主动定位，70%来自段落首句</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211014882.png" alt="image.png"></p><p><em>search agent 搜索代理程序或者搜索机器人、negotiate谈判、磋商</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211024090.png" alt="image.png"></p><blockquote><p><em>主题题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211032732.png" alt="image.png"></p><h2 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h2><blockquote><p><em>比对</em></p></blockquote><p><em>选项和答案来源比对,先根据题目细节定位到句子，再根据名词一定会重现，动词替换原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211036300.png" alt="image.png"></p><p><em>关于定位和比对的专项训练—细节题的定位和比对</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211039422.png" alt="image.png"></p><p><em>sustained 的意思是“持续的,不间断的”,是动词sustain的过去式和过去分词。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211043870.png" alt="image.png"></p><p><em>levy ,tax 税、 impose强制施加，征收税、platform站台，月台、apply primarily主要适用于… 、multinational跨国的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211051386.png" alt="image.png"></p><p><em>出现两个名词，可能要考虑两个名词需要用相近的次替换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211104367.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> english </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>acdemic_gpt添加slack-Claude模型</title>
      <link href="/undefined/6ca9ded9.html"/>
      <url>/undefined/6ca9ded9.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png" alt="image.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p><p><code>3.ppt生成promt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">帮我制作一篇内容关于这篇文章的PPT，要求如下： </span><br><span class="line">第一、一定要使用中文。 </span><br><span class="line">第二、页面形式有3种，封面、目录、列表。 </span><br><span class="line">第三、目录页要列出内容大纲。 </span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页内容使用“=====列表=====”作为开头。 </span><br><span class="line">第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 </span><br><span class="line">第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 </span><br><span class="line">第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 </span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。 </span><br><span class="line">第九、请用代码块回复你生成的内容。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/undefined/e255a10a.html"/>
      <url>/undefined/e255a10a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" alt="image.png"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被服务的</span><br><span class="line">关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资源有限同时发</span><br><span class="line">消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主要指</span><br><span class="line">下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上与服务端进</span><br><span class="line">    行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服务端又</span><br><span class="line">是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境当中，下载的</span><br><span class="line">主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一点点</span><br><span class="line">   交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电话(释放</span><br><span class="line">链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，然后再</span><br><span class="line"> 由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段的占用链路，</span><br><span class="line"> 不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机发出报</span><br><span class="line">  文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入</span><br><span class="line">10bit信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间</span><br><span class="line">被称为排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被</span><br><span class="line">称为处理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步(SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载app，网络</span><br><span class="line">断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用户数据</span><br><span class="line">报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返回确认</span><br><span class="line">信息后，才会发送下一段内容；如果没有接收到确认信息，那么会一直发送</span><br><span class="line">当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无需确认</span><br><span class="line">这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发消息，</span><br><span class="line">qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进行区分</span><br><span class="line">例如请qq的消息端口号是1，接收方端口号1的进程(qq)接收该条消息；微</span><br><span class="line">信端口号2，接收方端口号2的进程(微信)接受该条消息</span><br><span class="line">5.拥塞控制</span><br><span class="line">- 传输层协议</span><br><span class="line">1.TCP</span><br><span class="line">2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服务，网</span><br><span class="line">  络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则进行对</span><br><span class="line">分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制校验)</span><br><span class="line">4.拥塞控制：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里开始，</span><br><span class="line">到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合走可</span><br><span class="line">  在链路上传输</span><br><span class="line">- </span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基础知识1"><a href="#数据通信基础知识1" class="headerlink" title="数据通信基础知识1"></a>数据通信基础知识1</h3><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>单、半、全三种通信方式</em></p></blockquote><p><em>单工通信：一条单向的信道(一条信道同一时刻要么接收，要么发送)<br>半双工通信：两条单向的信道<br>全双工通信：两条双向的信道(一条信道同一时刻，可以同时发送和接收)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>串行与并行传输方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261729820.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输通信方式</em></p></blockquote><p><em>同步传输：传输数据是连续传输<br>异步传输：数据间间断断，传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261735457.png" alt="image.png"></p><h3 id="数据通信基础知识2"><a href="#数据通信基础知识2" class="headerlink" title="数据通信基础知识2"></a>数据通信基础知识2</h3><blockquote><p><em>码元</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261959550.png" alt="image.png"></p><blockquote><p><em>速率、波特</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001158.png" alt="image.png"></p><blockquote><p><em>带宽</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001622.png" alt="image.png"></p><h3 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h3><blockquote><p><em>奈氏准则</em></p></blockquote><ul><li><em>是在理想低通(无噪声、带宽受到限制)条件下，避免 <strong>码间串扰</strong>  确定的极限的码元的传输速率=2W Baud，所以极限 信息传输速率=2W ×n  （n是码元bit数，就是n进制码元）</em></li><li><em>W 表示带宽，单位Hz</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262100499.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262104722.png" alt="image.png"></p><blockquote><p><em>香农定理</em></p></blockquote><ul><li><em>是在带宽受限，且有噪声的信道中，规定的在该噪声条件下的，不影响码元判断的，极限数据传输速率</em></li><li><em>S/N是信噪比，常常用作10log10(S/N) 来进行转换，从而将单位记作dB,就是定义了一个转换数值的公式 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262108690.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262114311.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262115670.png" alt="image.png"></p><blockquote><p><em>香农和奈氏</em></p></blockquote><ul><li><em>奈氏准则：关注的是无噪声条件下，不会造成码间串扰的极限 数据传输速率</em></li><li><em>香农定理：关注的是在当前噪声条件下，不会导致数据码元判断失真的 数据极限传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262120589.png" alt="image.png"></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a><em>基带信号与宽带信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262222235.png" alt="image.png"></p><h4 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a><em>编码与调制</em></h4><p><em>将数据 编码 /调制 —&gt;信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262223896.png" alt="image.png"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a><em>数字数据编码为数字信号</em></h4><blockquote><p><em>非归零编码</em></p></blockquote><p><em>缺点是，需要额外的信道，传输时钟周期信号，告诉多久发一个bit信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271044394.png" alt="image.png"></p><blockquote><p><em>归零编码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262237642.png" alt="image.png"></p><blockquote><p><em>反向不归零编码</em></p></blockquote><ul><li><em>缺点是，对于发送全1的信号，无法判断，有多少个1，因为，高低电平都有可能是1</em></li><li><em>还有就是，缺点在全1，的时候，会出现长条，没有时钟周期，就无法得知发送了，多少个1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262234072.png" alt="image.png"></li></ul><blockquote><p><em>曼彻斯特编码</em></p></blockquote><ul><li><em>1bit数据，就是1码元，被调制成两段电平，所以数据传输速率只有调制速率的1/2</em></li><li><em>每个码元中间，有一次跳变，可以实现同步，可通过中间跳变反应时钟信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271051270.png" alt="image.png"></li></ul><blockquote><p><em>差分曼彻斯特编码</em></p></blockquote><ul><li><em>每个码元中间都有一次跳变，可以实现同步</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271059163.png" alt="image.png"></li></ul><blockquote><p><em>4B/5B编码</em></p></blockquote><ul><li><em>编码效率80%</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271101120.png" alt="image.png"></li></ul><h4 id="数字数据调制成模拟信号"><a href="#数字数据调制成模拟信号" class="headerlink" title="数字数据调制成模拟信号"></a><em>数字数据调制成模拟信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271105446.png" alt="image.png"></p><ul><li><em>采样频率要达到信号最高频率的2倍以上，以保证，可以在每一个最高频的信号峰之内都可以采样到2个信息，得到波峰图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271112992.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271114621.png" alt="image.png"></p><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271138465.png" alt="image.png"></p><blockquote><p><em>1.电路交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271319318.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320037.png" alt="image.png"></p><blockquote><p><em>2.报文交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320009.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320369.png" alt="image.png"></p><blockquote><p><em>3.分组交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321465.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321976.png" alt="image.png"></p><blockquote><p><em>数据交换方式的选择</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271324239.png" alt="image.png"></p><blockquote><p><em>3.1.分组交换—数据报方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271325439.png" alt="image.png"></p><p><em>无连接服务，就是事先不为分组确定传输路径，传输路径全靠路由选择</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326584.png" alt="image.png"></p><blockquote><p><em>3.2分组交换—虚电路方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326838.png" alt="image.png"></p><p><em>连接服务，就是事先要确定分组的传输路径，提前建立连接，然后再按照这个路径输送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327331.png" alt="image.png"></p><blockquote><p><em>虚电路与数据报方式的区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327057.png" alt="image.png"></p><h2 id="传输介质-信道"><a href="#传输介质-信道" class="headerlink" title="传输介质(信道)"></a>传输介质(信道)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271453976.png" alt="image.png"></p><ul><li><em>传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。</em></li><li><em>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了 电 气 特 性，因此能够识别所传送的比特流</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271431578.png" alt="image.png"></li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a><em>导向性传输介质</em></h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a><em>双绞线</em></h4><p><em>电流方向相反的铜线，绞合一起，磁感线相互抵消，减少相邻导线的电磁干扰</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271436145.png" alt="image.png"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><em>同轴电缆</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271440754.png" alt="image.png"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><em>光纤</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443295.png" alt="image.png"></p><blockquote><p><em>单模光纤和双模光纤</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271447411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443816.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271448705.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449288.png" alt="image.png"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a><em>非导向性传输介质</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449201.png" alt="image.png"></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><blockquote><p><em>中继器</em></p></blockquote><ul><li><em>中继器是对数字信号的再生(整形)</em></li><li><em>中继器是连接两个网段的桥梁，以助于数字信号的再生</em></li><li><em>中继器，只负责将数据发送到另一网段，不管数据中是否有错误</em></li><li><em>中继器两端可以连接相同传输介质，也可以不同传输介质</em></li><li><em>中继器两端网段一定要是统一协议</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271612539.png" alt="image.png"></p><blockquote><p><em>集线器</em></p></blockquote><p><em>集线器，可以连接多台主机，平分带宽，共享数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271616925.png" alt="image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="链路层的功能"><a href="#链路层的功能" class="headerlink" title="链路层的功能"></a>链路层的功能</h2><blockquote><p><em>数据链路层基本概念</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271636246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271637260.png" alt="image.png"></p><blockquote><p><em>功能概述</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639722.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639736.png" alt="image.png"></p><h3 id="封装成帧-amp-透明传输"><a href="#封装成帧-amp-透明传输" class="headerlink" title="封装成帧&amp;透明传输"></a><em>封装成帧&amp;透明传输</em></h3><blockquote><p><em>封装成帧</em></p></blockquote><p><em>在一段数据添加首部、尾部构成一个帧，接收端就能收到bit流后，能识别帧的开始和结束</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271708120.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271711174.png" alt="image.png"></p><blockquote><p><em>透明传输</em></p></blockquote><p><em>就是传输数据的bit组合不会影响，到帧开始和结束的判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271714311.png" alt="image.png"></p><blockquote><p><em>四种组帧的方法</em></p></blockquote><p><strong><em>1.字符计数法</em></strong></p><ul><li><em>帧的开始字符记录的是该帧的字符数(包括自己)</em></li><li><p><em>缺点是，当前面的字符出错，往后的全部会出错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271716399.png" alt="image.png"><br><strong><em>2.字符填充法</em></strong></p></li><li><p><em>传送文本，由于文本字符对应的ASCII码不会出现的bit组合充当帧头，帧尾，中间数据部分不会产生边界判定错误</em></p></li><li><em>如果传送的帧，由二进制程序，或图像等等非ASCII编码文本文件，数据内容有可能出现帧头，帧尾bit组合，导致中间穿插,帧边界判定错误</em></li><li><em>通过对数据部分 字节填充ESC转义字节 ，—&gt;使得特殊字符意义失效，实现干扰的解决</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271720950.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271724181.png" alt="image.png"></p><p><strong><em>3.零比特填充法</em></strong></p><p><em>以01111110 作为帧头和帧尾，发送端先将数据扫描，将所有连续的5个1 后都插入0，这样就不会出现6个1 ，再封装成帧；接收端，再逆过程去掉0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271726553.png" alt="image.png"></p><p><strong><em>4.违规编码法</em></strong></p><p><em>曼彻斯特编码中不会出现的状态(高-高/低-低)来表示帧头，帧尾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271729961.png" alt="image.png"></p><h3 id="差错控制—检错编码"><a href="#差错控制—检错编码" class="headerlink" title="差错控制—检错编码"></a><em>差错控制—检错编码</em></h3><blockquote><p><em>差错从何而来？</em></p></blockquote><ul><li><em>差错来源：随机噪声（线路本身电气特性产生）、冲击噪声（外界短暂原因）</em></li><li><p><em>差错：位错；帧错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271901773.png" alt="image.png"></p></li><li><p><em>链路层编码与物理层编码调制不同：链路层编码是用于<strong>一组比特</strong>，判断传输过程是否出现出错。物理层编码调制针对<strong>单个比特</strong>，解决的是传输过程中 比特同步的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271903232.png" alt="image.png"></p></li></ul><blockquote><p><em>差错控制—检错编码—奇偶校验码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271910981.png" alt="image.png"></p><blockquote><p><em>差错控制—检错编码—CRC循环冗余码</em></p></blockquote><p><em>接收结果作 余数为0，就无差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271911773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271912297.png" alt="image.png"></p><h3 id="差错控制—纠错编码"><a href="#差错控制—纠错编码" class="headerlink" title="差错控制—纠错编码"></a><em>差错控制—纠错编码</em></h3><blockquote><p><em>海明距离</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272215926.png" alt="image.png"></p><blockquote><p><em>海明码纠错步骤</em></p></blockquote><p><strong><em>1.确定校验码位数r</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217701.png" alt="image.png"></p><p><strong><em>2.确定校验码和数据的位置</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217078.png" alt="image.png"></p><p><strong><em>3.求出校验码的值</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272220510.png" alt="image.png"></p><p><strong><em>4.检错并纠错</em></strong><br><em>方式1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272228839.png" alt="image.png"></p><ul><li><em>先每个校验码对应一个大圆，分别填入器其校验码序号</em></li><li><em>交集部分，填入校验码负责校验的一组序号中重叠的序号数据</em></li><li><em>最中间是三个校验码负责的重叠序号</em></li><li><em>2号校验码负责的没有出错，1,4号出错，所以3，6,7，排除，只剩下5</em></li></ul><p><em>方式2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272242979.png" alt="image.png"></p><blockquote><p><em>海明码纠错演示</em></p></blockquote><p><strong><em>1．传输的数据：1101</em></strong></p><p><strong><em>2．校验位计算公式：</em></strong></p><p>2^k &gt;= k+n+1,n为数据位在本例中计算的k为3；</p><p>用P1,P2,P3,表示校验位，其中</p><p>P1,的位数2^0,P2,的位数2^1,P3,的位数2^2</p><p>则：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>1+2</th><th>4</th><th>1+4</th><th>2+4</th><th>1+2+4</th></tr></thead><tbody><tr><td>位数的二进制</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td></tr><tr><td>位数</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>数据位</td><td></td><td></td><td>1</td><td></td><td>1</td><td>0</td><td>1</td></tr><tr><td>校验位</td><td>P1,</td><td>P2,</td><td></td><td>P3</td><td></td><td></td></tr></tbody></table></div><p><strong><em>3.分组：</em></strong></p><div class="table-container"><table><thead><tr><th>校验位</th><th>位数分组</th></tr></thead><tbody><tr><td>P1,</td><td>1,3,5,7</td></tr><tr><td>P2,</td><td>2,3,6,7</td></tr><tr><td>P3</td><td>4,5,6,7</td></tr></tbody></table></div><p><strong><em>4.计算校验位值(异或运算)</em></strong></p><p>P1^1^1^1=0,得P1=1</p><p>P2^1^0^1=0,得P2=0</p><p>P3^1^0^1=0,得P3=0</p><p>最终传输的数据位：10101<code>0</code>1</p><p><strong><em>5,检验</em></strong><br>     如果接收端收到的是10101<code>1</code>1<br>     还是按照刚才的分组进行计算P1,P2P3每个分组的异或值，为零则无错，为1则有错。<br>     P1组 1^1^1^1=0<br>     P2组 0^1^1^1=1<br>     P3组 0^1^1^1=1</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a><em>流量控制与可靠传输机制</em></h3><p><em>可靠传输的意思是数据发送端发送什么数据，数据接收放就接收到什么数据，没有出现分组丢失、差错、重复、乱序等情况。</em></p><h4 id="流量控制与可靠传输的方法"><a href="#流量控制与可靠传输的方法" class="headerlink" title="流量控制与可靠传输的方法"></a><em>流量控制与可靠传输的方法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281155434.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157464.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157841.png" alt="image.png"></p><ul><li><em>停止-等待协议  ，发送窗口=1，接收窗口=1</em></li><li><em>后退N帧协议（GBN）发送窗口&gt;1,接收窗口=1</em></li><li><em>选择重传协议（SR）发送窗口&gt;1,接收窗口&gt;1</em></li></ul><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p><em>为什么要有停止等待协议？</em></p></blockquote><ul><li><em>为了解决流量控制的问题：互相的停止等待，使得不会传输太多的数据</em></li><li><em>为了解决可靠传输的问题：互相停止等待，接收确认帧，能保证能发现差错，以及处理差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281348782.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—无差错情况</em></p></blockquote><ul><li><em>ACK i 是接收方收到第 i 号帧之后，返回给发送方的确认帧</em></li><li><em>每次发送一个数据帧就停止等待，所以只需要1bit来对帧进行编号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352535.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—有差错情况</em></p></blockquote><p><strong><em>1.数据帧丢失或检测到帧出错</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352337.png" alt="image.png"></p><ul><li><em>超时计时器，当没有在设定时间内收到确认帧，发送方就重发一次</em></li><li><em>超时计时器设置的设定时间，要并RTT(往返传播时延)高一点，因为还有发送时延</em></li><li><em>发完一个帧之后，要保留这个帧的副本，用来重发</em></li><li><em>数据帧和确认帧必须编号，以确定确认帧确定的是哪一个数据帧</em></li></ul><p><strong><em>2.ACK丢失</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356757.png" alt="image.png"></p><p><strong><em>3.ACK迟到</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356868.png" alt="image.png"></p><blockquote><p><em>信道利用率</em></p></blockquote><ul><li><em>信道利用率就是发送方在一个发送周期内，有效的发送数据所需时间(发送时延)，占整个发送周期的比率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281403631.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281404211.png" alt="image.png"></p><blockquote><p><em>梳理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281406220.png" alt="image.png"></p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><h6 id="后退N帧协议GBN"><a href="#后退N帧协议GBN" class="headerlink" title="后退N帧协议GBN"></a><em>后退N帧协议GBN</em></h6><blockquote><p><em>停等协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281646729.png" alt="image.png"></p><blockquote><p><em>后退N帧协议中的滑动窗口</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281541947.png" alt="image.png"></p><blockquote><p><em>GBN发送方要响应的三件事</em></p></blockquote><ul><li><em>窗口已满是指，当前窗口的数据，在没有收到确认帧之前，不能往前移动，此时的状态就是窗口已满</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281539613.png" alt="image.png"></li></ul><blockquote><p><em>GBN接收方要做的事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281651074.png" alt="image.png"></p><blockquote><p><em>运行中的GBN</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281536912.png" alt="image.png"></p><blockquote><p><em>滑动窗口长度</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281559974.png" alt="image.png"></p><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281532640.png" alt="image.png"></p><ul><li><em>1000个窗口，所以发送方同时可以发1000个帧，每个帧1000个字节<br>所以一次右1000x1000x8 bit数据，<strong>受到信道带宽限制，所以发送延时=<br>1000x1000x8b/100Mb/s =80ms</strong></em></li><li><em>只有受到受到1号帧的确认帧，发送框才会开始移动一个，所以，<strong>在没有受到第一个确认帧之前，发送方不会发送新的数据</strong></em></li><li><em>所以计算，受到确认帧的时间=2x50ms + 1000x8b/100Mb/s =100.08ms &gt;80ms ,所以，信道会有20ms没有新数据推入，空闲，有100.08-80ms=20ms无输入，所以<strong>实际平均数据传输率=1000x1000x8b/100.08ms=80Mb/s</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281518658.png" alt="image.png"></li></ul><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281543131.png" alt="image.png"></p><h6 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a><em>选择重传协议SR</em></h6><blockquote><p><em>后退N帧协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281647073.png" alt="image.png"></p><blockquote><p><em>选择重传协议中的滑动窗口</em></p></blockquote><ul><li><em>发送窗口黄色部分是未被确认的帧，绿色部分是发送之后，收的确认帧的帧</em></li><li><em>接收窗口，紫色部分是收到的帧，灰色部分是<strong>希望收到</strong>的帧，发现，接收窗口可以在没有收到希望收到的帧前，接收其他序号的帧，这里不同于GBN协议，GBN协议在没有收到希望收到的帧之前，对其他发送过来的帧会全部丢弃</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281652798.png" alt="image.png"></li></ul><blockquote><p><em>SR 发送方必须响应的三件事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281659010.png" alt="image.png"></p><blockquote><p><em>SR接收方要做的事</em></p></blockquote><ul><li><em>接收窗口只有当接收到窗口下届的帧，才会将接收窗口往前移动，移动到最小的未接收的帧，并将接收到的这批帧，交付给网络层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705434.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705718.png" alt="image.png"></p><blockquote><p><em>运行中的SR</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281708817.png" alt="image.png"></p><blockquote><p><em>SR滑动窗口长度</em></p></blockquote><ul><li><em>发送窗口=接收窗口（防止溢出）</em></li><li><em>窗口长度=2^(n-1),n为帧的个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281711388.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281714834.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281713327.png" alt="image.png"></p><h3 id="信道划分介质访问控制-MAC协议"><a href="#信道划分介质访问控制-MAC协议" class="headerlink" title="信道划分介质访问控制(MAC协议)"></a><em>信道划分介质访问控制(MAC协议)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942630.png" alt="image.png"></p><ul><li><em>当一个对讲机讲话，其他对讲机就不能够进行讲话，否则会信号冲突</em></li><li><em>广播式链路，如何实现，两对节点之间通信不会互相干扰，就需要介质访问控制来实现</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942457.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291141124.png" alt="image.png"></p><h4 id="静态划分信道-信道划分介质访问控制"><a href="#静态划分信道-信道划分介质访问控制" class="headerlink" title="静态划分信道(信道划分介质访问控制)"></a><em>静态划分信道(信道划分介质访问控制)</em></h4><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a><em>频分多路复用FDM</em></h5><ul><li><em>不同用户同一时间占用不同的带宽(频率资源)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282109872.png" alt="image.png"></li></ul><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a><em>时分多路复用TDM</em></h5><ul><li><p><em>缺点是每个用户在每一个帧中占用固定的时隙，导致其他用户空闲时，不传送数据时，时隙被浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282111844.png" alt="image.png"></p></li><li><p><em>改进后的统一时分复用STDM,就解决了上面的问题，铜国集中器，将不同用户的数据，按照进入的先后，排列使得每一个STDM帧都排满</em></p></li><li><em>所以STDM帧的每个用户的时隙，不是固定的，是按照需要动态分配的时隙</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282112256.png" alt="image.png"></li></ul><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a><em>波分多路复用WDM</em></h5><ul><li><em>实际上就是光的频分多路复用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282115560.png" alt="image.png"></li></ul><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a><em>码分多路复用CDM</em></h5><ul><li><em>不太理解</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282116386.png" alt="image.png"></li></ul><h4 id="动态分配信道-随机访问介质访问控制"><a href="#动态分配信道-随机访问介质访问控制" class="headerlink" title="动态分配信道(随机访问介质访问控制)"></a><em>动态分配信道(随机访问介质访问控制)</em></h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><em>ALOHA协议</em></h5><blockquote><p><em>纯ALOHA协议</em></p></blockquote><ul><li><em>这里帧用T0表示，T0是一个帧从的 发送时间+传播时间 这所有过程，所耗费的时间，所以是在时间坐标上表示帧</em></li><li><em>ALOHA协议想发就发，多个站点，可以在任何时刻，发送数据帧，只是，如果有两个数据帧产生，时间重叠，那么就发生冲突，接收方会检测到差错，不返回确认，如此发送方就会等待一个随机的时刻再次发送数据帧</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282134246.png" alt="image.png"></li></ul><blockquote><p><em>时隙ALOHA协议</em></p></blockquote><ul><li><em>把时间分为若干相同的时间片段，所有用户只允许在<strong>开始时刻</strong>且 <strong>同步</strong>接入网络信道，这样所有用户拥有一个统一的时间划分，都只能在时间片开始时刻发送数据，若发生冲突，则等到下一个时间片开始时刻发送,大大降低了数据冲突问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282138877.png" alt="image.png"></li></ul><h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a><em>CSMA协议</em></h5><p><strong><em>载波监听多路访问协议</em></strong></p><ul><li><em>CS ：载波监听，每一个站发送数据前先检测总线上是否有其他计算机发送数据</em></li><li><em>当信道空闲：发送完整帧(具体发送看CSMA类型)</em></li><li><em>当信道忙：则等待一个随机时间再监听</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290953369.png" alt="image.png"></li></ul><blockquote><p><em>1-坚持CSMA</em></p></blockquote><ul><li><em>空闲直接传输，不等待；忙则一直监听，直到空闲马上传输</em></li><li><em>不是都是空闲的时候再传输吗？为什么会出现冲突？</em></li><li><em>因为，当有两个以上站，同时在等候监听时，由于信息在两台站之间有传播时延，即使是信道上已经存在数据传输，任然检测不出，所以就当做信道空闲，也把数据传输上去，这样就导致数据碰撞，造成冲突</em></li><li><em>优点：只要空闲就发送，媒体利用率最高</em></li><li><em>缺点：冲突概率高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290956924.png" alt="image.png"></li></ul><blockquote><p><em>非坚持CSMA</em></p></blockquote><ul><li><em>空闲则直接传输，不等待；忙则放弃监听，随机时间后再监听</em></li><li><em>优点：减少了当台站，同时监听到空闲直接发送数据，产生冲突的可能</em></li><li><em>缺点：媒体空闲无法迅速被利用起来，利用率低</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291000848.png" alt="image.png"></li></ul><blockquote><p><em>p-坚持CSMA</em></p></blockquote><ul><li><em>空闲时，概率p直接发送，概率1-p等待下一个时间槽传输。</em></li><li><em>忙则持续监听，直到信道空闲</em></li><li><em>冲突则等待下一个时间槽监听</em></li><li><em>优点：即减少了冲突发生，有能减少空间时间的浪费</em></li><li><em>缺点：冲突后还是会把数据帧发送完，造成浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291004905.png" alt="image.png"></li><li><strong><em>正确使用以上策略可以在一定程度上减少碰撞的发生，但无法彻底解决碰撞问题。</em></strong></li></ul><blockquote><p><em>比对</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291009309.png" alt="image.png"></p><h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><em>CSMA/CD协议</em></h5><blockquote><p><strong><em>强化CSMA协议，推出CSMA/CD协议</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034112.png" alt="image.png"></p><p><strong><em>载波监听多点接入/碰撞检测协议</em></strong></p><ul><li><em>CSMA/CD适用于半双工网络(也就是<strong>有线以太网</strong>)—就是不能一方发送还没发送完，另一方就发送，这样会造成数据在路上的碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034904.png" alt="image.png"></li></ul><blockquote><p><em>为什么先听后发会产生冲突</em></p></blockquote><ul><li><em>为什么先听后发还会产生冲突？</em></li><li><em>因为电磁波在总线上有传播时延，B暂时没有检测到A发送过来的数据</em></li><li><em>以A为基准，对于A来说，A检测到发生碰撞的最长时间=2τ</em></li><li><em>所以当发送数据之后过了2τ还没接受到碰撞，说明这次传输，不会产生碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291053463.png" alt="image.png"></li></ul><blockquote><p><em>如何确定碰撞后重传时机</em></p></blockquote><ul><li><em>碰撞之后如何重传，以及重传几次，通过以下方式**</em>截断二进制指数规避法<em>**</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291055125.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291057356.png" alt="image.png"></li></ul><blockquote><p><em>最小帧长</em></p></blockquote><ul><li><em>当检测到碰撞之后，应当立即停止继续发送帧，但是如果检测到碰撞之前就将帧发送完毕，就显得有些尴尬</em></li><li><em>为了避免检测到碰撞之前，就将帧发完，应该设置一个最小的帧长度，保证2τ(最大检测到碰撞时间)之内不会将帧传输完</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103100.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103689.png" alt="image.png"></p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><em>CSMA/CA协议</em></h5><blockquote><p><em>为什么要有CSMA/CA协议</em></p></blockquote><ul><li><em>无线局域网中无法辺全面的检测碰撞</em></li><li><em>并且当多台站点A,C检测到信道空闲，会同时向终端B发送数据帧，就会导致冲突</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134454.png" alt="image.png"></li></ul><blockquote><p><em>CSMA/CA协议工作原理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291133228.png" alt="image.png"></p><blockquote><p><em>CSMA/CA与CSMA/CD区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134135.png" alt="image.png"></p><h4 id="动态分配信道-轮询访问介质访问控制"><a href="#动态分配信道-轮询访问介质访问控制" class="headerlink" title="动态分配信道(轮询访问介质访问控制)"></a><em>动态分配信道(轮询访问介质访问控制)</em></h4><ul><li><strong><em>结合了静态划分信道的优点，不会产生冲突；又结合了随机访问协议的优点发送时能独占信道，占全部带宽</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291220580.png" alt="image.png"></li></ul><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><em>轮询协议</em></h5><ul><li><em>主节点，挨个轮流询问（实际就是以数据帧形式）下面的主机是否要发送数据</em></li><li><em>主节点故障，就无法询问，所有结点就无法传输数据—称为单点故障</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291214203.png" alt="image.png"></li></ul><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><em>令牌传递协议</em></h5><ul><li><em>令牌就是特殊格式的MAC协议控制帧，不包含任何信息</em></li><li><em>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291218760.png" alt="image.png"></li></ul><h3 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a><em>局域网基本概念和体系结构</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291600023.png" alt="image.png"></p><p><strong><em>决定局域网主要要素</em></strong></p><ul><li><em>网络拓扑</em></li><li><em>传输介质</em></li><li><em>介质访问控制方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291548371.png" alt="image.png"></li></ul><blockquote><p><em>局域网拓扑结构</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291550233.png" alt="image.png"></p><blockquote><p><em>局域网传输介质</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551105.png" alt="image.png"></p><blockquote><p><em>局域网介质访问控制方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551614.png" alt="image.png"></p><blockquote><p><em>局域网的分类</em></p></blockquote><p><em>以太网。是目前应用最广泛的局域网，逻辑拓扑是总线型，物理拓扑是星型。使用的是CSMA/CD 协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291554255.png" alt="image.png"></p><blockquote><p><em>IEEE 802标准</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291556090.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291555065.png" alt="image.png"></p><blockquote><p><em>LLC子层和MAC子层</em></p></blockquote><p><em>IEEE 802标准将局域网的数据链路层划分为：逻辑链路层LLC子层，和介质访问控制MAC子层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291559577.png" alt="image.png"></p><h4 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><em>以太网</em></h4><blockquote><p><em>以太网概述</em></p></blockquote><ul><li><em>以太网有两个标准，DIX Ethernet V2 和IEEE 802.3 ;两种标准的帧格式只有1点点的不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291654999.png" alt="image.png"></li></ul><blockquote><p><em>以太网提供无连接、不可靠服务</em></p></blockquote><ul><li><em>无连接：发送方接受方，之间通信前，不提前确立信道，无握手</em></li><li><em>不可靠：是指，不管接受数据帧是否乱序、差错、丢失</em></li><li><em>无差别接收：是指，在接收数据不会有意外，来什么收什么</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291655881.png" alt="image.png"></li></ul><blockquote><p><em>以太网传输介质与拓扑结构</em></p></blockquote><ul><li><em>现在以太网都是逻辑上总线型，物理上星型</em></li><li><em>传输介质采用双绞线+集线器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291658840.png" alt="image.png"></li></ul><blockquote><p><em>10BASE-T以太网</em></p></blockquote><ul><li><em>BASE 表示传输基带信号，也就是数字信号</em></li><li><em>T表示采用双绞线</em></li><li><em>采用曼彻斯特编码</em></li><li><em>采用CSMA/CD介质访问控制</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291700140.png" alt="image.png"></li></ul><blockquote><p><em>适配器与MAC地址</em></p></blockquote><ul><li><em>通信适配器，实现计算机与外界局域网的连接，也称网络接口板，或网卡NIC</em></li><li><em>现在计算机都嵌入了适配器，就无须单独使用网卡了</em></li><li><em>适配器上装有处理器和存储器(RAM,ROM)，ROM上存储了计算机硬件(网卡)地址MAC地址</em></li><li><em>MAC地址全球唯一，换网卡，MAC地址改变</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291704298.png" alt="image.png"></li></ul><blockquote><p><em>以太网MAC帧—V2格式</em></p></blockquote><ul><li>*为什么有帧开始定界符 ，却没有帧结尾定界符呢？</li><li><em>因为以太网编码采用的是曼彻斯特编码，一个bit内就有一个跳变，当这种形式消失，就说明帧结束，然后只需要往前推4bit就能找到数据位置</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291717806.png" alt="image.png"></li></ul><blockquote><p><em>高速以太网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292033086.png" alt="image.png"></p><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><em>无线局域网</em></h4><blockquote><p><em>802.11的MAC帧头格式</em></p></blockquote><ul><li><em>基站AP(也称无线接入点), 是主机通过连接无线网络连入有线网络（以太网）的设备</em></li><li><em>以下的场景：A 想要与B通信，由于距离太远，A要先通过无线网络将数据发送给Ap1,然后Ap1发送给AP2，最后由Ap2将数据发送给B</em></li><li><em>接收端—AP2的MAC地址 ；发送端—AP1的MAC地址；目的地址—B的MAC地址；源地址—A的MAC地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292038208.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292052190.png" alt="image.png"></p><blockquote><p><em>无线局域网的分类</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292053304.png" alt="image.png"></p><p><strong><em>1.有固定基础设施无线局域网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292055469.png" alt="image.png"></p><ul><li><em>一个基本服务集BSS内，的主机可以相互之间直接通过基站发送数据</em></li><li><em>不同基本服务集之间要进行远距离通信，需要借助基站与基站之间的互相通信来实现，称作“漫游”</em></li><li><em>wifi名称—就是服务集标识符</em></li></ul><p><strong><em>2.无固定基础设施无线局域网的自组织网络</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292101049.png" alt="image.png"></p><h4 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a><em>虚拟局域网VLAN</em></h4><h4 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a><em>广域网</em></h4>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字扩展与多模块存储器区别</title>
      <link href="/undefined/a9bcdbf2.html"/>
      <url>/undefined/a9bcdbf2.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于一个存储器的一部分，也就是说拥有同一个读写周期。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哪些方法可以判断一个有向图是否有环</title>
      <link href="/undefined/d30215e4.html"/>
      <url>/undefined/d30215e4.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模4补码与模2补码</title>
      <link href="/undefined/f711f08b.html"/>
      <url>/undefined/f711f08b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补码、模与运算</title>
      <link href="/undefined/b988fae0.html"/>
      <url>/undefined/b988fae0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补码的移位</title>
      <link href="/undefined/fe859f5c.html"/>
      <url>/undefined/fe859f5c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/undefined/8d4b7ae1.html"/>
      <url>/undefined/8d4b7ae1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg" alt="白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期=主频周期=节拍：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 </span><br><span class="line">  入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF-Overflow-Flag"><a href="#OF-Overflow-Flag" class="headerlink" title="OF:Overflow Flag"></a>OF:Overflow Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">1011 + 1001 = 1 0100 --&gt; 只有符号位进位 溢出</span><br><span class="line">0100 + 0100 =   1000 --&gt; 只有次高位进位 溢出</span><br><span class="line">1111 + 1100 = 1 1011 --&gt; 符号位和次高位都进位，不溢出</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF-Sign-Flag"><a href="#SF-Sign-Flag" class="headerlink" title="SF: Sign Flag"></a>SF: Sign Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF-Zero-Flag"><a href="#ZF-Zero-Flag" class="headerlink" title="ZF: Zero Flag"></a>ZF: Zero Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF-Carry-Flag"><a href="#CF-Carry-Flag" class="headerlink" title="CF: Carry Flag"></a>CF: Carry Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 进位/借位标志位，表示无符号数的加减法是否发生了进位或借位</span><br><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B</span><br><span class="line">               电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那就需</span><br><span class="line"> 要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10条字选</span><br><span class="line"> 线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内全部</span><br><span class="line">      刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期变为</span><br><span class="line">  1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功耗低</span><br><span class="line">  价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache-缓存"><a href="#Cache-缓存" class="headerlink" title="Cache(缓存)"></a>Cache(缓存)</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><p><em>思考一个问题？如何确定将主存中的数据搬到Cache中后，数据在Cache中的存放位置？这就需要一个具体的映射方式来确定，一个主存地址中的数据在Cache中的存储位置</em></p><p><strong>*地址映射</strong>：地址映射是一种规则，它指明了把主存地址空间映射到Cache地址空间所用的规则，即把存放在主存中的程序按照某种规则装入Cache。，由Cache的块数比主存块数少得多，因此需要加入主存字块标记和字块内地址*</p><p><strong>*地址变换</strong>：地址变换是一个过程，它是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始</span><br><span class="line">都为0)如果不加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位</span><br><span class="line">表示块号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要</span><br><span class="line">6bit位表示--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221529841.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一快的副本。</em></li><li><em>字块内地址：由于Cachei块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit位就对应表示Cache中的块号</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221530376.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一块的副本。</em></li><li><em>Cache:字块地址：指明存放在Cache中的哪个Cache块。</em></li><li><em>字块内地址：由于Cache块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221531760.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中那一块的副本。</em></li><li><em>组地址：指明存放在Cache中的哪个Cache块的组。</em></li><li><em>字块内地址：由于Cche块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></li></ul><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">- 当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><ul><li><em>有效位：1bit 用于判断该数据是否有效</em></li><li><em>脏位：1bit 用于标记Cache中数据是否被修改过</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块</span><br><span class="line">中，因此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主</span><br><span class="line">存块大小相等)因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑页号对应，所以出现了一个映射表，存储</span><br><span class="line">块号与页号的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;10 转换地址 000001(操作码) 10(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺序编</span><br><span class="line"> 址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表示SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br><span class="line">&gt;快表TLB ,相当于主存与外存之间的&quot;Cache&quot;用于存放外存中页表的副本</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><hr><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h3 id="高速缓冲存储器-Cache-习题"><a href="#高速缓冲存储器-Cache-习题" class="headerlink" title="高速缓冲存储器(Cache)习题"></a>高速缓冲存储器(Cache)习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221203457.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221209136.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221219813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221351133.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221353099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221455353.png" alt="image.png"></p><p>*128KB/16B = 8K(块)=2^13(块)，组相连映射，每组8块，所以2^13/8=2^10(组)，—&gt;10bit表示Cache内组号</p><p>主存地址1234567H —&gt;说明主存地址共4x7=28位，28-10-4=14(主存字块标记位数)*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221542461.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221604202.png" alt="image.png"></p><p><em>逻辑地址与物理地址区别就是页号不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221642813.png" alt="image.png"></p><p><em>Cache容量计算：数据部分+控制部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221650066.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222021823.png" alt="image.png"></p><p><em>没有告诉主存地址位数,只知道地址号数<br>通过逻辑右移·取余数得到低位部分数<br>就可得如组号是多少了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221659922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221710825.png" alt="image.png"></p><p><em>Cache一次缺失，就需要将一个主存块替换进Cache里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221701004.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221705615.png" alt="image.png"></p><p><em>1.做这题第一眼，忽略了写命中也要算进去<br>2.这里k=1000刚好是4的倍数，，因为一个块16B,可以存4个数组元素，所以替换到Cache中的数组都可以访问到不会遗漏，所以可以根据每8次缺失1次算<br>3.当k=10,时，只能访问到a[9],剩余替换到Cache块中的a[10],a[11]不会访问到，所以要按实际情况计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222004782.png" alt="image.png"></p><p>*时间局部性：一条指令一旦被执行，在不久的将来可能会再次执行<br>典型代表：循环指令</p><p>空间局部性：一旦一个存储单元被访问，那么它附近的存储单元也很快被访问典型代表：数组，顺序指令*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222013840.png" alt="image.png"></p><p><em>比较器的作用：用于判断需要取的数据是否在Cache中已存在<br>1.由于一次存取只能存取一个数据，故一次存取先根据主存地址中的Cache组号，确定数据所在Cache组（一组8个Cache块）<br>2.在根据主存地址标志位tag(用于确定对应的主存块号)，通过比较器将目的tag位，与该组中所有Cache块中存储的数据的tag位进行比对，如果匹配成功，说明Cache命中<br>3.所以比较器是用在确定组号之后，比较组内所有块的tag位，所以组内有8块，就需要8个比较器，tag位有20位，比较器位数就需要20位</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222036946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222048277.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222054958.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222059557.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222116123.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222121516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222132157.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154250.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154018.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222153389.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222208624.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217240.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222219607.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217728.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231216744.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231307226.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231314918.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231319447.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231321170.png" alt="image.png"><br><em>本题要点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231323044.png" alt="image.png"></p><p><em>(1)(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231339697.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231340569.png" alt="image.png"><br><em>(4)</em><br>*修改页面，是指改完主存中的内容后，再将主存中修改的内容写到辅存(外存)</p><p>Cache直写，是一并将修改写入Cache和主存，就是全写法，通过写缓冲实现*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231343247.png" alt="image.png"></p><p><em>LRU标记位需要3bit,用于标记各个块被访问的先后顺序，由于每个分组内只有8个块，先后顺序无非1~8，所以3bit位标记先后顺序即可</em><br><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231353841.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406025.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406198.png" alt="image.png"></p></blockquote><h3 id="虚拟存储器-1"><a href="#虚拟存储器-1" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码 </span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr><h3 id="汇编语言的考试要求"><a href="#汇编语言的考试要求" class="headerlink" title="汇编语言的考试要求"></a>汇编语言的考试要求</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111601729.png" alt="image.png"></p><h3 id="X86汇编语言基础"><a href="#X86汇编语言基础" class="headerlink" title="X86汇编语言基础"></a>X86汇编语言基础</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是X86?</span><br><span class="line">1978年Intel公司生产了一块CPU芯片代号8086，</span><br><span class="line">之后就出现了80286、80386等一系列86结尾的型号的CPU，都兼容之前的CPU，能够将程序</span><br><span class="line">移植到新的CPU执行。因此X86汇编语言指令，是指能够被这一系列CPU处理的汇编语言指</span><br><span class="line">令</span><br></pre></td></tr></table></figure><hr><h4 id="以mov指令为例"><a href="#以mov指令为例" class="headerlink" title="以mov指令为例"></a>以mov指令为例</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111617341.png" alt="image.png"><br>s-&gt;source-&gt;源操作数<br>d-&gt;destination-&gt;目标操作数<br><code>mov d , s</code>-&gt;将源操作数s复制到目的操作数d所指的位置</p><p>mov指令常用格式有一下几种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111619250.png" alt="image.png"><br>其中当指明的是内存地址的时候，通过dword ptr(双字)、word ptr(单字)、byte ptr(字节)<br>来指明需要读写的长度</p><hr><h4 id="X86CPU有哪些寄存器"><a href="#X86CPU有哪些寄存器" class="headerlink" title="X86CPU有哪些寄存器"></a>X86CPU有哪些寄存器</h4><ul><li>X 结尾：通用寄存器</li><li>I 结尾 ：变址寄存器</li><li>P结尾：堆栈寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111633315.png" alt="image.png"></li></ul><ul><li>寄存器都以E开头，E-&gt;Extenden=32bit，</li><li>对于通用寄存器而言如果指向使用低位的16bit，那么可将E 去掉</li><li>变地址寄存器和堆栈寄存器都不能去掉E ,只能固定使用32bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111638172.png" alt="image.png"></p><hr><h4 id="源、目的-操作数书写格式"><a href="#源、目的-操作数书写格式" class="headerlink" title="源、目的 操作数书写格式"></a>源、目的 操作数书写格式</h4><ul><li>[寄存器] 是指寄存器里所存的地址所指向的数据，相当于寄存器间接寻址</li><li>[地址/寄存器] 前没有指明读学长度时，默认32bit</li><li>[af996-12 h]-&gt;最后h表示16进制，这样写是指地址af886往前偏移12位地址所指数据</li><li>[abx +8]-&gt;是指该寄存器内地址往后+8的主存地址所指向的数据<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111642835.png" alt="image.png"></li></ul><hr><h4 id="常见的算数运算指令"><a href="#常见的算数运算指令" class="headerlink" title="常见的算数运算指令"></a>常见的算数运算指令</h4><ul><li>乘法 mul d,s -&gt; 表示无符号数d * s,乘积存入d</li><li>乘法 imul d,s -&gt; 表示有符号数d * s,乘积存入d</li><li>除法 div s -&gt;无符号数除法，被除数会提前存放在edx:eax中<br>  -&gt;edx:eax表示两个寄存器拼接将被除数从原来的32bit扩展为64bit ;<br>  -&gt;商存入eax,余数存入edx中</li><li>除法 idiv s -&gt;有符号数除法，被除数会提前存放在edx:eax中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111737632.png" alt="image.png"></li></ul><hr><h4 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111750543.png" alt="image.png"></p><hr><h4 id="s、d操作数"><a href="#s、d操作数" class="headerlink" title="s、d操作数"></a>s、d操作数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于X86系统，指令后面的两个操作数不允许两个都来自主存&lt;mem&gt;</span><br><span class="line">2.并且，目的操作数d 不能是常数&lt;con&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172215148.png" alt="image.png"></p><hr><h4 id="AT-amp-T格式指令与Intel格式指令区别"><a href="#AT-amp-T格式指令与Intel格式指令区别" class="headerlink" title="AT&amp;T格式指令与Intel格式指令区别"></a>AT&amp;T格式指令与Intel格式指令区别</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111800835.png" alt="image.png"></p><ul><li>基址+变址 <em> 比例因子+偏移量<br>用于结构体数组内信息的寻址<br>基地址-&gt;寻找数组起始地址<br>变址 </em> 比例因子-&gt;寻找目标元素在数组内的位置<br>偏移量-&gt;寻找目标信息在该元素内的具体位置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111806568.png" alt="Uploading file...npg0j"></li></ul><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><hr><h4 id="jmp指令与cmp指令"><a href="#jmp指令与cmp指令" class="headerlink" title="jmp指令与cmp指令"></a>jmp指令与cmp指令</h4><p><strong>1.程序中选择分支结构</strong></p><ul><li>程序计数器PC又被称为IP寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112305940.png" alt="image.png"></li></ul><hr><p><strong>2.无条件跳转指令—Jmp</strong></p><p>执行该条指令PC会无条件跳转到某个主存地址，执行那个地址的指令</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317121.png" alt="image.png"></p><p>无条件跳转指令格式 -&gt; jmp &lt;地址&gt; </p><ul><li>jmp 128 -&gt;跳转到地址128</li><li>jmp eax -&gt; 地址来自于寄存器</li><li>jmp [999] -&gt;地址来自于主存地址999中存的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317178.png" alt="image.png"></li></ul><hr><p><strong>3.jmp跳转标记位格式</strong></p><pre><code>因为写程序的时候，例如if-else分支语句的时候，通过条件判断决定跳转执行那一条程序语句，这样就有一个问题，如果都采用上面的三种jmp跳转指令--需要先知道需要跳转的程序的主存地址(jmp 116)，这样写死了地址，很不灵活，一旦程序的主存地址一改变，原有的jmp指令就会跳转错误位置，所以就可以通过对需要跳转的语句做标记NEXT ,通过jmp NEXT 的跳转方式实现跳转</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112330386.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112332972.png" alt="image.png"></p><hr><p><strong>4.条件转移指令-jxxx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112334438.png" alt="image.png"></p><p>通常使用条件跳转指令前，需要使用cmp指令。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336192.png" alt="image.png"></p><p>所以cmp指令经常和条件跳转指令搭配使用。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336184.png" alt="image.png"></p><hr><p><strong>5.cmp指令的底层原理</strong></p><p>本质上就是对a,b两个操作数镜像减法运算a-b,并生成了OF、ZF、CF、SF四个标志位信息<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112339041.png" alt="image.png"></p><p>ALU 每进行一次运算的标志位都会自动存入<br>PSW程序状态字寄存器中(Intel称它为“标志寄存器FR”)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112341179.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340390.png" alt="image.png"></p><p>jxxx指令，就是根据cmp指令得到的标志位，来判断是否= &lt;  &gt; ！=<br>进而决定进行跳转<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112345836.png" alt="image.png"></p><hr><h4 id="条件转移指令jmp实现循环"><a href="#条件转移指令jmp实现循环" class="headerlink" title="条件转移指令jmp实现循环"></a>条件转移指令jmp实现循环</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142216499.png" alt="image.png"></p><hr><h4 id="loop指令实现循环"><a href="#loop指令实现循环" class="headerlink" title="loop指令实现循环"></a>loop指令实现循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 指令：</span><br><span class="line">- 格式loop Looltop  // ecx-- ,若ecx!=0,跳转到Looptop</span><br><span class="line">- 只能用ecx作为循环计数器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142229529.png" alt="image.png"></p><hr><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><h4 id="call、leave、ret指令"><a href="#call、leave、ret指令" class="headerlink" title="call、leave、ret指令"></a>call、leave、ret指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call、leave、ret指令实现函数调用：</span><br><span class="line">call 指令 作用：</span><br><span class="line">1.将IP旧址压栈保存(保存在当前函数的栈帧顶部)</span><br><span class="line">2.设置新的IP值，无条件转移到被调用函数的第一条指令</span><br><span class="line">leave 指令 作用：</span><br><span class="line">1.将现在的函数的栈帧撤销，相当于将该函数弹栈</span><br><span class="line">ret 指令 作用：</span><br><span class="line">1.弹栈后，从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP原有的值指向回原来位</span><br><span class="line">置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142240959.png" alt="image.png"></p><hr><h4 id="如何访问栈帧里的数据？"><a href="#如何访问栈帧里的数据？" class="headerlink" title="如何访问栈帧里的数据？"></a>如何访问栈帧里的数据？</h4><h5 id="访问栈帧数据Push和Pop指令"><a href="#访问栈帧数据Push和Pop指令" class="headerlink" title="访问栈帧数据Push和Pop指令"></a>访问栈帧数据Push和Pop指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ebp和esp：</span><br><span class="line">ebp指向当前栈帧的底部，esp指向当前栈帧的顶部，两者标记了当前栈帧的一个范围</span><br><span class="line">ebp、esp存的是地址不是数据值，ebp和esp只是一个指针</span><br><span class="line"></span><br><span class="line">Push、Pop指令实现入栈出栈操作操作，X86默认以4字节为单位：</span><br><span class="line">格式:</span><br><span class="line">Push ?  //先让esp-4，在将数据压入</span><br><span class="line">Push eax   #将寄存器eax的值压栈</span><br><span class="line">Push 985   #将立即数985压入栈中</span><br><span class="line">Push [ebp+8] #将主存地址[ebp+8]的数据压栈</span><br><span class="line">(所谓压栈是指将esp里保存的地址，所指向的数据的值修改,然后esp-4)</span><br><span class="line">Pop ?  //栈顶元素出栈并写入&lt;寄存器/主存地址&gt;，在esp+4</span><br><span class="line">Pop eax   # 将栈顶元素出栈，写入寄存器eax</span><br><span class="line">Pop [ebp+8] # 将栈顶元素出栈，并写入主存地址[ebp+8]</span><br><span class="line">(所谓出栈是指,将esp保存的地址所指向的值写入?,然后esp+4)</span><br><span class="line">问题： </span><br><span class="line">这样访问栈帧数据不灵活，因为每次Push都只能往esp+4的位置Push(压入数据)</span><br><span class="line">每次Pop也只能一次弹出一个栈顶元素，并写入一个栈顶栈顶元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151025134.png" alt="image.png"></p><hr><h5 id="访问栈帧数据mov指令"><a href="#访问栈帧数据mov指令" class="headerlink" title="访问栈帧数据mov指令"></a>访问栈帧数据mov指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以直接对esp进行加减运算：</span><br><span class="line">可以使用减法/加法，即sub/add修改栈顶指针esp的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151046206.png" alt="image.png"></p><hr><h4 id="如何切换栈帧？"><a href="#如何切换栈帧？" class="headerlink" title="如何切换栈帧？"></a>如何切换栈帧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.先执行call指令：</span><br><span class="line">1.将当前IP(取出call之后自动指向下一条)值，相当于 Push IP</span><br><span class="line">2.将IP设置为被调用函数的第一条指令地址, 相当于jmp add</span><br><span class="line"></span><br><span class="line">2.进入目标函数后：&lt;保存上一个函数的栈帧，并设置当前函数栈帧&gt;</span><br><span class="line">1.Push ebp --&gt;将前一个函数的栈底地址保存入栈(先esp+4,然后将ebp值压入)</span><br><span class="line">2.mov ebp esp --&gt; 将esp的地址值复制给ebp,使ebp指向另一个函数的栈底地址</span><br><span class="line"> ==&gt; 1+2等价于enter指令</span><br><span class="line"> </span><br><span class="line">3.一系列逻辑处理</span><br><span class="line"></span><br><span class="line">4.恢复上一层函数的栈帧：</span><br><span class="line">1.mov esp ebp --&gt; 让esp指向当前函数栈底</span><br><span class="line">2.Pop ebp --&gt; 将栈顶元素出栈，并写入ebp(ebp重新指回上一个函数基底)</span><br><span class="line"> ==&gt; 等价于leave指令</span><br><span class="line">5.ret指令：</span><br><span class="line">从栈顶找到返回的地址(原来基础上继续执行)，出栈并将值写到IP寄存器中，使其继续执</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><code>调用函数</code></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151109099.png" alt="image.png"></p><p><code>函数返回</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151130458.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151214922.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151105535.png" alt="image.png"></p><hr><h4 id="如何传递参数和返回值？"><a href="#如何传递参数和返回值？" class="headerlink" title="如何传递参数和返回值？"></a>如何传递参数和返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈帧最底部(基址)一定是上一层栈帧的基址</span><br><span class="line"></span><br><span class="line">栈帧的最顶部，一定是IP的返回地址(当前栈帧除外)</span><br><span class="line"></span><br><span class="line">栈帧结构，分为以下几块区域，每块区域内同时越靠前定义的就越靠近栈顶:</span><br><span class="line">1.局部变量区域</span><br><span class="line"></span><br><span class="line">2.未使用区域</span><br><span class="line">为什么会有未使用区域？</span><br><span class="line">因为gcc编译器会将每个栈帧大小设置为16B的整数倍(当前函数栈帧除外)</span><br><span class="line">当局部变量和调用参数没有填满栈帧时，就会空出未使用的部分</span><br><span class="line">3.调用参数区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172225143.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172137430.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数，返回值</span><br><span class="line">传低参数：在call指令前，将调用参数写入栈帧顶部区域</span><br><span class="line">接收返回值：在执行ret指令前将函数返回值写入eax寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172234781.png" alt="image.png"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CISC: Complex Instruction Set Computer(复杂指令集)</span><br><span class="line">- 通过一条指令完成复杂的基本功能，所以，它的指令往往是变长的</span><br><span class="line">- 变长，这也决定了它的指令执行效率低，因为需要花时间判断该指令的长度</span><br><span class="line">- 像是前面提到的乘法指令 000100 0000000110 只通过乘法指令就可以进行访存，所以</span><br><span class="line">  CISC指令对指令的访存权限没有限制</span><br><span class="line">- 由于随着CISC指令变得越来越复杂，很难用一个专门的电路硬件来实现，所以&quot;存储程</span><br><span class="line">  序&quot;，就是事先将几条组合指令存储在某个地方，比如要实现矩阵的乘法--&gt;可以通过</span><br><span class="line">  矩阵的加法、减法;整数加法、减法、乘法，5个比较通用的电路之间配合使用来实现复</span><br><span class="line">  杂的矩阵乘法</span><br><span class="line">RISC: Reduced Instruction Set Computer(精简指令集)</span><br><span class="line">- 一条指令只完成一个基本动作，一条指令一个电路</span><br><span class="line">- 由于电路设计简单功耗更低，所以主要用于移动设备:手机、平板等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172336854.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSIC:</span><br><span class="line">1.寄存器数量少，因为可以访存的指令没有限制，可以直接从主存中存取，不会过多的占</span><br><span class="line">  用寄存器的数量</span><br><span class="line">2.难以用优化编译生成高效的目标代码程序，因为，CISC本身就是一个复杂体，又胖又无</span><br><span class="line"> 法切割重组，决定了其效率的上限很低</span><br><span class="line"></span><br><span class="line">RISC:</span><br><span class="line">1.寄存器数量多，因为，可以访存的指令只有Load/Stroe，所以进行计算等操作的时候，</span><br><span class="line">  只能通过寄存器来存放数据，最后再通过Load/Stroe指令来进行写入或删除</span><br><span class="line">2.指令精简，可以很大程度上重组功能，生成更高效的代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172340404.png" alt="image.png"></p><h1 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041138990.png" alt="image.png"></p><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a><em>CPU的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032012738.png" alt="image.png"></p><h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a><em>运算器和控制器的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032026718.png" alt="image.png"></p><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a><em>运算器的基本结构</em></h3><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个寄存器与ALU之间都有专门的单独的数据通路--&gt;称为专用数据通路</span><br><span class="line">下图所示，所有寄存器与ALU都直接相连，但是我们不需要同时有这么多寄存器同时输入数据</span><br><span class="line">以下有两种解决办法:1.多路选择器;2.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032116421.png" alt="image.png"></p><blockquote><p><em>多路选择器</em></p></blockquote><p><em>使用多路选择器根据控制信号选择一路输出</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032113430.png" alt="image.png"></p><blockquote><p><em>三态门</em></p></blockquote><p>计算机里面<strong>1 0</strong> 分别表示 <strong>是  非</strong> 两种逻辑，但是还不够，因此引入了一种新的状态——<strong>高阻态</strong>(相当于电阻无穷大，断路状态)。</p><p>三态：高电平、低电平、高阻态。</p><p>三态门主要与总线连接，因为总线在同一时间内只能对一个设备有效。<br>通常在数据总线上连接有<strong>多个器件</strong>。同一时刻只能有一个设备选通，用于数据传输；其他设备处于高阻态(断开)。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032142905.png" alt="image.png"></p><p>EN使能信号：<br>    EN是<strong>0信号</strong>表示数据从A-&gt;B ;<strong>1信号</strong>表示数据从B-&gt;A；当EN使能信号无效时(没有产生信号)处于高阻态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032148055.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032150494.png" alt="image.png"></p><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将所有寄存器的输入端和输出端都连接到一条公用的通路上(CPU内部总线)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032203518.png" alt="image.png"></p><p><strong>引入暂存寄存器</strong><br><em>从这开始内部总线就只能同时有一个输入信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032207030.png" alt="image.png"></p><p><strong>为了避免输入信号还没稳定的时候就发出输出信号，在ALU后面再引入一个暂存寄存器+一个三态门</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当输入信号稳定前，期间产生的输出信号被存放在暂存器中(此时三态门没有导通);</span><br><span class="line">当输入信号稳定之后，(三态门接通)最终产生的输出信号才传输到CPU内部总线</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032209466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032216449.png" alt="image.png"></p><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032229276.png" alt="image.png"></p><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041129708.png" alt="image.png"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041136632.png" alt="image.png"></p><hr><h2 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><strong>CPU从主存中每取出并执行一条指令所需的全部时间</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041154511.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041200018.png" alt="image.png"></p><h3 id="数据流-微操作-有效信号"><a href="#数据流-微操作-有效信号" class="headerlink" title="数据流(微操作+有效信号)"></a>数据流(微操作+有效信号)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041429770.png" alt="image.png"><br><strong>注意书写数据流的时候需要写出——&gt; 微操作 + 有效控制信号</strong></p><hr><blockquote><p><em>指令周期的数据流向-取指周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041216231.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-间址周期</em></p></blockquote><p><strong>Ad(MDR) -&gt; MAR</strong> 中Ad 表示的是将MDR数据(取得的指令)中的<code>地址码部分</code>放入MAR中<br><strong>Ad(IR) -&gt; MAR</strong> 中Ad表示的也是将IR数据(取得的指令)中的<code>地址码部分</code>放到MAR中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041238584.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-执行周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041412833.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-中断周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041428150.png" alt="image.png"></p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041435747.png" alt="image.png"></p><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041434691.png" alt="image.png"></p><h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据通路的基本结构有:</span><br><span class="line">1.CPU内部单总线方式</span><br><span class="line">所有CPU部件连接一根内部总线，同时只能一组部件数据交换(一个发出，一个接收)</span><br><span class="line">2.CPU内部多总线方式</span><br><span class="line">为了解决同时只能有一组部件进行数据交换，所以提出CPU内部多总线，所有部件与这些</span><br><span class="line">多根总线都有连接，同时可以支持n组部件数据交换(n是总线根数)</span><br><span class="line">3.专用数据通路方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041936960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041935158.png" alt="image.png"></p><h3 id="数据通路-CPU内部单总线方式"><a href="#数据通路-CPU内部单总线方式" class="headerlink" title="数据通路-CPU内部单总线方式"></a>数据通路-CPU内部单总线方式</h3><blockquote><p><em>完成一次加法运算，完整的数据通路(单总线方式)</em></p></blockquote><p>由于这是单总线方式，一次只能有一组部件传输数据(例如 (ACC)-&gt;Bus-&gt;ALU  实现ACC和ALU之间的 <strong>被加数</strong>传输，<strong>加数</strong>只能先通过MDR-&gt;Bus-&gt;Y 存放在暂存寄存器中)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042005863.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>取指周期过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042040431.png" alt="image.png"></p><p>间址周期过程(省略微操作)：<br>    1.R0out  ,MARin 控制信号有效 -&gt;R0内间接地址传送到MAR<br>    2.MemR ,MARout ,MDRinE 控制信号有效 -&gt; 根据间接地址得到的直接地址EA存入MDR<br>    3.MDRout ,MARin 控制信号有效 -&gt;EA传给MAR<br>    4.MARout ,MemR ,MDRinE 控制信号有效 -&gt; 根据EA找到的操作数()存入MDR<br>    5.MDRout ,Yin 控制信号有效 -&gt; 将目的操作数((R0))放入暂存寄存器Y中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137539.png" alt="image.png"></p><p>执行周期过程(省略微操作):<br>    1.R1out , ALUin ,CU向ALU发送加法操作信号, 控制信号有效 -&gt;将源操作数送入ALU运算(Y寄存器同时会将之前暂存的目的操作数通过专用数据通路送往ALU)<br>    2.Zout ,MDRin 控制信号有效 -&gt; 将计算结果送入MDR寄存器<br>    3.MemW ,MDRoutE ,MARout -&gt; MDR将计算结果送到主存，MAR目的操作数地址传给主存，主存根据MAR中已经存在的目的操作数的有效地址，将结果写回到目的操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137717.png" alt="image.png"></p><h3 id="数据通路-专用数据通路方式"><a href="#数据通路-专用数据通路方式" class="headerlink" title="数据通路-专用数据通路方式"></a>数据通路-专用数据通路方式</h3><blockquote><p><em>专用数据通路-取指周期</em></p></blockquote><p>取指周期数据流向:<br>    <em>1</em>. (PC)-&gt;MAR                 C0有效<br>    <em>2</em>. (MAR) -&gt;主存             C1有效<br>    <em>3</em>. 1-&gt;R                          控制单元向主存发送读命令<br>    <em>4</em>.  M(MAR) -&gt; MDR      C2有效<br>    <em>5.</em>  (MAR) -&gt; IR              C3有效<br>    <em>6.</em>  (PC)+1-&gt;PC<br>    <em>7.</em>  Op(IR) -&gt;CU             C4有效【Op是操作码，Ad是地址码；将操作码传给CU分析】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042219807.png" alt="image.png"></p><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="硬布线控制器（组合逻辑控制器）"><a href="#硬布线控制器（组合逻辑控制器）" class="headerlink" title="硬布线控制器（组合逻辑控制器）"></a>硬布线控制器（组合逻辑控制器）</h3><h4 id="什么是硬布线控制器？"><a href="#什么是硬布线控制器？" class="headerlink" title="什么是硬布线控制器？"></a><em>什么是硬布线控制器？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070922995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070924177.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070930551.png" alt="image.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a><em>硬布线控制器的设计</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070934082.png" alt="image.png"></p><blockquote><p><em>1.分析每个阶段的微操作序列</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070935646.png" alt="image.png"></p><p><em>2.选择CPU的控制方式</em><br><strong>这里采用同步控制方式(定长机器周期)—&gt;一个周期安排3个节拍</strong></p><p><em>3.安排微操作时序</em></p><p><strong>取指周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070943155.png" alt="image.png"><br><strong>间址周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070946256.png" alt="image.png"><br><strong>执行周期</strong><br><em>访存指令STA 、ADD 、LDA<br>非访存指令<br>转移指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070945614.png" alt="image.png"></p><p><em>4.电路设计</em><br><strong>a.列出操作时间表</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951515.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952398.png" alt="image.png"><br><strong>b.写出微操作命令的最简表达式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070948343.png" alt="image.png"><br><strong>c.画出逻辑图</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951629.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062351469.png" alt="image.png"></p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><h4 id="什么是微程序控制器？"><a href="#什么是微程序控制器？" class="headerlink" title="什么是微程序控制器？"></a>什么是微程序控制器？</h4><blockquote><p><em>为了方便修改和扩展，提出了微程序控制器</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071919688.png" alt="image.png"></p><ul><li>微命令是控制部件向执行部件发出的控制信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CPU内的控制器包含:CU IR PC</span><br><span class="line">CU控制单元用于实现微指令的执行</span><br><span class="line">1.由于CM内存储了多种指令 的 微程序,所以“微地址形成部件”需要根据IR内具体</span><br><span class="line">的指令的操作码，判断该指令对应CM内哪个微程序，以获得其&quot;起始微地址&quot;</span><br><span class="line">  (改正一下表述:所谓微程序既可以说是一条完整指令，包括取指周期、间址周</span><br><span class="line">  期、执行周期、中断周期的所有微指令的总和;也可以说单独的某个周期的微程</span><br><span class="line">  序，例如:取指周期微程序，这里“微地址形成部件，的作用是在根据IR中的操作</span><br><span class="line">  码特征，分析执行周期的微程序的微指令首地址，而不是取指周期微指令首地址</span><br><span class="line">  因为取指周期是通用的它的地址可以由执行周期中最末尾的微指令的下地址指</span><br><span class="line">  明，而执行周期的微指令不是通用的，所以需要单独通过“微地址形成部件”，来</span><br><span class="line">  获得首地址)</span><br><span class="line">2.再根据&quot;顺序逻辑&quot; 中&quot;标志&quot;信息判断下一步要执行微指令的存放地址(一般标志</span><br><span class="line">信息是根据指令地址码(IR中的地址码)的特征，判断是否要进行间址周期，无需间</span><br><span class="line">接寻址就跳过间址周期微指令;如果要间接寻址,那么按照“CMDR中的下地址”顺序执</span><br><span class="line">行下去)</span><br><span class="line">3.CMAR接收来自经过顺序逻辑处理后的“起始微地址”</span><br><span class="line">4.CMAR 将地址(微指令地址)送入地址译码器，找到地址对应的微指令在CM中的位</span><br><span class="line">置</span><br><span class="line">5.CM(控制存储器)根据位置取出该条微指令(操作控制+下地址) ,送到CMDR</span><br><span class="line">6.CMDR将微指令的操作控制信息 传至CPU内部和系统总线的控制信号</span><br><span class="line">7.CMDR 将下一条(相邻的)微指令地址传给顺序逻辑(顺序逻辑会根据之前获得的标</span><br><span class="line">志+CLK信息，如果当前执行到了间址周期微指令，会根据标志信息，判断是否跳过)</span><br><span class="line">8.重复这一循环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071924474.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071950460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个微程序包括一条指令的所有周期的微指令，所以一条指令的取指周期微程序+执行周期微程序，其实是一个微程序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071958856.png" alt="image.png"></p><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092240574.png" alt="image.png"></p><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><blockquote><p><em>水平型微指令、垂直型微指令、混合型微指令</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092245360.png" alt="image.png"></p><h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><blockquote><p><em>编码方式</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微指令编码主要方式分为3种</span><br><span class="line">直接编码: </span><br><span class="line">n个微命令-&gt;需要分别对应n个bit信号位</span><br><span class="line">字段直接编码: </span><br><span class="line">采用译码器，将控制字段分段,比如3bit为1段,能产生2^3种不同信号,</span><br><span class="line">这样就能用更少bit存储控制信号。</span><br><span class="line">这样实现，相同字段内的控制信息无法并行进行--&gt;所以互斥信号放在同一字段</span><br><span class="line">字段间接编码:</span><br><span class="line">译码器上加一层译码器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101035576.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101037705.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101047396.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><em>互斥的放在同一段内，控制字段，需要表示的状态数，需要预留一个全0,表示无操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101046382.png" alt="image.png"></p><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><blockquote><p><em>方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101050533.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101053029.png" alt="image.png"></p><h5 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h5><blockquote><p><em>微程序控制单元的设计</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141414952.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141419465.png" alt="image.png"></p><p><em>微程序设计的分类</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141420731.png" alt="image.png"></p><p><em>硬布线与微程序的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421167.png" alt="image.png"></p><p><em>微程序控制器回顾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421854.png" alt="image.png"></p></blockquote><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141625402.png" alt="image.png"></p><h3 id="指令流水线基本概念性能指标"><a href="#指令流水线基本概念性能指标" class="headerlink" title="指令流水线基本概念性能指标"></a>指令流水线基本概念性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141515119.png" alt="image.png"></p><h4 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a><em>指令流水的定义</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141632815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141501856.png" alt="image.png"></p></blockquote><h4 id="流水线表示方法"><a href="#流水线表示方法" class="headerlink" title="流水线表示方法"></a><em>流水线表示方法</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141500715.png" alt="image.png"></p></blockquote><h4 id="流水线的性能指标-—吞吐率、加速比、效率"><a href="#流水线的性能指标-—吞吐率、加速比、效率" class="headerlink" title="流水线的性能指标 —吞吐率、加速比、效率"></a><em>流水线的性能指标</em> —<strong>吞吐率、加速比、效率</strong></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513423.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513840.png" alt="image.png"></p></blockquote><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">完成一条指令，常分为五个阶段:</span><br><span class="line">IF(取指阶段)、ID(译码段)、EX(执行段)、M(访存)、WB(写回)</span><br><span class="line"></span><br><span class="line">由于每个功能段需要消耗时间不一致，为了统一方便指令流水线，以最长耗时为准这里就设为100ns</span><br><span class="line"></span><br><span class="line">同时就需要在每个功能段后面加一个缓冲寄存器--&gt;锁存器</span><br><span class="line">目的是为了保证执行更快的阶段，将数据存放，处于缓冲等待的状态，以维持统一</span><br><span class="line"></span><br><span class="line">Instruction Cache(指令Cache)--也就是Cache中存放指令的区域</span><br><span class="line">取指一般都是在指令Cache中取指</span><br><span class="line"></span><br><span class="line">Data Cache(数据Cache)--也就是Cache数据区域</span><br><span class="line">M访存，当Cache命中的情况下，直接访问数据Cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142119460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考试中常见的指令有五类(RSIC精简指令集)</span><br><span class="line">运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142127965.png" alt="image.png"></p><h4 id="各类指令的执行过程"><a href="#各类指令的执行过程" class="headerlink" title="各类指令的执行过程"></a>各类指令的执行过程</h4><h5 id="运算类指令执行过程"><a href="#运算类指令执行过程" class="headerlink" title="运算类指令执行过程"></a>运算类指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142135940.png" alt="image.png"></p><h5 id="LOAD指令执行过程"><a href="#LOAD指令执行过程" class="headerlink" title="LOAD指令执行过程"></a>LOAD指令执行过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD--取数指令，RSIC指令集中唯二可以访存的指令,作用是从主存取数到寄存器中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142144944.png" alt="image.png"></p><h5 id="STORE指令执行过程"><a href="#STORE指令执行过程" class="headerlink" title="STORE指令执行过程"></a>STORE指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142150614.png" alt="image.png"></p><h5 id="条件转移指令执行过程"><a href="#条件转移指令执行过程" class="headerlink" title="条件转移指令执行过程"></a>条件转移指令执行过程</h5><p><strong>WrPC逻辑上既不属于M段，也不属于WB段，只是因为WrPC所需要的功能部件与这5个阶段的功能部件是“相互独立的”，所以可以看做一个独立的阶段，可以自由安排</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142157041.png" alt="image.png"></p><h5 id="无条件转移指令执行过程"><a href="#无条件转移指令执行过程" class="headerlink" title="无条件转移指令执行过程"></a>无条件转移指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142205108.png" alt="image.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207049.png" alt="image.png"></p><h3 id="指令流水线的影响因素"><a href="#指令流水线的影响因素" class="headerlink" title="指令流水线的影响因素"></a>指令流水线的影响因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142243130.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142245235.png" alt="image.png"></p><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p><em>这里三地址指令的顺序搞错了，顺序应该是OP R1 R2 R3  —&gt; (R1)OP(R2)—&gt;R3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142254264.png" alt="image.png"></p><blockquote><p><em>硬件阻塞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142257185.png" alt="image.png"><br><em>NOP空操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142256095.png" alt="image.png"><br><em>数据旁路技术</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142308675.png" alt="image.png"></p></blockquote><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><em>由于指令会提前预取，如果到时候需要进行条件转移，那么之前预取的指令就不会执行，浪费导致阻塞</em><br><em>解决办法就是尽早的判别是否需要跳转</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151112357.png" alt="image.png"></p><h3 id="指令流水线分类"><a href="#指令流水线分类" class="headerlink" title="指令流水线分类"></a>指令流水线分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151115488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151120957.png" alt="image.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151125637.png" alt="image.png"></p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127336.png" alt="image.png"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127292.png" alt="image.png"></p><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151153767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151258121.png" alt="new.png"></p><blockquote><p><em>SISD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453525.png" alt="image.png"></p><p><em>SIMD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453930.png" alt="image.png"></p><p><em>MIMD</em></p><p><strong>共享存储多处理器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454475.png" alt="image.png"><br><strong>多计算机系统</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454095.png" alt="image.png"></p><p><em>向量处理器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151455393.png" alt="image.png"></p></blockquote><h2 id="硬件多线程的基本概念"><a href="#硬件多线程的基本概念" class="headerlink" title="硬件多线程的基本概念"></a>硬件多线程的基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504162.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504522.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151505623.png" alt="image.png"></p><h2 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h2><h3 id="CPU的功能与结构习题"><a href="#CPU的功能与结构习题" class="headerlink" title="CPU的功能与结构习题"></a>CPU的功能与结构习题</h3><blockquote><p><em>PSW属于运算器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161825605.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161834865.png" alt="image.png"></p><p><em>指令寄存器就是IR</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161835516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161844725.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161846997.png" alt="image.png"></p><p><em>CPU中寄存器分为用户可见，和不可见</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161847536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161853622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161854165.png" alt="image.png"></p><p><em>存储字长—假如内存按照字节寻址，则内存中一个地址对应1byte,存储字长就是1byte</em><br><em>机器字长—CPU一次性能处理的数据的最大位数，往往等于运算器中寄存器的位数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161856909.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162105859.png" alt="image.png"></p><p><em>地址译码器属于主存，是将地址信号翻译成存储器的选通信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162111498.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162129014.png" alt="image.png"></p><p><em>如果指令字按字边界对齐，那么可以按一个机器字(这里是32bit=4B)，占一个地址。所以，本来按字节编址需要32位，那么按字编址，就只需30位</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162132028.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162201928.png" alt="image.png"></p></blockquote><h3 id="指令执行过程习题"><a href="#指令执行过程习题" class="headerlink" title="指令执行过程习题"></a>指令执行过程习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162204207.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162208016.png" alt="image.png"></p><p><em>需要存取的指令地址信息，追根究底来自于PC</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162215113.png" alt="image.png"></p><p><em>机器周期—取决于访存时间—&gt;存取周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172057737.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172103654.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172106455.png" alt="image.png"></p><p><em>1.取指操作是控制器固有的功能，不需要操作码控制</em><br><em>2.指令有长有短，当指令过长占两个存储字长时，就需要两次访存</em><br><em>3.中断周期，是在当前指令执行完之后才出现</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172110895.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172113362.png" alt="image.png"></p><p><em>冯诺依曼计算机—&gt;同时存储指令和数据，并且统一编址</em><br><em>那吗如何区分取得的二进制串是数据还是指令呢？</em><br><em>1.首先先规定一个指令入口地址，这个地址存放的必定是指令</em><br><em>2.从入口地址取指令，然后根据指令周期的阶段，当进行到执行周期，取的<br>一定是数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172122269.png" alt="image.png"></p><p><em>开中断是指 允许中断</em><br><em>取完空操作指令，PC照样会+1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172154839.png" alt="image.png"></p><p><em>中断周期的前一个周期—&gt;执行周期</em><br><em>中断周期的后一个周期—&gt;下一条指令的取指周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172159620.png" alt="image.png"></p></blockquote><h3 id="数据通路的功能和基本概念习题"><a href="#数据通路的功能和基本概念习题" class="headerlink" title="数据通路的功能和基本概念习题"></a>数据通路的功能和基本概念习题</h3><blockquote><p><em>数据通路是指数据不同功能部件之间传送的路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172205638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172227023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172232124.png" alt="image.png"></p><p><em>CPU内部单总线结构—由于只有一条数据总线，所以切换时钟周期T(节拍时)<br>就需要先释放上一个时钟周期里面微操作所占用的数据通路，才能开始下一个微操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181557135.png" alt="image.png"></p><p><em>举例：一整个完整管道系统(管道+阀门) ，就是一个数据通路(电路+部件)<br>水管就是电路，阀门就是部件(不能存储，是时序逻辑元件)</em><br><em>部件 分为 组合逻辑元件(不能存储，也称操作元件) 和 时序逻辑元件(能存储，也称状态元件)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181603679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181612657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181621484.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181630451.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181631386.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181716181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181719840.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181720622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182056692.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182057675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182058005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182102014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182117697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182112370.png" alt="image.png"></p><p><em>1.该指令，是变址寻址, X是变址寄存器XR ,D是形式地址，所以有效地址是(X)+D,那么，得到有效地址只有1个，也就意味着操作数只有一个，所以是隐含了一个操作数在ACC里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182129217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182147615.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182151182.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182158118.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191121774.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191123723.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191124619.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191128718.png" alt="image.png"></p><p><em>答题要爽快</em><br><em>1.题中M(MAR)-&gt;MDR ,外部总线数据输入到MDR控制信号MDRinE ,图中没有给出，可以不写<br>2.IR，FR(状态字寄存器)都与CU输入端相连<br>3.rd,目的寄存器，rs，源寄存器<br>4.题中声明了数据送到MDR需要5个时钟周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146369.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146756.png" alt="image.png"></p></blockquote><h3 id="控制器的功能和工作原理-1"><a href="#控制器的功能和工作原理-1" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191433576.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191444240.png" alt="image.png"></p><p><em>1.缩短微指令长度，自然可以减少从CM中取指的次数，加快速度</em><br><em>2.增大控制存储器CM容量，会增加对CPU占用率，所以应该是减少CM容量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191447484.png" alt="image.png"></p><p><em>1.控制存储器CM是用的ROM芯片，只读存储器，非易失性存储器，里面的微指令是出厂就设定好的</em><br><em>2.主存是用的DRAM芯片，易失性存储器，关机数据就清空</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191454136.png" alt="image.png"></p><p><em>访存延迟比电路延迟大很多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191502908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191504073.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191550336.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191556007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191627070.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191628996.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191633814.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191636725.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191923360.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191928517.png" alt="image.png"></p><p><em>对于汇编语言程序员可见的寄存器，即是在汇编语言中能出现的寄存器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191930184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191936535.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191952494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191958740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192104787.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192107103.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192115047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192116029.png" alt="image.png"></p></blockquote><h3 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192120189.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192123119.png" alt="image.png"></p></blockquote><h3 id="指令流水线习题"><a href="#指令流水线习题" class="headerlink" title="指令流水线习题"></a>指令流水线习题</h3><blockquote><p><em>流水CPU—时间并行技术<br>RSIC采用的一定是流水CPU，部分CSIC也采用流水CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202134527.png" alt="image.png"></p><p><em>超标量流水线—空间换时间，配置多个相同功能部件，同时处理相同任务</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202140283.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202147772.png" alt="image.png"></p><p><em>m段流水线稳定时，是指，第一条指令完全从头到尾执行完，之后，每隔一个时钟周期，都会有一条指令执行结束，这样的状态就是稳定状态<br>稳定状态平均下来，一个时钟周期，完成一条任务,CPU吞吐能力(单位时间内流水线完成的任务数量)=1条/T ; 等效于m个并行部件CPU吞吐能力</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211139928.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211150637.png" alt="image.png"><br><em>度为4，表示处理机能并行处理4条指令(超标量流水技术)，那么处理20条指令，相当于普通流水线处理20/4=5条指令，过程与上面一致</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211153372.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211200981.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211444035.png" alt="image.png"></p><p><em>1.加入空操作，可以解决所有类型的指令流水线影响因素(结构、数据、控制)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211450269.png" alt="image.png"></p><p><em>数据相关流水线冲突有:<br>RAW(写后读冲突)：在前一条指令还没有写回数据，后面就开始读取该数据<br>WAR(读后写冲突)：在前一条指令对数据还没有开始读，后一条指令就开始写<br>WAW(写后写冲突)：后续指令比前面的指令先进行写数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211512534.png" alt="image.png"></p><p><em>要实现流水线必须将每个功能段时间取为一样长,且按照最长的功能段为标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211513312.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211529027.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211532867.png" alt="image.png"></p><p><em>动态调度技术，就是将能够并行执行，不会造成数据冲突的指令安排调度在同一个周期内完成</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211540142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211603920.png" alt="image.png"></p><p><em>流水段寄存器延时—指令功能段与段(部件与部件)之间需要通过将之前的数据放到寄存器里，传递给后面的功能段(部件)，这里存在一些时间延迟，所以考虑CPU时钟周期，不仅要以最长时间为标准，还需要加上寄存器延时</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211606983.png" alt="image.png"></p><p><em>1.单周期CPU—指令周期不细化分为取指、间址、执行、等等周期，理想状态1个时钟周期就可执行一条指令<br>2.多周期CPU—指令周期细分为取指、间址、执行、中断等多个机器周期，每个机器周期都需要多个时钟周期<br>3.基本流水线—理想状态下，稳定后，隔1个时钟周期就能完成一条指令<br>4.超标量流水线—理想状态下，稳定后，隔一个时钟周期，能完成多条指令，CPI&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211617413.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211635734.png" alt="image.png"></p><p><em>画出流水线时空图、非流水线时空图、指令周期流程图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211700005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211644593.png" alt="image.png"></p><p><em>画出流水线功能段结构图、指令执行过程流水线的时空图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211658332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211659606.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211942581.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211944729.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211948548.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211951115.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212046439.png" alt="image.png"></p><p><em>（1）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212115428.png" alt="image.png"><br><em>（2）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212123922.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212120953.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212127310.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212150355.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159175.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159029.png" alt="image.png"><br><em>（3）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212206954.png" alt="image.png"></p></blockquote><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151633335.png" alt="image.png"></p><h2 id="总线的概念与分类"><a href="#总线的概念与分类" class="headerlink" title="总线的概念与分类"></a>总线的概念与分类</h2><h3 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151634177.png" alt="image.png"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151641836.png" alt="image.png"></p><h4 id="按数据传输格式"><a href="#按数据传输格式" class="headerlink" title="按数据传输格式"></a>按数据传输格式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151644599.png" alt="image.png"></p><h4 id="按总线功能"><a href="#按总线功能" class="headerlink" title="按总线功能"></a>按总线功能</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151646654.png" alt="image.png"></p><blockquote><p><em>重点介绍系统总线- 单总线结构</em></p><p><em>1.单总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151655545.png" alt="image.png"><br><em>2.双总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151701271.png" alt="image.png"></p><p><em>3.三总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151821115.png" alt="image.png"></p><p><em>4.四总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151822640.png" alt="image.png"></p></blockquote><h4 id="按时序控制方式"><a href="#按时序控制方式" class="headerlink" title="按时序控制方式"></a>按时序控制方式</h4><blockquote><p><em>略</em></p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151648934.png" alt="image.png"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p>&gt;<br><em>1.总线的传输周期（总线周期）<br>2.总线时钟周期<br>3.总线的工作频率<br>4.总线的时钟频率<br>5.总线宽度<br>6.总线带宽<br>7.总线复用<br>8.信号线数</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151833607.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834590.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834082.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151838059.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151844178.png" alt="image.png"></p><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Telegram</title>
      <link href="/undefined/fd45428c.html"/>
      <url>/undefined/fd45428c.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python安装</title>
      <link href="/undefined/ae5c380e.html"/>
      <url>/undefined/ae5c380e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg" alt="绘梨衣壁纸_彼岸壁纸.jpg"></p><h1 id="配置python"><a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><hr><ul><li><code>下载好python环境，将文件夹配置到环境变量当中</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355861.png" alt="image.png"></li></ul><ul><li><code>CMD输入python查看版本信息，若显示说明配置成功</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355755.png" alt="image.png"></li></ul><ul><li><code>若不显示，打开CMD窗口，where python查看python安装位置 path查看环境变量配置</code></li><li><code>不显示，而是打开微软商店，需要将变量中的python移到Microsoft上方,或者删除Microsoft环境变量</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355535.png" alt="image.png"></li></ul><h1 id="添加pip"><a href="#添加pip" class="headerlink" title="添加pip"></a>添加pip</h1><hr><p><strong>pip</strong>是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包</p><ul><li>将图中<code>\python311\Script</code>配置到环境变量当中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355943.png" alt="image.png"></li></ul><ul><li><code>查看配置是否成功</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure></li></ul><h1 id="最便捷方式"><a href="#最便捷方式" class="headerlink" title="最便捷方式"></a>最便捷方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装python后，install前勾选pip to path</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令</title>
      <link href="/undefined/3e5cd712.html"/>
      <url>/undefined/3e5cd712.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg" alt="可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="调出远程桌面控制"><a href="#调出远程桌面控制" class="headerlink" title="调出远程桌面控制"></a>调出远程桌面控制</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><p><code>输入ip地址</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352256.png" alt="image.png"></p><h1 id="查看连接过的wifi密码"><a href="#查看连接过的wifi密码" class="headerlink" title="查看连接过的wifi密码"></a>查看连接过的wifi密码</h1><hr><p><code>1.查看历史所有wifi</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure></p><p><code>2.查看指定wifi的密码</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile name=&quot;wifi名&quot; key=clear</span><br></pre></td></tr></table></figure></p><h1 id="查询本机当前ip地址"><a href="#查询本机当前ip地址" class="headerlink" title="查询本机当前ip地址"></a>查询本机当前ip地址</h1><hr><ul><li><code>查看当前局域网ip和其他信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353460.png" alt="image.png"></li></ul><ul><li><code>查看更详细信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353598.png" alt="image.png"></li></ul><ul><li><code>查看当前外网地址</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L ip.tool.lu</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353405.png" alt="image.png"></li></ul><h1 id="ping检测ip地址或服务器网络情况"><a href="#ping检测ip地址或服务器网络情况" class="headerlink" title="ping检测ip地址或服务器网络情况"></a>ping检测ip地址或服务器网络情况</h1><hr><ul><li><code>短暂监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353128.png" alt="image.png"></li></ul><ul><li><code>持续监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名) -t</span><br></pre></td></tr></table></figure></li></ul><h1 id="调出资源监测器"><a href="#调出资源监测器" class="headerlink" title="调出资源监测器"></a>调出资源监测器</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfmon.msc</span><br></pre></td></tr></table></figure><p><code>监测磁盘、网络、CPUz占用率</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353676.png" alt="image.png"></p><h1 id="查看电脑当前所有用户"><a href="#查看电脑当前所有用户" class="headerlink" title="查看电脑当前所有用户"></a>查看电脑当前所有用户</h1><hr><p><code>查看用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354885.png" alt="image.png"></p><p><code>删除用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user 名字 /del</span><br></pre></td></tr></table></figure></p><h1 id="修复丢失或损坏的系统文件"><a href="#修复丢失或损坏的系统文件" class="headerlink" title="修复丢失或损坏的系统文件"></a>修复丢失或损坏的系统文件</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具可以允许用户扫描所有受保护的系统文件，并且检查系统文件的完整性，然后恢复Windows损坏的系统文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(三)</title>
      <link href="/undefined/1db5c403.html"/>
      <url>/undefined/1db5c403.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg" alt="北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jpg"></p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="补码解析"><a href="#补码解析" class="headerlink" title="补码解析"></a>补码解析</h2><hr><ul><li><code>补码</code>：计算机只能加法运算<code>2+(-5)</code>,所以需要补码，补码大小是<code>原码取反+1</code></li><li><p><code>原码</code>：补码取反+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0101     //5的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5    fffffffb </span><br></pre></td></tr></table></figure><p><code>由于X8架构采用的是小端存储</code>：低字节在前(低地址)，高字节在后(高地址) —&gt; <code>fbffffff</code></p></li><li><p><code>补码原码相加</code>：对应位置相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010     //2的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5 </span><br><span class="line"></span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1101     //补码 -3 =2+(-5)  --&gt;依次相加</span><br></pre></td></tr></table></figure></li><li><p>对于有符号数，最高位为1，就是负数</p></li></ul><h2 id="整型不同类型"><a href="#整型不同类型" class="headerlink" title="整型不同类型"></a>整型不同类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">整型类型</th><th style="text-align:center">符号</th><th style="text-align:center">字节</th><th style="text-align:center">整型数范围</th></tr></thead><tbody><tr><td style="text-align:left">基本整型</td><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31~(2^31-1)</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15~(2^15-1)</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:center">long</td><td style="text-align:center">(32位)4;(64位)8</td><td style="text-align:center">-2^31~(2^31-1)或-2^63~(-2^63-1)</td></tr><tr><td style="text-align:left">无符号整型</td><td style="text-align:center">unsigned int</td><td style="text-align:center">4</td><td style="text-align:center">0~2^32-1</td></tr><tr><td style="text-align:left">无符号短整型</td><td style="text-align:center">unsigned short</td><td style="text-align:center">2</td><td style="text-align:center">0~2^16-1</td></tr><tr><td style="text-align:left">无符号长整型</td><td style="text-align:center">unsigned long</td><td style="text-align:center">(32位)4;(62位)8</td><td style="text-align:center">0~(2^32-1)或0~(-2^64-1)</td></tr></tbody></table></div><ul><li><code>有符号数</code>：最高位只表示正负，不代表大小</li><li><code>无符号数</code>：最高位代表大小，不表示正负</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short最小数字：</span><br><span class="line">1000 0000 0000 0000  //补码 -32768 </span><br><span class="line">1000 0000 0000 0000  //原码  32768</span><br></pre></td></tr></table></figure><h2 id="溢出解析"><a href="#溢出解析" class="headerlink" title="溢出解析"></a>溢出解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">32767</span>;   <span class="comment">//01111 1111 1111 1111     32767</span></span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);  <span class="comment">//10000 0000 0000 0000    -32768 </span></span><br><span class="line"><span class="comment">//解决办法是用更大的空间存储</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=a+<span class="number">1</span>;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304111919441.png" alt="image.png"></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><h3 id="浮点数IEE754标准解析"><a href="#浮点数IEE754标准解析" class="headerlink" title="浮点数IEE754标准解析"></a>浮点数IEE754标准解析</h3><hr><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>格式</th><th>SEEEEEEE</th><th>EMMMMMMM</th><th>MMMMMMMM</th><th>MMMMMMMM</th></tr></thead><tbody><tr><td>二进制</td><td>01000000</td><td>10010000</td><td>00000000</td><td>00000000</td></tr><tr><td>十六进制</td><td>40</td><td>90</td><td>00</td><td>00</td></tr></tbody></table></div><ul><li><code>S</code>：符号位1表示正，0表示负</li><li><code>E</code>：指数部分，(指数部分的值规定只能是1到254，不能是全0，全1)，指数部分运算前都要减去127(这是EEE-754的规定)，因为还要表示负指数。这里的<code>10000001</code>转换为十进制数为129,129-127=2，即实际指数部分为2.<code>表示小数部分小数点往后移两位</code></li><li><code>M</code>：小数部分 <code>0010000 00000000 00000000</code> 左边默认省略了一个1，应该是<code>1.0010000 00000000 00000000(二进制数)</code></li></ul><blockquote><p>分析上面浮点数<br>S=0，表示正数<br>E=2^0+2^7-127=129-127=2,表示小数点向后移动两位<br>M=<code>0010000 00000000</code> ，前面默认有个1，<code>1.0010000 00000000 00000000</code><br>因为E，M小数点向后移动两位，<code>100.10000 00000000 00000000</code> =2^2 + 2^-1 =4.5</p></blockquote><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><hr><ul><li>浮点型变量分为单精度（float）型、双精度（double）型</li><li>float的数值范围：<code>2^-126~2^127</code>(因为指数部分值1~254，再减去127，得到的-126~127，也就是二进制位数小数点后126位，到小数点前127位)</li><li>float的精度：<code>6~7位</code></li><li>double数值范围：<code>2^-1022~2^1023</code></li><li>double的精度：<code>15~16位</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们赋给a的值为1.23456789e10,加20后，应该得到的值为1.234567892e10,</span><br><span class="line">但b输出结果却是b=12345678848.000000,变得更小了。我们将这种现象称为精度丢失，因</span><br><span class="line">为float型数据能够表示的有效数字为7位，最多只保证1.234567e10的正确性，要使结果正确，</span><br><span class="line">就需要把a和b均改为double型，因为double可以表示的精度为15~16位。</span><br></pre></td></tr></table></figure><code>int 溢出 可以考虑改用double存储</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git远程仓库</title>
      <link href="/undefined/3f8bae1e.html"/>
      <url>/undefined/3f8bae1e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg" alt="Uploading file...0i2ar"></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>当安装Git后首先要做的事情是设置用户名称和emailt地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息</p><ul><li><code>git config --global user.name &quot;itcast&quot;</code></li><li><code>git config --global user.email &quot;hello@iteast.cn&quot;</code></li></ul><p>查看用户信息</p><ul><li><code>git config --global user.name</code></li><li><code>git config --global user.email</code></li></ul><h1 id="获取本地仓库及其基础操作指令"><a href="#获取本地仓库及其基础操作指令" class="headerlink" title="获取本地仓库及其基础操作指令"></a>获取本地仓库及其基础操作指令</h1><ul><li>初始化仓库文件夹：<code>git init</code></li><li><code>git status</code>：查看的修改的状态（暂存区、工作区）</li><li><code>git add 单个文件名|通配符.</code>：工作区-&gt;暂存区</li><li><code>git commit -m &#39;注释内容&#39;</code>：暂存区-&gt;本地仓库的当前分支</li><li><code>git-log</code>：查看提交日志</li><li><code>git reset --hard commitID</code>：版本回退；commitID 可以使用 git-log 或 git log 指令查看</li><li><code>git push -f -u origin master</code>：把修改推送至远程</li><li><code>git branch</code>：查看本地分支</li><li><code>git branch 分支名</code>：创建本地分支</li><li><code>git checkout 分支名</code>：切换本地分支</li><li><code>git merge 分支名称</code>：一个分支上的提交合并到另一个分支上</li><li><code>git branch -d 分支名</code>：删除分支，不能删除当前分支<h1 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h1></li></ul><hr><ul><li>生成SSH公钥：<code>ssh-keygen -t rsa</code>   不断回车; 如果公钥已经存在，则自动覆盖</li><li>获取公钥：<code>cat ~/.ssh/id_rsa.pub</code></li><li>公钥获取后，将其添加到github仓库设置中，以获取推送权限</li><li>验证是否配置成功: <code>ssh-T:git@github.com</code></li></ul><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><hr><ul><li>命令：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354039.png" alt="image.png"></li></ul></li></ul><h1 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h1><hr><ul><li>命令：<code>git remote</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354389.png" alt="image.png"></li></ul><h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><hr><ul><li>命令：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>当前分支已经和远端分支关联，则可以省略分支名和远端名<code>git push</code></li><li><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<br><code>git push --set-upstream origin master</code></li></ul><h1 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h1><hr><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354898.png" alt="image.png"></li></ul><h1 id="从远程仓库抓取和拉取"><a href="#从远程仓库抓取和拉取" class="headerlink" title="从远程仓库抓取和拉取"></a>从远程仓库抓取和拉取</h1><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code> </li><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li><p>如果不指定远端名称和分支名，则抓取所有分支。</p></li><li><p>拉取 命令：<code>git pull [remote name] [branch name]</code></p></li><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul><h1 id="其他基础命令"><a href="#其他基础命令" class="headerlink" title="其他基础命令"></a>其他基础命令</h1><h2 id="查看当前仓库大小"><a href="#查看当前仓库大小" class="headerlink" title="查看当前仓库大小"></a>查看当前仓库大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354114.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白鲸vpn无限白嫖</title>
      <link href="/undefined/e47230b0.html"/>
      <url>/undefined/e47230b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181102465.jpg" alt="232826-1622906906220f.jpg"></p><h2 id="官网下载地址"><a href="#官网下载地址" class="headerlink" title="官网下载地址"></a>官网下载地址</h2><p><a href="https://www.bjchuhai.com/?mid=3020">https://www.bjchuhai.com/?mid=3020</a></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ul><li>随便填写一个邮箱，密码随意，没有二次验证</li><li>邀请码可以填写安卓手机端的账户邀请码，可以延长30天试用时间，并加速5%<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351374.png" alt="image.png"></li></ul><h2 id="重复注册"><a href="#重复注册" class="headerlink" title="重复注册"></a>重复注册</h2><ul><li>注册之后重新注册一个账号<br>一般情况提示账户密码错误<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351877.png" alt="image.png"></li></ul><ul><li><p>找到<code>‪C:\ProgramData\Whale</code> 路径下的文件，并将所有文件删除<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352313.png" alt="image.png"></p></li><li><p>再次注册即可</p></li></ul><h1 id="手机端-安卓"><a href="#手机端-安卓" class="headerlink" title="手机端(安卓)"></a>手机端(安卓)</h1><h2 id="手机注册"><a href="#手机注册" class="headerlink" title="手机注册"></a>手机注册</h2><p>与pc注册步骤一致</p><h2 id="重复注册-1"><a href="#重复注册-1" class="headerlink" title="重复注册"></a>重复注册</h2><p>手机最多注册两个账号，且无法像pc端进行重复注册操作<br>有两个方法：</p><ul><li>安装安卓模拟器(推荐voms pro)：通过手机模拟器，注册账号，并改变模拟器虚拟机的设备信息，实现重复注册，再通过填写邀请码延长时间</li><li>利用电脑端重复注册时，填写手机账号的邀请码，延长手机账号使用时间</li><li>注意,pc端，手机端 账号<code>是通用的^-^</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> VPN 白嫖 备用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(一)</title>
      <link href="/undefined/cc777f4a.html"/>
      <url>/undefined/cc777f4a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108759.jpg" alt="大海 棕榈树 海滩沙滩 帆船 岛 插图风景 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td>形式-&gt;0.123 或 1.23e-1</td></tr><tr><td>double</td><td>8字节</td><td>双精度浮点型</td></tr><tr><td>char</td><td>1字节</td><td>与int类型可通用，printf(“%c\n”,c+32);—&gt;a</td></tr><tr><td>字符串</td><td>字符数+1</td><td>字符串结尾\0字符不显示，用于判断字符串结束，因此+1</td></tr></tbody></table></div><p><code>一个字节byte = 8 bit</code><br>-&gt; 1 byte = 0000 0000 </p><p><code>补充</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h1 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h1><div class="note blue [icon] modern"><p>printf函数的具体代码格式</p></div><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">带符号整数,-左对齐，不带右对齐(printf函数默认靠右对齐)</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">无符号十六进制数，用小写字母</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">无符号十六进制数，用大写字母</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点数；%5.2f显示5位数字，并带有2位小数的浮点数</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">一串字符，%10s代表占用10个字符位置</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号整数</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">一个指针</td></tr></tbody></table></div><h1 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><div class="table-container"><table><thead><tr><th style="text-align:left">数组初始化</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">（1）在定义数组时对数组元素赋初值。</td><td style="text-align:left">int a[10]={0,1,2,3,4,5,6,7,8,9};不能写成int a[10];a[10]={0,1,2,3,4,5,6,7,8,9}</td></tr><tr><td style="text-align:left">（2）可以只给一部分元素赋值</td><td style="text-align:left">int a[10]={0,1,2,3,4};</td></tr><tr><td style="text-align:left">（3）使一个数组中全部元素的值为 0，那么可以写为</td><td style="text-align:left">int a[10]={0,0,0,0,0,0,0,0,0,0};或int a[10]={0};</td></tr><tr><td style="text-align:left">（4）在对全部数组元素赋初值时，数据的个数，可以不指定数组的长度</td><td style="text-align:left">int a[]={1,2,3,4,5};</td></tr></tbody></table></div><ul><li>数组名a存的是数组的起始地址，数组名传递到子函数后，形参接收到的是数组起始地址</li><li>指针在64为计算机上是8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[k]; --&gt;<span class="comment">//有的编译器支持，但是有的编译器不支持，尽量还是不要这样使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外不能直接给指针赋值一个数组</span></span><br><span class="line"><span class="type">int</span> *data;</span><br><span class="line">data=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; --&gt; 错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *data</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">data=arr         --&gt; 正确</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，数组名是一个常量指针，它指向数组第一个元素，无法被修改</span></span><br><span class="line"><span class="comment">//如果要修改，需要定义一个指针变量</span></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">arr++;  --&gt;错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *data=arr;</span><br><span class="line">data++; --&gt;正确</span><br></pre></td></tr></table></figure></li></ul><h1 id="调试debug"><a href="#调试debug" class="headerlink" title="调试debug"></a>调试debug</h1><p><code>进入子函数</code></p><ul><li>按向下箭头进入子函数</li><li>按拐弯箭头越过子函数，只在当前函数一步一步走下去<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091733716.png" alt="image.png"></li></ul><p><code>查看变量内存视图</code></p><ul><li>点击内存视图</li><li>输入&amp;i，i为要查看内存视图的变量<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102154125.png" alt="image.png"></li></ul><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>指针在64位计算机上站8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* 在变量定义中的意思</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span>* pa = &amp;a; <span class="comment">//这里的*声明定义的p是指针,指向的是a的内存地址</span></span><br><span class="line"><span class="type">int</span> ** p = &amp;pa; <span class="comment">//二级指针，** 声明该指针是 指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 在变量赋值运算中的意思</span></span><br><span class="line">*pa == <span class="number">1</span>; <span class="comment">//这里*是取值得意思 pa的值</span></span><br><span class="line">*p == pa;</span><br><span class="line">**p == *pa == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针进行+运算</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061516769.png" alt="image.png"></li></ul><h1 id="struct结构体"><a href="#struct结构体" class="headerlink" title="struct结构体"></a>struct结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><hr><ul><li><p>方式1</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，每次结构体声明都要<code>struct student s；</code>指针声明<code>struct student *p*;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方式2</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，结构体声明方式直接<code>stu s；</code>结构体指针<code>pstu p;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span><span class="comment">//下面起了别名stu后student可以省略不写</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;stu,*pstu; <span class="comment">//stu结构体别名；*pstu结构体指针别名</span></span><br></pre></td></tr></table></figure></li><li><p>结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> val;</span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明单独结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">x</span>;</span></span><br><span class="line"><span class="comment">//声明结构体数组</span></span><br><span class="line">Stack st; <span class="comment">//最大容量MaxSize,无需手动分配空间，默认MaxSize</span></span><br><span class="line"><span class="comment">//声明结构体二维数组</span></span><br><span class="line">Stack b[<span class="number">10</span>]; <span class="comment">//声明一个名为b的结构体数组的数组，包含10个结构体数组</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="typedef的使用"><a href="#typedef的使用" class="headerlink" title="typedef的使用"></a>typedef的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Element;<span class="comment">//重命名int类型  Element i;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *p;<span class="comment">//重命名指针类型      p k;</span></span><br><span class="line">trpedef <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span><span class="comment">//如上，重命名结构体类型 stu s;</span></span><br></pre></td></tr></table></figure><h1 id="循环体循环判断"><a href="#循环体循环判断" class="headerlink" title="循环体循环判断"></a>循环体循环判断</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(a&lt;i);找到第i个结点</span><br><span class="line">while(a&lt;=i);找到第i+1个结点</span><br><span class="line">同理&gt;;&gt;=</span><br></pre></td></tr></table></figure><h1 id="二的次方"><a href="#二的次方" class="headerlink" title="二的次方"></a>二的次方</h1><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td><td>256</td><td>512</td><td>1024</td><td>2048</td><td>4096</td><td>8192</td><td>16384</td><td>32768</td><td>65536</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/undefined/f134a8e5.html"/>
      <url>/undefined/f134a8e5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181116370.jpg" alt="唯美 梦幻 鲸鱼 女孩 Сè 日落 大海 动漫 高清 壁纸_彼岸壁纸.jpg"></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h1 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% label text color %&#125;</span><br></pre></td></tr></table></figure><ul><li>text    文字</li><li>color可选，背景顏色，默认为 default</li><li>default/blue/pink/red/purple/orange/green</li></ul><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="表格写法"><a href="#表格写法" class="headerlink" title="表格写法"></a>表格写法</h2><hr><blockquote><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">写法1</button></li><li class="tab"><button type="button" data-href="#test1-2">效果1</button></li><li class="tab"><button type="button" data-href="#test1-3">写法2</button></li><li class="tab"><button type="button" data-href="#test1-4">效果2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p></blockquote><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><hr><p>标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">语法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h1 id="分栏显示"><a href="#分栏显示" class="headerlink" title="分栏显示"></a>分栏显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab 栏目1--&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目2--&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目3--&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">栏目1</button></li><li class="tab"><button type="button" data-href="#test1-2">栏目2</button></li><li class="tab"><button type="button" data-href="#test1-3">栏目3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>这里是1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">语法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>名称</th><th>用法</th></tr></thead><tbody><tr><td>color</td><td>顔色(default / blue / pink / red / purple / orange / green)</td></tr><tr><td>icon</td><td>可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td>可以覆盖配置中的 style（simple/modern/flat/disabled）</td></tr></tbody></table></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><div class="note blue [icon] modern"><p>效果展示</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="大量内容隐藏"><a href="#大量内容隐藏" class="headerlink" title="大量内容隐藏"></a>大量内容隐藏</h1><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">写法</button></li><li class="tab"><button type="button" data-href="#test1-2">效果</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;  </span><br><span class="line">&lt;summary&gt;点击打开&lt;/summary&gt;  </span><br><span class="line">隐藏的内容  </span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><details>  <summary>显示的文字</summary>  隐藏的内容  </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/undefined/79666db.html"/>
      <url>/undefined/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181106524.jpg" alt="崩坏 星穹铁道 女孩 相机 星空 高清壁纸_彼岸壁纸 (1).jpg"></p><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><hr><blockquote><p>概念：</p><ul><li>数据元素：一个数据体，考虑为一个人，一份订单…</li><li>数据项：数据体内的各项，人的信息项，订单的信息项…</li><li>数据对象：具有相同性质，数据元素的集合<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302328740.png" alt="image.png"></li><li>数据类型：是指一个值得集合，和定义在此集合上一组操作的总称<ul><li>原子类型：基本数据类型<br>  结构体运算：+ - * % …</li><li>结构类型：结构体(可以再分为若干分量)<br>  结构体运算—&gt;封装为函数</li><li>抽象数据类型：抽象数据组织及与之相关操作(描述了数据的<code>逻辑结构</code>和<code>抽象运算</code>)，可以用其定义一个完整的数据结构</li><li>数据结构：相互间存在一种或多种特定关系的数据元素的集合</li></ul></li></ul><p>数据结构三要素：</p><ul><li><code>逻辑结构</code><ul><li>线性结构</li><li>非线性结构(集合结构、树形结构、图状结构)</li></ul></li><li><code>存储结构</code><ul><li>链式存储：离散存放的</li><li>顺序存储：占用大片连续空间</li><li>索引存储</li><li>散列存储</li></ul></li><li><code>数据的运算</code>：比如，栈的抽象运算是<code>先进后出</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341139.png" alt="image.png"></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341254.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.数据的逻辑结构独立于其存储结构，逻辑结构是抽象表达方式，例如图的逻辑结构，采用顶点与边</span><br><span class="line">而图的存储结构采用二维数组(顺序存储)或链表结点(链式存储)</span><br><span class="line"></span><br><span class="line">2.存储数据时，不仅要存储数据的值，还要存储数据元素之间的关系(例如顺序表存储元素有下标，表示与其他数据元素的位置关系)</span><br><span class="line"></span><br><span class="line">3.对于两种不同的数据结构，他们的逻辑结构完全有可能相同，</span><br><span class="line"></span><br><span class="line">4.举例说明，对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同？</span><br><span class="line">线性表，可以顺序存储，可以链式存储，顺序存储方式，插入删除操作要平均移动一半元素，O(n)</span><br><span class="line">链式存储方式，插入删除时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">5.以下与数据存储结构无关的术语是：D</span><br><span class="line">  A 循环队列  B 链表  C 哈希表  D 栈 </span><br><span class="line">  解析：栈是一种抽象数据类型，可采用顺序存储，链式存储，只表示逻辑结构</span><br><span class="line"></span><br><span class="line">6.以下属于逻辑结构的是（c）。</span><br><span class="line">A.顺序表</span><br><span class="line">B.哈希表</span><br><span class="line">C.有序表</span><br><span class="line">·D.单链表</span><br><span class="line"></span><br><span class="line">顺序表体现数组存储方式，哈希表体现散列存储方式，单链表体现链式存方式，有序表体现有序的逻辑结构</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><hr><blockquote><p>算法：求解问题的步骤<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304061942250.png" alt="image.png"><br>-算法特性：</p><ul><li>有穷性，有限步骤内完成，有穷时间内完成</li><li>确定性，意义明确，无歧义；给定相同的输入，输出结果确定唯一</li><li>可行性，可以通过基本运算执行有限次来实现</li><li>输入，0个或多个输入</li><li>输出，1个或多个输出</li></ul><p>好的算法具备特质：</p><ul><li>正确性，能正确实现目的</li><li>可读性，容易理解阅读</li><li>健壮性，可以灵活处理数据中的非法数据，给出反应进行处理</li><li>高效率地存储需求，花费时间少(时间复杂度低)，不费内存(空间复杂度低)</li></ul><p><mark class="hl-label blue">时间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th>a</th><th>结论</th></tr></thead><tbody><tr><td>1</td><td>顺序执行的代码只影响常数项</td></tr><tr><td>2</td><td>只需要挑去循环当中的某一个基本操作分析它的执行次数与n的关系</td></tr><tr><td>3</td><td>如果有多层嵌套循环，只需要关注最深层得循环执行了几次</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072136217.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072140867.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072141426.png" alt="image.png"></p><blockquote><p><mark class="hl-label blue">空间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">普通程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">只需关注存储空间大小与问题规模相关的变量</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">分析所占空间x与问题规模n的关系 x=f(n)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">递归程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">找到递归深度x与问题规模n的关系</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072151890.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072152388.png" alt="image.png"></p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">总结</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:center">数据类型同类型、有限、有序(先后顺序)</td></tr><tr><td style="text-align:center">位序</td><td style="text-align:center">线性表数据元素的位序从1开始(数组下标以0开始)</td></tr><tr><td style="text-align:center">基本操作</td><td style="text-align:center">创销、增删改查；判空、判长、打印输出</td></tr><tr><td style="text-align:center">注意</td><td style="text-align:center">函数名要有可读性、见名知意</td></tr><tr><td style="text-align:center">包括</td><td style="text-align:center">链表(链式存储)、顺序表(顺序存储)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072231315.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072232709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造方法框架：</span><br><span class="line">InitL1st(&amp;L）:初始化表。构造一个空的线性表。</span><br><span class="line">Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetE1em(L,i):按位查找操作。获取表L中第1个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e.</span><br><span class="line">ListDelete(&amp;L,i,&amp;e):别除操作，别除表L中第1个位置的元素，并用e返回别除元素的值。</span><br><span class="line">Pr1 ntList(L):输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L):判空操作。若L为空表，则返回true,否则返回false.</span><br><span class="line">DestroyList(&amp;L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><h1 id="线性表顺序存储"><a href="#线性表顺序存储" class="headerlink" title="线性表顺序存储"></a>线性表顺序存储</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表定义"><a href="#顺序表定义" class="headerlink" title="顺序表定义"></a>顺序表定义</h3><hr><blockquote><p>顺序表实现方式：<br><code>静态分配</code>：ElemType data[MaxSize]（存储空间不可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data [MaxSize];</span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; <span class="comment">//定义的是结构体的数据类型</span></span><br></pre></td></tr></table></figure><p><code>动态分配</code>：ElemType  * data （存储空间可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize10 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data ;</span><br><span class="line"><span class="type">int</span> Maxsize;<span class="comment">//记录最大容量</span></span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line"><span class="comment">//用ma11oc函数申请一片连续的存储空间</span></span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(Initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">L.MaxSize=Initsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Increasesize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="type">int</span> *p=L.data;</span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//申请另一块内存空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">L.data[i]=p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize=L.MaxSize+len;<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344408.png" alt="image.png"></p><p>顺序表特点</p><ul><li>随机访问：可以在O(1)时间内找到第i给元素</li><li>存储密度高，只能存储数据本身，不能存储指针信息</li><li>拓展容量不方便：每次拓展容量都需要开拓一个新的内存空间，并复制过去</li><li>插入删除元素不方便，需要移动大量的元素</li></ul></blockquote><h3 id="顺序表插入操作"><a href="#顺序表插入操作" class="headerlink" title="顺序表插入操作"></a>顺序表插入操作</h3><hr><blockquote><p>健壮性，异常处理：</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>方法要进行，判满，判断插入位置是否有效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList&amp;L <span class="type">int</span> i，<span class="type">int</span> e)</span>&#123;<span class="comment">//i插入位置，e要插入元素</span></span><br><span class="line"><span class="keyword">if</span>（i&lt;<span class="number">1ll</span>i&gt;L.length+<span class="number">1</span>） <span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">if</span>（L.length&gt;=MaxSize） <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">for</span>（intj=L.length;j&gt;=i；j--） <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>]；</span><br><span class="line">L.data[i<span class="number">-1</span>]=e； <span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++； <span class="comment">//长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>；</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：插入到表尾i=n+1，无需移动元素 <code>O(1)</code></li><li>最坏：插入到表头i=1，全部后移一位<code>O(n)</code></li><li>平均：假设新元素插入到任何一个位置的概率相同，即i=1,2,3,,length+1的概率都是p=1/n+1,i=1,循环n次：i=2时，循环n-1次：i=3,循环n-2次…i=n+1时，循环0次;平均循环次数=np+(n-1)p+(n-2)p+…+1p=n/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的删除操作"><a href="#顺序表的删除操作" class="headerlink" title="顺序表的删除操作"></a>顺序表的删除操作</h3><hr><blockquote><p>健壮性异常处理</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>判空、判断删除位置i是否有效</li><li>要加一个变量e(注意要&amp;e)，将被删除元素的值带回来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;<span class="comment">//引用，否则无法带回数据</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> i&gt;L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：删除表尾i=n，无需移动元素 <code>O(1)</code></li><li>最坏：删除表头i=1，全部前移一位<code>O(n)</code></li><li>平均：假设删除任何一个位置的概率相同，即i=1,2,3,,length的概率都是p=1/n,i=1,循环n-1次：i=2时，循环n-2次：i=3,循环n-3次…i=n时，循环0次;平均循环次数=(n-1)p+(n-2)p+(n-3)p+…+1p=n-1/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h3><hr><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SeqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(1)</code></p><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L,ElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;<span class="number">1</span>++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//数组下标为i的元素值等于e,返回其位i+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环，说明查找失败</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>最好：<code>O(1)</code> 查找元素在表头</li><li>最坏：<code>O(n)</code> 查找元素在表尾</li><li>平均：<code>O(n)</code>  循环n+1/2次</li></ul><h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li><li class="tab"><button type="button" data-href="#test1-10">10</button></li><li class="tab"><button type="button" data-href="#test1-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.从顺序表中别除具有最小值的元素（假设唯一）并由函数返回被别元素的值。空出的位</span></span><br><span class="line"><span class="comment">//置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_min</span><span class="params">(SqList T,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]&lt;T.data[min])&#123;</span><br><span class="line">min=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e=T.data[min];</span><br><span class="line">T.data[min]=T.data[length<span class="number">-1</span>];</span><br><span class="line">T.length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O（1）,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inverse</span><span class="params">(SqList T)</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp=T.data[i];</span><br><span class="line">T.data[i]=T.data[T.length-i];</span><br><span class="line">T.data[T.length-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.对长度为n的顺序表L,编写一个时间复杂度为O（n）、空间复杂度为O（1）的算法，该算</span></span><br><span class="line"><span class="comment">法别除线性表中所有值为x的数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void delet(Sqlist T,int pos)&#123;</span></span><br><span class="line"><span class="comment">if(T.length=0||pos&gt;T.length||pos&lt;0)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int i=pos;i&lt;=T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">T.data[i]=T.data[i+1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void delet_x(Sqlist T,int x)&#123;</span></span><br><span class="line"><span class="comment">int* arr;</span></span><br><span class="line"><span class="comment">int k=0;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">if(T.data[i]=x)&#123;</span></span><br><span class="line"><span class="comment">arr[k]=i;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(k;k&gt;=0;k--)&#123;</span></span><br><span class="line"><span class="comment">delet(T,arr[k]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//上述代码，不符合时间复杂度与空间复杂度要求</span></span><br><span class="line"><span class="comment">//解法1.正确思路：用k记录值不等于x的元素的个数，然后，将不等于x的值移到下标为x的位置，然后调整k位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]!=x)&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2，用k记录值等于x的元素个数，边扫描L边统计k,并将不等于x的元素前移k位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]==x)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.len=L.len-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.从顺序表中删除其值在给定值s与t之间(要求s&lt;t)的所有元素，若s或t不合理</span></span><br><span class="line"><span class="comment">或顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法1.用k记录不符合删除条件的元素个数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(T.data[i]&gt;s&amp;&amp;T.data[i]&lt;t))&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2.用k记录在s和t之间的元素个数，并边扫描，边统计k，将不在s和t之间的元素前移k位</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]&gt;s&amp;&amp;L.data[i]&lt;t)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.length-=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqTable</span>&#123;</span>  </span><br><span class="line">    <span class="type">int</span>* data;  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">&#125;Sqlist;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos+<span class="number">1</span>;i&lt;T.length;i++)&#123;  </span><br><span class="line">        T.data[i<span class="number">-1</span>]=T.data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    T.length--;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;T.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(j==T.length)&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(T.data[i]==T.data[j])&#123;  </span><br><span class="line">                delet(T,j);  </span><br><span class="line">                j--;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化思路，先排序，后遍历删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先排序</span></span><br><span class="line">    qsort(T.data, T.length, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; T.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T.data[i] != T.data[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            T.data[i] = T.data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序的时间复杂度为O(nlogn),遍历的时间复杂度为O(n),所以总时间复杂度为O(nlogn)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*6.将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表*/</span></span><br><span class="line"><span class="comment">//算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看</span></span><br><span class="line"><span class="comment">//哪个表还有剩余，将剩下的部分加到新的顺序表后面。</span></span><br><span class="line">Sqlist <span class="title function_">merge</span><span class="params">(Sqlist T1,Sqlist T2)</span>&#123;  </span><br><span class="line">    Sqlist T3;  </span><br><span class="line">    T3.data=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(T1.length+T2.length));  </span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length&amp;&amp;j&lt;T2.length)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(T1.data[i]&lt;=T2.data[j])&#123;  </span><br><span class="line">            T3.data[k]=T1.data[i];  </span><br><span class="line">            i++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            T3.data[k]=T2.data[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length)&#123;  </span><br><span class="line">        T3.data[k]=T1.data[i];  </span><br><span class="line">        k++;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(j&lt;T2.length)&#123;  </span><br><span class="line">        T3.data[k]=T2.data[j];  </span><br><span class="line">        k++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    T3.length=k;  </span><br><span class="line">    <span class="keyword">return</span> T3;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.[2010统考真题]设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间</span></span><br><span class="line"><span class="comment">两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置，即将R</span></span><br><span class="line"><span class="comment">中的数据由(X0,X1,…,Xn-1)变换为(XpXp+1,…,Xn-1,X0,X1,…,Xp-1).要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度和空间复杂度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">答：</span></span><br><span class="line"><span class="comment">1.可以将问题看做将数组ab转换成ba,可以先将a逆转置，再将b逆置，再将整体逆置，就得到ba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_singel</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> bengin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(begin,end;begin&lt;end;begin++,end--)&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=T.data[begin];</span><br><span class="line">T.data[begin]=T.data[end];</span><br><span class="line">T.data[end]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_all</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,p,n<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上算法中三个reserve_all的时间复杂度分别是O(p/2),O((n-p)/2),O(n/2);</span></span><br><span class="line"><span class="comment">//总时间复杂度是O(n),空间复杂度O(1)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8.线性表(a1,a2,a3,an)中元素递增有序且按顺序存储于计算机内。要求设计一算法完成用最少时间在表中查找数值为x的元素，若找到将其与后继元素位置相交换，若找不到将其插入表中并使表中元素仍递增有序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//算法思路：二分查找函数+交换函数+插入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(SSTable &amp;S,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=S.len)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=S.data[i];</span><br><span class="line">S.data[i]=S.data[i+<span class="number">1</span>];</span><br><span class="line">S.data[i+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">(SSTable &amp;S,<span class="type">int</span> x,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=S.len<span class="number">-1</span>;i&gt;=pos;i--)&#123;</span><br><span class="line">S.data[i+<span class="number">1</span>]=S.data[i];</span><br><span class="line">&#125;</span><br><span class="line">S.len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Binary_Search_insert</span><span class="params">(SSTable S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=S.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(S.data[mid]==x)&#123;</span><br><span class="line">Swap(S,mid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(S.data[mid]&lt;x)&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Insert(S,x,low);  <span class="comment">//没有查到，那么low所指向位置，就是插入位置,low一定是比x大的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050853124.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050947008.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051013253.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMissMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> *B;</span><br><span class="line">B=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//创建一个存放标记的数组</span></span><br><span class="line"><span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*n*);  <span class="comment">//赋值初始0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;=n)&#123;</span><br><span class="line">B[A[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线性表链式存储"><a href="#线性表链式存储" class="headerlink" title="线性表链式存储"></a>线性表链式存储</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><hr><ul><li>定义结构体</li><li>初始化</li><li>判空</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">不带头结点的链表</button></li><li class="tab"><button type="button" data-href="#test1-2">带头结点链表</button></li><li class="tab"><button type="button" data-href="#test1-3">区别</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=<span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点,同时为了防止脏数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L =<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123; <span class="comment">//内存不足，分配失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空的表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344241.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位插入不带头结点</button></li><li class="tab"><button type="button" data-href="#test1-2">按位插入带头结点</button></li><li class="tab"><button type="button" data-href="#test1-3">指定结点的前插操作O(n)</button></li><li class="tab"><button type="button" data-href="#test1-4">指定结点的前插操作O(1)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344545.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345110.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定结点，这种方式，先找到指定节点的前驱结点--&gt;遍历</span><br><span class="line">平均复杂度O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345224.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种方式，无需找到指定结点前驱结点，先插入到后面，然后交换data,等效为前插</span><br><span class="line">O(1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345353.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><hr><div class="note blue [icon] [style] flat"><p>这里就不讨论不带头结点的链表删除情况了</p></div><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位序删除</button></li><li class="tab"><button type="button" data-href="#test1-2">指定结点删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按位置删除，只能通过遍历找到第i-1个结点</span><br><span class="line">最坏，平均都是O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345569.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种指定节点删除方式，时间复杂度`O(1)`,但是极限情况，当p最后结点的时候</span><br><span class="line">就无法通过转移数据的方式完成删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345879.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h3><hr><h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><p><code>时间复杂度O(n)</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">优化前</button></li><li class="tab"><button type="button" data-href="#test1-2">优化后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Linklist p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li><code>无需再定义一个p指针用来遍历，直接用头结点L进行遍历，然后返回L，由于L没有用引用,最终并不会改变L</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">Linklist <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line"><span class="keyword">while</span> (L !=<span class="literal">NULL</span>&amp;&amp;L-&gt;data!=e)</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//找到后返回该结点指针，否则返回WULL</span></span><br></pre></td></tr></table></figure></p><h4 id="统计表长"><a href="#统计表长" class="headerlink" title="统计表长"></a>统计表长</h4><p><code>时间复杂度O(n)</code></p><h3 id="单链表建立"><a href="#单链表建立" class="headerlink" title="单链表建立"></a>单链表建立</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_head_insert</span><span class="params">(LNode* &amp;L)</span>&#123;  </span><br><span class="line">    L= (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//给L申请一个头结点结点空间  </span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;<span class="comment">//读取的第一个元素  </span></span><br><span class="line">    LinkList s;<span class="comment">//用来指向新节点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));<span class="comment">//给s申请一个新的空间  </span></span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//实现头插法，s成为第一个结点  </span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//L作为头结点，任然指向第一个结点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//读取x的值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>重要性质：头插法实现的链表数据是逆置的，用于链表的逆置</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346377.png" alt="image.png"></p><p><code>链表逆置：循环依次读取老链表数据，然后用头插法依次建立新链表/再次用头插法插入到之后，这样就是实现了链表逆置</code></p><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点 ,将L赋给s,r ,相当于s,r,L都是头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  <span class="comment">//将s赋给r,r重新指向尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了克服单链表无法直接通过一个结点访问其前驱</span><br><span class="line">提出了双链表</span><br><span class="line">双链表结点结构体，有两个指针，一个指向前驱，另一个指向后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表中结点类型的描述如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DNode</span><span class="params">(            <span class="comment">//定义双链表结点类型</span></span></span><br><span class="line"><span class="params">ElemType data;               <span class="comment">//数据域</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> DNode *prior,*next;   <span class="comment">//前驱和后继指针</span></span></span><br><span class="line"><span class="params">&#125;DNode,*DLinklist;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346859.png" alt="image.png"></p><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，</span><br><span class="line">循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</span><br><span class="line"></span><br><span class="line">循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执</span><br><span class="line">行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，因</span><br><span class="line">此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346340.png" alt="image.png"></p><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态链表借助数组，表示链式存储结构</span><br><span class="line">需要大片的连续的空间，删除或增加结点不需要移动其他元素</span><br><span class="line">结点有指针域(下一个结点的数组下标)，数据域(存储的数据)；</span><br><span class="line">静态链表以next=-1表示结束</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50           <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">ElemType data;               <span class="comment">//存储数据元素</span></span><br><span class="line"><span class="type">int</span> next;                    <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList [Maxsize];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346580.png" alt="image.png"></p><h2 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.静态链表中指针表示的是（C）。</span></span><br><span class="line"><span class="comment">A.下一元素的地址</span></span><br><span class="line"><span class="comment">B.内存储器地址</span></span><br><span class="line"><span class="comment">C.下一个元素在数组中的位置</span></span><br><span class="line"><span class="comment">D.左链或右链指向的元素的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：静态链表就是用数组(顺序存储)的链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用（C）</span></span><br><span class="line"><span class="comment">最节省时间。</span></span><br><span class="line"><span class="comment">A.不带头结点的单循环链表</span></span><br><span class="line"><span class="comment">B.双链表</span></span><br><span class="line"><span class="comment">C不带头结点且有尾指针的单循环链表</span></span><br><span class="line"><span class="comment">D.单链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.[2021统考真题]已知头指针h指向一个带头结点的非空单循环链表，结点结构为</span></span><br><span class="line"><span class="comment">【data next】</span></span><br><span class="line"><span class="comment">,其中next是指向直接后继结，点的指针，p是尾指针，q是临时指针。现要</span></span><br><span class="line"><span class="comment">删除该链表的第一个元素，正确的语句序列是（D）。</span></span><br><span class="line"><span class="comment">A.h-&gt;nextsh-&gt;next-&gt;next;q=h-&gt;next;free(q)</span></span><br><span class="line"><span class="comment">B.q=h-&gt;next;h-&gt;next=h-&gt;next-&gt;next;free(q);</span></span><br><span class="line"><span class="comment">C.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p!=q) p=h;free(q);.</span></span><br><span class="line"><span class="comment">D.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p==q) p=h;free(q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：如果删除的元素是尾结点，则需要判断是否是尾结点，是则将尾指针指向头结点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.[2009统考真题]已知一个带有表头结，点的单链表，结点结构为</span></span><br><span class="line"><span class="comment">data link</span></span><br><span class="line"><span class="comment">假设该链表只给出了头指针11st。在不改变链表的前提下，请设计一个尽可能高效的</span></span><br><span class="line"><span class="comment">算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结</span></span><br><span class="line"><span class="comment">点的data域的值，并返回l;否则，只返回0。要求：</span></span><br><span class="line"><span class="comment">1)描述算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)描述算法的详细实现步骤。</span></span><br><span class="line"><span class="comment">3)根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言</span></span><br><span class="line"><span class="comment">实现），关健之处请给出简要注释。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本思路：设置p、q两个指针，p指针先走当p指针走到底k的结点时，q开始移动，当p移动到尾部时，q停止</span></span><br><span class="line"><span class="comment">//此时q所指得结点就是倒数第k个结点</span></span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">search_k</span><span class="params">(LinkList L,<span class="type">int</span> k)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    LinkList p=L-&gt;next;  </span><br><span class="line">    LinkList q=L-&gt;next;<span class="comment">//p、q起点可以不是L-&gt;next,因为求得是倒数，只要倒数个数比起点更右端即可  </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            q=q-&gt;next;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> q;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.[2012统考真题]假定采用带头结点的单链表保存单词，当两个单词有相同的后缎时，</span></span><br><span class="line"><span class="comment">可共享相同的后缀存储空间；例如，loading和being的存储映像如下图所示。</span></span><br><span class="line"><span class="comment">   str1</span></span><br><span class="line"><span class="comment">  头结点1 -&gt; l -&gt; o -&gt; a -&gt; d ----&gt; i -&gt; n -&gt; g</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">   str2                            |</span></span><br><span class="line"><span class="comment">  头结点2 -&gt; b -&gt; e ----------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设str1和str2分别指向两个单词所在单链表的头结点，链表结，点结构为[data next]</span></span><br><span class="line"><span class="comment">请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀</span></span><br><span class="line"><span class="comment">的起始位置(如图中字符1所在结点的位置p)。要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解：因为是单链表无法，从后往前遍历，于是只能单向从前往后遍历，p 、q指针分别指向str1 str2的头结点，判断str1和str2的长度m、n.如果m&gt;n则p先走，使得p q到尾结点的距离一致。然后p、q共同移动直到遇到结点内容一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历两条链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出共同后缀起始地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_same_str</span><span class="params">(LinkList str1,LinkList str2)</span>&#123;</span><br><span class="line">m=Get_length(str1);</span><br><span class="line">n=Get_length(str2);</span><br><span class="line"><span class="keyword">for</span>(str1;m&gt;n;m--)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(str2;n&gt;m;n--)&#123;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(str1-&gt;next!=<span class="literal">NULL</span>&amp;&amp;str1-&gt;next!=str2-&gt;next)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度 m+n+(m-n)+2(n-x)=2m+2n-2x 所以时间复杂度为O(m+n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.将链表L&#123;a1,a2 a3 a4 a5...an-2 an-1an&#125;--&gt;L&#123;a1 an a2 an-1 a3...&#125;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resort</span><span class="params">(LinkNode *L)</span>&#123;</span><br><span class="line">LinkNode *k,kk=L;</span><br><span class="line">LinkNode *r,s;</span><br><span class="line"><span class="keyword">while</span>(kk-&gt;next)&#123;</span><br><span class="line">k=k-&gt;next;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(kk-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表后半段逆置</span></span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=k-&gt;next;</span><br><span class="line">k-&gt;next=kk;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">s=L-&gt;next;</span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=s-&gt;next;</span><br><span class="line">s-&gt;next=q;</span><br><span class="line">s=q-&gt;next;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><hr><p><code>定义</code>：一种只允许在一端进行插入或删除<code>的线性表</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">栈实现(顺序存储)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line">typeof <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;  <span class="comment">//栈针</span></span><br><span class="line">&#125;SqStack</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">S.top=<span class="number">-1</span>;  <span class="comment">//初始指向-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span>  <span class="title function_">isEmpty</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.data[++S.top]=x; <span class="comment">//先+，后赋值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x=S.data[S.top--]; <span class="comment">//先赋值，后-</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h2 id="栈在括号匹配中应用"><a href="#栈在括号匹配中应用" class="headerlink" title="栈在括号匹配中应用"></a>栈在括号匹配中应用</h2><hr><blockquote><p><code>括号匹配问题</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后出现的左括号，最先被匹配</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051432873.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051433730.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遇到左括号--&gt;入栈</span><br><span class="line">遇到右括号--&gt;出栈，并且匹配检查</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051434299.png" alt="image.png"></p><p><code>算法实现</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051439016.png" alt=""></p></blockquote><h2 id="栈在表达式求值应用"><a href="#栈在表达式求值应用" class="headerlink" title="栈在表达式求值应用"></a>栈在表达式求值应用</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051442887.png" alt="image.png"></p><blockquote><p><code>前缀、中缀、后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051522948.png" alt="image.png"></p><p><code>中缀转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051524252.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然两种后序表达式都是正确的，但是由于计算机运算遵循左优先原则，尽可能的先算左边运算符</span><br><span class="line">这样就保证运算顺序唯一</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051529561.png" alt="image.png"></p><p><code>用栈实现后缀表达式的计算</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从左往右依次扫描</span><br><span class="line">2.扫描到数字，则压入栈</span><br><span class="line">3.扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，继续1</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051548740.png" alt="image.png"></p><p><code>用栈实现中缀表达式转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051613746.png" alt="image.png"></p><p><code>用栈实现中缀表达式求值</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中缀转后缀+后缀计算</span><br><span class="line"></span><br><span class="line">1.扫描中缀表达式，从左往右</span><br><span class="line">2.扫描到数，入数栈；扫描到符号，入符号栈</span><br><span class="line">3.扫描到符号如果前面有优先级更高的，则要先弹出高优先级，再入栈当前符号，并弹出两个操作数</span><br><span class="line">  与弹出的符号运算，并将结果入回数栈顶部</span><br><span class="line">4.如果扫描到的符号前面没有优先级更高的，则无需操作，继续扫描</span><br><span class="line">5.遇到 ( 则 直接入栈，遇到 ) 依次弹出栈内运算符，并弹出相应数进行运算，直到弹出 ( 为止</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051619822.png" alt="image.png"></p></blockquote><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><hr><blockquote><p><code>递归工作栈</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051744820.png" alt="image.png"></p></blockquote><h2 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">3</button></li><li class="tab"><button type="button" data-href="#test1-5">4</button></li><li class="tab"><button type="button" data-href="#test1-6">5</button></li><li class="tab"><button type="button" data-href="#test1-7">6</button></li><li class="tab"><button type="button" data-href="#test1-8">7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051804701.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051939158.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本操作是指能直接实现的操作，ACD都属于基本操作，但是B栈不能直接删除栈底元素，需要一个一个移开上面元素，再删除，再放回之前的元素</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052010610.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052024207.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链栈,头指针为栈顶--&gt;才能实现先进后出</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3个不同元依次进栈，能得到（B)种不同的出栈序列。</span><br><span class="line">A.4</span><br><span class="line">B.5</span><br><span class="line">C.6</span><br><span class="line">D.7</span><br><span class="line"></span><br><span class="line">解析：卡特兰数，(6x5x4)/(3x2x1)/4=5</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052151736.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符可以字母，下划线开头，不可以数字开头</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">共享栈，可以节省存储空间，降低发生上溢的可能</span><br><span class="line"></span><br><span class="line">共享栈是一种两个栈共享同一片存储空间的数据结构。它的特点是两个栈的栈底在这片存储空间的两</span><br><span class="line">端，当元素入栈时，两个栈的栈顶指针相向而行。这样可以更有效地利用存储空间，只有在整个空间</span><br><span class="line">满时才会发生上溢</span><br><span class="line"></span><br><span class="line">共享栈栈满条件判断有两种：</span><br><span class="line">栈顶指针初始指向-1:</span><br><span class="line">栈顶指针初始指向0：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052212674.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052231925.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><hr><p><code>是只允许在一端进行插入，在另一端删除的线性表</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">队列(顺序存储)</button></li><li class="tab"><button type="button" data-href="#test1-2">队列(链式存储-带头结点)</button></li><li class="tab"><button type="button" data-href="#test1-3">队列(链式存储-不带头结点)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> rear,front;</span><br><span class="line">&#125;SqSueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//为空</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.data[Q.rear]=x;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize; </span><br><span class="line"><span class="comment">//取模，例如x%7,最终得到的值只能是0,1,2,3,4,5,6</span></span><br><span class="line"><span class="comment">//循环往复变化，采用取模方式的队列，被称为&quot;循环队列&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051245346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 队列中元素个数=(rear+MaxSize-front)%MaxSize</span><br><span class="line">- 队列中最多存储MaxSize-1个元素，留一个空位给rear用来(rear+1)%MaxSize判定</span><br><span class="line">  否则，全装满，rear=front,那么判空，判满无法区分</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种判断队列空满的方法，增加辅助变量，可以充分利用存储单元，可以装满</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051252761.png" alt="image.png"></p><p><code>回顾</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051257769.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051400428.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，带头结点                           </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;                </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">Q.front=Q.rear=L;                        </span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;                   </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)&#123;                         </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                                 </span><br><span class="line">&#125;                                           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;                               </span><br><span class="line">&#125;                                            </span><br><span class="line"></span><br><span class="line"><span class="comment">//无需判满，链表可以无限长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，带头结点                             </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;           </span><br><span class="line">LinkList s;                                  </span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">s-&gt;data=x;                                     </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;                                </span><br><span class="line">Q.rear-&gt;next=s;                              </span><br><span class="line">Q.rear=s;                                        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;  <span class="comment">//x将出队元素带出</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">LinkList p=Q.front-&gt;next;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)&#123;  <span class="comment">//如果是出队队尾元素，要考虑rear的变化</span></span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;                            </span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051416101.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//盘空，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">linkList s;</span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=x; </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.front-&gt;next=s;</span><br><span class="line">Q.rear=s;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Linklist p=Q.front;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p==Q.rear)&#123;  <span class="comment">//如果删除的最后一元素</span></span><br><span class="line">Q.rear=<span class="literal">NULL</span>:</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><blockquote><p><code>注意</code>：顺序存储，<code>rear</code>指向的是尾部元素的后一位；链式存储，<code>rear</code>指向的就是尾部元素</p></blockquote><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于判断输出序列的合法性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051419921.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051424490.png" alt="image.png"></p><h2 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061135804.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这题实质上问的需要多少个队列</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061155791.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061203327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迷宫求解，本质是岔路选择，遇到选择则入栈</span><br><span class="line"></span><br><span class="line">缓冲区，本质是一个队列，将信息，按原本顺序输出(先入先出)，作用是缓存信息(延长信息存在时间)，以防止计算机反应慢接收不到</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.一个问题的递归算法求解和其相对应的非递归算法求解，（B）。</span><br><span class="line">A.递归算法通常效率高一些 B.非递归算法通常效率高一些</span><br><span class="line">C.两者相同    D.无法比较</span><br><span class="line"></span><br><span class="line">解析：递归算法--&gt;代码简洁，容易理解，但是效率低，因为递归存在大量重复运算；非递归算法--&gt;代码繁琐，但是效率较高，没有多余运算</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">2.执行（B）操作时，需要使用队列作为辅助存储空间。</span><br><span class="line">A.查找散列（哈希）表 B 广度优先搜索图</span><br><span class="line">C．前序（根）遍历二叉树 D.深度优先搜索图</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">B：图的广度优先遍历：以广度为优先考虑，使用队列</span><br><span class="line">C：前中后序遍历二叉树，在递归方法中都隐含 递归栈。 那么非递归方法中必然是使用栈来进行这些  </span><br><span class="line">   相关操作的。</span><br><span class="line"></span><br><span class="line">3.下列说法中正确的是（A）。</span><br><span class="line">A.消除递归不一定需要使用栈</span><br><span class="line">B。对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同</span><br><span class="line">C.通常使用队列来处理函数或过程调用</span><br><span class="line">D.队列和栈都是运算受限的线性表，只允许在表的两端进行运算</span><br><span class="line"></span><br><span class="line">解析：A本来没必要使用递归的算法，使用递归，那么消除递归就不一定需要使用栈替代</span><br><span class="line"></span><br><span class="line">4.为解决计算包主机省打印机之间速度不匹配问题，通常设置一个打印数缓冲区，庄机将要输出的数据依次写入该缓冲，而打机则依次从该缓冲区中取出数据。该缓冲区的逻辑结应该是(A)</span><br><span class="line">A.栈</span><br><span class="line">B.队列</span><br><span class="line">C.树</span><br><span class="line">D.图</span><br><span class="line"></span><br><span class="line">5.某汽车轮渡口，过江渡船每次能载10辆车过江。过江车辆分为客车类和货车类，上渡船有如下规定：同类车先到先上船；客车先于货车上渡船，且每上4辆客车，才允许放上一辆货车；若等待客车不足4辆，则以货车代替；若无货车等待，允许客车都上船。试设计一个算法模拟渡口管理。</span><br><span class="line"></span><br><span class="line">“同类车先到先上船’一一队列。一个队列负责一种车。</span><br><span class="line">接下来是按照条件进行按顺序上车。</span><br><span class="line">每次上限是10，也就是4客车+1货车，4客车+1货车。</span><br><span class="line">最后两个条件，其实就是“没客车的话货车可以替代客车”和“没货车的话客车可以替代货车”。</span><br><span class="line">写两个函数，用于上客车和上货车，每一个内部再进行判断是否够用。</span><br><span class="line">经过上面的过程，整个算法的思路就明确下来了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061647514.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;        <span class="comment">//保存n</span></span><br><span class="line"><span class="type">double</span> val;   <span class="comment">//保存Pn的值</span></span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comculate</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">Stack a; <span class="comment">//结构体数组，最大限制100</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>,i;</span><br><span class="line"><span class="keyword">for</span>(i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">top++;</span><br><span class="line">a[top].n=i;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> fv1=<span class="number">1</span>,fv2=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">while</span>(top&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">a.[top].val=<span class="number">2</span>*x*fv2<span class="number">-2</span>*(a.[top].n)*fv1;</span><br><span class="line">fv1=fv2;</span><br><span class="line">fv2=a.[top].val;</span><br><span class="line">top--;     <span class="comment">//出栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> fv1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fv2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><hr><ul><li><code>分支结点</code>：有左孩子或右孩子或都有的结点</li><li><code>叶子结点</code>：没有左右孩子的结点</li><li><code>结点之间的路径</code>：结点与结点之间的边的数量，只能单方向从上往下</li><li><code>结点的层次(深度)</code>：从上往下数，<code>默认从1开始</code></li><li><code>结点的高度</code>：从下往上数</li><li><code>树的高度(深度)</code></li><li><code>结点的度</code>：结点有多少个分支</li><li><code>树的度</code>：各结点的度的最大值</li><li><code>森林</code>：m个(m&gt;=0)互不相交的树组成</li><li><code>前驱</code>：<code>遍历后的顺序</code>，当前节点的前一个节点为该节点的前驱节点</li><li><code>后继</code>：<code>遍历后的顺序</code>，当前节点的后一个节点为该节点的前驱节点</li></ul><h2 id="树的常考性质"><a href="#树的常考性质" class="headerlink" title="树的常考性质"></a>树的常考性质</h2><hr><ul><li>1.结点数=总度数+1<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336588.png" alt="image.png"></li></ul><ul><li>2.度为m的树第i层最多有<code>m^(i-1)</code>个结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336371.png" alt="image.png"></li></ul><ul><li>3.高度为h的m叉树最多有<code>(m^h - 1)/(m - 1)</code>个结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337980.png" alt="image.png"></li></ul><ul><li>4.具有n个结点的m叉树的最小高度为[logm(n(m-1)+1)]<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337731.png" alt="image.png"></li></ul><ul><li>5.具有n个结点的二叉树，总共有n+1个空链域</li></ul><h2 id="几种特殊的二叉树"><a href="#几种特殊的二叉树" class="headerlink" title="几种特殊的二叉树"></a>几种特殊的二叉树</h2><ul><li><code>满二叉树</code>：度全为2或0</li><li><p><code>完全二叉树</code>:最多只有一个度为1的结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338981.png" alt="image.png"></p></li><li><p><code>二叉排序树</code>：左子树上所有节点均小于根节点，右子树上均大于根节点</p></li><li><code>平衡二叉树</code>：树上任意结点的左子树和右子树的深度只差不超过1,能有更高的搜索效率<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338997.png" alt="image.png"></li></ul><h2 id="二叉树的常考性质"><a href="#二叉树的常考性质" class="headerlink" title="二叉树的常考性质"></a>二叉树的常考性质</h2><p><code>1.具有n个结点的完全二叉树的高度</code><br><code>向上取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338666.png" alt="image.png"></p><p><code>向下取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339299.png" alt="image.png"></p><p><code>2.完全二叉树，度为0、1、2的结点个数</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设度为0、1、2的结点个数分别为n0、n1、n2</span><br><span class="line">yw 是完全二叉树</span><br><span class="line">sy n0=0或1</span><br><span class="line">yw n0=n2+1</span><br><span class="line">sy n0+n2--&gt;奇数</span><br><span class="line">sy n0+n2+n0的奇偶性看n1</span><br><span class="line">sy 当n1=1时，结点数是偶数；当n1=0时，结点数为奇数</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><ul><li><code>顺序存储(指的是顺序表的结构实现)</code>：<ul><li><code>完全二叉树</code><ul><li>如果结点从1开始</li><li>i结点的左孩子：2i</li><li>i结点的右孩子：2i+1</li><li>i的父节点：i/2向下取整</li><li>i所在层次：参照3.4</li></ul></li><li><code>不完全二叉树</code><ul><li>判断是否有左右孩子就没有规律了</li><li>这样的顺序表的数组没被填满，造成存储空间浪费</li></ul></li><li><code>结论</code><ul><li>顺序存储只适合于存储完全二叉树</li></ul></li></ul></li><li><code>链式存储(链表结点实现)</code>：</li></ul><h2 id="课后习题-5"><a href="#课后习题-5" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">1.树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是树的高度-1</span><br><span class="line"></span><br><span class="line">2.[2010统考真题]在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结</span><br><span class="line">点，1个度为2的结，点，10个度为1的结点，则树T的叶结点个数是（82）</span><br><span class="line"></span><br><span class="line">解析：结点总数=20x4+10x3+1x2+10x1+1=123;又因为结点总数=有度结点（20+10+1+10）+无度结点所以</span><br><span class="line">123-41=82;</span><br><span class="line"></span><br><span class="line">3.度为2的有序树不一定是二叉树，因为，二叉树的每个结点都有左右次序，若一个树有两个结点但是没有左右次序，那么就不算是二叉树</span><br><span class="line"></span><br><span class="line">4.重要--&gt;n个结点的完全二叉树的高度为(log2n) + 1  或log2(n+1)</span><br><span class="line"></span><br><span class="line">5.设二叉树有2n个结点，且m&lt;n,则不可能存在（）的结点。</span><br><span class="line">A.n个度为0</span><br><span class="line">B.2m个度为0</span><br><span class="line">C.2m个度为1</span><br><span class="line">D.2m个度为2</span><br><span class="line"></span><br><span class="line">解析：因为2n=n0 + n1 + 2n2，所以n1=2(n-n2)-1是奇数</span><br><span class="line"></span><br><span class="line">5.重要总结：高度为h的满二叉树的结点个数=2^h-1--&gt;类比，二进制位计算</span><br><span class="line"></span><br><span class="line">6.[2009统考真题]已知一棵完全二叉树的第6层(设根为第1层)有8个叶结，点，则该</span><br><span class="line">完全二叉树的结点个数最多是（）</span><br><span class="line">A.39</span><br><span class="line">B.52</span><br><span class="line">C.111</span><br><span class="line">D.119</span><br><span class="line"></span><br><span class="line">解析：第六层有8个叶子结点，说明树有可能6层有可能7层，最多就是7层的时候，计算得到111</span><br><span class="line"></span><br><span class="line">7.[2011统考真题]若一棵完全二叉树有768个结，点，则该二叉树中叶结点的个数是（）。</span><br><span class="line">A.257</span><br><span class="line">B.258</span><br><span class="line">C.384</span><br><span class="line">D.385</span><br><span class="line"></span><br><span class="line">解析：完全二叉树最后一个分支结点的序号是n/2，有小数舍去小数部分</span><br><span class="line"></span><br><span class="line">8.2018统考真题]设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结</span><br><span class="line">点都有2个子结点。若T有k个叶结点，则T的结点总数是（）。</span><br><span class="line">A.2k-1</span><br><span class="line">B.2k</span><br><span class="line">C.2^k</span><br><span class="line">D.2^k-1</span><br><span class="line"></span><br><span class="line">解析：A</span><br><span class="line"></span><br><span class="line">9.[2020统考真题]对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构</span><br><span class="line">保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存</span><br><span class="line">储单元数量至少是（）。</span><br><span class="line">A.31</span><br><span class="line">B.16</span><br><span class="line">C.15</span><br><span class="line">D.10</span><br><span class="line"></span><br><span class="line">解析：顺序存储，数组存放，又因为逻辑结构的二叉树高5层，却只有10个结点，说明没有放满</span><br><span class="line">想象成一颗5层的满二叉树 A</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序-深度优先遍历"><a href="#先序-深度优先遍历" class="headerlink" title="先序/深度优先遍历"></a>先序/深度优先遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339295.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339938.png" alt="image.png"></p><h2 id="递归遍历求树的深度"><a href="#递归遍历求树的深度" class="headerlink" title="递归遍历求树的深度"></a>递归遍历求树的深度</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339775.png" alt="image.png"></p><h2 id="层序-广度优先遍历-BFS"><a href="#层序-广度优先遍历-BFS" class="headerlink" title="层序/广度优先遍历(BFS)"></a>层序/广度优先遍历(BFS)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339790.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340204.png" alt="image.png"></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340268.png" alt="image.png"></p><h2 id="确定一颗二叉树"><a href="#确定一颗二叉树" class="headerlink" title="确定一颗二叉树"></a>确定一颗二叉树</h2><ul><li><code>如果只是给定一个二叉树的前\中\后\层序\遍历序列中的一种，那么是无法确定唯一的一颗二叉树的</code></li><li>至少要知道两种不同遍历的序列：<code>前+中</code>、<code>后+中</code>、<code>层序+中</code></li><li>基本思路都是通过<code>前\后\层序遍历</code>确定根节点，再通过<code>中序遍历</code>确定左右子树</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前序+中序</button></li><li class="tab"><button type="button" data-href="#test1-2">后序+中序</button></li><li class="tab"><button type="button" data-href="#test1-3">层序+中序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><code>前+中</code><br>前序遍历，可以确定序列<code>第一个是根节点</code><br>—&gt;然后再中序遍历中找到根节点位置，根节点左边就是<code>左子树</code>，右边就是<code>右子树</code><br>—&gt;接着，可以找出前序遍历中左子树的位置，和右子树的位置，分别看做新的独立二叉树<br>—&gt;找出左子树的根节点，和右子树的根结点，再分别在中序遍历中找出对应根结点位置<br>—&gt;重复直到确定一颗二叉树所有结点位置</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340641.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340184.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340293.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><hr><h2 id="线索二叉树定义"><a href="#线索二叉树定义" class="headerlink" title="线索二叉树定义"></a>线索二叉树定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尾部结点的左右指针，由指向NULL转变为指向前驱和后继</span><br><span class="line">这样有利于二叉树寻找前驱和后继</span><br><span class="line">疑问？那如果左右指针不是空的结点该如何指向自己的前驱后继呢？</span><br></pre></td></tr></table></figure><ul><li><code>注意</code>：这里讲的前驱，后继是指的是遍历后<code>序列</code>顺序的前后结点，不是二叉树结构上的前后关系<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341836.png" alt="image.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,<span class="title">rchild</span></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ltag</span>,<span class="title">rtag</span>;</span><span class="comment">//左右线索标记</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当线索标记为1时，左右指针才作为线索，指向前驱后继</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341247.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中序线索二叉树、后序线索二叉树、前序线索二叉树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341794.png" alt="image.png"></p><h2 id="线索二叉树的实现"><a href="#线索二叉树的实现" class="headerlink" title="线索二叉树的实现"></a>线索二叉树的实现</h2><ul><li>这里只举例<code>中序遍历线索化</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">本质就是二叉树的中序遍历</span><br><span class="line"></span><br><span class="line">只是在参数里多传递了一个前驱指针pre</span><br><span class="line"></span><br><span class="line">主要结构 左、根、右 --&gt;就是一个中序遍历结构</span><br><span class="line"></span><br><span class="line">pre指向的是p的前驱</span><br><span class="line">当遍历到最底层时，开始执行访问结点操作，也就是中间黄色代码操作</span><br><span class="line">如果p左节点为空，那么可以转为线索指向前驱pre,标记变为1</span><br><span class="line">接着如果pre的右结点有空位，也可以指向前驱p</span><br><span class="line">接着，pre后移为后继p</span><br><span class="line">p后移为后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree spre)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">InThread(p-&gt;<span class="number">1</span>child,pre); <span class="comment">//递归，线索化左子树</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)(  <span class="comment">//左子树为空，建立前驱线索</span></span></span><br><span class="line"><span class="params">p-&gt;lchild=pre;</span></span><br><span class="line"><span class="params">p-&gt;<span class="number">1</span>tag=<span class="number">1</span>:</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;<span class="number">6</span>pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">pre-&gt;rchild=p;           <span class="comment">//建立前驱结点的后继线索</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">pre=p;                                <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span></span><br><span class="line"><span class="params">InThread(p-&gt;rchild,pre); <span class="comment">//递归，线索化右子树</span></span></span><br><span class="line"><span class="params">&#125;<span class="comment">//if (p!=NULL)</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="type">void</span> CreateInThread(ThreadTree T)&#123;</span></span><br><span class="line"><span class="params">ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//pre传入的是NULL,因为递归遍历到最低部结点(序列第一个结点)，没有前驱</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//非空二叉树，线索化</span></span></span><br><span class="line"><span class="params">InThread(T,pre);</span></span><br><span class="line"><span class="params"><span class="comment">//线索化二叉树</span></span></span><br><span class="line"><span class="params">pre-&gt;rchild=<span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//处理遍历的最后一个结点</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304152226551.png" alt="image.png"></p><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只举例中序线索二叉树的遍历</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">p=p-&gt;lchi1d;<span class="comment">//最左下结点（不一定是叶结点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p的后继</span></span><br><span class="line">TreadNode *<span class="title function_">Nextnode</span><span class="params">(TreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Firstnode(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;right;<span class="comment">//rtsg==1直接返回线索</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综合上述两个方法，能够写出遍历中序线索二叉树的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(TreadNode *T)</span>&#123;</span><br><span class="line">TreadNode *p;</span><br><span class="line"><span class="keyword">for</span>(p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课后习题-6"><a href="#课后习题-6" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.引入线索二叉树的目的是（）</span><br><span class="line">A,加快查找结点的前驱或后继的速度</span><br><span class="line">B.为了能在二叉树中方便插入和删除</span><br><span class="line">C.为了能方便找到双亲</span><br><span class="line">D.使二叉树的遍历结果唯一</span><br><span class="line"></span><br><span class="line">解析：线索是结点的前驱和后继结点的指针，可以加快遍历</span><br><span class="line"></span><br><span class="line">2.线索二叉树是一种(C)结构。</span><br><span class="line">A.逻辑B.逻辑和存储C.物理D.线性</span><br><span class="line"></span><br><span class="line">解析：二叉树是一种逻辑结构。</span><br><span class="line">而线索二义树明确指明了在存储过程中的数据存放方式(指明了线索是标记为1的时候)，就是物理结构了。</span><br><span class="line">(物理结构=存储结构)</span><br><span class="line"></span><br><span class="line">3.n个结点的线索二叉树上含有的线索数为(B)</span><br><span class="line">A.2n</span><br><span class="line">B.n-1</span><br><span class="line">C.n+l</span><br><span class="line">D.n.</span><br><span class="line"></span><br><span class="line">解析：每个结点有两条链域指针，总共2n条，每个结点被一条指针指向，剩余的构成线索，2n-(n-1)</span><br><span class="line"></span><br><span class="line">4.二叉树在线索化后，仍不能有效求解的问题是（D）。</span><br><span class="line">A.先序线索二叉树中求先序后继</span><br><span class="line">B.中序线索二叉树中求中序后继</span><br><span class="line">C.中序线索二叉树中求中序前驱</span><br><span class="line">D.后序线索二叉树中求后序后继</span><br><span class="line"></span><br><span class="line">4.注意，前序、中序线索树的遍历不需要通过弹栈的方式来遍历后继结点，因为后继都可以通过线索来指向</span><br><span class="line">但是，后序线索二叉树的遍历必须通过弹栈的方式，返回上一层及的后继结点，如下图所示，结点3既没有左右孩子指针指向4结点，又没有后继线索指向4结点(左右子树占用了线索)</span><br><span class="line"></span><br><span class="line">所以，中序，前序线索二叉树不需要栈支持了，但是后序线索二叉树任然需要</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231343369.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5.[2011统考真题]一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1,</span><br><span class="line">该二叉树的中序遍历序列不会是（C）。</span><br><span class="line">A.1,2,3,4</span><br><span class="line">B.2,3,4,1</span><br><span class="line">C.3,2,4,1</span><br><span class="line">D.4,3,2,1</span><br><span class="line"></span><br><span class="line">解析：前后序遍历序列相反，说明每个结点只能有左孩子或只能有右孩子,不会同时存在两个子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.编写后序遍历二叉树的非递归算法</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路先将左子树遍历到底，再遍历右子树，最后根</span></span><br><span class="line"><span class="comment">//1.沿着根的左孩子，依次入栈，直到左孩子为空</span></span><br><span class="line"><span class="comment">//2.读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1;否则，栈顶元素出栈并访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack S; 指针访问标记r ; 当前指针p; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">push(S,p);</span><br><span class="line">p=p-&gt;lift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Getop(S,p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right&amp;&amp;p-&gt;right!=r)&#123; <span class="comment">//标记r,结点弹栈之后要防止原来的再入栈</span></span><br><span class="line">p=p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pop(S,p);</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">r=p;</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.试给出二叉树的自下而上、从右到左的层次遍历算法。</span><br><span class="line"></span><br><span class="line">解析：思路，按照层序遍历遍历，新增一个栈，用于存放出队列的结点，这样就能将原有序列取反，并在最后通过弹栈进行后续操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InvertLevel</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Queue Q;</span><br><span class="line">Init(Q);</span><br><span class="line">BiTree q;</span><br><span class="line">Q.EnQueue(T); <span class="comment">//入栈T</span></span><br><span class="line"><span class="keyword">while</span>(!iSEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line">Push(S,q);<span class="comment">//出队列，入栈</span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">Pop(S,p);</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.采用非递归算法，遍历一棵树并得到树的高度</span></span><br><span class="line"><span class="comment">//思路，采用层序遍历的方式，设置变量level记录当前层数。设置变量last,指向当前层的最后一个结点，当辅助队列的front=last时，就表示，当前层的结点遍历完了,那么level+1；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">BiNode data[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">level_order</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">int</span> level=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">Queue Q;</span><br><span class="line">InitQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(!T)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EnQueue(T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">BiTree p=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">EnQueue(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">EnQueue(Q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q.front=last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072029018.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">BiTree data[MaxSize];</span><br><span class="line"><span class="type">int</span> level[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Qu;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BiWide</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max i;</span><br><span class="line">Qu Q;</span><br><span class="line">Q.front=Q.rear=<span class="number">-1</span>;</span><br><span class="line">Q.rear++;   <span class="comment">//T入队</span></span><br><span class="line">Q.data[rear]=T</span><br><span class="line">Q.level[rear]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q.front&lt;Q.rear)&#123;</span><br><span class="line">Q.front++;  <span class="comment">//出队</span></span><br><span class="line">q=Q.data[front];</span><br><span class="line">k=Q.level[front];</span><br><span class="line"><span class="keyword">if</span>(q-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;left;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;right;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历level数组，看那个层次的个数最多</span></span><br><span class="line">max=<span class="number">0</span>;i=<span class="number">0</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear)&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear&amp;&amp;k==Q.level[i])&#123;  <span class="comment">//统计第k层的结点的个数</span></span><br><span class="line">i++;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">k=Q.level[i];</span><br><span class="line"><span class="keyword">if</span>(n&gt;max)&#123;</span><br><span class="line">max=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062342344.png" alt="image.png"></p><p>10.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设有一颗满二叉树，已知其先序序列为pre,设计一个算法求其后序序列post</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProToPost</span><span class="params">(Element pre[],<span class="type">int</span> l1,<span class="type">int</span> h1,Element post[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>)&#123;</span><br><span class="line"><span class="type">int</span> half;</span><br><span class="line"><span class="keyword">if</span>(l1&lt;=h1)&#123;</span><br><span class="line">post[h2]=pro[l1];</span><br><span class="line">half=(l1+h1)/<span class="number">2</span>;</span><br><span class="line">ProToPost(pre,l1+<span class="number">1</span>,l1+half,post,l2,l2+half<span class="number">-1</span>); <span class="comment">//转换左子树</span></span><br><span class="line">ProToPost(pre,l1+half+<span class="number">1</span>,h1,post,l2+half,h2<span class="number">-1</span>); <span class="comment">//转换右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072042893.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11.设一颗二叉树中各个结点的值不相同，其先序遍历和中序遍历的序列分别存放在数组A[1..n]和数组B[1..n]中，试编写一个算法建立该二叉树的二叉链表</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.现根据先序序列确定树的根节点</span></span><br><span class="line"><span class="comment">//2.在结合中序遍历，确定左子树右子树节点个数--&gt;划分左右子树--&gt;也就是划分数组中左右</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">BiTree <span class="title function_">BuildTree</span><span class="params">(ElemType A[],<span class="type">int</span> l1,<span class="type">int</span> h1,ElemType B[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>&#123;</span><br><span class="line"><span class="comment">//初始调用时，设l1,l2=1，h1,h2=n</span></span><br><span class="line">BiTree root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode))  <span class="comment">//建立根节点</span></span><br><span class="line">root-&gt;data=A[l1];                          <span class="comment">//将根节</span></span><br><span class="line"><span class="type">int</span> i=l2;</span><br><span class="line"><span class="keyword">while</span>(A[l1]!=B[i])&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">llen=i-l2;   <span class="comment">//左子树结点个数</span></span><br><span class="line">rlen=h2-i;  <span class="comment">//右子树结点个数</span></span><br><span class="line"><span class="keyword">if</span>(llen)&#123;   <span class="comment">//对左子树递归</span></span><br><span class="line">root-&gt;left=BuildTree(A,l1+<span class="number">1</span>,l1+llen,B,l2,l2+llen<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;     <span class="comment">//左子树为空</span></span><br><span class="line">root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rlen)&#123;</span><br><span class="line">root-&gt;right=BuildTree(A,h1-rlen+<span class="number">1</span>,h1,B,h2-rlen+<span class="number">1</span>,h2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071436493.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取层次遍历算法，将所有结点入队(包括空节点，当遍历遇到空节点时，如果是满二叉树，其后必定是全部为空，如果还有非空节点就不是完全二叉树)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsCompelet</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">init(Q);</span><br><span class="line">EnQueue(Q,T);</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line">EnQueue(q-&gt;left);</span><br><span class="line">EnQueue(q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">    q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line"><span class="keyword">return</span> fasle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071454344.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取任意一种遍历算法即可，这里采取最基本的中序遍历算法，对当前节点处理时，判断其是否存在左右孩子，并设置一个static变量用于统计具有双分支结点的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">InOrder(T-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>&amp;&amp;T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">InOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><h2 id="什么是森林？"><a href="#什么是森林？" class="headerlink" title="什么是森林？"></a>什么是森林？</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062345931.png" alt="image.png"></p><h2 id="树、森林转化为二叉树"><a href="#树、森林转化为二叉树" class="headerlink" title="树、森林转化为二叉树"></a>树、森林转化为二叉树</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先将树转化为二叉树</span><br><span class="line">将树转化为二叉树</span><br><span class="line">1.给兄弟加线</span><br><span class="line">2.将除长子外的与父节点的线去掉</span><br><span class="line">3.最后层次调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070951715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将森林转化为二叉树</span><br><span class="line">1.先将所有树先转化为二叉树</span><br><span class="line">2.将第一课树的根节点，将自己的子树森林转化为左子树，右子树指向下一棵树的根节点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071001666.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071002020.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树、森林、二叉树遍历序列等价问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071103398.png" alt="image.png"></p><h2 id="课后习题-7"><a href="#课后习题-7" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062357926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070943205.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071004393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071008954.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设树原始分支只有一条</span><br><span class="line">想象树每多一条分支，就会出现一个叶子结点，且多一组兄弟结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071021560.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.若森林F有15条边、25个结点，则F包含树的个数是</span><br><span class="line">A.8</span><br><span class="line">B.9</span><br><span class="line">C.10</span><br><span class="line">D.11</span><br><span class="line"></span><br><span class="line">解析：对于一棵树而言，除了根节点，其他每个结点都由一条边指向，也就是说，其他每个结点都对应一条边，所以，一棵树的结点数=边数+1</span><br><span class="line">所以，结点数-边数=25-15=10，所以有10棵树</span><br><span class="line"></span><br><span class="line">2.编程求以孩子兄弟表示法存储的森林的叶子结点数。</span><br><span class="line"></span><br><span class="line">解析：题目意思是，求在森林转化的二叉树中，找到原森林中叶子结点的个数</span><br><span class="line">找规律发现，森林中的叶子结点，在二叉树中都没有左子树，所以可以通过遍历二叉树，每次碰到结点判断一下该节点是否有左孩子，没有就num++</span><br><span class="line"></span><br><span class="line">3.在二叉树中有两个结点m和n,如果m是n的祖先，使用（C）可以找到从m到n的路径。</span><br><span class="line">A.先序遍历</span><br><span class="line">B.中序遍历</span><br><span class="line">C.后序遍历</span><br><span class="line">D.层次遍历</span><br><span class="line"></span><br><span class="line">解析：后序遍历是从后往前，在找到n之后，层层往上层父节点寻找，这个过程一定能找到m，并且父节点入栈顺序是按照从后往前的顺序。</span><br><span class="line">但是先序遍历，在找到n之后，因为在这之间先访问了父节点，所以这个父节点入栈顺序是从前往后，从一开始就要入栈的话，就无法保证找到n</span><br><span class="line">中序遍历一样抽象</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结点的带权路径长度：从树的根节点到该结点的路径长度(经过的边数)与该结点上值得乘积</span><br><span class="line">树的带权路径长度：树种所有叶子结点的带权路径之和(WPL,Weight Path Length)</span><br><span class="line">带权路径长度最小的二叉树被称为哈夫曼树，也称最优二叉树</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树是为了达到 使编码串变短的目的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>编码问题</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>S=AAABBACCCDEEA<br>T(S)=000000000001001000010010010011100100000</p><p><code>S中出现次数</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">为了使得编码变短，尽量将出现次数较多的编码缩短</span><br><span class="line">于是建立如下哈夫曼树</span><br><span class="line"></span><br><span class="line">1.将字符按出现次数从多到少排列</span><br><span class="line">2.从最少的两个次数相加组成 次数结点</span><br><span class="line">3.同样的过程完全建立一颗抽象的树状结构</span><br><span class="line">4.在树上左分支0,右分支1</span><br><span class="line">5.向右寻找一位,编码1，向左寻找一位编码0</span><br><span class="line">6.例如 B --&gt; 110</span><br><span class="line">7.A次数最多5--&gt;编码最短0  ；D次数最少1--&gt;编码最长1110</span><br><span class="line">8.达到了编码串缩短的目的</span><br><span class="line"></span><br><span class="line">如何解码呢？</span><br><span class="line">从左到右逐个扫描编码串字符，0向左走，1向右走，如果走到叶子结点（字符位置），就读取</span><br><span class="line">然后再次回到根节点，没有就继续扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707509.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707805.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.权值越大的字符，离根节点越近(权值看做字符的次数)</span><br><span class="line">2.哈夫曼树中，没有度为1的结点，这类树叫做&quot;正则二叉树&quot;(严格二叉树)</span><br><span class="line">3.哈夫曼树的带权路径长度最短(也称最优二叉树)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707715.png" alt="image.png"></p><h2 id="二叉树的估计"><a href="#二叉树的估计" class="headerlink" title="二叉树的估计"></a>二叉树的估计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右侧的分别是表示遍历后的顺序 黑色表示要删除的</span><br><span class="line">注意：前后结果相反，有两种情况，没有左(L)或没有右(R)都满足</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707899.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708586.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708670.png" alt="image.png"></p><h2 id="二叉存储表达式"><a href="#二叉存储表达式" class="headerlink" title="二叉存储表达式"></a>二叉存储表达式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据二叉存储表达式建立二叉树：3+4*5*(2+3)</span><br><span class="line">手工方法：1.加括号明确运算次序(3+((4*5)*(2+3)))</span><br><span class="line">         2.列出数字元素 3  4  5  2  3 作为叶子结点</span><br><span class="line">         3.按运算次序 用运算符作为分支节点 建立二叉树</span><br><span class="line">栈方法：不介绍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708561.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用树，来求表达式的值 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708601.png" alt="image.png"></p><h2 id="课后习题-8"><a href="#课后习题-8" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.前缀码是一种编码系统，通常是可变长度码，在其中的每个码字，都具备「前缀性质」(prefix property)，也就说，在编码中的每个码字，都不能被其他码字当成前置部位。例如，编码字&#123;9,55&#125;具备了前缀性质，但编码字&#123;9,5,59,55&#125;就不具备，因为其中的&quot;5”，是59&quot;及&quot;55&quot;的前缀</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目已对两个字符编码1和01，因为哈夫曼树只对叶子结点进行编码，所以1和01两个结点就是叶子结点，不能继续延伸。故只能往左下继续寻找，最终如图，注意要数的是叶子结点的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061929244.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树如果有n个叶子结点，那么总共有2n-1个结点</span><br><span class="line">因为n个叶子结点，经过n-1次整合，构建出n-1个非叶子结点，总共2n-1个结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061936631.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次整合需要m个，之后整合只需m-1个叶子结点，每次整合有一个非叶子结点，所以n-1/m-1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061956033.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1对于哈夫曼树的说法错误的是（D）</span><br><span class="line">A.对应一组权值构造出来的哈夫曼树一能不是唯一的</span><br><span class="line">B.哈夫曼树具有最小的带权路径长度</span><br><span class="line">C.哈夫曼树中没有度为1的结点</span><br><span class="line">D.哈夫曼树中除了度为1的结点外，还有度为2的结点和叶结点</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">A:确实不唯一。仅思考两个结点的情况：1和2，就有两种：1在左子树2在右子树和反过来。</span><br><span class="line">B:正确。正是我们使用哈夫曼树进行编码的意义所在。</span><br><span class="line">C:正确。任意非叶子结点都是由两个树（数据元素）构成的，因此不存在度为1的结点。</span><br><span class="line">D:解析同C,因此错误。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓定长编码集，就是所有字符编码位数都一样，0001 1100 1010 ..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062100296.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062127393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="课后习题-9"><a href="#课后习题-9" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.图中有关路径的定义是(A).</span><br><span class="line">A.由顶点和相邻顶点序偶构成的边所形成的序列</span><br><span class="line">B.由不同顶，点所形成的序列</span><br><span class="line">C.由不同边所形成的序列</span><br><span class="line">D.上述定义都不是</span><br><span class="line"></span><br><span class="line">解析：A路径是由顶点与相邻顶点序偶构成的边的序列 例如顶点A到顶点D的路劲 &lt;A B&gt; &lt;B C&gt; &lt;C D&gt; ; B路劲不是由顶点构成 ；C没有讲明是由相邻的边形成的序列</span><br><span class="line"></span><br><span class="line">2.[2017统考真题]已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶</span><br><span class="line">点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是（11）</span><br><span class="line"></span><br><span class="line">解析：无向图边数的2倍等于各顶点度数的总和。为求至少的顶点数，应使每个顶点的度取最大，由</span><br><span class="line">于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x,列出方程4×3+3×4+2x=16×2,</span><br><span class="line">解得x=4。因此至少包含4+4+3=11个顶点。</span><br><span class="line"></span><br><span class="line">3.图G是一个非连通无向图，共有28条边，该图至少有多少个项点？</span><br><span class="line"></span><br><span class="line">解析：由于图G是一个非连通无向图，在边数固定时，顶点数最少的情况是该图由两个连通子图构</span><br><span class="line">成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全</span><br><span class="line">图的边数为n(n-1)2=28,得n=8。所以该图至少有1+8=9个顶点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图的逻辑结构-王道"><a href="#图的逻辑结构-王道" class="headerlink" title="图的逻辑结构(王道)"></a>图的逻辑结构(王道)</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顶点与顶点的关系</span><br><span class="line">- 路径一一顶点v到顶点v之间的一条路径是指顶点序列</span><br><span class="line">- 回路一一第一个顶点和最后一个顶点相同的路径称为回路或环</span><br><span class="line">- 简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。</span><br><span class="line">- 简单回路一一除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</span><br><span class="line">- 路径长度一一路径上边的数目</span><br><span class="line">- 点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到的距离</span><br><span class="line">  若从u到v根本不存在路径，则记该距离为无穷(∞)。</span><br><span class="line">- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的</span><br><span class="line">- 有向图中，若从项点到项w和从项点w到项点之间都有路径，则称这两个项点是强连通的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162341036.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连通图、强连通图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162353758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部图的研究--子图</span><br><span class="line">- 子图：部分顶点，与部分边构成的较小的局部图</span><br><span class="line">- 生产子图：包含原图所有顶点的子图，不一定要所有边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162355746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连通分量--描述无向图</span><br><span class="line">- 包含尽可能多的顶点和边</span><br><span class="line">- 下面三个部分都是极大连通子图，属于单独的一个分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162357370.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">强连通分量--描述有向图</span><br><span class="line">同上</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305170000437.png" alt="image.png"></p><h2 id="图逻辑结构-天勤"><a href="#图逻辑结构-天勤" class="headerlink" title="图逻辑结构(天勤)"></a>图逻辑结构(天勤)</h2><ul><li>图由<code>顶点</code>和<code>边</code>构成</li><li><code>无向图</code>：边没有指向方向 (A1,A3)   没有指向 </li><li><code>有向图</code>：边有箭头方向    <A1,A3> 表示A1—&gt;A3 ,不能反过来</li><li><code>顶点的度</code>：多少条边与该顶点相连<ul><li>无向图：A1的度为3</li><li>有向图：A1入度为1，出度为2，度为3</li></ul></li><li><code>简单图</code>：不存在重复的边，并且没有指向自身的边</li><li><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302311509.png" alt="image.png"></p></li><li><p><code>无向完全图</code>：任意两个顶点之间，都存在边，总共<code>n(n-1)/2</code>条边</p></li><li><p>有向完全图：任意两个顶点之间，都存在两条方向相反的边，总共<code>n(n-1)</code>条边<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302312402.png" alt="image.png"></p></li><li><p>若边含有权值则称为网<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342083.png" alt="image.png"></p></li><li><p><code>路径</code>：一个顶点到相邻顶点序偶构成的<code>边</code>的序列,例如：（A1 A2）（A2 A3）（ A3 A6）</p></li><li><code>简单路径</code>：序列中顶点不重复出现的路径 例如：A1 A2 A3 A2 A4就不是简单路径，其中A2重复了</li><li><code>回路(环)</code>：第一个顶点和最后一个顶点相同，例如：A1 A4 A3 A1</li><li><p><code>简单回路</code>：除了第一个顶点和最后顶点，中间没有重复出现顶点</p></li><li><p><code>连通图</code>：针对<code>无向图</code>不一定要闭合，只要任意顶点间有路径即可<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342495.png" alt="image.png"></p></li><li><p><code>非连通图</code>：<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342005.png" alt="image.png"></p></li></ul><ul><li><code>强连通图</code>：针对有向图。如果有向图中的任意两个节点都可以互相到达，则该有向图是强连通的</li><li><code>弱连通图</code>：针对有向图。如果将有向图中的所有有向边都看作无向边，得到的无向图是连通的，则该有向图是弱连通的。</li><li><code>极大强连通子图（强连通分量）</code>：针对有向图</li><li><code>极小强连通子图</code>：针对有向图</li></ul><h2 id="极小连通子图与最小生成树"><a href="#极小连通子图与最小生成树" class="headerlink" title="极小连通子图与最小生成树"></a>极小连通子图与最小生成树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 极小连通子图是指一个无向图的子图，如果它是连通的，并且在保持子图连通的前提下，不能从子图中删除任何边，那么它就是极小连通子图。</span><br><span class="line"></span><br><span class="line">- 最小生成树是指一个连通无向图的生成树，它包含图中所有的顶点，并且边的权值之和最小。生成树是一种特殊的极小连通子图，它没有环，并且边数等于顶点数减1。如果一个极小连通子图是一个树，那么它也是原图的生成树。但是，并不是所有的极小连通子图都是树，也不是所有的极小连通子图都是最小生成树。</span><br></pre></td></tr></table></figure><h2 id="有向-无向图的连通问题"><a href="#有向-无向图的连通问题" class="headerlink" title="有向-无向图的连通问题"></a>有向-无向图的连通问题</h2><hr><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161023514.png" alt="image.png"></p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只讨论有向图强连通，弱连通就是无向图的情况，不再讨论</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161039922.png" alt="image.png"></p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><hr><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用一个二维数组，形成的一个矩阵表示顶点之间的关系</span><br><span class="line">这里演示的是带权的路径</span><br><span class="line">用行标、列标组合表示两个顶点之间路径</span><br><span class="line">按行列找到的数值就是路径权值，例如(1,0)=2,表示1--&gt;0的路径权值为2</span><br><span class="line">这里规定对角线上的值为无穷，也就是顶点到自身的路径为无穷(有的地方也规定为0)</span><br><span class="line"></span><br><span class="line">注意：当二位数组对称，说明是无向图，互相指向；当二维数组不对称，说明是有向图</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342024.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0行 X 3列</span><br><span class="line">只有0行与3列对应相乘都不为0时才有值</span><br><span class="line">结果=3，说明有3个点，与0和3都存在路径</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343697.png" alt="image.png"></p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只能表示出边，或只能表示入边</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于稀疏图，避免矩阵造成大量空间的浪费</span></span><br><span class="line"><span class="comment">//采用了顺序存储+链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;        <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode,AdjList[MaxSize]   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">AdjList vertice;       <span class="comment">//顶点数组指针(也可以说顶点数组)</span></span><br><span class="line"><span class="type">int</span> n,e                <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下图邻接表由两部分构成，左边的顶点数组(存着下标信息)+右边的边结点链表(1.数字是顶点下标，2.右侧是相接该顶点的另一条边的指针)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各个边在边组成链表中出现的先后顺序不是固定的，所以图邻接表的表示方式并不唯一，</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011638260.png" alt="image.png"></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">针对有向图</span><br><span class="line">只能用于存储有向图</span><br><span class="line">由于邻接表无法表示入边，与出边，所以改进为十字链表</span><br><span class="line">左结构体--&gt;顶点   右结构体--&gt;边</span><br><span class="line">in表示入边，out表示出边，由first引出第一条，由next引出下一条，01、14、20...表示边(有方向)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639953.png" alt="image.png"></p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">针对无向图</span><br><span class="line">左结构体--&gt;顶点  右结构体--&gt;边</span><br><span class="line">由于边是双向</span><br><span class="line">接下来有点抽象自己看^o^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639673.png" alt="image.png"></p><h4 id="课后习题-10"><a href="#课后习题-10" class="headerlink" title="课后习题"></a>课后习题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.邻接表可以用于存储无向图，，只是把每条边都视为两条方向相反的有向边，因此需要存储两次</span><br><span class="line"></span><br><span class="line">2.在有向图的邻接表存储结构中，顶，点v在边表中出现的次数是（C）。</span><br><span class="line">A顶点v的度</span><br><span class="line">B.顶点v的出度</span><br><span class="line">C:顶点v的入度</span><br><span class="line">D.依附于顶，点v的边数</span><br><span class="line"></span><br><span class="line">3.n个顶点的无向图的邻接表最多有(B)个边表结点。</span><br><span class="line">A.n2</span><br><span class="line">B.n(n-1)</span><br><span class="line">C.n(n+1)·</span><br><span class="line">D.n(n-1)/2</span><br><span class="line"></span><br><span class="line">解析：n个顶点的无向图最多有(n-1)/2条边，每条边在邻接表中存储两次，所以边表结点最多为</span><br><span class="line">n(n-l)个。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.带权有向图G用邻接矩阵存储，则的入度等于邻接矩阵中(D).</span><br><span class="line">A.第i行非∞的元素个数</span><br><span class="line">B.第i列非∞的元素个数：</span><br><span class="line">C.第i行非∞且非0的元素个数</span><br><span class="line">D.第i列非∞且非0的元素个数</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.写出从图的邻接表表示转换成邻接矩阵表示的算法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思路：通过普通的遍历，依次序的遍历所有的顶点，并修改邻接矩阵的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert</span><span class="params">(AlGraph *G,<span class="type">int</span> [M][N])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ArcNode *p = G-&gt;v[i].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="type">int</span>[i][p-&gt;adjv]=<span class="number">1</span>;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152205562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点的连通图，最多有n(n-1)/2条边--&gt;每个顶点与其他n-1个顶点相连，最后每条边重复考虑了一次。</span><br><span class="line">所以28条边的连通图最少有8个顶点，要是非连通图则+1顶点 与其他顶点隔离 --&gt;8+1=9</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152210169.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点，组成连通无向图，边最少n-1，因为 形成单链</span><br><span class="line">组成强连通有向图，边最少n ，因为形成有向环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152218916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无向图将所有顶点的度相加=边数x2 ，因为每条边会多重复算一次，利用这个特性，求出度为2的点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152229507.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向图,求每个顶点最大的度--&gt;每个顶点最多与n-1个顶点相连--&gt;出边+入边--&gt;(n-1)*2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152235585.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152256350.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环任意去除一条边都是一颗生成树--&gt;共有n条边--&gt;有n条生成树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152313137.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在树中，每个顶点都有一条边指向，除了根节点，所以n-e=根结点数目</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152317313.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这道题比较难</span><br><span class="line">保证形成连通图的最少变数，7个顶点，前6个保证连通边数达到最大无法再增多，再多加1条连接剩下的顶点，7个就保证连通了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152329630.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无向图双向的，所以邻接矩阵沿对角线一定对称；由于这个矩阵不对成所以一定是有向图</span><br><span class="line">第i个顶点的度=矩阵中i行i列的1之和</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152347902.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Edge --&gt; E 边</span><br><span class="line">Vertex --&gt; V 顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161019171.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28条边用最少顶点充分利用n(n-1)=26--&gt;8个顶点--&gt;再额外+1孤立顶点--&gt;实现非连通--&gt;最少9顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161042675.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所有1集中在对角线往上</span><br><span class="line">- i&lt;j</span><br><span class="line">- i到j有边</span><br><span class="line"></span><br><span class="line">运用拓扑排序方式，对顶点号依次编号</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161111107.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161116342.png" alt="image.png"></p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历犯法</span><br><span class="line"></span><br><span class="line">为了防止出现图遍历的时候的死循环问题需要，将遍历过得结点进行标记，防止再次遍历</span><br><span class="line">于是</span><br><span class="line">1.设置一个与顶点数组相对应的标记数组(设为全局变量)，数组初始=0；</span><br><span class="line">2.遍历过后标记为1，visit[v]=1;</span><br><span class="line">3.然后ArcNode*q=G-&gt;adjList [v].first 找到第一条与该顶点相连的边</span><br><span class="line">4.找到第二条与该顶点相连的边，访问下一个顶点(往深处找)，先判断是否访问过</span><br><span class="line">5.如果没有访问过进行递归</span><br><span class="line">6.如果访问过就找与之相连的下一条边，直到与该顶点相连的边遍历完</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjV;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边(兄弟边)的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;        <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode,AdjList[MaxSize]   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">AdjList vertice;       <span class="comment">//顶点数组指针(也可以说顶点数组)</span></span><br><span class="line"><span class="type">int</span> n,e                <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639135.png" alt="image.png"></p><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历</span><br><span class="line">要点：</span><br><span class="line">1.找到与一个顶点相邻的所有顶点</span><br><span class="line">2.标记哪些顶点被访问过</span><br><span class="line">3.需要一个辅助队列，这里采用循环队列</span><br><span class="line"></span><br><span class="line">采用循环的队列作为辅助队列</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedeof <span class="type">int</span> maxSize</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G,<span class="type">int</span> v,<span class="type">int</span> visited[maxSize])</span>&#123;</span><br><span class="line">ArcNode *p;</span><br><span class="line"><span class="type">int</span> que[maxSize],front=<span class="number">0</span>,rear=<span class="number">0</span>;  <span class="comment">//辅助队列</span></span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">visit(v);                         <span class="comment">//访问出队顶点；</span></span><br><span class="line">vistted[v]=<span class="number">1</span>;</span><br><span class="line">rear = (rear+<span class="number">1</span>)%maxSize;  </span><br><span class="line">que[rear]=v;                      <span class="comment">//顶点入队,入队的其实是位置下标</span></span><br><span class="line"><span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">front = (front+<span class="number">1</span>)%maxSize;     <span class="comment">//出队一个顶点，赋值给j</span></span><br><span class="line">j=que[front];</span><br><span class="line">p=G-&gt;AdjList[j].first;         <span class="comment">//找到与这个顶点出去的边</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[p-&gt;adjV]==<span class="number">0</span>)&#123;   <span class="comment">//判断是否访问过</span></span><br><span class="line">visit(p-&gt;adjV);</span><br><span class="line">visited[p-&gt;adjV]==<span class="number">1</span>;</span><br><span class="line">rear=(rear+<span class="number">1</span>)%maxSize; </span><br><span class="line">que[rear]=p-&gt;adjV      <span class="comment">//入队</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;               <span class="comment">//寻找下一条边(找与之相连的下一个)</span></span><br><span class="line">&#125;                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640748.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640524.png" alt="image.png"></p><h2 id="最小生成树-Prim算法"><a href="#最小生成树-Prim算法" class="headerlink" title="最小生成树(Prim算法)"></a>最小生成树(Prim算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成树：由一个图按照某一种规则，导出里面包含的一颗树(就是由图所有顶点，与部分边，构成的一颗树，就是极小连通子图)</span><br><span class="line"></span><br><span class="line">最小生成树：构成的这颗生成树的所有分支的权值和最小(所以讨论的是带权图)</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.先确定一个根节点A0</span><br><span class="line">2.找到与根节点相邻的所有的边，选择权值最小的并入树中(如果产生环，则选择第二小的)，此时A0  A1两个结点</span><br><span class="line">3.继续，找到与A0 A1相邻的所有的边，3,2,7,8 --&gt;将权值为2的边并入树，此时结点A0 A1 A2</span><br><span class="line">4.重复...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640486.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641608.png" alt="image.png"></p><h2 id="最小生成树-Kruskal算法"><a href="#最小生成树-Kruskal算法" class="headerlink" title="最小生成树(Kruskal算法)"></a>最小生成树(Kruskal算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大致思想是</span><br><span class="line">1.将每条边都列举出来，按照权值从小到大排列</span><br><span class="line">2.从最小的边开始，如果边两边的顶点并未&quot;连通&quot;，则连通这条边</span><br><span class="line">3.如果两边顶点处于同一个&quot;并查集&quot;，即连通，则遍历下一条边</span><br><span class="line">4.直到所有顶点处于同一个&quot;并查集&quot;中，即生成了最小生产树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641841.png" alt="image.png"></p><h2 id="最短路径-DIjkstra"><a href="#最短路径-DIjkstra" class="headerlink" title="最短路径(DIjkstra)"></a>最短路径(DIjkstra)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">求某一个顶点(确定某一点)到其余各顶点之间的最短路径</span><br><span class="line"></span><br><span class="line">设置3个数组</span><br><span class="line">dist[] --&gt;树中，min[从起点经过新增顶点与上述顶点间的距离,原本直接距离] ，初始=无穷</span><br><span class="line">path[] --&gt; 表示，上述顶点的起始顶点 ,初始=-1</span><br><span class="line">set[] --&gt; 0表示未并入树中，1表示已在树中 ，初始=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641565.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新 ，&#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新，&#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><h2 id="最短路径-Floyd"><a href="#最短路径-Floyd" class="headerlink" title="最短路径(Floyd)"></a>最短路径(Floyd)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">求带权图中各顶点之间的最短路劲</span><br><span class="line"></span><br><span class="line">A矩阵：记录顶点到顶点的距离(一开始无中转点，无路径则为∞)</span><br><span class="line">path矩阵：记录顶点到顶点之间中转点(一开始无设为-1)</span><br><span class="line"></span><br><span class="line">接下来依次将中转点由V0~Vn遍历</span><br><span class="line">确定每一个中转点后，又在A距离矩阵遍历，比较加入中转点后与原距离的大小</span><br><span class="line">比如A(-1)[2][1] &gt; A(-1)[2][0] + A(-1)[0][1] 表示将0作为中转点，V2到V1的距离缩短了 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161335255.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三层循环，时间复杂度O(V^3)；空间复杂度O(V^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161351010.png" alt="image.png"></p><h2 id="最短路劲总结"><a href="#最短路劲总结" class="headerlink" title="最短路劲总结"></a>最短路劲总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161410881.png" alt="image.png"></p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不存在环路的有向图，也称DAG图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642453.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式，将重复部分，只保留一个(可以节省空间)，由两个指针指向同一个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642293.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642866.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式的构建</span><br><span class="line">1.将出现的元素罗列出来</span><br><span class="line">2.按照运算次序，按顺序加入运算符结点，并且将运算符号分层</span><br><span class="line">3.最后从最底层检查是否有重复部分，并合并</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643679.png" alt="image.png"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列是有向无环图（DAG）中所有顶点的一种线性排序，使得对于每一条有向边 &lt;u, v&gt;，顶点 u 在拓扑序列中都排在顶点 v 的前面。换句话说，拓扑序列可以看作是一个 DAG 中所有顶点的一种合法排序方式。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AOV网</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643547.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例，下列拓扑排序总共有5种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序，实现的是，将AOV网中依次的输出具有传递性的活动(顶点),找到做事的先后顺序</span><br><span class="line"></span><br><span class="line">AOV网允许有多个入度为0的顶点活动</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.找到入度为0的顶点，先输出</span><br><span class="line">2.删除顶点，与顶点有关的边（出边，也就是将由该顶点指向的所有顶点入度-1）</span><br><span class="line">3.重复1 2 直到为空</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码实现需要定义两个数组，一个栈</span><br><span class="line">indegree[] 记录当前所有顶点的入度</span><br><span class="line">print[] 记录拓扑排好的的顶点序列</span><br><span class="line">Stack S 保存度为0的顶点(也可以用队列代替)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TopoSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化栈</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.n;i++)&#123; <span class="comment">//遍历找出所有入度为0的顶点</span></span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">push(S,i);      <span class="comment">//将入度为0的顶点进栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数目</span></span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Pop(S); <span class="comment">//栈顶元素出栈</span></span><br><span class="line">print[count]=i;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].first;p!=<span class="literal">NULL</span>;p=p-&gt;next)&#123;<span class="comment">//将所有由i指向的顶点入度-1</span></span><br><span class="line"><span class="type">int</span> v=p-&gt;adjV;</span><br><span class="line"><span class="keyword">if</span>(!(--indegree[v]))&#123;</span><br><span class="line">push(S,v); <span class="comment">//入度为0，入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//说明有回路，排序失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该算法。每一个顶点要被处理一次，每一条边也要遍历一次，所以时间复杂度O(|V|+|E|) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643741.png" alt="image.png"></p><h2 id="DFS实现逆拓扑排序"><a href="#DFS实现逆拓扑排序" class="headerlink" title="DFS实现逆拓扑排序"></a>DFS实现逆拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里和深度优先遍历几乎一样</span><br><span class="line">只是将Visit(v)放到最后</span><br><span class="line">实现了，只有递归结束之后访问本节点(在这之前已经先访问了递归里面的结点，也就是深处结点)</span><br><span class="line">这样就实现了逆拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643774.png" alt="image.png"></p><h2 id="DFS算法实现拓扑排序"><a href="#DFS算法实现拓扑排序" class="headerlink" title="DFS算法实现拓扑排序"></a>DFS算法实现拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1)假设结点u是结点v的祖先，则在调用DFS访问u的过程中，必然会在这个过程结束之</span><br><span class="line">前递归地对y调用DFS访问，即v的DFS函数结束时间先于u的DFS结束时间。从而</span><br><span class="line">可以考虑在DFS调用过程中设定一个时间标记，在DFS调用结束时，对各结点计时。因</span><br><span class="line">此，祖先的结束时间必然大于子孙的结束时间。</span><br><span class="line"></span><br><span class="line">2)若u是结点v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。</span><br><span class="line">3)若u和v没有关系，则u和v在拓扑序列的关系任意。</span><br><span class="line">从而按结束时间从大到小，可以得到一个拓扑序列。</span><br><span class="line"></span><br><span class="line">实际上和深度优先遍历算法完全相同，只不过加入了变量time</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> v,ALGraph *G,<span class="type">int</span> time,<span class="type">int</span> Time[])</span>&#123;</span><br><span class="line">vistit[v]=<span class="number">1</span>;</span><br><span class="line">ArcNOde *p=G-&gt;AdjList[v].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[q-&gt;AdjV]==<span class="number">0</span>)&#123;</span><br><span class="line">DFS(q-&gt;AdjV,G);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">time++;</span><br><span class="line">Time[v]=time;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后再按照time从多到少的顺序，输出，就得到了拓扑排序结果</span></span><br></pre></td></tr></table></figure><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图中所有路径长度=总工期的路径 ，都是关键路径</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOE网，边表示活动，顶点表示事件</span><br><span class="line"></span><br><span class="line">1.只有顶点事件发生后，各条边活动才能开始</span><br><span class="line">2.顶点的所有入边活动都结束时，顶点事件才能发生</span><br><span class="line">3.有些活动是能并行进行的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOE网只有1个入度为0的顶点，开始顶点(源点)，他表示整个工程的开始</span><br><span class="line">也只有1个出度为0的顶点，结束顶点(汇点)，他表示整个工程的结束</span><br><span class="line"></span><br><span class="line">从源点到汇点的所有路径中，具有最大路径长度(总权值)的路径称为关键路径，关键路径上的活动称为，关键活动</span><br><span class="line"></span><br><span class="line">在这里关键路径的总长度就是整个工程完成所需最短时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644443.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vk--&gt;顶点(事件)  ai--&gt;活动(边)</span><br><span class="line"></span><br><span class="line">1.事件vk的最早完成时间ve(k)</span><br><span class="line">2.事件vk的最晚完成时间vl(k)</span><br><span class="line">3.边ai的最早完成时间e(i)</span><br><span class="line">4.边ai的最晚完成时间l(i)</span><br><span class="line"></span><br><span class="line">规定将发生时间最长的路线定为汇点的 最晚发生时间=最早发生时间(如果不规定一下最晚发生时间，那么没有意义，因为，前面的事件可以一直拖下去永远不执行)</span><br><span class="line"></span><br><span class="line">可以通过逆拓扑排序先从后往前的倒推每个事件的最迟发生时间(由汇点来反推)</span><br><span class="line"></span><br><span class="line">关键活动是，活动最迟发生时间=活动最早发生时间 的活动</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644666.png" alt="image.png"></p><h2 id="课后习题1"><a href="#课后习题1" class="headerlink" title="课后习题1"></a>课后习题1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.以下叙述中，正确的是（A）。</span><br><span class="line">A.只要无向连通图中没有权值相同的边，则其最小生成树唯一</span><br><span class="line">B.只要无向图中有权值相同的边，则其最小生成树一定不唯一</span><br><span class="line">C.从n个顶，点的连通图中选取n-1条权值最小的边，即可构成最小生成树</span><br><span class="line">D.设连通图G含有n个顶点，则含有n个顶点、n-1条边的子图一定是G的生成树</span><br><span class="line"></span><br><span class="line">解析：选项A最小生成树的算法是基于贪心策略的，每次从事选取权值最小的，且满足条件的边，如果各边权值不同，则每次选择的新的顶点也是唯一的，因此最小生成树是唯一的</span><br><span class="line">选项B,若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。选项C,选取的一1条边可</span><br><span class="line">能构成回路。选项D,含有n个顶点、n-1条边的子图可能构成回路，也可能不连通。</span><br><span class="line"></span><br><span class="line">2.最短路径一定是简单路劲</span><br><span class="line"></span><br><span class="line">3.下面的（A）方法可以判断出一个有向图是否有环（回路）。</span><br><span class="line">I.深度优先遍历Ⅱ.拓扑排序Ⅱ.求最短路径V.求关键路径</span><br><span class="line">A.I、Ⅱ、IV</span><br><span class="line">B.I、II、V,</span><br><span class="line">C.:I、IⅡ、IⅢ</span><br><span class="line">D.全部可以</span><br><span class="line"></span><br><span class="line">解析：深度优先遍历，深度优先遍历是逐层遍历的,通过栈等数据结构可以记录已经访问过的顶点。一旦发现重复顶点,立即结束遍历,返回最终结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最小生成树不唯一的话，得到的最小生成树就可能相同也可能不同</span><br><span class="line">但是如果最小生成树唯一，那不同算法得到的就一定相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161206652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基础</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161210191.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先画出图</span><br><span class="line">2.根据图直接判断，因为是选择题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161413553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序结束条件时找到直至为空，如果有环，则无法找到拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161418914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161426088.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不能排成拓扑序列，说明有环，那么D正确</span><br><span class="line">强连通分量--&gt;就是顶点之间可以相互抵达，那么就是存在闭环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161444715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下列拓扑排序总共5种，理解什么是拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵 顶点指向方向 i-&gt;j 行-&gt;列  </span><br><span class="line">如果上三角矩阵：那么必定 编号小指向编号大</span><br><span class="line">如果下三角矩阵：那么必定 编号大指向编号小的</span><br><span class="line"></span><br><span class="line">而拓扑排序，必定是小编号指向大编号，那么体现在邻接矩阵就是上三角矩阵</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161456601.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图拓扑序列唯一 但是图却不止一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161503337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">关键路径手算</span><br><span class="line">1.画出图</span><br><span class="line">2.画表格，最早开始时间 ；最晚开始时间</span><br><span class="line">3.从前往后依次计算各个顶点最早开始时间(就是等顶点之前所有顶点完成的时间)</span><br><span class="line">4.之后再从后往前，求各个顶点的最晚开始时间(应该满足不影响工期，就是最后一个顶点的最早开始时间 21)</span><br><span class="line">5.找出最早、最晚开始时间相等的点组成关键路径</span><br><span class="line"></span><br><span class="line">关键路径的长度必然=整个工程完成的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161515079.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I ：加入只有一个路径，那么关键路径就是自己，怎么变都是一条关键路径</span><br><span class="line">II ：关键路径就是整个工程时间，没问题</span><br><span class="line">III：如果有多条关键路径，降低某一条不影响其他条</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161608871.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS深度优先遍历</span><br><span class="line">这样想，比如1这个结点最先入栈，在它后面的结点没有弹栈之前不会弹栈</span><br><span class="line">递归的思考，对于每个结点都是这样，于是就神奇的发现，实现了逆拓扑排序，只需要在弹栈之后再输出元素就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161635017.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新  &#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新 &#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩短工期问题，必须缩短所有关键路径共有的边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161806152.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例子，举最简单例子 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161809806.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列，边推进边删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161813650.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161854380.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">4...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162037259.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顶点的最早开始时间与最晚开始时间容易求</span><br><span class="line">需要注意的是，边的最早开始时间就是顶点的最早开始时间(顶点刚开始，就开启活动)</span><br><span class="line">但是，边的最晚开始时间却不是起始顶点的最晚开始时间(活动可能有剩余时间等待)，所以</span><br><span class="line">应该从 下一个顶点的最晚开始时间减去活动所需时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162102546.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图 DAG 表达式应用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162112044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">注意：如果存在多个入度=0的顶点，那么拓扑序列可能有多个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162135908.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间余量：就是不拖延工期前提，活动最多能拖延多久</span><br><span class="line">活动时间余量=结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162216094.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2)该图有多少个强连通分量？</span><br><span class="line">只有入度没有出度，或者只有出度没有入度的顶点，必然不可能和其他顶点连通，所以这种顶点自身就是一个强连通分量。通过不断去除已经找到的强连通分量进而更加清晰的寻找另外的强连通分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172253366.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">综合3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172318917.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明如何用DFS 实现拓扑排序?</span><br><span class="line">- 深度优先遍历，会将先经过的结点入栈，先入后出，一般用于实现逆拓扑排序</span><br><span class="line">- 如果反过来要实现逆拓扑排序，则需要定义一个全局变量time,标记当前结点的结束时间</span><br><span class="line">- 然后将顶点按时间从大到小排序，得到的的就是拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181137335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra最短路径算法能否给出一颗生产树？该树是否一定是最小生成树？</span><br><span class="line">- 能，但不一定是最下生成树。</span><br><span class="line"></span><br><span class="line">解答：Dijkstra最短路径算法能够给出一棵生成树，但该树不一定为最小生成树。虽然Dijkstra算法和Prim算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</span><br><span class="line"></span><br><span class="line">Dijkstra算法对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;Min[k]+G[k][j]);</span><br><span class="line">Min[j]=Min[k]+G[k][j];</span><br><span class="line"></span><br><span class="line">而Pim算法Q对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;G[k][j]);</span><br><span class="line">Min[j]=G[k][j]</span><br><span class="line"></span><br><span class="line">为此，可考虑以下的反例</span><br><span class="line">对于以下的带权连通无向图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181208563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181147863.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2011年真题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181217437.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（2）.本质就是图结构体=顶点结构体+边结构体</span><br><span class="line">（3）.本质就是找出R1到各个路由器的最短路劲，然后按照从小到大的顺序排序，Dijkstra算发就是按照，先入较短路径的顶点，然后根据新入顶点找下一个较短路劲顶点，这样得到的顶点路劲必然是后面加入的顶点路劲更长</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232316553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.按照prim算法过程依次选出边即可</span><br><span class="line">（2）.题目只问一个问题——是否唯一？；答，唯一即可，无需多做解释</span><br><span class="line">（3）.题目只问满足什么条件时？；答一个充分条件即可。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232328694.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.&quot;所有可能&quot;，说明要列出所有，的最小生成树的情况</span><br><span class="line">（2）.写prim算法名称--&gt;奇怪怎么会有怎么简单的问题？</span><br><span class="line">（3）.TTL就是信息保留时间，当路径长度大于TTL时，信息销毁</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232343584.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储的图</span><br><span class="line">DFS遍历使用了栈--&gt;栈内存的顶点最多不超过顶点数n</span><br><span class="line">BFS使用了队列--&gt;队列内的顶点数，最多也不超过n</span><br><span class="line">那么DFS BFS空间复杂度都与n都有关,空间复杂度&#x27;不可避免&#x27;的O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241436702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无论是DFS还是BFS</span><br><span class="line">邻接矩阵都有nxn个空间需要依次遍历，所以时间复杂度是O(n^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241535428.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DFS遍历</span><br><span class="line">分析D选项</span><br><span class="line">从a作为开始结点a--&gt;e--&gt;d--&gt;f--&gt;c </span><br><span class="line">到c往下DFS发现边为NULL，执行到底不再递归弹栈,返回到c</span><br><span class="line">返回c，发现c的next为空，执行到底，退出栈</span><br><span class="line">返回f,发现..</span><br><span class="line">返回d,发现...</span><br><span class="line">返回e,发现e的next边与b相连，于是对b递归，访问b</span><br><span class="line">--&gt;最终顺序是a e d f c b</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241553960.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241544054.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错--&gt;至于通过报错判断是否有环是否可以利用还存在争议</span><br><span class="line">B.Dijikstra算法是求最短路劲，通过依次加入顶点，更新距离的操作与有没有环没有关系</span><br><span class="line">C.深度优先遍历算法.这里可以微调一下深度优先算法.将弹栈后的结点，清除器访问标记--&gt;</span><br><span class="line">这样做虽然会导致访问重复结点，但是我们的目的是判断是否有环，而不是遍历。所以有环的话，必然会在某一条深度递归中，压入已经存在栈内的顶点(重复顶点)，那么就可以判断有环存在。至于清除访问标记是因为该深度已经遍历，那么将节点释放相当于弹栈，以便判断下一条单条深度递归中的重复顶点。</span><br><span class="line">D.广度优先遍历,无法实现有向图是否有环的判断，因为，广度优先遍历无法判断图是否有环，因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242130768.png" alt="Uploading file...urh96"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于图的概念辨别题，主要是要理清楚图的概念</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242257386.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这道题目需要注意的点：</span><br><span class="line">1.对于写出深度优先生成树，不能根据给出的表，画出完整的图G后再进行深搜。因为给定的表隐含着遍历顺序，而你完整图中进行的遍历没有符合题目要求的顺序,因此，应该直接根据邻接表来深度搜索--&gt; 1--&gt;2--&gt;3--&gt;4--&gt;5</span><br><span class="line">2.对于写出广度优先生成树，同样的道理不能按照画出的完整图来遍历，原因依然是要按照题目中邻接表中隐含的顺序来进行推进--&gt;1 2 3 4 5 如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242335365.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242328392.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算法设计</span><br><span class="line">1.切入点：树的顶点=数的边+1</span><br><span class="line">2.步骤：初始化两个变量i j,分别存储顶点数目，边的数目；遍历顶点，没访问一个顶点i++,在访问与该点所有相连的边,每条边j++;最终边的数量统计了两次，因为一条边连接了两个顶点，所以最终统计i=j/2 + 1是否成立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252008877.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS如果不用递归，那么必须需要栈的数据结构来替代递归栈.</span><br><span class="line">邻接表采用深度优先遍历，从i开始--&gt;i入栈--&gt;遍历j--&gt;j入栈--&gt;跳转到j开头那一行--&gt;遍历k--&gt;k入栈--&gt;跳转到k的那一行--&gt;...--&gt;遍历到最深层--&gt;一次往回弹栈</span><br><span class="line">从过程中，入栈需要存入两种信息：</span><br><span class="line">1.该入栈结点的编号 </span><br><span class="line">2.该入栈顶点位于哪行的地几个位置(为了使得弹栈之后回到相对应的位置继续遍历) </span><br><span class="line">3.另外还需要，用一种数据结构存储已经遍历过的顶点，防止重复遍历</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252034320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用遍历算法判断邻接表方式存储的有向图中，是否存在顶点i到j的路径</span><br><span class="line">1.将i作为遍历的开始顶点</span><br><span class="line">2.采用任意遍历算法，遍历只要寻找到顶点j就说明存在从i到j的路径,返回true，否则返回false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252052716.png" alt="image.png"></p><h2 id="课后习题2"><a href="#课后习题2" class="headerlink" title="课后习题2"></a>课后习题2</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252202149.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完全图的定义：任意两个顶点之间都存在边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252206168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵:nxn</span><br><span class="line">无向图:矩阵中2e个1</span><br><span class="line">0个数=n^2-2e</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252208299.png" alt="Uploading file...p539r"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于邻接矩阵而言，&quot;行出列入&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252219197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图的邻接表的存储结构--&gt;左边一列，顶点结构体；右边的是由顶点引出的与顶点相连的所有边结构体。</span><br><span class="line"></span><br><span class="line">这题顶点v在边表中的出现次数，是指边表中存储的是边指向的下一个顶点(有向图)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271149779.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储无向图，由于无向图边是双向的，所以n(n-1)条边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271202239.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除有向图某个顶点v相关的所有边</span><br><span class="line">1.删除该顶点引出的所有一连串的边表结点，最多引出n-1条边 O(n) </span><br><span class="line">2.删除所有指向该顶点的所有边，由于无法判断起始点是哪一个，所以只能从头到尾遍历O(e)</span><br><span class="line"></span><br><span class="line">最终时间复杂度O(n+e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271210580.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十字链表是存储有向图</span><br><span class="line">邻接多重表是存储无向图</span><br><span class="line"></span><br><span class="line">推出十字链表和邻接多重表的目的是为了将某一条边的两个顶点都表示出来，以至于可以直接通过一条边找到两端的两个顶点，而不是只能从一个顶点出发</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271422325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271515927.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> numVertice,numEdge;</span><br><span class="line"><span class="type">char</span> Vertice[maxV];    <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> Edge[maxv][maxv];  <span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsExistEL</span><span class="params">(Mgraph G)</span>&#123;</span><br><span class="line"><span class="type">int</span> degree,count;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.numV;i++)&#123;</span><br><span class="line">degree =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j;j&lt;G.numV;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G.Edge[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">degree++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(degree%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">2</span>||count==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271544169.png" alt="image.png"></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><blockquote><p>基本概念<br><code>查找长度</code>：查找运算中，需要对比关键字的次数<br><code>平均查找长度</code>：（ASL  Average Search Length），所有查找过程中进行关键字比较次数的平均值</p></blockquote><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><hr><p>时间复杂度 无论如何优化，始终为<code>O(n)</code></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><hr><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041349757.png" alt="image.png"></p><ul><li>针对<code>有序的顺序表</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable T,ElemType key)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=T.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(T.data[mid]==key)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T.data[mid]&lt;key)&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//查找失败</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041428775.png" alt="image.png"><br><code>折半查找判定树</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041435628.png" alt="image.png"><br><code>折半查找判定树的性质</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- mid=(low+high)/2 采用的是向下取整方式</span><br><span class="line">- 结点数n为奇数，右子树结点数-左子树结点数=1</span><br><span class="line">- 结点数n为偶数，右子树结点数=左子树结点速</span><br><span class="line"></span><br><span class="line">- 折半查找判定树一定是平衡二叉树</span><br><span class="line">- 折半查找判定树，只有最下面一层不是满的，因此求树高h于完全二叉树公式一致</span><br><span class="line">- 失败结点：n+1个也就是查找成功结点的空链域数量</span><br><span class="line">- 每个元素所在层数表示查找次数，所以查找成功，失败的时间复杂度不会超过树高(树高不包括失败</span><br><span class="line">  结点)log2(n+1),时间复杂度O(log2n)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041446033.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041448619.png" alt="image.png"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树高不包含失败的结点(紫色的空节点)，因为查找失败的查找次数也就是查找到其父节点的查找次数(也就是失败结点的父节点的树高)，因为，当查找到树梢结点发现没找到就查找失败，那么查找是吧的次数也就是树梢结点的高度了</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041453663.png" alt="image.png"></li></ul><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：块内无序，块间有序,块内存放数据个数不同，索引中保存每个块的最大关键字和起始到末尾的地址</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041501254.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 考察选择，不要求代码</span><br><span class="line"></span><br><span class="line">索引表中保存的是每个区块中最大的关键字</span><br><span class="line"></span><br><span class="line">分块查找</span><br><span class="line">- 对分块的索引表采用顺序查找</span><br><span class="line"></span><br><span class="line">- 对分块的索引表采用折半查找</span><br><span class="line">分两种情况：</span><br><span class="line">1.查找元素正好是索引表的元素,例如30</span><br><span class="line">2.查找元素不是索引表的元素此时，折半查找，最终low&gt;high，low指向的就是目标元素</span><br><span class="line"> 所在区块</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041711226.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序查找方式</span><br><span class="line">ASL=查索引表的平均查找长度+查分块的平均查找长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041723622.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找方式</span><br><span class="line">ASl分析，不太重要，就不讨论了...</span><br></pre></td></tr></table></figure><h2 id="二叉查找-排序-树-BST"><a href="#二叉查找-排序-树-BST" class="headerlink" title="二叉查找(排序)树(BST)"></a>二叉查找(排序)树(BST)</h2><h3 id="查找-插入-构造树"><a href="#查找-插入-构造树" class="headerlink" title="查找-插入-构造树"></a><code>查找-插入-构造树</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">二叉查找(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-2">二叉查找(递归)</button></li><li class="tab"><button type="button" data-href="#test1-3">二叉排序树插入(递归)</button></li><li class="tab"><button type="button" data-href="#test1-4">二叉排序树插入(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-5">二叉排序树的建立</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;left,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&gt;T-&gt;key,key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若原二叉树为空，则直接插入结点，否则关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=key;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;left,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BST_Search</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T=T-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=k;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="type">int</span> str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">BST_Insert(T,str[i]); <span class="comment">//插入方法</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><code>查找ASL分析</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">查找成功ASL分析</button></li><li class="tab"><button type="button" data-href="#test1-2">查找失败ASL分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042035408.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042036128.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="二叉排序树删除"><a href="#二叉排序树删除" class="headerlink" title="二叉排序树删除"></a><code>二叉排序树删除</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">情况1-删叶节点</button></li><li class="tab"><button type="button" data-href="#test1-2">情况2-只有左或·右结点-</button></li><li class="tab"><button type="button" data-href="#test1-3">同时有左右结点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接删除，不影响排序树结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042039542.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也是可以直接删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042040203.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><code>有两种方式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将删除节点的右子树的最小节点替代删除节点</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042048914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将左子树的最大节点替代删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042049351.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a><code>回顾</code></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042051390.png" alt="image.png"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><hr><h3 id="平衡二叉树概念"><a href="#平衡二叉树概念" class="headerlink" title="平衡二叉树概念"></a>平衡二叉树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树(Balanced Binary Tree)，在二叉排序树基础上，树上任意结点的左子树与右子树高度只差不超过1</span><br><span class="line"></span><br><span class="line">平衡因子=左子树高度-右子树高度</span><br><span class="line"></span><br><span class="line">如果二叉树平衡，各个结点的平衡因子只能是0,-1,1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072211245.png" alt="image.png"></p><h3 id="平衡二叉树插入调整"><a href="#平衡二叉树插入调整" class="headerlink" title="平衡二叉树插入调整"></a>平衡二叉树插入调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树插入新结点如何保持平衡？</span><br><span class="line"></span><br><span class="line">只需调整引起不平衡的最小的那个子树，画圈的部分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072213624.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如何调整？</span><br><span class="line"></span><br><span class="line">插入导致不平衡分为四种情况：(A是最小不平衡子树)</span><br><span class="line">LL 在A的左孩子的左子树中插入导致不平衡</span><br><span class="line">RR 在A的右孩子的右子树中插入导致不平衡</span><br><span class="line">LR 在A的左孩子的右子树中插入导致不平衡</span><br><span class="line">RL 在A的右孩子的左子树中插入导致不平衡</span><br><span class="line"></span><br><span class="line">通过旋转来调整二叉树的失衡</span><br><span class="line">要找到最小的那颗失衡的二叉树调整</span><br></pre></td></tr></table></figure><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><code>LL右旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231082.png" alt="image.png"></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><code>RR左旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231424.png" alt="image.png"></p><p><code>LL&amp;RR代码思路</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072232020.png" alt="image.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><code>LR</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072238460.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072239049.png" alt="image.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><code>RL</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072241280.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072242585.png" alt="image.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072243530.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072250049.png" alt="image.png"></p><h3 id="平衡二叉树ASL分析"><a href="#平衡二叉树ASL分析" class="headerlink" title="平衡二叉树ASL分析"></a>平衡二叉树ASL分析</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072259228.png" alt="image.png"></p><h3 id="平衡二叉树删除调整"><a href="#平衡二叉树删除调整" class="headerlink" title="平衡二叉树删除调整"></a>平衡二叉树删除调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①删除结点(方法同“二叉排序树”)</span><br><span class="line">②一路向北找到最小不平衡子树，找不到就完结撒花</span><br><span class="line">③找最小不平衡子树下，“个头”最高的儿子、孙子</span><br><span class="line">④根据孙子的位置，调整平衡(LL/RR/LR/RL)</span><br><span class="line">⑤如果不平衡向上传导，继续②，对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081219106.png" alt="image.png"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><hr><h3 id="红黑树定义性质"><a href="#红黑树定义性质" class="headerlink" title="红黑树定义性质"></a>红黑树定义性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然平衡二叉树与红黑树，search、Insert、Delete操作时间复杂度都是O(log2(n)),但是平衡二叉树需要频繁调整数的形态；如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/RR/LR/RL调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081233506.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">红黑树特性：</span><br><span class="line">1.每个结点或是红或是黑色</span><br><span class="line">2.根节点一定是黑</span><br><span class="line">3.叶子结点均是黑(指的是失败结点，查找失败结点，也叫NULL结点)</span><br><span class="line">4.不存在两个相邻红结点(即红结点的父、孩子结点一定是黑)</span><br><span class="line">5.对于每个结点，从该结点到任一叶子结点的简单路劲，所含黑结点数量一致</span><br><span class="line"></span><br><span class="line">=&gt;1.红黑树从根节点到叶结点(NULL结点)的最长路径长度不大于最短路径的两倍</span><br><span class="line">  2.n个结点的红黑树高度h&lt;=2log2(n+1) --&gt; search时间复杂度O(log2(n))</span><br></pre></td></tr></table></figure><p><code>红黑树结点结构体</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> key;           <span class="comment">//保存得值</span></span><br><span class="line">RBnode* parent;    <span class="comment">//父节点指针</span></span><br><span class="line">RBnode* lChild;</span><br><span class="line">RBnode* rChild;</span><br><span class="line"><span class="type">int</span> color;         <span class="comment">//结点颜色，也可用0/1表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081253235.png" alt="image.png"></p><h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p><a href="[7.3_5_红黑树的插入_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=77&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081354530.png" alt="image.png"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="B树概念"><a href="#B树概念" class="headerlink" title="B树概念"></a>B树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">考察选择，不考察代码</span><br><span class="line"></span><br><span class="line">B树性质如下</span><br><span class="line"></span><br><span class="line">1.最少有1个关键字，也就最少有2个分叉;最多有4个关键字，最多就5个分叉</span><br><span class="line"></span><br><span class="line">如何保证查找效率？</span><br><span class="line">- m叉查找树中，规定除了根节点，任何结点都必须至少有[m/2向上取整]个分叉，即保证</span><br><span class="line">  除了根结点之外的结点至少有[m/2向上取整]-1个关键字</span><br><span class="line">- m叉查找树中，规定对于任何一个结点，其所有子树的高度都相同</span><br><span class="line">-- &gt;保证了上述两个条件的m叉查找树就是B树</span><br><span class="line"></span><br><span class="line">- B树,又称为多路平衡查找树</span><br><span class="line">- B树的阶，是B树中所有节点的分支数的最大值</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081519493.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301813773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081516407.png" alt="image.png"></p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B树的高度不包括叶子结点(失败结点)</span><br><span class="line">要使得n个结点的B树高度最小--&gt;尽可能的让结点里的关键字多，且分叉多--&gt;推导--&gt;</span><br><span class="line">m-1个关键字，m个分叉，则有(m-1)(1 + m + m^2 + m^3 +...+ m^h-1) = m^h - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301833168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要使得含有n个关键字的B树的高度最大--&gt;让每个结点包含的关键字尽可能的少，分叉尽可能的少--&gt;记k=[m/2向上取整]，--&gt;每个结点关键字(根节点可以只有1个关键字，其他结点都为k-1个结点)，分叉最少为k --&gt;如下表</span><br><span class="line"></span><br><span class="line">h层的m阶B树至少包含多少关键字--&gt;就是B树高度最高的情况--&gt;根据上面的推到求得</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301857073.png" alt="image.png"></p><h3 id="B树的插入和删除"><a href="#B树的插入和删除" class="headerlink" title="B树的插入和删除"></a>B树的插入和删除</h3><hr><p><a href="[7.4_2_B树的插入删除_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=80&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h2 id="课后习题-11"><a href="#课后习题-11" class="headerlink" title="课后习题"></a>课后习题</h2><hr><h3 id="顺序查找、折半查找、分块查找"><a href="#顺序查找、折半查找、分块查找" class="headerlink" title="顺序查找、折半查找、分块查找"></a>顺序查找、折半查找、分块查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序查找概念，从一端到另一端，适合链式存储结构和顺序存储结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271605230.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为查找的目标元素是任意的，对有序表而言，需要一次从头查找直到遇到mubiao,而对无序表而言依然需要从头查找直到遇到目标，所以，无论有序还是无序表，只要查找目标四任意的，那么查找平均时间都是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271615270.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均查找长度=∑（查找概率*查找长度）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271620424.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271627148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.字符型不能比较，所以没法做到有序，也就无法二分查找</span><br><span class="line">D.二分查找只能以顺序方式存贮</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271629499.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271635334.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">折半查找树一定是一颗平衡二叉树，因为查找的元素一定是中间的元素，那么就有左半部分与右半部分，也就是左右结点，最极端的情况也就是两端没有左或没有右，也就是说，左右子树的高度只差不会大于1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271644073.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找对应着一颗平衡二叉树，任意结点的左右子树高度只差不超过1，所以对应查找时间（=树高=查找次数=log2(n)）,但是二叉排序树，没有限制高度相差，所以二叉排序树可以单个高度很高，加入要查的目标元素就在这个很高的分支里面，那么查找次数就多。</span><br><span class="line">所以，折半查找和二叉排序树的查找时间性能上，时而相同时而不同，但是大部分是折半查找效率高，</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271649628.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">折半查找树是平衡二叉树</span><br><span class="line">但是不是所有平衡二叉树都满足折半查找树要求，折半查找树，左右子树都平均，最多相差一两个结点，但是平衡二叉树比如下图，右下有一大部分空缺。</span><br><span class="line">所以如果找折半查找树的高度，可以把其当成一颗完全二叉树来求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271703396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解一下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271716769.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空节点的个数就是查找失败的个数，但是查找失败所需次数(查找长度)不是失败结点的高度，而是查找到的最后一个结点的查找次数，也就是失败结点没有高度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271734741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分块查找，将数据分为若干块，块间有序是指按每块的最大值排序，块内无序，块内数据个数无需相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271749420.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据下面推到，块内最理想块长=根号n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271806326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最好情况：最理想分块 √n ;块内有序;块内快外都进行二分查找；</span><br><span class="line">在上述最好情况下，最多比较16次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271811217.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较5次最多</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271855161.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于A 500,200说明500向左走,左边的应该都比500小符合；200,450,说明200向右走，说明200右边应该比比200大且比500小,不符合；</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271859916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该题的算法本质就是顺序查找，而顺序查找如果要比折半查找比较次数更少，那只有x接近数组开头处</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271905335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.折半查找当结点个数为偶数时，要么统一选取左边结点为中间结点，要么统一选取右边结点为中间结点，看图B 末梢处，剩余两个结点，一边的选取了靠右的为中间结点，另一边选取了考左的为中间结点，不符合算法</span><br><span class="line">C.与B类似</span><br><span class="line">D.左子树4结点，右子树5结点，说明偶数结点数，统一选取考左的为中间结点，那么又因为，更小的子树的左子树为2，右子树为1，选取的又是靠右的，互相矛盾，所以不符合算法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271914099.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当个例题来看吧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272138000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k分查找成功时间复杂度--&gt;查找树的高度logk n + 1--&gt;查找成功次数最多logk n + 1时间复杂度O(logk n)</span><br><span class="line">查找不成功查找次数最多也为logk n + 1--&gt;时间复杂度也为O(logk n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272205598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">顺序查找查找成功7,15，23...8N-1 ---&gt;共n个--&gt;查找长度1+2+3+..+n</span><br><span class="line">二分查找查找成功</span><br><span class="line">第一层结点查找长度分别为2,3,4,5,..n+1</span><br><span class="line">第二层结点查找长度分别为2x3,2x4,2x5...2x(n+2)</span><br><span class="line">第三层.. 4x4,4x5,4x6...4x(n+3)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272220088.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSearch</span><span class="params">(SSTable ST,x,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;=end)&#123;</span><br><span class="line"><span class="type">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ST.data[mid]=x)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.data[mid]&lt;x)&#123;</span><br><span class="line">end = mid<span class="number">-1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">begin = mid+<span class="number">1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272249235.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_swap</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ST.data[i]!=x&amp;&amp;i&lt;ST.length)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=ST.length)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(ST.data[i],ST.data[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line">LinkList <span class="title function_">Search_swap</span><span class="params">(Linklist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next.data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(p=L;p-&gt;next-&gt;next.data!=x;p=p-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next=q-&gt;next-&gt;next;</span><br><span class="line">p-&gt;next-&gt;next=q;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272312095.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272350405.png" alt="image.png"></p><h3 id="平衡二叉树习题"><a href="#平衡二叉树习题" class="headerlink" title="平衡二叉树习题"></a>平衡二叉树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.查找失败则插入所查找的结点，查找失败说明找到结点的右边或左边已经无节点才导致失败</span><br><span class="line">那么，直接在空的位置上插入结点，并不会导致树的分裂和组合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282215672.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">完全二叉树才是二叉排序树的最理想情况</span><br><span class="line">完全二叉树求深度以满二叉树为模板</span><br><span class="line">，根据等比数列求和 --&gt; n=2^h -1 --&gt;这是n完全沾满第h层的时候</span><br><span class="line">但是第h层没有完全沾满时，数的高度同样是h,这样就需要对log2(n+1)向上取整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282251776.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据平衡二叉树，高度为h所需最少结点数的关系，解决此题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282321303.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树任意结点的左右子树高度只差不超过1</span><br><span class="line">H=1, n=1</span><br><span class="line">H=2, h左=1，h右=0 ; 1+1+0=2</span><br><span class="line">H=3, h左=2，h右=1 ; 1+2+1=4 --&gt;h左 根据前面H=2求得的n，h右 根据前面H=1求得的n</span><br><span class="line">...</span><br><span class="line">递推</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291911448.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树RL 型调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292125948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平衡因子均为1--&gt;用最少的结点构成高度最高的平衡二叉树</span><br><span class="line">与之前那题一模一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292137300.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全程用到RR的情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292146525.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292157774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292205741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.平衡二叉树的调整，需要调整的是插入后导致的最小的不平衡子树</span><br><span class="line">2.这题是RL型，RL是指，新插入的导致二叉树不平衡的结点是相对于最小不平衡子树的头号结点的位置，是先往右，再往左</span><br><span class="line">3.相对应的树的调整相当于打方向盘，从后往前考虑，先是往左偏了，就要右旋。接着考虑上层往右偏了，就要左旋</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292214226.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直到一个二叉排序树的先序遍历序列。--&gt;数字从小到大就是中序遍历序列--&gt;结合中序遍历序列和先序遍历序列，就能完整的画出一颗二叉排序树--&gt;在根据树来进行分析</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292226147.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈用于存放结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsOrderTree</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Push(S,T);</span><br><span class="line">BiTree Q;</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Q=Pop(S);</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift-&gt;data&lt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;lift);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right-&gt;data&gt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292251685.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树求指定结点所在的树的层次</span></span><br><span class="line"><span class="comment">//思路是，通过二叉排序树查找算法，查找指定结点，查找的次数就是结点所在层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BS_Search_high</span><span class="params">(BSTree T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">BSTree Q = T;</span><br><span class="line"><span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(Q-&gt;data&lt;x)&#123;</span><br><span class="line">Q=Q-&gt;left;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q=Q-&gt;right;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301546891.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个二叉树的平衡标记balance(1,表示平衡；0表示不平衡)</span></span><br><span class="line"><span class="comment">//h为二叉树的高度，</span></span><br><span class="line"><span class="comment">//如果树空，高度为0，如果树只有一个结点高度为1，</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Jude_AVL</span><span class="params">(BiTree T,<span class="type">int</span> &amp;balance,<span class="type">int</span> &amp;h)</span>&#123;</span><br><span class="line"><span class="type">int</span> bl=<span class="number">0</span>,br=<span class="number">0</span>,hl=<span class="number">0</span>,hr=<span class="number">0</span>;  <span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line"><span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">0</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lichild==<span class="literal">NULL</span>&amp;&amp;bt-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">1</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Judge_AVL(bt-&gt;lchild,bl,hl);  <span class="comment">//递归判断左子树</span></span><br><span class="line">Judge_AVL(bt-&gt;rchild,br,hr);  <span class="comment">//递归判断右子树</span></span><br><span class="line">h=(h1&gt;h2?h1:h2)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(h1-h2)&lt;<span class="number">2</span>)&#123;    <span class="comment">//若树的高度差的绝对值&lt;2,则看左右子树是否平衡</span></span><br><span class="line">balance=bl&amp;&amp;br;    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">balance=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301559886.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从大到小输出--&gt;中序遍历稍作修改</span><br><span class="line">2.输出的值不小于k，对中间结点输出的时候，做一个判断</span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_dechute</span><span class="params">(BSTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;right); <span class="comment">//先大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data&gt;=k)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;data);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301637025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这题思路是</span><br><span class="line">在每个结点里面保存，以当前结点为根的子树中总共有多少个结点</span><br><span class="line">假设这棵树的根节点是T</span><br><span class="line">一下几种情况：</span><br><span class="line">1.T-&gt;lchild==NULL </span><br><span class="line">- 若T-&gt;rchild非空且k=1,则T就是滴k小节点</span><br><span class="line">- 若T-&gt;rchild非空且k!=1,则第k小元素在T的右子树上</span><br><span class="line">2.T-&gt;lchild!==NULL</span><br><span class="line">- T-&gt;lchild-&gt;count=k-1,则T就是第k小元素</span><br><span class="line">- T-&gt;lchild-&gt;count&gt;k-1,则第k小元素必在左子树，继续到左子树中去找</span><br><span class="line">- T-&gt;lchild-&gt;count&lt;k-1,则第k小元素必在右子树，继续搜索右子树，寻</span><br><span class="line">   找第k-(T-&gt;lchild-&gt;count+1)小的元素</span><br><span class="line"></span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTree <span class="title function_">Search_Small</span><span class="params">(BSTree T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;T-&gt;count)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count==k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&gt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;lchild,k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&lt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k-(T-&gt;lchild-&gt;count+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301709526.png" alt="image.png"></p><h3 id="红黑树习题"><a href="#红黑树习题" class="headerlink" title="红黑树习题"></a>红黑树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟悉红黑树的性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291920684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D选项：根据两个性质解答</span><br><span class="line">1.红黑树对于每个结点，到叶子结点的任意一条路径上的黑结点的个数相同</span><br><span class="line">2.红结点不能与红结点相邻</span><br><span class="line">所以红黑树的单条从根结点到叶子结点的路径上的黑色结点个数是确定的设为x</span><br><span class="line">假设出发结点是black:</span><br><span class="line">- 高度最小的子树，全部位黑色结点，高度为 x-1</span><br><span class="line">- 高度最高的子树，黑色结点与红色结点相间出现</span><br><span class="line">- 子树原结点是black--&gt; x-1 + (x-2)=2x-3</span><br><span class="line">- 子树原结点是red --&gt; (x-1)+(x-1)=2x-2</span><br><span class="line">假设出发结点是red:</span><br><span class="line">- 高度最小子树，x</span><br><span class="line">- 高度最大子树，2x-1</span><br><span class="line">左右子树高度之比都小于2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291937703.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.红黑树是自平衡的树，但不是平衡二叉树</span><br><span class="line">B.红黑树所有结点都是黑色，那么它一定是满二叉树因为从根节点出发，到叶子结点，黑色结点数是一样的</span><br><span class="line">C.红色结点孩子结点可以全为黑</span><br><span class="line">D.一看就是错的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292029968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红黑树的插入操作</span><br><span class="line">1.插入的结点始终一致染成红色</span><br><span class="line">2.如果违反了不红红，则看叔叔的颜色</span><br><span class="line">3.黑叔，影响不向上传递，只需先按照平衡二叉树旋转，然后将旋转后的爷爷结点染黑</span><br><span class="line">4.红叔，影响向上传递，只需向先将爷爷结点染红，儿子染黑，然后爷爷结点作为新插入结点继续向上判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292043633.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292116716.png" alt="image.png"></p><h3 id="B树习题"><a href="#B树习题" class="headerlink" title="B树习题"></a>B树习题</h3><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">排序算法分为 交换类排序、插入类排序、选择类排序、归并类排序</span><br><span class="line">交换类排序</span><br><span class="line"></span><br><span class="line">冒泡排序</span><br><span class="line">初冒泡排序,一般靠选择题，考大题几率小</span><br><span class="line">快速排序</span><br><span class="line">更重要，考大题</span><br><span class="line"></span><br><span class="line">插入类排序</span><br><span class="line"></span><br><span class="line">直接插入</span><br><span class="line"></span><br><span class="line">折半插入</span><br><span class="line"></span><br><span class="line">希尔排序，以上三种插入算法，一般考选择题，考大题概率低</span><br><span class="line">选择排序</span><br><span class="line"></span><br><span class="line">简单选择排序</span><br><span class="line"></span><br><span class="line">堆排序(重要)</span><br><span class="line">很有可能考大题</span><br></pre></td></tr></table></figure><h2 id="课后习题-12"><a href="#课后习题-12" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于</span><br><span class="line">我们这里所提到的内部排序范畴，也不满足前面排序的定义。</span><br><span class="line"></span><br><span class="line">2.排序算法的稳定性是指? 经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">加入需要排序的数组是arr=[1,0,6,3,2,7,5]</span><br><span class="line">需要两个下标指针i、j</span><br><span class="line">初始时，只有第一个元素有序，那i从 1开始，j=i-1</span><br><span class="line"></span><br><span class="line">arr=[  1,  0,  6,  3,  2,  7,  5]</span><br><span class="line">       j   i</span><br><span class="line">先将arr[i]=temp存着</span><br><span class="line">如果arr[j] &gt; arr[i],arr[j]往后移一位，arr[j+1]=arr[j],j--;</span><br><span class="line"></span><br><span class="line">arr[  1,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1   </span><br><span class="line">      </span><br><span class="line">arr[j+1]=temp</span><br><span class="line"></span><br><span class="line">arr[  0,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1    </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(ElemType *str,<span class="type">int</span> n)</span>&#123; <span class="comment">//n为数组长度 </span></span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        temp=str[i];<span class="comment">//暂时存目标元素  </span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;str[j]&gt;temp)&#123;<span class="comment">//将比插入的数大的全部往后移一格  </span></span><br><span class="line">            str[j+<span class="number">1</span>]=str[j];  </span><br><span class="line">            j--;</span><br><span class="line">        &#125;  </span><br><span class="line">        str[j+<span class="number">1</span>]=temp;<span class="comment">//j来到了插入位置，将temp插入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，</span><br><span class="line">因而时间复杂度为O（n）.</span><br><span class="line">在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达</span><br><span class="line">到最大，总的移动次数也达到最大，总的时间复杂度为O（n^2）.</span><br><span class="line">平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为</span><br><span class="line">平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n^2/4。</span><br><span class="line">稳定性：</span><br><span class="line">由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置</span><br><span class="line">发生变化的情况，即直接插入排序是一个稳定的排序方法</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="课后习题-13"><a href="#课后习题-13" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在待排序的元素序列基本有序的前提下，效率最高的排序方法是（）。</span><br><span class="line">A.直接插入排序B.简单选择排序C.快速排序</span><br><span class="line">D.归并排序</span><br><span class="line"></span><br><span class="line">解析:待排序序列基本有序，只需比较n-1次时间复杂度O(n),达到效率最高</span><br></pre></td></tr></table></figure><h1 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从后往前(或从前往后)两两比较相邻元素的值，如果逆序，就交换，直到将最小元素，交换到最上层</span><br><span class="line">第1轮，比较n个元素，比较n-1次，找到最小的，放到第一位</span><br><span class="line">第2轮，比较n-1个元素，比较n-2次，找到剩余中最小，放到第二位</span><br><span class="line">...</span><br><span class="line">比较n-1轮</span><br><span class="line"></span><br><span class="line">n-1 + n-2 + ...+ 3 + 2 + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(ElemType arr[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="type">bool</span> flag;  <span class="comment">//用来标记是否发生了交换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环需要比较n-1次  </span></span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//内层循环  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);  </span><br><span class="line">                flag=<span class="literal">true</span>;<span class="comment">//有交换就返回true  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;<span class="comment">//如果这一趟没有比较，直接结束无须比较  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">最好情况：数组本身有序，那么比较第一轮比较了n-1次后，标记返回false，退出排序，O(n)</span><br><span class="line">最坏情况：O(n^2)</span><br><span class="line">平均：O(n^2)</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line">稳定性：由于i&gt;j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个顺序表</span><br><span class="line">以第一个数为基数，赋值给pviot存起来，此时，基数的位置看做为空</span><br><span class="line">定义两个指针i j</span><br><span class="line">i从左往右找比3大的数，i停止</span><br><span class="line">j从右往左找比3小的数，j停止</span><br><span class="line">然后i j 对应的数完成一次交换，i j 继续前进</span><br><span class="line">循环..直到ij相遇i==j</span><br><span class="line">arr[i]=pviot</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(ElemTypeA[],intlow，inthigh）&#123; <span class="comment">//一趟划分</span></span></span><br><span class="line"><span class="params">ElemType pivot=A[<span class="number">1</span>ow]：<span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high）&#123; <span class="comment">//循环跳出条件</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high&amp;sA[high]&gt;=pivot)</span></span><br><span class="line">--high；</span><br><span class="line">A[low]=A[high]； <span class="comment">//将比框轴小的元素移动到左端</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;sA[low]&lt;=pivot)</span><br><span class="line">++<span class="number">1</span>ow；</span><br><span class="line">A[high]=A[low] <span class="comment">//将比框轴大的元素移动到右端</span></span><br><span class="line">&#125;</span><br><span class="line">A[low]=pivot <span class="comment">//框轴元素存放到最终位置</span></span><br><span class="line"><span class="keyword">return</span> low； <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序方法  </span></span><br><span class="line"><span class="type">void</span> quick_sort(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;<span class="comment">//low high用来限定分割的范围  </span></span><br><span class="line">        <span class="type">int</span> postion = partition(str, low, high);<span class="comment">//partition方法是核心方法，每一次分割的方法  </span></span><br><span class="line">        quick_sort(str, low, postion - <span class="number">1</span>);<span class="comment">//递归左边的数组  </span></span><br><span class="line">        quick_sort(str, postion + <span class="number">1</span>, high);<span class="comment">//递归数组右边  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645079.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度</span><br><span class="line">最好情况：每次分割都能平均分成两份则2^x=n; x=log2 n;每轮分割，所有子数组的比较总次数n-1次</span><br><span class="line">所以是(n-1)log2 n,O(n)=nlog2 n</span><br><span class="line">平均状态：接近最好情况O(n)=nlog2 n</span><br><span class="line">最差情况：如果数组本来就有序，那么每次都无法一次切一半，变成从1到n-1都要分割一次,每轮分割依</span><br><span class="line">旧比较n-1次，那么O(n)=n^2</span><br><span class="line">空间复杂度</span><br><span class="line">容量与递归的最大深度一致，最好情况log2 n ;最坏n-1</span><br><span class="line"></span><br><span class="line">稳定性：</span><br><span class="line">在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换</span><br><span class="line">到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方法。例如，表L=</span><br><span class="line">&#123;3,2,2&#125;,经过一趟排序后L=&#123;2,2,3&#125;,最终排序序列也是L=&#123;2,2,3&#125;,显然，2与2的相对次</span><br><span class="line">序已发生了变化。</span><br><span class="line"></span><br><span class="line">快速排序时内部排序算法中平均性能最优的一种算法</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组设置两个指针</span><br><span class="line">min j</span><br><span class="line">第一轮：</span><br><span class="line">min指向第1个数据，j指向min后一个,j移动寻找比min小的，然后min=j，j遍历到最后，最终交换arr[i]和arr[min]</span><br><span class="line"></span><br><span class="line">第二轮：</span><br><span class="line">min指向第2个数据，重复上述步骤</span><br><span class="line"></span><br><span class="line">...重复n-1趟</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;   <span class="comment">//一共进行n-1趟</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> min=i;        <span class="comment">//记录最小元素位置  </span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> j=i+l;j&lt;n;j++)      <span class="comment">//在A[i.n-1]中选择最小的元素</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (A[j]&lt;A(min])&#123;  </span></span><br><span class="line"><span class="params">min=j;              <span class="comment">//更新最小元素位置</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (min!=<span class="number">1</span>)&#123;</span></span><br><span class="line"><span class="params"> swap(A(i],A[min]);  <span class="comment">//封装的swap（）函数共移动元素3次</span></span></span><br><span class="line"><span class="params">&#125; </span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645595.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：第一轮比较n-1次 第二轮比较n-2次 ...最后一次比较1次</span><br><span class="line">n-1 + n-2 + n-3 +...+3 + 2 + 1=(n-1)n/2  所以是O(n^2)</span><br><span class="line">最好最坏都是O(n^2)</span><br><span class="line">稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同</span><br><span class="line">关键字元素的相对位置发生改变。例如，表L=&#123;2,2,1&#125;,经过一趟排序后L=&#123;1,2,2&#125;,最终排</span><br><span class="line">序序列也是L=&#123;1,2,2&#125;,显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳</span><br><span class="line">定的排序方法</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">引入大根堆的概念：</span><br><span class="line">对于一颗二叉树，任意结点的数值要比左右子树的所有结点的值都大</span><br><span class="line">这样一来，根节点成为了最大的结点</span><br><span class="line">既然大根堆的根节点最大，就不断调整为大根堆：</span><br><span class="line">对非叶子结点进行检测，判断这些非根节点是否大于左右</span><br><span class="line">非叶子结点也就是--&gt;叶子结点的父节点--&gt;i/2向下取整</span><br><span class="line"></span><br><span class="line">例如下面这个例子：</span><br><span class="line">想要调整为大根堆，从8/2=4号结点(非终端结点)开始调整,</span><br><span class="line">然后3号结点78,接着2号结点17,最后1号结点53</span><br><span class="line">这样从后往前调整--&gt;若元素互换破坏了下一级的堆--&gt;则采用相同的方法继续往下调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312317433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312340910.png" alt="image.png"></p><p>1.实现逻辑<br> <code>1.建立大根堆</code> :<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">建堆</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li><li>检查当前结点是否满足龈≥左、右若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(<code>小元素不断下坠</code>)</li><li>一般从<code>最底层的分支结点开始调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645508.png" alt="image.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=len/<span class="number">2</span>,i&gt;<span class="number">0</span>,i--)&#123;</span><br><span class="line">HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">A[<span class="number">0</span>]=A[k];</span><br><span class="line"><span class="keyword">for</span>(son;son&lt;=len;son*=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(son&lt;length&amp;&amp;A[son]&lt;A[son+<span class="number">1</span>])&#123; <span class="comment">//son&lt;len == son+1&lt;=len</span></span><br><span class="line">son++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(A[k]&lt;A[son])&#123;</span><br><span class="line">A[k]=A[son];</span><br><span class="line">k=son;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A[k]=A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646852.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p><code>2.交换堆顶元素与最后一个元素.并将小元素下坠,恢复成大根堆</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">排序过程</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(nlog2n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>交换顶部元素和末尾元素</li><li>小元素下坠</li><li>排除末尾最大元素，<code>len-1</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646651.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010950043.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010952356.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[A],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">BuildMaxHeap(A,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">swap(A[<span class="number">1</span>],A[i]);</span><br><span class="line">HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li>根节点最多才下坠<code>h-1</code>次，且没下坠一次最多比较2次，根结点最多比较2(h-1)次 时间复杂度 <code>O(h)</code></li><li>时间复杂度,其他结点<code>&lt;</code>根节点 , 假设每个都是 O(h),公有n个结点<code>O(nh)</code></li><li>h高度=log2n ，总时间复杂度<code>O(nh)=O(nlog2n)</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646722.png" alt="image.png"></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>2.算法稳定性</p><ul><li>堆排序<code>不稳定</code></li><li>假设只有<code>1、a1、a2</code>当左右子节点相同时a1=a2，会优先考虑左结点和根结点交换</li><li>排序时，交换根结点与最后结点，使得位序在前的a1跑到a2后面，—&gt;<code>1、a2、a1</code> 因此是不稳定的 </li></ul><h1 id="堆的插入和删除"><a href="#堆的插入和删除" class="headerlink" title="堆的插入和删除"></a>堆的插入和删除</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆的插入：</span><br><span class="line">1.插入的新元素放到表尾，最末尾的结点</span><br><span class="line">2.与父节点对比，对于小根堆而言，如果新元素比父结点更小，二者互换</span><br><span class="line">3.新元素一路上升,直至无法继续上升为止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011005919.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆的删除：</span><br><span class="line">1.被删除的元素空出来的位置，用堆底部的元素替代</span><br><span class="line">2.最后让该元素不断下坠，直至无法下坠</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011009010.png" alt="image.png"></p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><hr><h2 id="什么是归并？"><a href="#什么是归并？" class="headerlink" title="什么是归并？"></a>什么是归并？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">归并两个有序数组</span><br><span class="line">定义指针i指向有序数组1，指针j指向有序数组2,指针k指向要放入的数组</span><br><span class="line">对比i,j所指向的元素，选择更小的一个放入k中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011017728.png" alt="image.png"></p><h2 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4路归并，就是归并4个数组</span><br><span class="line">根据规律发现，m路归并，每次选出一个元素，最少需要比较关键字m-1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011022249.png" alt="image.png"></p><h2 id="单个归并代码实现"><a href="#单个归并代码实现" class="headerlink" title="单个归并代码实现"></a>单个归并代码实现</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge的时候，需要三个指针,i指向A的有序的前半段，j指向A有序的后半段，k指向放入的数组的当前位置</span><br><span class="line"></span><br><span class="line">1、将A[] 元素全部复制放到B[] ，i ,j分别对应low\mid+1起始位置，k=i.</span><br><span class="line"></span><br><span class="line">2、i j 先比较，小的放入A[k],i++,j不动，k++</span><br><span class="line"></span><br><span class="line">3、直到有剩余，i到头了，j还没到头;或者j到头了，i还没到头。while循环将剩余的全部放入,k随着++</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> mid)</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=low;k&lt;high;k++)&#123;</span><br><span class="line">B[k]=A[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]&lt;=B[j])&#123;</span><br><span class="line">A[k]=B[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">A[k]=B[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">A[k++]=B[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011030720.png" alt="image.png"></p><h2 id="归并排序完整代码"><a href="#归并排序完整代码" class="headerlink" title="归并排序完整代码"></a>归并排序完整代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;=high)&#123;</span><br><span class="line"><span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">MergeSort(A,low,mid);  <span class="comment">//不断递归的左右划分</span></span><br><span class="line">MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">Merge(A,low,mid,high); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011043727.png" alt="image.png"></p><h2 id="归并排序效率分析"><a href="#归并排序效率分析" class="headerlink" title="归并排序效率分析"></a>归并排序效率分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">递归调用栈的所占的空间不会超过log2 n 数量级；运用了额外的数组B空间O(n)</span><br><span class="line">相加O(log2 n)+O(n);舍去小的--&gt; O(n)</span><br><span class="line">时间复杂度：</span><br><span class="line">每一层归并时间复杂度O(n),共h=log2 n 层，时间复杂度O(nlog2 n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011048307.png" alt="image.png"></p><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><h2 id="基数排序算法"><a href="#基数排序算法" class="headerlink" title="基数排序算法"></a>基数排序算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">基数排序：</span><br><span class="line">递增排序：</span><br><span class="line">1.分别对一组数据根据他的的个位、十位、百位、分别先后进行排序</span><br><span class="line">2.其中个位为最次位关键字(对整体的值影响最小)，百为为最主要关键字(对值影响</span><br><span class="line">最大)</span><br><span class="line">3.先根据对权重最低的个位对数进行分配收集，然后在第一次排好的序列之上，再根</span><br><span class="line">据十位进行分配收集，最后是百位--&gt;最红会得到一个有序序列</span><br><span class="line">递减排序：</span><br><span class="line">步骤与递增相同，不过是先对高位进行分配收集，后对低位进行分配和收集</span><br><span class="line">注意：</span><br><span class="line">基数排序不是基于“比较”的排序算法，而是根据相同位数字的不同进行分类规整然后收集</span><br><span class="line">的过程，只是这个分类收集的顺序导致了最后的有序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011400022.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011351923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011404664.png" alt="image.png"></p><h2 id="基数排序算法效率分析"><a href="#基数排序算法效率分析" class="headerlink" title="基数排序算法效率分析"></a>基数排序算法效率分析</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">初始序列为一串链表，定义了一个链式队列的数组用来分配各个数字，由于数组里只是存</span><br><span class="line">放队头指针+队尾指针，实际所需的空间只有数组的10个空间，里面的队列是在原有链表</span><br><span class="line">序列的基础上修改指针指向得到，并没有消耗多余的空间。所以空间复杂度O(r)--&gt;r是</span><br><span class="line">数字可能出现的种类0~9</span><br><span class="line">时间复杂度：</span><br><span class="line">一趟分配n个O(n);一次收集扫描r个队列O(r) --&gt;因为只需将队列整个拆下来拼接</span><br><span class="line">总共分配收集3趟,设趟数为d</span><br><span class="line">时间复杂度 O(d(n+r))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011429831.png" alt="image.png"></p><h2 id="基数排序应用"><a href="#基数排序应用" class="headerlink" title="基数排序应用"></a>基数排序应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基数排序适用：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011433515.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011435864.png" alt="image.png"></p><h1 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是外部排序？</span><br><span class="line">对磁盘(外存)中的数据进行排序，由于外存容量很大，但内存容量很小，要对外存中所有</span><br><span class="line">数据进行啊排序的话，内存放不下</span><br></pre></td></tr></table></figure><h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041049305.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041048131.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题目转化--&gt;4个结点的二叉树有多少种形状，然后可以将a b c d按照先序遍历填进二叉树里(填法唯一)</span><br><span class="line">(每种形状必定能按照一定顺序填 a b c d 使得先序遍历出来次序符合要求)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041051053.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为1入栈马上出栈，接着2入栈马上出栈，所以只看后面三个数的出栈序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041058998.png" alt="image.png"></p><h2 id="并查集-2022新增考点"><a href="#并查集-2022新增考点" class="headerlink" title="并查集(2022新增考点)"></a>并查集(2022新增考点)</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008040.png" alt="image.png"></p><p><code>Find查操作</code>：如何查到一个元素到底属于哪个集合？</p><ul><li>从指定元素出发，一路向北，找到根节点，判断根节点是否相同 <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008041.png" alt="image.png"></li></ul><p><code>Union并操作</code>：如何把两个集合合并为一个集合？</p><ul><li>让一棵树成为另一棵树的子树即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008042.png" alt="image.png"></li></ul><p><code>双亲表示法</code>：便于找到父节点(查)，便于合并两棵树(并)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008043.png" alt="image.png"></p><blockquote><p><code>代码实现</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Size 20</span></span><br><span class="line"><span class="type">int</span> UFSets[Size]; <span class="comment">//集合元素数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size;i++)&#123;</span><br><span class="line">S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008044.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find查操作，找到x所属集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">x=S[x]; <span class="comment">//找父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏：O(n)，树高=n,find时间复杂度与树高相关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//Union并操作，将两个集合合并为一个</span></span><br><span class="line"><span class="comment">void Union(int S[],int root1,int root2)&#123;</span></span><br><span class="line"><span class="comment">if(root2==root1)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">S[root2]=root1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//`Union优化`：小树合并到大树上(用树结点绝对值表示)，避免高度增加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> root1,<span class="type">int</span> root2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root2==root1)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S[root1]&gt;S[root2])&#123; </span><br><span class="line">S[root1] += S[root2];</span><br><span class="line">S[root2]=root1;  <span class="comment">//小树合并到大树</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">S[root2] += S[root1];</span><br><span class="line">S[root1] = root2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后，树高&lt;=log2n ,find最坏时间复杂度O(log2n)</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008045.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008046.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008047.png" alt="image.png"></p></blockquote><p><code>总结</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008048.png" alt="image.png"></p><p><code>find优化+Union优化</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008050.png" alt="image.png"></p><h2 id="课后习题-14"><a href="#课后习题-14" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">栏目2</button></li><li class="tab"><button type="button" data-href="#test1-3">栏目3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062010458.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数基础</title>
      <link href="/undefined/95b2ede4.html"/>
      <url>/undefined/95b2ede4.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础扫盲"><a href="#基础扫盲" class="headerlink" title="基础扫盲"></a>基础扫盲</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181104621.jpg" alt="ai绘画 动漫女孩 粉色长发 水手服 高清电脑壁纸_彼岸壁纸.jpg"></p><h2 id="偏导数存在-连续-可微-偏导数连续关系"><a href="#偏导数存在-连续-可微-偏导数连续关系" class="headerlink" title="偏导数存在-连续-可微-偏导数连续关系"></a>偏导数存在-连续-可微-偏导数连续关系</h2><details>  <summary>点击展开</summary>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续(x.y)</span><br><span class="line">一阶偏导数连续的意思是，该函数的图像是一条连续的线，无论从哪个方向接近某一点，偏导数的</span><br><span class="line">极限都存在且相等。也就是说，偏导数函数在每一点都满足连续性的定义。如果一个函数在某个区</span><br><span class="line">域内的所有点都有一阶连续偏导数，那么这个函数就是可微的(x、y方向的偏导数都连续)</span><br><span class="line">可微(x.y其他任意方向)</span><br><span class="line">是指曲面某一个点处存在一个切面，该点的各个方向的偏导数都存在(x、y和其他任意方向)</span><br><span class="line">偏导数存在(x.y)</span><br><span class="line">偏导数存在的意思是，一个多变量函数的偏导数，就是它关于其中一个变量的导数而保持其他变量</span><br><span class="line">恒定。也就是说，如果一个多元函数在某一点沿着某个方向的偏增量与该方向的增量之比当增量趋</span><br><span class="line">于零时的极限存在，那么这个极限值就是该函数在该点沿着该方向的偏导数(对于二元函数来说</span><br><span class="line">变量只有x.y那么要xy方向都存在偏导数，那么偏导数存在，要考虑两个变量)</span><br><span class="line">函数连续</span><br><span class="line">就是说二元函数所形成的的曲面是连续的没有断口，判断方法--&gt;该点函数值是否等于函数极限值</span><br><span class="line">等于就是连续</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">综上可以得到</span><br><span class="line"></span><br><span class="line">偏导数连续</span><br><span class="line">=&gt;可微</span><br><span class="line">=&gt;连续</span><br><span class="line">=&gt;偏导数存在</span><br></pre></td></tr></table></figure></details><div class="row">    <embed src="/pdf/基础扫盲题.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="三大核心计算"><a href="#三大核心计算" class="headerlink" title="三大核心计算"></a>三大核心计算</h1><h2 id="函数求极限"><a href="#函数求极限" class="headerlink" title="函数求极限"></a>函数求极限</h2><h3 id="无穷小的比较-泰勒公式-极限"><a href="#无穷小的比较-泰勒公式-极限" class="headerlink" title="无穷小的比较-泰勒公式-极限"></a>无穷小的比较-泰勒公式-极限</h3><div class="row">    <embed src="/pdf/无穷小的比较-泰勒公式-极限.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><div class="row">    <embed src="/pdf/习题.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="函数与求导"><a href="#函数与求导" class="headerlink" title="函数与求导"></a>函数与求导</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135693.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135205.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051139974.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051146278.png" alt="image.png"></p><h3 id="导数的几何意义"><a href="#导数的几何意义" class="headerlink" title="导数的几何意义"></a>导数的几何意义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051150223.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051229079.png" alt="image.png"></p><h3 id="各类函数求导"><a href="#各类函数求导" class="headerlink" title="各类函数求导"></a>各类函数求导</h3><h4 id="基本求导公式与四则运算"><a href="#基本求导公式与四则运算" class="headerlink" title="基本求导公式与四则运算"></a>基本求导公式与四则运算</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051700546.png" alt="image.png"></p><h4 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051701696.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708912.png" alt="image.png"></p><h4 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708838.png" alt="image.png"></p><h4 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051747241.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051757501.png" alt="image.png"></p><h4 id="反函数求导"><a href="#反函数求导" class="headerlink" title="反函数求导"></a>反函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051804246.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051810310.png" alt="image.png"></p><h4 id="高阶导数求导"><a href="#高阶导数求导" class="headerlink" title="高阶导数求导"></a>高阶导数求导</h4><h5 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821928.png" alt="image.png"></p><h5 id="莱布尼茨公式"><a href="#莱布尼茨公式" class="headerlink" title="莱布尼茨公式"></a>莱布尼茨公式</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821393.png" alt="image.png"></p><h5 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304052214444.png" alt="image.png"></p><h2 id="不定积分的计算"><a href="#不定积分的计算" class="headerlink" title="不定积分的计算"></a>不定积分的计算</h2><h3 id="四大积分方法"><a href="#四大积分方法" class="headerlink" title="四大积分方法"></a>四大积分方法</h3><hr><h4 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081717182.png" alt="image.png"></p><h4 id="第一类换元法-凑微分"><a href="#第一类换元法-凑微分" class="headerlink" title="第一类换元法(凑微分)"></a>第一类换元法(凑微分)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.两部分相乘，其中一项的导数是否与另外一项有关</span><br><span class="line">2.提到dx里面</span><br><span class="line">3.换元整体求积分</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081709362.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081727642.png" alt="image.png"></p><h4 id="第二类换元法-去根号"><a href="#第二类换元法-去根号" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根号下x是一次，整体换成t</span><br><span class="line">根号下x是二次，三角换元</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082024835.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082211375.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082333064.png" alt="image.png"></p><h4 id="第三类分部积分法"><a href="#第三类分部积分法" class="headerlink" title="第三类分部积分法"></a>第三类分部积分法</h4><hr><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091242072.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091447042.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091457248.png" alt="image.png"></p><h4 id="第四类有理函数积分"><a href="#第四类有理函数积分" class="headerlink" title="第四类有理函数积分"></a>第四类有理函数积分</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假分式：分子幂次比分母幂次高--&gt;一定可以写成`多项式+真分式`</span><br><span class="line">真分式：分子的幂次比分母低--&gt;例如 </span><br><span class="line">?/(1)(2) --&gt; a/(1) + b/(2)</span><br><span class="line">?/(1)(2)(3)--&gt;a/(1) + b/(2) + c/(3); </span><br><span class="line">?/(1)(2)^2 --&gt; a/(1) + b/(2) + c/(2)^2</span><br><span class="line">其中(1)(2)(3)都是x的一次多项式</span><br><span class="line">多项式的除法如下：</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091523975.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091533686.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091544726.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091550885.png" alt="image.png"></p><h3 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">奇数次凑微分</span><br><span class="line">偶数次降幂</span><br><span class="line">化为同倍角</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091623849.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091632455.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091637269.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091639418.png" alt="image.png"></p><h2 id="定积分的计算"><a href="#定积分的计算" class="headerlink" title="定积分的计算"></a>定积分的计算</h2><h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><h4 id="线性性质"><a href="#线性性质" class="headerlink" title="线性性质"></a>线性性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092231993.png" alt="image.png"></p><h4 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092232647.png" alt="image.png"></p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092239776.png" alt="image.png"></p><h3 id="定积分的计算-1"><a href="#定积分的计算-1" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><h4 id="牛顿莱布尼茨公式"><a href="#牛顿莱布尼茨公式" class="headerlink" title="牛顿莱布尼茨公式"></a>牛顿莱布尼茨公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101351992.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101357337.png" alt="image.png"></p><h4 id="定积分的换元法"><a href="#定积分的换元法" class="headerlink" title="定积分的换元法"></a>定积分的换元法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101404616.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101410502.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101413007.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101426085.png" alt="image.png"></p><h4 id="华里士公式"><a href="#华里士公式" class="headerlink" title="华里士公式"></a>华里士公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132472.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132831.png" alt="image.png"></p><h4 id="定积分的分部积分法"><a href="#定积分的分部积分法" class="headerlink" title="定积分的分部积分法"></a>定积分的分部积分法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038875.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038203.png" alt="image.png"></p><h4 id="区间在线公式"><a href="#区间在线公式" class="headerlink" title="区间在线公式"></a>区间在线公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102944.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102751.png" alt="image.png"></p><h2 id="变限积分与反常积分"><a href="#变限积分与反常积分" class="headerlink" title="变限积分与反常积分"></a>变限积分与反常积分</h2><h1 id="高数1-函数-极限-连续"><a href="#高数1-函数-极限-连续" class="headerlink" title="高数1-函数-极限-连续"></a>高数1-函数-极限-连续</h1><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="考试内容要点精讲"><a href="#考试内容要点精讲" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="函数的概念及常见函数"><a href="#函数的概念及常见函数" class="headerlink" title="函数的概念及常见函数"></a>函数的概念及常见函数</h4><blockquote><p>略</p></blockquote><h4 id="函数的性态"><a href="#函数的性态" class="headerlink" title="函数的性态"></a>函数的性态</h4><h5 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a><em>单调性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052057975.png" alt="image.png"></p><h5 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a><em>奇偶性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052058171.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100778.png" alt="image.png"></p><h5 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a><em>周期性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052059224.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052106503.png" alt="image.png"></p><h5 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a><em>有界性</em></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个f(x)函数[a,b]上连续，则在[a,b]上有界</span><br><span class="line">2.f(x)在(a,b)上连续，且limf(a+), limf(b-)存在,则f(x)在(a,b)上有界</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052105228.png" alt="image.png"></p><h3 id="常考题型方法与技巧"><a href="#常考题型方法与技巧" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-复合函数"><a href="#题型1-复合函数" class="headerlink" title="题型1-复合函数"></a>题型1-复合函数</h4><h4 id="题型2-函数性态"><a href="#题型2-函数性态" class="headerlink" title="题型2-函数性态"></a>题型2-函数性态</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052117557.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052138255.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052155476.png" alt="image.png"></p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="考试内容要点精讲-1"><a href="#考试内容要点精讲-1" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="极限概念"><a href="#极限概念" class="headerlink" title="极限概念"></a>极限概念</h4><h5 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061313246.png" alt=""></p><h5 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061315178.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061326428.png" alt=""></p><h5 id="需要分左右极限求极限的三种情况"><a href="#需要分左右极限求极限的三种情况" class="headerlink" title="需要分左右极限求极限的三种情况"></a>需要分左右极限求极限的三种情况</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061328805.png" alt=""></p><h4 id="极限性质-局部有界、保号、保序"><a href="#极限性质-局部有界、保号、保序" class="headerlink" title="极限性质(局部有界、保号、保序)"></a>极限性质(局部有界、保号、保序)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061341030.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061343978.png" alt=""></p><h4 id="极限存在准则"><a href="#极限存在准则" class="headerlink" title="极限存在准则"></a>极限存在准则</h4><p><em>夹逼准则、单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061347339.png" alt=""></p><h4 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061348994.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061351785.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061353923.png" alt=""></p><h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061402353.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061404007.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061408279.png" alt=""></p><h3 id="常考题型方法与技巧-1"><a href="#常考题型方法与技巧-1" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-极限的概念性质及其存在准则"><a href="#题型1-极限的概念性质及其存在准则" class="headerlink" title="题型1-极限的概念性质及其存在准则"></a>题型1-极限的概念性质及其存在准则</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061417690.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061426091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061429689.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061438026.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061539946.png" alt="image.png"></p><h4 id="题型2-求极限"><a href="#题型2-求极限" class="headerlink" title="题型2 求极限"></a>题型2 求极限</h4><h5 id="8种求极限方法"><a href="#8种求极限方法" class="headerlink" title="8种求极限方法"></a>8种求极限方法</h5><h6 id="method1-基本极限求极限"><a href="#method1-基本极限求极限" class="headerlink" title="method1-基本极限求极限"></a>method1-基本极限求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012219540.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012220359.png" alt="image.png"></p><h6 id="method2-等价无穷小求极限"><a href="#method2-等价无穷小求极限" class="headerlink" title="method2-等价无穷小求极限"></a>method2-等价无穷小求极限</h6><ul><li><code>等价无穷小</code>才能代换</li><li>加减关系 在一定条件下可以换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221508.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221512.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081035273.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061838287.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061852881.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061706618.png" alt="image.png"></p><h6 id="method3-有理运算法则求极限"><a href="#method3-有理运算法则求极限" class="headerlink" title="method3-有理运算法则求极限"></a>method3-有理运算法则求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相加的极限=极限相加，前提是,两部分的极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222899.png" alt="image.png"></p><h6 id="method4-洛必达法则求极限"><a href="#method4-洛必达法则求极限" class="headerlink" title="method4-洛必达法则求极限"></a>method4-洛必达法则求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222158.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222786.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222445.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：f(x) n阶可导，最多用洛必达到n-1阶</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012223174.png" alt="image.png"></p><h6 id="method5-泰勒公式求极限"><a href="#method5-泰勒公式求极限" class="headerlink" title="method5-泰勒公式求极限"></a>method5-泰勒公式求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061734684.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061734035.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061736381.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224130.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.传统方法</span><br><span class="line">2.各个击破</span><br><span class="line">3.代入选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224551.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，不能拆分成两部分，因为有理运算前提是两部分函数，极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225514.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225840.png" alt="image.png"></p><h6 id="method6-夹逼定理求极限"><a href="#method6-夹逼定理求极限" class="headerlink" title="method6-夹逼定理求极限"></a>method6-夹逼定理求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n项和的极限</span><br><span class="line">放缩法，分母放大，缩小，求一个范围</span><br><span class="line">然后用夹逼定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225906.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种形式开n方，放大时--&gt;全部换成最大项；缩小时--&gt;只保留最大项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226412.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226541.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如，根号里常数是2,可以写成1+1,最终还是可以舍去分成3段函数求最大</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226674.png" alt="image.png"></p><h6 id="method7-单调有界准则求极限"><a href="#method7-单调有界准则求极限" class="headerlink" title="method7-单调有界准则求极限"></a>method7-单调有界准则求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226920.png" alt="image.png"></p><h6 id="method8-定积分定义求极限"><a href="#method8-定积分定义求极限" class="headerlink" title="method8-定积分定义求极限"></a>method8-定积分定义求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题用夹逼定则做不出来，基本思路是，看做求定积分，将函数平均划分为n部分，每部分1/n</span><br><span class="line">底x高</span><br><span class="line">看做f(x)求0~n的积分,主要是要抽提出f(x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226489.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061744403.png" alt="image.png"></p><h5 id="求极限常见题型"><a href="#求极限常见题型" class="headerlink" title="求极限常见题型"></a>求极限常见题型</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061756108.png" alt="image.png"></p><h6 id="0-0-型-极限"><a href="#0-0-型-极限" class="headerlink" title="0/0 型 极限"></a>0/0 型 极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常用的方法有三种</span><br><span class="line">1)洛必达法则</span><br><span class="line">2)等价无穷小代换</span><br><span class="line">3)泰勒公式</span><br><span class="line">【原式化简】</span><br><span class="line">1)极限非零的因子极限先求出</span><br><span class="line">2)有理化</span><br><span class="line">3)变量代换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061759317.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061809413.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061810079.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061814083.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061816882.png" alt="image.png"></p><p><em>题目3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061822490.png" alt="image.png"></p><p><em>题目4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061843841.png" alt="image.png"></p><p><em>题目5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061858852.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061858804.png" alt="image.png"></p><p><em>题目6</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061904712.png" alt="image.png"></p></blockquote><h6 id="∞-∞-型极限"><a href="#∞-∞-型极限" class="headerlink" title="∞/∞ 型极限"></a>∞/∞ 型极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上就是抓大头，忽略低阶无穷大，这样就能快速的找到极限(用于选填)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061945142.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061953358.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061955452.png" alt="image.png"></p></blockquote><h6 id="∞-∞型-极限"><a href="#∞-∞型-极限" class="headerlink" title="∞-∞型 极限"></a>∞-∞型 极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用的方法有三种</span><br><span class="line">1)通分化为0/0（适用于分式差）</span><br><span class="line">2)根式有理化（适用于根式差）</span><br><span class="line">3)提无穷因子，然后等价代换或变量代换，泰勒公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062002687.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062010773.png" alt="image.png"></p></blockquote><h6 id="0x∞型极限"><a href="#0x∞型极限" class="headerlink" title="0x∞型极限"></a>0x∞型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072059652.png" alt="image.png"></p><h6 id="1-∞型极限"><a href="#1-∞型极限" class="headerlink" title="1^∞型极限"></a>1^∞型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072136795.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072138361.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072139454.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072149021.png" alt="image.png"></p></blockquote><h6 id="∞-0-0-0型极限"><a href="#∞-0-0-0型极限" class="headerlink" title="∞^0 ,0^0型极限"></a>∞^0 ,0^0型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072153693.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072203098.png" alt="image.png"></p></blockquote><h6 id="数列不定式的极限"><a href="#数列不定式的极限" class="headerlink" title="数列不定式的极限"></a>数列不定式的极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072219695.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072219882.png" alt="image.png"></p><h6 id="n项和的数列极限"><a href="#n项和的数列极限" class="headerlink" title="n项和的数列极限"></a><em>n项和的数列极限</em></h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072222306.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072223713.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072233723.png" alt="image.png"></p><blockquote><p><em>小结</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072226909.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072230787.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072236891.png" alt="image.png"></p></blockquote><h6 id="n项连乘的数列极限"><a href="#n项连乘的数列极限" class="headerlink" title="n项连乘的数列极限"></a><em>n项连乘的数列极限</em></h6><blockquote><p><em>1.夹逼 2.取对数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072239494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072241247.png" alt="image.png"></p></blockquote><h6 id="递推关系数列极限"><a href="#递推关系数列极限" class="headerlink" title="递推关系数列极限"></a><em>递推关系数列极限</em></h6><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072248858.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下都是使用方法1，先证明出数列单调、有界--&gt;得到极限存在，然后再求极限</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072254033.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072300552.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081046927.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当数列不单调时，使用方法2,先假设极限为A,然后证明该极限是数列的极限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081055977.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当题目条件出现f&#x27;(x)与f(x)时，需要建立导数与函数之间的关系，两种方法</span><br><span class="line">1.拉格朗日</span><br><span class="line">2.积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081121965.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081121039.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081122391.png" alt="image.png"></p><h4 id="题型3-确定极限式中的参数"><a href="#题型3-确定极限式中的参数" class="headerlink" title="题型3-确定极限式中的参数"></a>题型3-确定极限式中的参数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081151898.png" alt="image.png"></p><h4 id="题型4-无穷小量阶的比较"><a href="#题型4-无穷小量阶的比较" class="headerlink" title="题型4 无穷小量阶的比较"></a>题型4 无穷小量阶的比较</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081204556.png" alt="image.png"></p><blockquote><p><em>变上限积分型无穷小量阶的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081203105.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081223704.png" alt="image.png"></p><blockquote><p><em>利用泰勒公式展开求量阶</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081238252.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081244643.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081246900.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">有理化--&gt;分母极限先求</span><br><span class="line">等价代换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227140.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法2.</span><br><span class="line">由于x-&gt;0, 两个根式都趋向于1</span><br><span class="line">构建f(x)=x^(1/2)的拉格朗日中值定理 x2&lt;ζ&lt;x1 </span><br><span class="line">f(x1)-f(x2)=f&#x27;(ζ)(x1-x2)</span><br><span class="line"></span><br><span class="line">方法3.</span><br><span class="line">等价代换</span><br><span class="line">1-cosx~x^2/2 --&gt; 1-(cosx)^α=(α/2)x^2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227233.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231623122.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231627897.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.构成等价代换</span><br><span class="line">方法2.拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012230880.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231913.png" alt="image.png"></p><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="考试内容要点精讲-2"><a href="#考试内容要点精讲-2" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="连续性概念"><a href="#连续性概念" class="headerlink" title="连续性概念"></a>连续性概念</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081251811.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">连续需要满足，该点极限=该点函数值</span><br><span class="line">连续=左连续+右连续</span><br><span class="line">左连续--&gt;该点左极限=该点函数值</span><br><span class="line">右连续--&gt;该点右极限=该点函数值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231169.png" alt="image.png"></p><h4 id="间断点定义及分类"><a href="#间断点定义及分类" class="headerlink" title="间断点定义及分类"></a>间断点定义及分类</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231532.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要有一个极限是无穷,就是无穷间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232300.png" alt="image.png"></p><h4 id="连续性的运算与性质"><a href="#连续性的运算与性质" class="headerlink" title="连续性的运算与性质"></a>连续性的运算与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本初等函数是指最基本的函数：例如sinx cosx ...，在定义域内连续</span><br><span class="line"></span><br><span class="line">初等函数是指，最基本初等函数经过有限加减乘除运算后得到的例如√cosx-1 ,只在定义区间是定义域内连续的区间，所以只有存在连续区间，才能在区间内连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232062.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于f(x)是初等函数，所以，除x=0,1外处处连续</span><br><span class="line"></span><br><span class="line">x-&gt;0 左右极限没有区别 ，算出极限=-1 ，是第一类可去间断点</span><br><span class="line">x-&gt;1 左右极限不同 ，要分开讨论左右极限，左极限=0，右极限=1 ，是跳跃间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x^n，n趋于无穷，讨论4种情况：|x|&lt;1 、|x|&gt;1 、x=1、x=-1</span><br><span class="line">e^nx ,n趋于无穷，讨论3种情况：x&lt;0 、x&gt;0 、x=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233122.png" alt="image.png"></p><h3 id="常考题型方法与技巧-2"><a href="#常考题型方法与技巧-2" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-讨论连续性及间断点类型"><a href="#题型1-讨论连续性及间断点类型" class="headerlink" title="题型1-讨论连续性及间断点类型"></a>题型1-讨论连续性及间断点类型</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081307119.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081346105.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081358741.png" alt="image.png"></p><h4 id="题型2-介值定理、最值定理及零点定理的证明题"><a href="#题型2-介值定理、最值定理及零点定理的证明题" class="headerlink" title="题型2-介值定理、最值定理及零点定理的证明题"></a>题型2-介值定理、最值定理及零点定理的证明题</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081539699.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081540242.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这题用到了介值定理--&gt;零点一定介于函数值是正负的两点之间</span><br><span class="line">那么函数f(x)/x当 x-&gt;∞(注意这里是函数的区域∞，是同时趋于正负∞)，极限=0</span><br><span class="line">所以令F(x)=f(x) + x ; 则lim x-&gt;∞ F(x)/x = 1 ;</span><br><span class="line">所以存在X&gt;0,使得|x|&gt;X时，F(x)/x &gt;0 </span><br><span class="line">取a&gt;X ,则F(a)/a &gt;0 --&gt; F(a)&gt;0 ,F(-a)/-a &gt;0 --&gt;F(-a)&lt;0 </span><br><span class="line">从而(-a,a)之间存在 ζ，使得F(ζ)=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081531333.png" alt="image.png"></p><h1 id="高数2-导数-微分"><a href="#高数2-导数-微分" class="headerlink" title="高数2-导数-微分"></a>高数2-导数-微分</h1><h2 id="导数概念"><a href="#导数概念" class="headerlink" title="导数概念"></a>导数概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导数：函数在哪一点的变化率</span><br><span class="line">导数定义是△x-&gt;0 的极限(或x-&gt;x0的极限)</span><br><span class="line">注意:△x-&gt;0 是函数的趋近--&gt;是同时趋近与0+,0- ;同理x-&gt;x0+,x-&gt;x0</span><br><span class="line">所以，&lt;导数存在&gt; &lt;=&gt; &lt;是指左导数和右导数都存在，且相等&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该点左函数的极限值=该点函数值，所以左连续，可以直接求导</span><br><span class="line">该点右函数的极限值!=该点函数值，右不连续，右导数不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234982.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234642.png" alt="image.png"></p><h2 id="微分概念"><a href="#微分概念" class="headerlink" title="微分概念"></a>微分概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">微分：函数改变量的近似值，忽略了高阶无穷小，微分实际就是函数改变量的 线性主部</span><br><span class="line"></span><br><span class="line">eg.A△x--&gt;是一个关于x的线性函数--&gt;也称为线性主部分(微分)</span><br><span class="line"></span><br><span class="line">一元函数里面：可微等价于可导</span><br><span class="line">多元函数里面：可微=&gt;可导 ，可导不能推出可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234144.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235565.png" alt="image.png"></p><h2 id="导数几何意义"><a href="#导数几何意义" class="headerlink" title="导数几何意义"></a>导数几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">导数微分就是解决函数 &lt;非均匀变化&gt; 的问题,用用微分(线性主部，均匀变化)来代替非均匀，来研究函数变化</span><br><span class="line"></span><br><span class="line">微分就是A△x =Adx,导数就是斜率A,在一个微观角度，将函数看做线性均匀变化的小的直线</span><br><span class="line">--&gt;所以积分就是 无数个微分 f&#x27;(x)dx --&gt;在x的一个范围内的求和 </span><br><span class="line"></span><br><span class="line">可导=&gt;切线存在</span><br><span class="line">切线存在 不一定 可导 (切线斜率为∞，导数不存在)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235642.png" alt="image.png"></p><h2 id="微分几何意义"><a href="#微分几何意义" class="headerlink" title="微分几何意义"></a>微分几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">微分几何意义=切线上的增量dy=A△x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235182.png" alt="image.png"></p><h2 id="连续-可微-可导关系"><a href="#连续-可微-可导关系" class="headerlink" title="连续-可微-可导关系"></a>连续-可微-可导关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一元函数 </span><br><span class="line"></span><br><span class="line">可导：是指，f(x)在x0点处导数存在</span><br><span class="line">连续：f(x)在点x0处连续</span><br><span class="line"></span><br><span class="line">可微&lt;=&gt;可导 </span><br><span class="line">连续不一定可导(尖点)，所以连续不一定可微；</span><br><span class="line">可导/可微=&gt;连续 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)在x0的邻域内一阶可导，推不出，导函数在x0连续，也推不出，导函数在x0的极限存在</span><br><span class="line"></span><br><span class="line">所以总结：</span><br><span class="line">f(x)n阶可导 ,洛必达中中最多出现n-1阶导数</span><br><span class="line">f(x)n阶导数连续，洛必达可以出现n阶导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236777.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x趋于0的函数极限,与x=0的值毫无关系</span><br><span class="line">排除AB</span><br><span class="line">C:x=0处可导，说明函数在x=0处连续，既然连续，那么x=0处的极限存在即lim x-&gt;0 (f(x)/x)存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237415.png" alt="image.png"></p><h2 id="导数公式及求导法则"><a href="#导数公式及求导法则" class="headerlink" title="导数公式及求导法则"></a>导数公式及求导法则</h2><h3 id="基本初等函数求导公式"><a href="#基本初等函数求导公式" class="headerlink" title="基本初等函数求导公式"></a>基本初等函数求导公式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237303.png" alt="image.png"></p><h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237240.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">奇函数的导数是偶函数</span><br><span class="line">偶函数的导数是奇函数  </span><br><span class="line"></span><br><span class="line">周期函数的导数任然是周期函数</span><br><span class="line"></span><br><span class="line">运用了奇函数过(0,0)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237438.png" alt="image.png"></p><h3 id="隐函数求导法则"><a href="#隐函数求导法则" class="headerlink" title="隐函数求导法则"></a>隐函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238267.png" alt="image.png"></p><h3 id="反函数求导法则"><a href="#反函数求导法则" class="headerlink" title="反函数求导法则"></a>反函数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看到反函数，先写出原函数</span><br><span class="line">反函数对y求导数=原函数对x求导数的倒数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238483.png" alt="image.png"></p><h3 id="参数方程求导法则"><a href="#参数方程求导法则" class="headerlink" title="参数方程求导法则"></a>参数方程求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238001.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238200.png" alt="image.png"></p><h3 id="对数求导法则"><a href="#对数求导法则" class="headerlink" title="对数求导法则"></a>对数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两边ln</span><br><span class="line">两边求导。左边对y求，右边对x求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取对数，把连乘连除变成加减</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239343.png" alt="image.png"></p><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><h3 id="高阶导数定义"><a href="#高阶导数定义" class="headerlink" title="高阶导数定义"></a>高阶导数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n阶可导，那么就具有&lt;n阶的一切导数的存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239942.png" alt="image.png"></p><h3 id="常用高阶导数"><a href="#常用高阶导数" class="headerlink" title="常用高阶导数"></a>常用高阶导数</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239042.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240996.png" alt="image.png"></p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="导数定义应用"><a href="#导数定义应用" class="headerlink" title="导数定义应用"></a>导数定义应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种题，基本思路，认为凑成f(x)导数的定义式</span><br><span class="line"></span><br><span class="line">填空题，直接代入一个具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240723.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代入具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际要化为导数的定义式，转变化为求x=0的导数问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241229.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论：如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241771.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由定义式推出导数存在，要求左右极限都存在</span><br><span class="line">A.  h-&gt;+∞ ，1/h-&gt;0+  不行</span><br><span class="line">B.  n-&gt;∞，默认n-&gt;+∞,1/n-&gt;0+ ,不行</span><br><span class="line">C.  定义式求导数要求两个点,一定一动，两个点都动，不行</span><br><span class="line">D.  h-&gt;0，默认h-&gt;0+ &amp;&amp; h-&gt;0- ,可以</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241531.png" alt="image.png"></p><h3 id="复合-隐函-参数求导应用"><a href="#复合-隐函-参数求导应用" class="headerlink" title="复合-隐函-参数求导应用"></a>复合-隐函-参数求导应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要求二阶导数</span><br><span class="line">根据方程</span><br><span class="line">分别求出x=1时</span><br><span class="line">y=?</span><br><span class="line">y&#x27;=?</span><br><span class="line">最后</span><br><span class="line">y&#x27;&#x27;=?</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242620.png" alt="image.png"></p><h3 id="高阶导数应用"><a href="#高阶导数应用" class="headerlink" title="高阶导数应用"></a>高阶导数应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242698.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.高阶导数公式</span><br><span class="line">方法2.泰勒公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242415.png" alt="image.png"></p><h3 id="导数应用"><a href="#导数应用" class="headerlink" title="导数应用"></a>导数应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对方程求导</span><br><span class="line">求出y&#x27;-&gt;斜率</span><br><span class="line">继而求出切线方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242257.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243534.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243968.png" alt="image.png"></p><h2 id="常考题型方法与技巧-3"><a href="#常考题型方法与技巧-3" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h2><h3 id="题型1-导数与微分的概念"><a href="#题型1-导数与微分的概念" class="headerlink" title="题型1-导数与微分的概念"></a>题型1-导数与微分的概念</h3><h4 id="利用导数定义求极限"><a href="#利用导数定义求极限" class="headerlink" title="利用导数定义求极限"></a>利用导数定义求极限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将原极限式子，凑成该点导数形式，利用现有的导数值来求解。</span><br><span class="line">另外由于是填空题，可以直接构造一个符合条件的函数来代入计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081647015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081933181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081933716.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081951939.png" alt="image.png"></p><h4 id="利用导数定义求导数"><a href="#利用导数定义求导数" class="headerlink" title="利用导数定义求导数"></a>利用导数定义求导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082011740.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082039132.png" alt="image.png"></p><h4 id="利用导数定义判断函数的可导性"><a href="#利用导数定义判断函数的可导性" class="headerlink" title="利用导数定义判断函数的可导性"></a>利用导数定义判断函数的可导性</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082232692.png" alt="image.png"></p><blockquote><p><em>结论1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082257636.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082300275.png" alt="image.png"></p><p><em>结论2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082319379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082319993.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082323866.png" alt="image.png"></p><p><em>结论3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307090953890.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307090953749.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091027211.png" alt="image.png"></p></blockquote><h3 id="题型2-导数的集合意义"><a href="#题型2-导数的集合意义" class="headerlink" title="题型2-导数的集合意义"></a>题型2-导数的集合意义</h3><h3 id="题型3-导数与微分的计算"><a href="#题型3-导数与微分的计算" class="headerlink" title="题型3-导数与微分的计算"></a>题型3-导数与微分的计算</h3><h4 id="复合函数求导数"><a href="#复合函数求导数" class="headerlink" title="复合函数求导数"></a>复合函数求导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091056047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091057814.png" alt="image.png"></p><h4 id="隐函数的导数"><a href="#隐函数的导数" class="headerlink" title="隐函数的导数"></a>隐函数的导数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于函数对于y，x难以分离的函数，求导数，只能两边对x求导</span><br><span class="line">这样的就是隐函数求导，注意，将原方程带到一阶导数方程化简，这样求二阶导数方程时，可更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091102652.png" alt="image.png"></p><h4 id="参数方程的导数"><a href="#参数方程的导数" class="headerlink" title="参数方程的导数"></a>参数方程的导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091134761.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091221738.png" alt=""></p><h4 id="反函数的求导"><a href="#反函数的求导" class="headerlink" title="反函数的求导"></a>反函数的求导</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091229196.png" alt="image.png"></p><h4 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091230038.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091235678.png" alt="image.png"></p><h4 id="高阶导数-1"><a href="#高阶导数-1" class="headerlink" title="高阶导数"></a>高阶导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091241032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求不定点，n阶导数，找规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091246868.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091252942.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求具体某一点的n阶导数，方法1.利用n阶导数公式  2.利用泰勒公式在某一点的展开</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091255466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091300011.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论sinx的n阶导数=six(x+n(π/2))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091500937.png" alt="image.png"></p><h1 id="高数3-微分中值定理及导数应用"><a href="#高数3-微分中值定理及导数应用" class="headerlink" title="高数3-微分中值定理及导数应用"></a>高数3-微分中值定理及导数应用</h1><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微分中值定理目的是为了</span><br><span class="line">建立函数与导数之间的关系</span><br></pre></td></tr></table></figure><ul><li><code>费马定理</code></li><li><code>罗尔定理</code></li><li><code>拉格朗日中值定理</code></li><li><code>柯西中值定理</code>:在运动中，两者一定有某处的瞬时速度之比等于平均速度之比<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011611443.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实际上就是 x-&gt;0 处的泰勒展开</span><br><span class="line"></span><br><span class="line">建立了 函数 与 高阶导数 之间的关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612549.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由罗尔定理推导出拉格朗日中值定理和柯西中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252354448.jpg" alt="Screenshot_2023-05-24-20-47-07-55_769977972775e0c.jpg"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252355825.jpg" alt="Screenshot_2023-05-24-21-00-10-12_769977972775e0c.jpg"></p><h3 id="导数应用-1"><a href="#导数应用-1" class="headerlink" title="导数应用"></a>导数应用</h3><h4 id="函数极值"><a href="#函数极值" class="headerlink" title="函数极值"></a>函数极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">驻点：导数为0的点</span><br><span class="line">极值点不一定驻点 |x|</span><br><span class="line">驻点不一定是极值点 x^3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612417.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612620.png" alt="image.png"></p><h4 id="函数最值"><a href="#函数最值" class="headerlink" title="函数最值"></a>函数最值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">极值点是函数内部领域内的“凸点或尖点”，可以有多个，不一定是最大最小</span><br><span class="line">最值点，可以是某一个极值点，也可以是端点</span><br></pre></td></tr></table></figure><ul><li><code>连续函数f(x)</code>在（a,b）内有<code>多个极值点</code>，那么最值点要么是极值点，要么是端点</li><li><code>连续函数f(x)</code>在（a,b）内有`唯一极值点·，那么这个极值点就是(a,b)内的最大值或最小值点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求最值3部曲：</span><br><span class="line">- 求出函数f(x)的所有驻点、不可导点</span><br><span class="line">- 分别求出各自函数值</span><br><span class="line">- 比较函数值大小</span><br></pre></td></tr></table></figure><h4 id="函数凹凸性"><a href="#函数凹凸性" class="headerlink" title="函数凹凸性"></a>函数凹凸性</h4><ul><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&gt;0</code>,函数就是<code>凹的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&lt;0</code>,函数就是<code>凸的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)=0</code>,该点就是函数<code>拐点</code>，左右凹凸性变化<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092155259.png" alt="image.png"></li></ul><h4 id="函数的渐近线"><a href="#函数的渐近线" class="headerlink" title="函数的渐近线"></a>函数的渐近线</h4><ul><li><code>水平渐近线</code></li><li><code>垂直渐进线</code></li><li><code>斜渐近线</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613369.png" alt="image.png"></li></ul><h4 id="弧微分与曲率"><a href="#弧微分与曲率" class="headerlink" title="弧微分与曲率"></a>弧微分与曲率</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613748.png" alt="image.png"></p><h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="求函数极值最值及确定函数凹向与拐点"><a href="#求函数极值最值及确定函数凹向与拐点" class="headerlink" title="求函数极值最值及确定函数凹向与拐点"></a>求函数极值最值及确定函数凹向与拐点</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613878.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613028.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这种分段函数，求导数和极值问题</span><br><span class="line"></span><br><span class="line">求f&#x27;(x)</span><br><span class="line">1.首先要判断断点处，导数是否存在(即左导数是否等于右导数)</span><br><span class="line">2.根据在断点处导数是否存在，再写f&#x27;(x)，以判断是否在断点处要写等号</span><br><span class="line"></span><br><span class="line">求f(x)极值</span><br><span class="line">3.极值点是驻点或不可导点，列出驻点、不可导点</span><br><span class="line">4.在不可导电需要判断函数是否连续(不能跳跃),连续就继续求，不连续就不属于极值点</span><br><span class="line">5.分别求出驻点、不可导点，根据f&#x27;(x)的正负形判断极大极小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614666.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614341.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数选取的重要性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614024.png" alt="image.png"></p><p><code>画图</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614910.png" alt="image.png"></p><h3 id="求渐近线"><a href="#求渐近线" class="headerlink" title="求渐近线"></a>求渐近线</h3><ul><li><code>ln(1+e^x)-x=ln[(1+e^x)/e^x]</code></li><li>或者<code>ln(1+e^x)-x=x+ln(e^-x + 1)-x</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614026.png" alt="image.png"></li></ul><p><code>去绝对值，分别讨论正负</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614805.png" alt="image.png"></p><h3 id="方程的根"><a href="#方程的根" class="headerlink" title="方程的根"></a>方程的根</h3><p><code>证明根的存在性</code></p><ul><li>罗尔定理：两端为零，之间至少存在一个导数为零</li><li>零点定理：左端右端一正一负，之间至少存在一个值为零<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615914.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615726.png" alt="image.png"></p><p><code>给定根数量，求范围</code></p><ul><li>画图<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615579.png" alt="image.png"></li></ul><h3 id="不等式证明"><a href="#不等式证明" class="headerlink" title="不等式证明"></a>不等式证明</h3><p><code>1.利用拉格朗日中值定理</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)=lnx</span><br><span class="line">至少存在一个ζ</span><br><span class="line">f(1+x)-f(1)=f&#x27;(ζ)(1+x-1)</span><br><span class="line">然后放大分母为1+x,--&gt;最小</span><br><span class="line">缩小分母--&gt;最大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615051.png" alt="image.png"></p><p><code>2.利用单调性证明不等式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616772.png" alt="image.png"></p><h3 id="中值定理的证明"><a href="#中值定理的证明" class="headerlink" title="中值定理的证明"></a>中值定理的证明</h3><p><code>两次罗尔定理</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616005.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616926.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011617692.png" alt="image.png"></p><h2 id="常考题型方法与技巧-4"><a href="#常考题型方法与技巧-4" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h2><h3 id="题型1-函数的单调性、极值及最值"><a href="#题型1-函数的单调性、极值及最值" class="headerlink" title="题型1-函数的单调性、极值及最值"></a>题型1-函数的单调性、极值及最值</h3><blockquote><p><em>变上限积分函数极值问题</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求函数单调区间--&gt;列出所有驻点(导数为0的点)，接着判断驻点两侧导数的正负性判断出函数增减性--&gt;画出函数图像--&gt;找最值</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091503863.png" alt="image.png"></p><p><em>隐函数极值问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092038329.png" alt="image.png"></p><p><em>运用极限保号性求极值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092047530.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092053720.png" alt="image.png"></p><p><em>例5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092100111.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092100616.png" alt="image.png"></p></blockquote><h3 id="题型2-曲线的凹向、拐点、渐近线及曲率"><a href="#题型2-曲线的凹向、拐点、渐近线及曲率" class="headerlink" title="题型2-曲线的凹向、拐点、渐近线及曲率"></a>题型2-曲线的凹向、拐点、渐近线及曲率</h3><blockquote><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092136152.png" alt="image.png"></p><p><em>例题3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092219206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092219733.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092224807.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101028180.png" alt="image.png"></p><p><em>例子5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101033936.png" alt="image.png"></p></blockquote><h3 id="题型3-方程的根的存在性及个数"><a href="#题型3-方程的根的存在性及个数" class="headerlink" title="题型3-方程的根的存在性及个数"></a>题型3-方程的根的存在性及个数</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101126829.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101125852.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101128025.png" alt="image.png"></p><p><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101130085.png" alt="image.png"></p><p><em>例3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101150565.png" alt="image.png"></p></blockquote><h3 id="题型4-证明函数不等式"><a href="#题型4-证明函数不等式" class="headerlink" title="题型4-证明函数不等式"></a>题型4-证明函数不等式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101159151.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101200832.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101200275.png" alt="image.png"></p><p><em>例3</em><br><strong>题目给出二阶导数，要证明的是函数不等式，怎么才能将函数与高阶导数联系在一起?—&gt;想到用泰勒公式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101203461.png" alt="image.png"></p><p><em>例3其他方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101209128.png" alt="image.png"></p><p><em>2021大纲修改，9大题-&gt;6大题，证明不等式出现在选择题概率更高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101216068.png" alt="image.png"></p></blockquote><h3 id="题型5-微分中值定理有关的证明题"><a href="#题型5-微分中值定理有关的证明题" class="headerlink" title="题型5-微分中值定理有关的证明题"></a>题型5-微分中值定理有关的证明题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101722824.png" alt="image.png"></p><h4 id="证明一个存在一个中值点…，"><a href="#证明一个存在一个中值点…，" class="headerlink" title="证明一个存在一个中值点…，"></a>证明一个存在一个中值点…，</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101336631.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101358378.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101358182.png" alt="image.png"></p><p><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101406883.png" alt="image.png"></p><p><em>构造辅助函数纠结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101405730.png" alt="image.png"></p><p><em>没有需要证明的等式中没有出现导数—直接零点定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101603405.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101422052.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101424577.png" alt="image.png"></p><p><em>例5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101427000.png" alt="image.png"></p><p><em>柯西、拉格朗日实质就是通过构造辅助函数证明的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101442351.png" alt="image.png"></p><p><em>例6-积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101442713.png" alt="image.png"></p><p><em>例7-变上限积分函数-构造辅助函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101504848.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101505567.png" alt="image.png"></p></blockquote><h4 id="证明存在两个中值点"><a href="#证明存在两个中值点" class="headerlink" title="证明存在两个中值点"></a>证明存在两个中值点</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101526198.png" alt="image.png"></p><blockquote><p><em>没有要求两个中值不相等</em></p><p><strong>1.将两个中值分离到两边<br>2.再根据两边函数形势，判断用柯西还是拉格朗日中值定理</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101540675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101540161.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101552242.png" alt="image.png"></p><p><em>要求两个中值不相等<br>通过点c，将区域划分为左右两端</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101606123.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101630661.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101630646.png" alt="image.png"></p></blockquote><h4 id="证明存在一个中值点（含高阶导数）"><a href="#证明存在一个中值点（含高阶导数）" class="headerlink" title="证明存在一个中值点（含高阶导数）"></a>证明存在一个中值点（含高阶导数）</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101705983.png" alt="image.png"></p><blockquote><p><strong>1.判断所证明等式中是否含有高阶导数，含有则选用拉格朗日余项泰勒公式<br>2.接着在哪一点展开呢?—&gt;在提供信息最多的点展开(其中能提供导数信息的优先)<br>3.提供信息一样多的时候，都展开代入</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101708834.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101710062.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101723749.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101723067.png" alt="image.png"></p></blockquote><h1 id="高数4-不定积分"><a href="#高数4-不定积分" class="headerlink" title="高数4-不定积分"></a>高数4-不定积分</h1><h2 id="内容概要-1"><a href="#内容概要-1" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="不定积分概念性质"><a href="#不定积分概念性质" class="headerlink" title="不定积分概念性质"></a>不定积分概念性质</h3><h4 id="原函数存在定理"><a href="#原函数存在定理" class="headerlink" title="原函数存在定理"></a><code>原函数存在定理</code></h4><ul><li>若f(x)<code>在区间I连续</code>，则f(x)在区间I上一定存在原函数(导函数连续，原函数必定连续)</li><li>若f(x)在区间I上<code>有第一类间断点</code>，则一定没有原函数</li><li>若f(x)在区间I上<code>有第二类间断点</code>，则可能有原函数(有原函数的导数不一定连续)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011039122.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数连续,所以有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011041496.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一类间断点(跳跃)，一定没有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011042885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二类间断点(震荡)，可能有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011047495.png" alt="image.png"></p><h4 id="不定积分性质"><a href="#不定积分性质" class="headerlink" title="不定积分性质"></a>不定积分性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011053012.png" alt="image.png"></p><h4 id="不定积分基本公式"><a href="#不定积分基本公式" class="headerlink" title="不定积分基本公式"></a>不定积分基本公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cscx=1/sinx</span><br><span class="line">secx=1/cosx</span><br><span class="line">cotx=1/tanx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141412806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011110068.png" alt="image.png"></p><h3 id="三大积分方法"><a href="#三大积分方法" class="headerlink" title="三大积分方法"></a>三大积分方法</h3><h4 id="第一类换元-凑微分"><a href="#第一类换元-凑微分" class="headerlink" title="第一类换元(凑微分)"></a>第一类换元(凑微分)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011121307.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011123543.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011130757.png" alt="image.png"></p><h4 id="第二类换元法-去根号-1"><a href="#第二类换元法-去根号-1" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011134848.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153689.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153143.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154683.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154305.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152947.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152136.png" alt="image.png"></p><h4 id="第三类分部积分"><a href="#第三类分部积分" class="headerlink" title="第三类分部积分"></a>第三类分部积分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">何时用？</span><br><span class="line">出现两类不同函数相乘</span><br><span class="line">如何用？</span><br><span class="line">Pn(x)代表多项式；如下，画圈的代表先凑进去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011156648.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238404.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011242946.png" alt="image.png"></p><h3 id="三类常见可积函数积分"><a href="#三类常见可积函数积分" class="headerlink" title="三类常见可积函数积分"></a>三类常见可积函数积分</h3><h4 id="可积函数概念"><a href="#可积函数概念" class="headerlink" title="可积函数概念"></a>可积函数概念</h4><p><code>可积函数</code>，是指积分可以用<code>初等函数</code>的<code>加减乘除表示</code>，下列是三种常见积不出的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011244308.png" alt="image.png"></p><h4 id="常见可积函数"><a href="#常见可积函数" class="headerlink" title="常见可积函数"></a>常见可积函数</h4><h5 id="有理函数积分"><a href="#有理函数积分" class="headerlink" title="有理函数积分"></a>有理函数积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有理函数积分都能积分出来</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011246229.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011247873.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011256885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回顾之前的有理函数积分方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011259165.png" alt="image.png"></p><h5 id="三角有理式积分-1"><a href="#三角有理式积分-1" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三角函数可以代换为有理函数，因为有理函数都能积分出来，所以三角函数一定能积分出来</span><br><span class="line"></span><br><span class="line">左三角函数积分有两类方法</span><br><span class="line">- 万能代换(万不得已不使用)</span><br><span class="line">- 三角变形、换元、分部</span><br><span class="line"></span><br><span class="line">总结的三个简单规律：</span><br><span class="line">下图R(-sinx,cosx)=-R(sinx,cosx)--&gt;意思是原函数用-sinx替换sinx，只需在函数前加-,这种一般换元cosx=u</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011302914.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011305711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332272.png" alt="image.png"></p><h5 id="简单无理式积分"><a href="#简单无理式积分" class="headerlink" title="简单无理式积分"></a>简单无理式积分</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353852.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353702.png" alt="image.png"></p><h2 id="不定积分常考题"><a href="#不定积分常考题" class="headerlink" title="不定积分常考题"></a>不定积分常考题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011452143.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分段函数，求原函数</span><br><span class="line">- 首先保证原函数F(x)连续(这样才能处处可导)--&gt;断点处，原函数要连续--&gt;趋于断点处左右原函数极限相等</span><br><span class="line">- 可以得到c1 c2关系--&gt; c2 = c1 + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011503967.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分段函数求原函数</span><br><span class="line">- f(x)处处有定义--&gt;原函数F(x)连续</span><br><span class="line">- 原函数要连续--&gt;满足断点处连续--&gt;左右极限相等</span><br><span class="line">- 得到c1 c2关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011509154.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011603033.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下方的</span><br><span class="line">有理函数积分，将分子 利用分母有的两种因子 凑成1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011623381.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两次分部积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011627054.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011634510.png" alt="image.png"></p><h1 id="高数5-定积分"><a href="#高数5-定积分" class="headerlink" title="高数5-定积分"></a>高数5-定积分</h1><h2 id="内容概要-2"><a href="#内容概要-2" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="定积分的概念"><a href="#定积分的概念" class="headerlink" title="定积分的概念"></a>定积分的概念</h3><h4 id="定积分定义"><a href="#定积分定义" class="headerlink" title="定积分定义"></a>定积分定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011722857.png" alt="image.png"></p><h4 id="定积分存在充分条件"><a href="#定积分存在充分条件" class="headerlink" title="定积分存在充分条件"></a>定积分存在充分条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定积分存在就是可积</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011728280.png" alt="image.png"></p><h4 id="定积分存在必要条件"><a href="#定积分存在必要条件" class="headerlink" title="定积分存在必要条件"></a>定积分存在必要条件</h4><p><code>可积</code>=&gt;<code>有界</code>(反过来不成立)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011731879.png" alt="image.png"></p><h4 id="定积分几何意义"><a href="#定积分几何意义" class="headerlink" title="定积分几何意义"></a>定积分几何意义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011733974.png" alt="image.png"></p><h3 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h3><h4 id="不等式性质-1"><a href="#不等式性质-1" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011736842.png" alt="image.png"></p><h4 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)的证明</span><br><span class="line">- f(x)在区间[a,b]连续，即导函数连续，必有原函数F(x)，存在F(a)-F(b)=F&#x27;(ζ)(a-b),拉格朗日中值定理</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011741252.png" alt="image.png"></p><h3 id="积分上限的函数"><a href="#积分上限的函数" class="headerlink" title="积分上限的函数"></a>积分上限的函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于第二个定理</span><br><span class="line">若f(x)是奇函数，那么0到x对f(t)dt积分是偶函数，积分下限可以是任意常数，相当于偶函数+常数</span><br><span class="line">但是对于f(x)是偶函数，积分下限只能是0，因为奇函数+常数 就不是奇函数了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012252269.png" alt="image.png"></p><h3 id="定积分的计算-2"><a href="#定积分的计算-2" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012304896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012306157.png" alt="image.png"></p><h2 id="常考题型-1"><a href="#常考题型-1" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="定积分定义、几何性质应用"><a href="#定积分定义、几何性质应用" class="headerlink" title="定积分定义、几何性质应用"></a>定积分定义、几何性质应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这类题型</span><br><span class="line">- 提取1/n</span><br><span class="line">- 写成定积分形式求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021020359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021022319.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021026083.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021028407.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.常规根据上下限，算出面积</span><br><span class="line">解法2(快速).根据定积分奇偶性，根据图像,被积函数是奇函数，所以原函数是偶函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021036825.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021042331.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.f&#x27;&#x27;(x)&gt;0 ,函数凹的，根据定积分性质</span><br><span class="line">解法2.排除法，找一个满足题目要求的函数，代入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021050490.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分中值定理+微分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021421295.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021422494.png" alt="image.png"></p><h3 id="定积分的计算-3"><a href="#定积分的计算-3" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+点火公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021425241.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+几何意义</span><br><span class="line">常用的几种圆的积分形式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021428611.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用公式∫0-&gt;π xf(sinx) dx = π/2 ∫0-&gt;π f(sinx) dx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021433961.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021443943.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021445163.png" alt="image.png"></p><h3 id="变上限积分"><a href="#变上限积分" class="headerlink" title="变上限积分"></a>变上限积分</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021510612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521763.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021509396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于上下限有x的，且被积分函数含有x的因式因子，首先将x当成常数，将x提出到外面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521474.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意x&gt;=0,∫-1-&gt;x  包括了-1-&gt;0 要分两段计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021542735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021554116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021613968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解法2.利用积分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021610552.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021606709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021614121.png" alt="image.png"></p><h1 id="高数5-反常积分"><a href="#高数5-反常积分" class="headerlink" title="高数5-反常积分"></a>高数5-反常积分</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021617496.png" alt="image.png"></p><h2 id="内容概要-3"><a href="#内容概要-3" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="无穷区间上的反常积分"><a href="#无穷区间上的反常积分" class="headerlink" title="无穷区间上的反常积分"></a>无穷区间上的反常积分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021640001.png" alt="image.png"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021647869.png" alt="image.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找合适的p函数，p的取值，可以是，分母x的幂次-分子x的幂次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021657042.png" alt="image.png"></p><h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022201133.png" alt="image.png"></p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论中：画蓝线的为无界点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022207691.png" alt="image.png"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分上下限都是无界点，需要分别算--&gt;拆成两部分0-&gt;1/2 和1/2-&gt;1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022208858.png" alt="image.png"></p><h2 id="常考题型-2"><a href="#常考题型-2" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="反常积分敛散性"><a href="#反常积分敛散性" class="headerlink" title="反常积分敛散性"></a>反常积分敛散性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126385.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126832.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含无穷区间，和无界点，需要拆成两部分分别计算</span><br><span class="line">0-&gt;1      此时，主要看0点(无界点)，(1+x)^b-&gt;1 ,,所以p积分指数取a  </span><br><span class="line">1-&gt;无穷   此时,主要看无穷区间，1+x--&gt;x ,所以p积分指数取a+b   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031134500.png" alt="image.png"></p><h3 id="反常积分计算"><a href="#反常积分计算" class="headerlink" title="反常积分计算"></a>反常积分计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031156742.png" alt="image.png"></p><h1 id="高数6-定积分应用"><a href="#高数6-定积分应用" class="headerlink" title="高数6-定积分应用"></a>高数6-定积分应用</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031157707.png" alt="image.png"></p><h2 id="内容概要-4"><a href="#内容概要-4" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="几何应用"><a href="#几何应用" class="headerlink" title="几何应用"></a>几何应用</h3><h4 id="平面图形面积"><a href="#平面图形面积" class="headerlink" title="平面图形面积"></a>平面图形面积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本质上还是二重积分，利用二重积分更加容易</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031327184.png" alt="image.png"></p><h4 id="旋转体体积"><a href="#旋转体体积" class="headerlink" title="旋转体体积"></a>旋转体体积</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031344267.png" alt="image.png"></p><h4 id="曲线弧长"><a href="#曲线弧长" class="headerlink" title="曲线弧长"></a>曲线弧长</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031345840.png" alt="image.png"></p><h2 id="常考题型-3"><a href="#常考题型-3" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="几何应用-1"><a href="#几何应用-1" class="headerlink" title="几何应用"></a>几何应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用二重积分，先对x求积分，再对y求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031355804.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031401556.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427671.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427969.png" alt="image.png"></p><h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031500543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031459946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031508079.png" alt="image.png"></p><h1 id="高数7-常微分方程"><a href="#高数7-常微分方程" class="headerlink" title="高数7-常微分方程"></a>高数7-常微分方程</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031510341.png" alt="image.png"></p><h2 id="内容概要-5"><a href="#内容概要-5" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="常微分方程概念"><a href="#常微分方程概念" class="headerlink" title="常微分方程概念"></a>常微分方程概念</h3><hr><p><code>微分方程</code>：含有未知数导数的方程称为微分方程<br><code>微分方程的阶</code>：含有的未知数导数的最高阶导数的阶数<br><code>微分方程的解</code>：例如微分方程<code>y&#39;&#39;=e^x</code>，那么解可以是<code>y=e^x ，e^x + c1x , e^x + c1x + c2</code><br><code>微分方程的通解</code>：上面<code>y=e^x + c1x + c2</code>就是<code>y&#39;&#39;=e^x</code>的通解<br><code>微分方程的特解</code>：<code>y=e^x , e^x + c1x</code>都是特解<br><code>积分曲线</code>：微分方程的解对应的那条曲线就是微分方程的积分曲线</p><h3 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h3><hr><h4 id="可分离变量微分方程"><a href="#可分离变量微分方程" class="headerlink" title="可分离变量微分方程"></a>可分离变量微分方程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以将dx,dy分别移到两边，然后求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031657268.png" alt="image.png"></p><h4 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031703516.png" alt="image.png"></p><h4 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031751173.png" alt="image.png"></p><h4 id="伯努利方程及全微分方程"><a href="#伯努利方程及全微分方程" class="headerlink" title="伯努利方程及全微分方程"></a>伯努利方程及全微分方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031759927.png" alt="image.png"></p><h3 id="可降阶方程"><a href="#可降阶方程" class="headerlink" title="可降阶方程"></a>可降阶方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最简单</span><br><span class="line">2.基本思路，将y&#x27;替换为P,转换为一阶微分方程计算</span><br><span class="line">3.令y&#x27;=P，则y&#x27;&#x27;=(dP/dy)*P   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031811741.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031815908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031823129.png" alt="image.png"></p><h3 id="高阶线性微分方程"><a href="#高阶线性微分方程" class="headerlink" title="高阶线性微分方程"></a>高阶线性微分方程</h3><h4 id="变系数线性微分方程"><a href="#变系数线性微分方程" class="headerlink" title="变系数线性微分方程"></a>变系数线性微分方程</h4><hr><p><code>齐次线性微分方程</code><br><code>非齐次线性微分方程</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时还停留在理论层面，实际问题不好求特解</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031857961.png" alt="image.png"></p><h4 id="常系数齐次线性微分方程"><a href="#常系数齐次线性微分方程" class="headerlink" title="常系数齐次线性微分方程"></a>常系数齐次线性微分方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与线性齐次微分方程对比不同点，实际上就是，y导数的系数是常数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031901716.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031905608.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031925959.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031926834.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三阶，三解，单独拆开看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031944218.png" alt="image.png"></p><h4 id="常系数非齐次线性微分方程"><a href="#常系数非齐次线性微分方程" class="headerlink" title="常系数非齐次线性微分方程"></a>常系数非齐次线性微分方程</h4><hr><p>非齐次线性方程的解=<code>齐次通解</code>+<code>非齐次特解</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找特解</span><br><span class="line">1.k值看 λ 是几重根</span><br><span class="line">2.k值看 α+iβ 是几重根(α、β看f(x)里面的形式)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032048454.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.确定非齐次项类型</span><br><span class="line">2.根据特征方程特征根，得出齐次方程的通解</span><br><span class="line">3.设出合适非齐次特解，根据非齐次项得知 λ ,再根据λ比较特征方程的根，看是几重根,本题λ=0 != r,所以</span><br><span class="line">  k=0</span><br><span class="line">4.将假设的y*带回方程，求出系数</span><br><span class="line">5.非齐次线性方程的解=`齐次通解`+`非齐次特解`</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032101045.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032109778.png" alt="image.png"></p><h4 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D^2--&gt;r^2</span><br><span class="line">D--&gt;r</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032114735.png" alt="image.png"></p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307131145843.png" alt="image.png"></p><h2 id="常考题型-4"><a href="#常考题型-4" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="方程求解"><a href="#方程求解" class="headerlink" title="方程求解"></a>方程求解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的齐次方程求解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131818514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131914887.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判别类型：二阶(导数是二阶导数)  线性  常系数 齐次 微分方程 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131903867.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二阶 非齐次 线性 微分方程</span><br><span class="line">非其次项分为两种类型，因为非齐次线性微分方程的解具有叠加性</span><br><span class="line">所以可以分别设两种解，然后分别求出，再相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132117987.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二阶齐次线性微分方程,选取对应方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132132649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先判断(1/2)e^2x 只能是齐次的通解，因为如果是非齐次特解，那么代入方程得不到ce^x</span><br><span class="line">2.然后判断xe^x，是非齐次的特解，因为如果是齐次通解，由于是xe^x形式，原齐次特征方程特征根必然是二重根，且为1，但是之前已经知道一个齐次通解--&gt;其中一个根可知=2,；矛盾，所以必然是非齐次特解</span><br><span class="line">3.不难判断最后一个是齐次通解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132147848.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经典例题，多看看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132213446.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由二阶微分方程可知--&gt;y二阶可导--&gt;洛必达可以洛到一阶导数--&gt;2x/y&#x27;(0)--&gt;还是0/0型--&gt;由二阶微分方程可知y&#x27; y e^3x都连续，所以y&#x27;&#x27;也连续--&gt;所以可以洛到二阶导数--&gt;2/y&#x27;&#x27;(0)--&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132221621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f括号里的变量和d后面的变量相同，就无所谓是t还是t/3。变量前面的d表示你对该变量求导。所以f(t)dt和f(t/3)dt是等价的表达式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132308460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">综合性，很强</span><br><span class="line">1.令x-t=u，便于求导</span><br><span class="line">2.第二步处理，分开进行求导</span><br><span class="line">3.最终得到一阶线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132321419.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.分析微分方程类型，二阶微分方程，但是没有y，不属于高阶类型，降阶，令y&#x27;=p,则y&#x27;&#x27;=p&#x27;</span><br><span class="line">2.得到xp&#x27;-p+2=0;--&gt;线性微分方程，带对应公式</span><br><span class="line">3.这一步关键，积分过程中x&gt;0,所得y通解x&gt;0,所以不能直接代入y(0),因为是连续函数，应该取极限</span><br><span class="line">得到C2=0，</span><br><span class="line">4.旋转体体积积分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141104530.png" alt="image.png"></p><h1 id="高数8-多元函数微分学"><a href="#高数8-多元函数微分学" class="headerlink" title="高数8-多元函数微分学"></a>高数8-多元函数微分学</h1><h2 id="重极限-连续-偏导数-全微分"><a href="#重极限-连续-偏导数-全微分" class="headerlink" title="重极限-连续-偏导数-全微分"></a>重极限-连续-偏导数-全微分</h2><h3 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">证明该极限不存在</span><br><span class="line">1.假设y=kx;</span><br><span class="line">2.代入原式，得到极限=k/1+k^2</span><br><span class="line">3.由于极限随k变化而变化，所以极限不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181231264.png" alt="image.png"></p><h3 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与一元函数性质类似</span><br><span class="line">多元函数不考察间断点及其分类，因为过于复杂</span><br><span class="line">多元主要考察用定义判断，分段函数，在分界点上的连续性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181237219.png" alt="image.png"></p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数用的是偏增量</span><br><span class="line">偏导数本质上就是一元函数导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247801.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数几何意义</span><br><span class="line">偏x导数 : 作过y=y0垂直于xy平面的平面，与空间曲面上交于一曲线，这条曲线沿x轴方向的导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247505.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果函数在D内连续，混合偏导数与偏导次序无关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181254091.png" alt="image.png"></p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义法-判断二元函数是否可微？</span><br><span class="line">1.首先判断x、y的偏导数是否都存在，如果有1个不存在，肯定不可微</span><br><span class="line">2.两个偏导数存在，接着根据全微分定义，看O(ρ)是否是ρ的高阶无穷小，如果不是就不可微</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181401379.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">充分条件-判断是否可微?</span><br><span class="line">两个偏导数在(x0,y0)处连续，则函数在(x0,y0)一定可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181405682.png" alt="image.png"></p><h3 id="连续-可偏导-可微关系"><a href="#连续-可偏导-可微关系" class="headerlink" title="连续-可偏导-可微关系"></a>连续-可偏导-可微关系</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181424194.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数存在(x、y方向偏导存在、可偏导)--&gt;可能会有缺失,所以可能不连续，可微更推不出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181451922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续(四面八方不存在空缺)--&gt;面上可能有尖点，不存在切平面，也可能不存在切线</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181441922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微--&gt;某点有切平面(一定连续、可导)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181440267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续--&gt;等级最高</span><br></pre></td></tr></table></figure><h3 id="常考题型-5"><a href="#常考题型-5" class="headerlink" title="常考题型"></a>常考题型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断在点(0,0)连不连续： 求x-&gt;0,y-&gt;0 时，函数的极限。该极限之前求过，不存在，所以不连续</span><br><span class="line">2.判断在点(0,0)处偏导数存不存在，用定义式，先求偏x，令y=0代入，发现分子恒=0，分母趋近与0却不等于0，所以极限=0.偏x导数存在；接着求p偏y，令x=0...</span><br><span class="line">3.最后得出不连续，偏导存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181746558.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181754311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种填空题，一眼令f(x,y)=2x-y+2, dz=Adx+Bdy</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181824197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.直接法</span><br><span class="line">题目对x偏导数&gt;0 ,说明z随x增大而增大;偏y&lt;0,随y增大而减小</span><br><span class="line"></span><br><span class="line">2.特殊方程法</span><br><span class="line">根据题目要求，设一个函数，代入数值求证</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181859413.png" alt="image.png"></p><h4 id="四个经典反例"><a href="#四个经典反例" class="headerlink" title="四个经典反例"></a>四个经典反例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续，但不可导</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181842665.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可导但不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181843326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可导但不可微例子</span><br><span class="line"></span><br><span class="line">1.先判断可不可微，两部曲--a.判断两个偏导存不存在 b.求(△z-A△x-B△y)/(△x^2 +△y^2)^1/2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181841705.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微但偏导数不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181854359.png" alt="image.png"></p><h2 id="多元函数微分法"><a href="#多元函数微分法" class="headerlink" title="多元函数微分法"></a>多元函数微分法</h2><h3 id="复合函数微分法"><a href="#复合函数微分法" class="headerlink" title="复合函数微分法"></a>复合函数微分法</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192118819.png" alt="image.png"></p><h3 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如何判断谁是谁的函数？</span><br><span class="line">F&#x27;z(x0,y0,z0)!=0 ==&gt; 说明z是x、y的函数 =&gt;z=f(x,y)</span><br><span class="line">同理如果F&#x27;x(x0,y0,z0) != 0 ==&gt; 说明x是y、z的函数 ==&gt;x=f(y,z)</span><br><span class="line"></span><br><span class="line">2.由方程F(x,y,z)=0 确定的隐函数z=z(x,y)</span><br><span class="line">a.该函数在点P(x0,y0,z0)的某一领域内有连续偏导数</span><br><span class="line">b.F(x0,y0,z0)=0</span><br><span class="line">c.Fz&#x27;(x0,y0,z0)!=0</span><br><span class="line">==&gt;则方程F(x,y,z)=0,在点P(x0,y0,z0)的某一邻域可</span><br><span class="line">   唯一确定一个具有连续偏导数的函数 z=z(x,y)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192133986.png" alt="image.png"></p><h3 id="常考题型-6"><a href="#常考题型-6" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="复合函数偏导数与全微分"><a href="#复合函数偏导数与全微分" class="headerlink" title="复合函数偏导数与全微分"></a>复合函数偏导数与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.直接导两次</span><br><span class="line">方法2.先导一次，然后将y=2代入--&gt;只剩下x的函数--&gt;求x=0时的导数--&gt;运用导数定义</span><br><span class="line">      --&gt;求x=0处导数--&gt; f(x)-f(0)/x-0 --&gt; 求极限=4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192147510.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.换元</span><br><span class="line">考到了微分的有理运算法则</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192210116.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192220636.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∂z/∂x = (∂z/∂u)*(∂u/∂/x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数z=f(u,v)</span><br><span class="line">fu&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f1&#x27; </span><br><span class="line">fv&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f2&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192245416.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192300736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f12&#x27;=f21&#x27;本质是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192317760.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种求具体某一点的二阶偏导数</span><br><span class="line">可以先求出一阶偏x导数之后，代入x的值</span><br><span class="line">然后继续求偏y，不影响，更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192329042.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.多元复合求偏导</span><br><span class="line">2.微分方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336916.png" alt="image.png"></p><h4 id="隐函数偏导与全微分"><a href="#隐函数偏导与全微分" class="headerlink" title="隐函数偏导与全微分"></a>隐函数偏导与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1.微分形式不变性</span><br><span class="line"></span><br><span class="line">两边dK=dM ,看做两个新函数，x,y,z为变量</span><br><span class="line">同时求全微分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201615692.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br><span class="line">利用全微分定义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201627288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">隐函数求偏微分三种方法应用</span><br><span class="line">1.两边对x求导</span><br><span class="line">2.代隐函数偏导数公式</span><br><span class="line">3.两边求全微分(微分形式不变性)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201637250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252222727.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例13.</span><br><span class="line">方法1.使用隐函数偏导数公式。写成F(x,y,z)=0的形式--&gt;代偏导公式--&gt;再利用全微分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246104.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.利用微分形式不变，对两边求微分，求出dz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246977.png" alt="image.png"></p><h2 id="多元函数的极值与最值"><a href="#多元函数的极值与最值" class="headerlink" title="多元函数的极值与最值"></a>多元函数的极值与最值</h2><hr><h3 id="无约束极值"><a href="#无约束极值" class="headerlink" title="无约束极值"></a>无约束极值</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252310840.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对于二元函数,极值不一定是驻点，驻点不一定是极值</span><br><span class="line">驻点推不出极值，典例xy</span><br><span class="line">极值推不出驻点，典例|x|+|y|</span><br><span class="line"></span><br><span class="line">极值点有三种可能</span><br><span class="line">1.驻点</span><br><span class="line">2.fx&#x27;与fy&#x27;都不存在的点</span><br><span class="line">3.fx=0,且fy不存在;或fy=0且fx不存在的点</span><br><span class="line"></span><br><span class="line">一般只考察第一种可能</span><br><span class="line">--&gt;如何判断驻点是极大值还是极小值还是有没有极值</span><br><span class="line">--&gt;下面这个公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252311524.png" alt="image.png"></p><h3 id="有条件极值与拉格朗日数乘法"><a href="#有条件极值与拉格朗日数乘法" class="headerlink" title="有条件极值与拉格朗日数乘法"></a>有条件极值与拉格朗日数乘法</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">条件极值概念，在某一个约束条件下，函数的极值。</span><br><span class="line"></span><br><span class="line">例如下面这幅图，φ(x,y)=0的条件--&gt;得到一条曲线--&gt;在这条曲线对应的x,y范围内求f(x,y)的极值，这种极值被称为条件极值。</span><br><span class="line"></span><br><span class="line">如何求条件极值？</span><br><span class="line">--&gt;将f(x,y)与φ(x,y)两个函数写成非条件极值的形式</span><br><span class="line">--&gt;F(x,y,λ)分别对x,y,λ求偏导=0，</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br><span class="line"></span><br><span class="line">如果有两个约束条件呢？</span><br><span class="line">--&gt;那就假设四个变量的函数F(x,y,λ,Φ)</span><br><span class="line">--&gt;分别对四个变求偏导数，分别都等于0</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252334882.png" alt="image.png"></p><h3 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261155130.png" alt="image.png"></p><h3 id="常考题型-7"><a href="#常考题型-7" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="求极值"><a href="#求极值" class="headerlink" title="求极值"></a>求极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">根据题目可知全微分dz=xdx+ydy --&gt; fx&#x27;=x ;fy&#x27;=y --&gt; 代入点(0,0) --&gt; 两个偏导数都为0，是驻点(满足了极值点必要条件) --&gt; 接着求二阶偏导数，利用公式AC-B^2 ,判断时极小值还是极大值</span><br><span class="line"></span><br><span class="line">方法2.偏积分(找函数本身)</span><br><span class="line">方法3.凑微分(找函数本身)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261206463.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261222061.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261227562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261239426.png" alt="image.png"></p><h4 id="求最大最小值"><a href="#求最大最小值" class="headerlink" title="求最大最小值"></a>求最大最小值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不考条件极值而考条件最值？</span><br><span class="line">因为求得了驻点，我们无法判断时极大还是极小值。而一个问题如果存在最大值，那么驻点必是最值，所以可以根据最值必存在，推出该驻点是最大还是最小值</span><br><span class="line"></span><br><span class="line">根据条件约束--&gt;写出拉格朗日数乘法--&gt;求出所有可能极值点--&gt;再根据题目隐含意思推出该极值点大概是极大值还是极小值(注意这里没有公式可以得知是极大值还是极小值)。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261248743.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br><span class="line"></span><br><span class="line">像这种全微分为dz=2xdx - 2ydy --&gt;全微分存在说明可微--&gt;fx&#x27;=2x ;fy&#x27;=2y --&gt;驻点只有(0,0),是唯一驻点--&gt;可微说明函数光滑，接着驻点唯一，说明驻点要么是最大值或最小值或单调的水平过渡点。--&gt;意味着二元函数要么是单调的或凸的或凹的--&gt;这些情况都只需要我们求出边界上的极值点与驻点一比较就能得出最大值，最小值</span><br><span class="line"></span><br><span class="line">有两种方法：</span><br><span class="line">方法1.得出驻点之后，根据约束条件函数，将x或y代换，转变为一元函数化条件为无条件，在求边界最值。</span><br><span class="line">方法2.得出驻点之后，构造拉格朗日数乘法，求出边界极值</span><br><span class="line">方法3.参数方程，化条件为无条件，出现这种椭圆的可以转化为参数方程</span><br><span class="line"></span><br><span class="line">最终在与驻点函数值比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301211.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305262253388.png" alt="image.png"></p><h1 id="高数9-二重积分"><a href="#高数9-二重积分" class="headerlink" title="高数9-二重积分"></a>高数9-二重积分</h1><h2 id="二重积分的概念和性质"><a href="#二重积分的概念和性质" class="headerlink" title="二重积分的概念和性质"></a>二重积分的概念和性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二重积分几何意义：区域D内，以函数为顶的，这个圆柱体的体积</span><br><span class="line">二重积分的性质：不等式性质、中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282116780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282118635.png" alt="image.png"></p><h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><h3 id="利用直角坐标计算"><a href="#利用直角坐标计算" class="headerlink" title="利用直角坐标计算"></a>利用直角坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149154.png" alt="image.png"></p><h3 id="利用极坐标计算"><a href="#利用极坐标计算" class="headerlink" title="利用极坐标计算"></a>利用极坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149068.png" alt="image.png"></p><h4 id="适合极坐标计算的二重积分特征"><a href="#适合极坐标计算的二重积分特征" class="headerlink" title="适合极坐标计算的二重积分特征"></a>适合极坐标计算的二重积分特征</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282134528.png" alt="image.png"></p><h3 id="利用对称性奇偶性计算"><a href="#利用对称性奇偶性计算" class="headerlink" title="利用对称性奇偶性计算"></a>利用对称性奇偶性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.如果积分区域关于y轴对称</span><br><span class="line">- f(x,y)为关于x是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于x是奇函数--&gt; 积分就等于0</span><br><span class="line">2.如果积分区域关于x轴对称</span><br><span class="line">- f(x,y)为关于y是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于y是奇函数--&gt; 积分就等于0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282145694.png" alt="image.png"></p><h3 id="利用变量对称性计算"><a href="#利用变量对称性计算" class="headerlink" title="利用变量对称性计算"></a>利用变量对称性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量对称性也称轮换对称性</span><br><span class="line">积分区域关于y=x对称就有如下性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282204438.png" alt="image.png"></p><h3 id="常考题型-8"><a href="#常考题型-8" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="累次积分交换次序或计算"><a href="#累次积分交换次序或计算" class="headerlink" title="累次积分交换次序或计算"></a>累次积分交换次序或计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据积分上下限，画出积分区域</span><br><span class="line">2.根据积分区域重新定限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282210754.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302117455.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">极坐标转化为直角坐标--&gt;画域</span><br><span class="line">右边对ρ积分下限=0 ;对ρ积分上限=cosx;</span><br><span class="line">ρcosθ=0 --&gt; x=0 --&gt;积分区域在x=0上方</span><br><span class="line">ρ^2=x^2+y^2=ρcosθ=x --&gt; 积分区域在x^2+y^2=x的下方</span><br><span class="line">--&gt;最终就是如图所示的半圆区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302126758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题是将直角坐标转化为极坐标</span><br><span class="line">对y=0 --&gt; ρsinθ =0 --&gt; ρ=0</span><br><span class="line">y=(2x-x^2)^0.5 --&gt; y^2=2x-x^2 --&gt; ρ=2cosθ</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302143241.png" alt="image.png"></p><h4 id="二重积分的计算-1"><a href="#二重积分的计算-1" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用轮换对称性质+奇偶对称性</span><br><span class="line">1.积分区域(圆)关于y=x对称</span><br><span class="line">2.因为y是关于y轴的奇函数，积分区域关于y，所以对称积分为0</span><br><span class="line">3.轮换对称，对x^2积分=对y^2积分=1/2(x^2+y^2)积分 --&gt;转换成极坐标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302208501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域--&gt;划分为关于y轴对称的区域+关于x轴对称的区域</span><br><span class="line">2.对xy积分，x是关于x轴的奇函数，y是关于y轴的奇函数--&gt;所以两个部分积分区域积分=0</span><br><span class="line">3.对cosxsiny积分，siny是关于y轴的奇函数，cosx是关于x轴的偶函数--&gt;所以关于x轴对称积分区域=0；只剩下关于y轴对称的积分区域的积分</span><br><span class="line">4.就如A选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302217243.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域,积分区域关于y轴对称</span><br><span class="line">2.将被积函数拆开--&gt;x^2 + 2x + 1 ,其中2x是关于x轴的奇函数,积分区域有时关于y轴对称,</span><br><span class="line">  2x积分=0</span><br><span class="line">3.剩下x^2 + 1,关于x轴的偶函数--&gt;由于积分区域是圆--&gt;化成极坐标好做一点</span><br><span class="line">4.最后点火公式带走</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302233155.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据区域判断被积函数绝对值正负</span><br><span class="line">1.画出的积分区域是一个正方形</span><br><span class="line">2.被积函数有绝对值，所以要讨论函数的正负性</span><br><span class="line">3.发现被积函数是一个圆，小于圆时为负，入D1区域;大于该圆的部分为正，如D2区域</span><br><span class="line">4.于是分开两个区域讨论,圆内的区域，被积函数为负，圆外的积分区域，被积函数为正</span><br><span class="line">5.其中D1部分区域的积分用极坐标，D2部分积分化为正方形区域-圆的区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302253981.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302311344.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302314653.png" alt="image.png"></p><h1 id="高数10-无穷级数"><a href="#高数10-无穷级数" class="headerlink" title="高数10-无穷级数"></a>高数10-无穷级数</h1><h2 id="常数项级数"><a href="#常数项级数" class="headerlink" title="常数项级数"></a>常数项级数</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061714753.png" alt="image.png"></p><h3 id="级数概念"><a href="#级数概念" class="headerlink" title="级数概念"></a>级数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是无穷多个常数项相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720100.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720954.png" alt="image.png"></p><h3 id="级数的性质"><a href="#级数的性质" class="headerlink" title="级数的性质"></a>级数的性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.若一个级数收敛，则其每一项相都乘以常数k,这个级数任然收敛</span><br><span class="line"></span><br><span class="line">2.两个级数收敛，相加相减之后任然收敛，收敛于他们各自极限的和或差</span><br><span class="line"></span><br><span class="line">3.去掉或加上改变有限项不影响级数的敛散性--&gt;也就是说只有后面无穷多项会影响敛散性</span><br><span class="line"></span><br><span class="line">4.收敛级数加括号任然收敛，但是加括号收敛无法推出原级数收敛</span><br><span class="line"></span><br><span class="line">5.如果一个级数收敛--&gt;它的第n项(n趋于无穷)，一定趋近于0</span><br><span class="line">  但是通项趋近于0，不能得到级数收敛(例如∑1/n)</span><br><span class="line">  通项不趋近于0，一定发散</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061730770.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061742981.png" alt="image.png"></p><h3 id="级数的审敛准则"><a href="#级数的审敛准则" class="headerlink" title="级数的审敛准则"></a>级数的审敛准则</h3><h4 id="正项级数"><a href="#正项级数" class="headerlink" title="正项级数"></a>正项级数</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.比较判别法</span><br><span class="line">2.比较法的极限形式</span><br><span class="line">3.比值法</span><br><span class="line">4.根值法</span><br><span class="line">5.积分判别法</span><br><span class="line"></span><br><span class="line">5不常用，1，2,3,4做题比较常用</span><br><span class="line"></span><br><span class="line">1,2 适用范围广 但不方便(因为要找别的函数比较)</span><br><span class="line">3,4 适用范围窄 但方便比较(直接和自己比较)</span><br><span class="line"></span><br><span class="line">通常做题先用3,4 然后做不出再用1,2</span><br><span class="line"></span><br><span class="line">出现a^n 、n! 、n^n --&gt;使用3,4</span><br><span class="line">出现n^p 、ln n 使用1,2</span><br><span class="line"></span><br><span class="line">正项级数与负项级数本质一样，只不过多个负号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061800727.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061801216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802574.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802116.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061816942.png" alt="image.png"></p><h4 id="交错级数"><a href="#交错级数" class="headerlink" title="交错级数"></a>交错级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交错级数--&gt;正负项交替出现，有规律的级数</span><br><span class="line">莱布尼兹准则：</span><br><span class="line">1.若Un单调减小，且趋近于无穷是Un趋近于0，--&gt; 交错级数收敛</span><br><span class="line">2.但是反过来，交错级数收敛无法推出，Un递减</span><br><span class="line">为什么交错级数，Un递减，且Un趋近于0才能推出交错级数收敛？</span><br><span class="line">因为如果Un递减，但不趋向于0而如果是趋向于1，那么级数会在-1 1之间摇摆不可能收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061902443.png" alt="image.png"></p><h4 id="任意项级数"><a href="#任意项级数" class="headerlink" title="任意项级数"></a>任意项级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任意项级数--&gt;有正项有负项，正负项没有规律，正负项都是无穷项</span><br><span class="line">- 既然没有规律，那应该怎么判定是否收敛呢？</span><br><span class="line">- 引入绝对收敛和条件收敛：</span><br><span class="line">1.绝对收敛: 当级数的绝对值收敛那么原级数一定收敛，称原级数绝对收敛</span><br><span class="line">2.条件收敛：如果原级数是收敛的，但是他的绝对值是发散的，那么是条件收敛</span><br><span class="line">- 基本结论： </span><br><span class="line">- 绝对收敛的级数一定是收敛的</span><br><span class="line">- 条件收敛的级数，它的正项构成的级数发散，负向构成的级数也发散</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061917627.png" alt="image.png"></p><h2 id="常考题型-9"><a href="#常考题型-9" class="headerlink" title="常考题型"></a>常考题型</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062156822.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062217881.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062226142.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A.bn收敛 举反例bn=(-1)^n/√n ; an=(-1)^n/√n =&gt;相乘-调和级数1/n 发散</span><br><span class="line"></span><br><span class="line">B.举反例bn=1/n ;an=1/n =&gt; 相乘1/n^2 收敛</span><br><span class="line"></span><br><span class="line">C.</span><br><span class="line">首先</span><br><span class="line">∑|bn| 收敛 =&gt; |bn|-&gt;0 =&gt; |bn|&lt;1 =&gt; |bn|&gt;bn^2 大收则小收</span><br><span class="line">然后</span><br><span class="line">an-&gt;0 =&gt; |an|&lt;1 =&gt; a^2&lt;1 =&gt; an^2bn^2&lt;bn^2  </span><br><span class="line"></span><br><span class="line">D.举反例，与上面反例类似</span><br><span class="line"></span><br><span class="line">总结：常用结论--&gt; |bn|收敛=&gt; bn^2收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062230522.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062257669.png" alt="image.png"></p><h2 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102219380.png" alt="image.png"></p><h3 id="幂级数的收敛半径、收敛区间、收敛域"><a href="#幂级数的收敛半径、收敛区间、收敛域" class="headerlink" title="幂级数的收敛半径、收敛区间、收敛域"></a>幂级数的收敛半径、收敛区间、收敛域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不直接讨论改幂级数是收敛还是发散？</span><br><span class="line">因为幂级数∑an*x^n, 当x=1时，他就是一个常数项级数 a1,a2,a3,a4...an</span><br><span class="line">当x=2,就是一个另外一个常数项级数2a1,4a2,8a3,...</span><br><span class="line">--&gt;因为x是变化的，所以只能讨论x取什么时，级数的敛散性--&gt;也就是讨论收敛半径、区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102220953.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定理1(阿贝尔定理)：</span><br><span class="line">(1) x=x0(x0!=0),时收敛，则当|x|&lt;|x0|时,幂级数就是绝对收敛的</span><br><span class="line">(2) x=x0,时发散，则|x|&gt;|x0|时，幂级数发散</span><br><span class="line"></span><br><span class="line">定理2.</span><br><span class="line">幂级数的收敛性有且仅有一下三种可能</span><br><span class="line">(1).要么R上都收敛</span><br><span class="line">(2).要么只在x=0收敛</span><br><span class="line">(3).要么只在一个半径内收敛</span><br><span class="line">注意：如果幂级数在点x=x0出条件收敛，则点x0必为幂级数收敛区间(-R,R)上的一端点</span><br><span class="line"></span><br><span class="line">定理3.lim an+1/an = ρ，则收敛半径R=1/ρ </span><br><span class="line">因为假如R=1/2，那么x=1/3时，是收敛的，级数∑an*(1/3)^n --&gt; 比值法</span><br><span class="line">设bn+1=an+1*(1/3)^n+1 ，bn=an*(1/3)^n  ;bn+1/bn= (1/3)an+1/an=2/3&lt;1,收敛成</span><br><span class="line">立</span><br><span class="line">定理4.如果lim|an|^(1/n)=ρ，则收敛半径R=1/ρ</span><br><span class="line">--&gt;根值法证明</span><br><span class="line"></span><br><span class="line">概念：</span><br><span class="line">收敛半径:R </span><br><span class="line">收敛区间:(-R,R) --&gt;区间都是是开的区间</span><br><span class="line">收敛域：需要确定端点x=-R,x=R，处是否收敛，确定区间闭合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102237267.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102244221.png" alt="image.png"></p><h3 id="幂级数的性质"><a href="#幂级数的性质" class="headerlink" title="幂级数的性质"></a>幂级数的性质</h3><hr><h4 id="有理运算性质"><a href="#有理运算性质" class="headerlink" title="有理运算性质"></a>有理运算性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当幂级数A,收敛半径R1!,幂级数B收敛半径R2,R1!=R2,时</span><br><span class="line">令R=min&#123;R1,R2&#125;,当x∈(-R,R)</span><br><span class="line">1.幂级数加减法后新的幂级数的收敛半径=R</span><br><span class="line">2.乘除法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102317028.png" alt="image.png"></p><h4 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">幂级数的收敛半径为R,和函数S(x)有一下性质</span><br><span class="line">1.连续性：&lt;收敛域内&gt;</span><br><span class="line">和函数S(x)在收敛域内连续</span><br><span class="line"></span><br><span class="line">2.可导性：(任意阶可导) &lt;收敛区间内&gt;</span><br><span class="line">和函数S(x)在(-R,R)上可导，且逐项可导，半径不变</span><br><span class="line">例如S&#x27;(x)=(∑an*x^n)&#x27;=∑(an*x^n)&#x27;=∑n*an*x^n-1 --&gt;任然是幂级数，收敛半径任</span><br><span class="line">然与an有关，ρ=lim an+1/an, R=1/ρ不变 --&gt;所以是任意阶可导(可一直导下去)</span><br><span class="line">3.可积分性：&lt;收敛域内&gt;</span><br><span class="line">可导性逆过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102330711.png" alt="image.png"></p><h3 id="函数的幂级数的展开"><a href="#函数的幂级数的展开" class="headerlink" title="函数的幂级数的展开"></a>函数的幂级数的展开</h3><p><strong>泰勒公式的定义</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111216906.png" alt="image.png"><br>我们常说求极限0/0可以用泰勒展开，为什么呢？<br>    这样去想，因为将函数展开为幂级数，∑an (x-x0)^n ,其中x=x0时，必有级数收敛且=0<br>    lim(x-&gt;1/3) sinx<br>        1.首先确定展开级数∑an (x-x0)^n =0 ,sinx-&gt;0时，x-&gt;0，收敛中心x0=0<br>        2.接着，x-&gt;1/3,展开级数∑an (x-x0)^n=∑an (x)^n = ∑an (1/3)^n<br>    lim(x-&gt;1/3) x/sin(x-1)</p><pre><code>    - 求sin(x-1/3)极限为什么不能直接套上面的展开式呢？    - 因为sin(x-1)展开级数∑an (x-1)^n =0 ，收敛中心是x0=1    - 接着，x-&gt;1/3,其展开级数为∑an (x-x0)^n=∑an (x-1)^n = ∑an (1/3-1)^n</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110004937.png" alt="image.png"></p><h4 id="几个常用的展开"><a href="#几个常用的展开" class="headerlink" title="几个常用的展开"></a>几个常用的展开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">级数，power series，指的是麦克劳林级数。</span><br><span class="line">也就是在 x = 0 附近展开的泰勒级数。</span><br><span class="line">.</span><br><span class="line">展开的条件是 n 阶连续可导，而 n 趋向于无穷。</span><br><span class="line">y = x⁴ + x³ + x² + x + 1，就不可能展开成无穷项的幂级数。</span><br><span class="line">.</span><br><span class="line">y = sinx，可以展开为无穷项的幂级数。</span><br><span class="line">但是 y = sin|x| , 在 x = 0 处是不可导的，就不可以展开为幂级数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110005861.png" alt="image.png"></p><h4 id="函数展开为幂级数的方法"><a href="#函数展开为幂级数的方法" class="headerlink" title="函数展开为幂级数的方法"></a>函数展开为幂级数的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110006907.png" alt="image.png"></p><h3 id="常考题型-10"><a href="#常考题型-10" class="headerlink" title="常考题型"></a>常考题型</h3><hr><h4 id="求收敛半径、收敛区间、收敛域"><a href="#求收敛半径、收敛区间、收敛域" class="headerlink" title="求收敛半径、收敛区间、收敛域"></a>求收敛半径、收敛区间、收敛域</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两种方法：</span><br><span class="line"></span><br><span class="line">注意这里幂级数是从n=1开始，因为有限项不影响收敛性，所以无关紧要</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110019509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺项，x只有奇数次幂2n-1 </span><br><span class="line">采取根值法如下</span><br><span class="line">重要的步骤是对an取绝对值--&gt;因为(-3)^n正负性会变化--&gt;将(-3)^n提取出来取绝对值就可以</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111029840.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求完收敛区间之后，判断端点的收敛性</span><br><span class="line">1.代入端点，判断级数的类别(正项级数、还是交错还是，任意项)</span><br><span class="line">2.然后根据相对的审敛准则取判别就OK</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111115663.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111114107.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">灵活使用阿贝尔定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111127198.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111126688.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.幂级数和函数可导性，且收敛半径不变</span><br><span class="line">2.幂级数条件收敛点必定是收敛区间端点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111138377.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111138415.png" alt="image.png"></p><h4 id="将级数展开为幂级数"><a href="#将级数展开为幂级数" class="headerlink" title="将级数展开为幂级数"></a>将级数展开为幂级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有理函数的展开</span><br><span class="line">1.将有理分式拆开</span><br><span class="line">2.利用1/1+x  或1/1-x 的幂级数展开展开</span><br><span class="line">3.因为1/1+x 形式的幂级数展开的收敛区间是(-1,1)</span><br><span class="line">4.将两个级数相加之后，新的级数的收敛半径R=min&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111418024.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.转化ln(x²+x)=lnx + ln(x+1) = ln(1+(x-1)) + ln(1+x) </span><br><span class="line">2.利用ln(1+x)展开幂级数=∑((-1)^n) (x^n)/n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111428010.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下，需要注意的是，两边积分是做x的变上限积分，目的是为了消除常数项C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111446506.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111449509.png" alt="image.png"></p><h4 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运用常用的幂级数展开，将幂级数写为和函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111457760.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111501846.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111513581.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111513545.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111525933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111524725.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很综合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111558946.png" alt="image.png"></p><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><hr><h3 id="傅里叶系数与傅里叶级数"><a href="#傅里叶系数与傅里叶级数" class="headerlink" title="傅里叶系数与傅里叶级数"></a>傅里叶系数与傅里叶级数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121455442.png" alt="image.png"></p><h3 id="收敛定理-狄利克雷"><a href="#收敛定理-狄利克雷" class="headerlink" title="收敛定理(狄利克雷)"></a>收敛定理(狄利克雷)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于一个周期函数,f(x)在(-l,l)上连续或有有限个第一类间断点，有且仅有有限个极值点，则f(x)的傅里叶级数在[-l,l]上处处收敛</span><br><span class="line">(1).当x是连续点 --&gt; 就收敛于f(x)</span><br><span class="line">(2).当x是间断点 --&gt; 收敛于f(x-)+f(x+)/2 --&gt;左+右极限平均值</span><br><span class="line">(3).当x是区间端点 ±l --&gt; f((-l)+) + f((l)-)/2 --&gt; 左端点右极限+右端点左极限的平均值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121456469.png" alt="image.png"></p><h3 id="周期为2π的函数展开"><a href="#周期为2π的函数展开" class="headerlink" title="周期为2π的函数展开"></a>周期为2π的函数展开</h3><h4 id="在-π，π-上展开"><a href="#在-π，π-上展开" class="headerlink" title="在[-π，π]上展开"></a>在[-π，π]上展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121505750.png" alt="image.png"></p><h4 id="在-π，π-上奇偶函数的展开"><a href="#在-π，π-上奇偶函数的展开" class="headerlink" title="在[-π，π]上奇偶函数的展开"></a>在[-π，π]上奇偶函数的展开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)是奇函数时</span><br><span class="line">f(x)cosnx --&gt; 奇函数 --&gt;[-π，π]积分=0 --&gt; an=0</span><br><span class="line">f(x)sin nx --&gt;偶函数 --&gt;[-π，π]积分=2倍[0,π]积分 --&gt;bn ...</span><br><span class="line">f(x)是偶函数时</span><br><span class="line">与上面相反</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121505271.png" alt="image.png"></p><h4 id="在-0-π-上展为正弦或余弦"><a href="#在-0-π-上展为正弦或余弦" class="headerlink" title="在[0,π]上展为正弦或余弦"></a>在[0,π]上展为正弦或余弦</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">将f(x)在[0,π]上展开为正弦</span><br><span class="line">展开为正弦，那么an=0 ,将f(x)补齐为奇函数F(x),</span><br><span class="line">F(x)为奇函数：</span><br><span class="line">使得an=0</span><br><span class="line">bn=...,只剩下bn,bn是[0,π]上F(x)sinnx积分，由于[0,π]上F(x)=f(x),所以实际</span><br><span class="line">没变化</span><br><span class="line">将f(x)在[0,π]上展开为余弦</span><br><span class="line">展开为余弦，那么bn=0 ,将f(x)补齐为偶函数函数F(x),</span><br><span class="line">F(x)为奇函数</span><br><span class="line">使得bn=0</span><br><span class="line">只是剩下an，an是[0,π]上F(x)cosnx积分，由于[0,π]上F(x)=f(x),所以实际</span><br><span class="line">就是用f(x)求得</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121526212.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121506866.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121522043.png" alt="image.png"></p><h3 id="周期为2l的函数展开"><a href="#周期为2l的函数展开" class="headerlink" title="周期为2l的函数展开"></a>周期为2<em>l</em>的函数展开</h3><h4 id="在-l-l-上展开"><a href="#在-l-l-上展开" class="headerlink" title="在[-l,l] 上展开"></a>在[-l,l] 上展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121500736.png" alt="image.png"></p><h4 id="在-l-l-上奇偶函数的展开"><a href="#在-l-l-上奇偶函数的展开" class="headerlink" title="在[-l,l]上奇偶函数的展开"></a>在[-l,l]上奇偶函数的展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121501534.png" alt="image.png"></p><h4 id="在-0-l-上展开为正弦或余弦"><a href="#在-0-l-上展开为正弦或余弦" class="headerlink" title="在[0,l]上展开为正弦或余弦"></a>在[0,l]上展开为正弦或余弦</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121501330.png" alt="image.png"></p><h3 id="常考题型-11"><a href="#常考题型-11" class="headerlink" title="常考题型"></a>常考题型</h3><hr><h4 id="狄利克雷收敛定理"><a href="#狄利克雷收敛定理" class="headerlink" title="狄利克雷收敛定理"></a>狄利克雷收敛定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=1是区间端点--&gt; 收敛与 左端点右极限+右端点左极限/2 = 2+1/2=3/2  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121541162.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☆</span><br><span class="line">S(x)=∑bn Sin nx ,根据周期π/l=1 ∴l=1 </span><br><span class="line">∵ 区间[0,1) ,内展开,an=0</span><br><span class="line">∴ 做了奇延脱，将函数补齐为奇函数 使得an=0</span><br><span class="line">那么 奇延托函数 F(x)是奇函数--&gt; F(-x) =-F(x)=-f(x)=-1/4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121549416.png" alt="image.png"></p><h4 id="将函数展开为傅里叶级数"><a href="#将函数展开为傅里叶级数" class="headerlink" title="将函数展开为傅里叶级数"></a>将函数展开为傅里叶级数</h4><hr><script type="math/tex; mode=display">b3=1/{\pi}\int_{-\pi}^{\pi}({\pi}x+x^2)sin3xdx</script><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121559093.png" alt="Uploading file...iodwj"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finish</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121625119.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121700093.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121659769.png" alt="image.png"></p><h1 id="高数11-向量代数与空间解析几何及多元微分学在几何上的应用"><a href="#高数11-向量代数与空间解析几何及多元微分学在几何上的应用" class="headerlink" title="高数11-向量代数与空间解析几何及多元微分学在几何上的应用"></a>高数11-向量代数与空间解析几何及多元微分学在几何上的应用</h1><h2 id="向量代数"><a href="#向量代数" class="headerlink" title="向量代数"></a>向量代数</h2><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数量积得到一个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121818749.png" alt="image.png"></p><hr><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">向量积，得到一个向量</span><br><span class="line">|a×b| =|a||b| sinα </span><br><span class="line">a×b几何表示，右手四指从a-&gt;b，大拇指朝向就是向量积方向</span><br><span class="line">注意b×a ,右手四指从b-&gt;a,大拇指朝向与a×b相反</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121818710.png" alt="image.png"></p><hr><h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121819587.png" alt="image.png"></p><hr><h3 id="常考题型-12"><a href="#常考题型-12" class="headerlink" title="常考题型"></a>常考题型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121831866.png" alt="image.png"></p><h2 id="空间平面与直线"><a href="#空间平面与直线" class="headerlink" title="空间平面与直线"></a>空间平面与直线</h2><h3 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一般式</span><br><span class="line">2.点法式</span><br><span class="line">3.截距式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121843769.png" alt="image.png"></p><hr><h3 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1一般式：两组平面方程联立，几何意义两组平面相交所得到的的直线</span><br><span class="line"></span><br><span class="line">2.对称式：找一组方向向量(l,m,m),然后以直线经过的某一点(x0,y0,z0),通过两点确定一个方向(x-x0)/l=(y-y0)/m=(z-z0)/n ,也就是直线上任何一点(x,y)与(x0,y0)组成的向量都是</span><br><span class="line">方向向量(l,m,n)等了比例放大缩小得到--&gt;(x-x0)/l=(y-y0)/m=(z-z0)/n</span><br><span class="line"></span><br><span class="line">3.参数式：根据(x-x0)/l=(y-y0)/m=(z-z0)/n=t </span><br><span class="line"> =&gt; x=x0+lt , y=y0+mt, z=z0+nt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121844902.png" alt="image.png"></p><hr><h3 id="平面与直线的位置关系"><a href="#平面与直线的位置关系" class="headerlink" title="平面与直线的位置关系"></a>平面与直线的位置关系</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122048860.png" alt="image.png"></p><hr><h3 id="点到面的距离"><a href="#点到面的距离" class="headerlink" title="点到面的距离"></a>点到面的距离</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122049678.png" alt="image.png"></p><hr><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A是直线上一点，B是目标点</span><br><span class="line">求B到直线的距离--&gt;通过 AB向量 叉乘 直线方向向量 = 平行四边形面积</span><br><span class="line">--&gt; 面积/底=高 --&gt; 高就是B点到直线的距离</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122050775.png" alt="image.png"></p><hr><h3 id="常考题型-13"><a href="#常考题型-13" class="headerlink" title="常考题型"></a>常考题型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.直线1的参数方程，得到方向向量(0,1,1); 直线2的对称式方程得到方向向量(1,2,3)</span><br><span class="line">2.两方向向量 叉乘 得到与两向量垂直的向量</span><br><span class="line">3.利用 点法式 求平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122124290.png" alt="image.png"></p><hr><h2 id="曲面与空间曲线"><a href="#曲面与空间曲线" class="headerlink" title="曲面与空间曲线"></a>曲面与空间曲线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">柱面：一条直线L平行与定直线,并且沿着定曲线移动所形成的一个面(轨迹)</span><br><span class="line">1.准线: 如果为f(x,y)=0 ;z=0; --&gt; f(x,y)=0表示柱面的轨迹 ,z=0表示投影在xoy平</span><br><span class="line">面--&gt;两者就一起表示柱面在xoy面上的投影曲线,也就是准线 </span><br><span class="line">2.准线：如果为F(x,y,z)=0;G(x,y,z)=0 --&gt; 两个曲面所交得到一条曲线就是准线 --&gt;</span><br><span class="line"> 母线平行于z轴的柱面方程就为两方程联立 消去z =&gt; H(x,y)=0 </span><br><span class="line">为什么f(x,y)=0，在空间上能表示一个柱面？</span><br><span class="line">f(x,y)=0, 在空间坐标中设其方程为 Ax+By+Cz=0 --&gt; 其中C=0 --&gt; 意味着z任意变化</span><br><span class="line">空间上都是Ax+By=0这条曲线 --&gt; 这样就形成了一个柱面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138390.png" alt="image.png"></p><h3 id="常考题型-14"><a href="#常考题型-14" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="建立柱面与旋转面方程"><a href="#建立柱面与旋转面方程" class="headerlink" title="建立柱面与旋转面方程"></a>建立柱面与旋转面方程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消去z,得到的H(x,y)就是所要求的柱面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122234655.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">曲线方程法 f(x,y)=0 ,z=0 --&gt; 平行与z轴的柱面在xoy面上投影曲线</span><br><span class="line">2x^2 +y^2 =1 ,z=0 --&gt; 绕x轴旋转，f(x,√(z^2+y^2)) = 2x^2 + y^2 +z^2 =1</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122241142.png" alt="image.png"></p><hr><h2 id="多元微分在几何上的应用"><a href="#多元微分在几何上的应用" class="headerlink" title="多元微分在几何上的应用"></a>多元微分在几何上的应用</h2><h3 id="曲面的切平面与法线"><a href="#曲面的切平面与法线" class="headerlink" title="曲面的切平面与法线"></a>曲面的切平面与法线</h3><h3 id="曲线的切线与法平面"><a href="#曲线的切线与法平面" class="headerlink" title="曲线的切线与法平面"></a>曲线的切线与法平面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.曲面的切平面的法线</span><br><span class="line">曲面有两种写法，其对应的法向量写法也不同：</span><br><span class="line">1.曲面 F(x,y,z)=0  --&gt; 法向量 n=(Fx&#x27;,Fy&#x27;,Fz&#x27;)</span><br><span class="line"></span><br><span class="line">2.曲面 z=f(x,y) --&gt; 法向量 n=(fx&#x27;,fy&#x27;,-1)</span><br><span class="line">实际与第一种情况一样，将F(x,y,z)=f(x,y) - z</span><br><span class="line">--&gt; 法向量 n=(Fx&#x27;,Fy&#x27;,Fz&#x27;) = (fx&#x27;,fy&#x27;,-1)</span><br><span class="line">2.曲线的切线与法平面</span><br><span class="line">曲线有两种写法，其对应的切向量写法写法也不同：</span><br><span class="line">1.参数方程  --&gt; 如图</span><br><span class="line"></span><br><span class="line">2。两曲面相联立的交线 --&gt; 曲线上某点的切向量 = 两曲面在交线该点的法向量的</span><br><span class="line">叉乘</span><br><span class="line">为什么？</span><br><span class="line">因为曲线上的切线应该与两曲面在该点法向量都垂直</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122254988.png" alt="image.png"></p><hr><h3 id="常考题型-15"><a href="#常考题型-15" class="headerlink" title="常考题型"></a>常考题型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122310591.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.曲面的切平面与平面A平行--&gt;则曲线切平面的法向量与平面A的法向量平行</span><br><span class="line">2.求出曲面的法向量与平面A的法向量--&gt;两向量平行，所以对应成比例解得到x,y,z</span><br><span class="line">3.得到了曲面在哪个点的切平面与平面A平行，有又知道切面法向量--&gt;点法式得到切平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131602219.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.求曲线的切线方程</span><br><span class="line">曲线是参数方程，其切线向量=(x&#x27;(t0),y&#x27;(t0),z&#x27;(t0)),再利用对称式直线方程写出该</span><br><span class="line">点的切线方程</span><br><span class="line">2.求曲线某点的法平面方程</span><br><span class="line">求得的切向量与法平面是垂直的所以可以</span><br><span class="line">运用点法式求得法平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131612343.png" alt="image.png"></p><h1 id="高数12-多元积分学及其应用"><a href="#高数12-多元积分学及其应用" class="headerlink" title="高数12-多元积分学及其应用"></a>高数12-多元积分学及其应用</h1><hr><h2 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h2><h3 id="直角坐标"><a href="#直角坐标" class="headerlink" title="直角坐标"></a>直角坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一重积分积分区域是坐标轴的一个区间</span><br><span class="line">二重积分积分区域是平面区域</span><br><span class="line">三重积分的积分区域是一个空间体</span><br><span class="line"></span><br><span class="line">三重积分的直角坐标有两种积分方式</span><br><span class="line">1.先一后二: 穿线法</span><br><span class="line">先对z求积分，后对xy积分--&gt;就由空间体在xoy上的投影作为定限，在这个投影区域</span><br><span class="line">内对z积分</span><br><span class="line">2.先二后一: 切片法</span><br><span class="line">先对xy积分，后对z积分--&gt;积分限由在z轴上投影定限，在这段高度内对xy平面进行</span><br><span class="line">积分</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131907174.png" alt="image.png"></p><hr><h3 id="柱坐标"><a href="#柱坐标" class="headerlink" title="柱坐标"></a>柱坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r是空间上的点到z轴的距离</span><br><span class="line">θ是空间上的点A 在xoy面上投影点A&#x27;与原点的连线与x轴的夹角</span><br><span class="line">z是点A的z坐标</span><br><span class="line">通过以上s三个信息就可以唯一确定一点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306132129048.png" alt="image.png"></p><hr><h3 id="球坐标"><a href="#球坐标" class="headerlink" title="球坐标"></a>球坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己看图理解吧，有点抽象，不好解释</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306132135211.png" alt="image.png"></p><hr><h3 id="利用奇偶性"><a href="#利用奇偶性" class="headerlink" title="利用奇偶性"></a>利用奇偶性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151629686.png" alt="image.png"></p><hr><h3 id="利用变量的对称性"><a href="#利用变量的对称性" class="headerlink" title="利用变量的对称性"></a>利用变量的对称性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151634144.png" alt="image.png"></p><hr><h3 id="常考题型与典型例题"><a href="#常考题型与典型例题" class="headerlink" title="常考题型与典型例题"></a>常考题型与典型例题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A.函数x是x轴的奇函数，积分区域Ω1关于zoy面对称，所以积分为0</span><br><span class="line">积分区域Ω2属于第I卦限，对x积分不为0，所以A错误</span><br><span class="line">B.函数y是y轴的奇函数，积分区域Ω1关于zox对称，，所以积分为0</span><br><span class="line">...</span><br><span class="line">C.函数z是z轴的奇函数，积分区域Ω1不关于xoy对称; 同样函数z是y轴和x轴的偶函数，且积分</span><br><span class="line">  区域关于x轴对称,所以前一半=后一半，且积分区域关于y轴对称，所以左一半=右一半;</span><br><span class="line">  所以C是对的</span><br><span class="line">D.函数xyz是关于z轴的奇函数,∵f(x,y,-z)=-f(x,y,z)  ;所以同上</span><br><span class="line"></span><br><span class="line">这题主要运用到函数的奇偶性和积分区域的对称性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151708018.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">分析：积分区域是一个球--&gt;采用切片法积分--&gt; 每一块切片都是一个圆x^2+y^2&lt;=1-z^2</span><br><span class="line"> --&gt; 先对其二重积分(函数 x 积分域面积) ，然后对z方向积分 --&gt; 如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151739552.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">积分区域具有变量对称性--&gt;对x^2积分和对y^2、在z^2积分等效--&gt;...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151746218.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于方程x+y+z=1，随便拿两个变量交换，方程不变--&gt;反应了一种轮换性质</span><br><span class="line">那么对x、y、z积分就是等效的</span><br><span class="line">下面就可以写成对6z的积分</span><br><span class="line">...</span><br><span class="line">既可以穿线法，也可以切片法，此题被积函数6z是z的一元函数，用切片法更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151751448.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151824750.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四种方法</span><br><span class="line">1.球坐标</span><br><span class="line">2.直角坐标，先一后二，穿线法</span><br><span class="line">3.直角坐标，先二后一，切片法</span><br><span class="line">4.柱坐标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152251947.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152252789.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152259255.png" alt="image.png"></p><hr><h2 id="曲线积分"><a href="#曲线积分" class="headerlink" title="曲线积分"></a>曲线积分</h2><h3 id="一类曲线积分与二类曲线积分区别"><a href="#一类曲线积分与二类曲线积分区别" class="headerlink" title="一类曲线积分与二类曲线积分区别"></a>一类曲线积分与二类曲线积分区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一类曲线是对曲线的长度，二类是对X坐标。怎么理解呢？</span><br><span class="line">告诉你一根线的线密度，问你线的质量，就要用一类。</span><br><span class="line">告诉你路径曲线方程，告诉你Xy两个方向的力，求功，就用二类。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161253118.png" alt="image.png"></p><hr><h3 id="对弧长的曲线积分-第一类线积分"><a href="#对弧长的曲线积分-第一类线积分" class="headerlink" title="对弧长的曲线积分(第一类线积分)"></a>对弧长的曲线积分(第一类线积分)</h3><h4 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被积函数f(x,y)就是线的密度，将弧微分，求每一段弧微分与密度的乘积之和=&gt;求得线的质量</span><br><span class="line"></span><br><span class="line">一类线积分是函数值乘弧长，弧长与曲线方向没有关系，所以与路径方向无关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161301817.png" alt="image.png"></p><hr><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><h5 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161337797.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面是公式推导</span><br></pre></td></tr></table></figure><p><strong>一般方程</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161330352.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161330136.png" alt="image.png"><br><strong>参数形式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161334783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161342105.png" alt="image.png"></p><p><strong>极坐标形式</strong></p><hr><h5 id="利用奇偶性-1"><a href="#利用奇偶性-1" class="headerlink" title="利用奇偶性"></a>利用奇偶性</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161343425.png" alt="image.png"></p><hr><h5 id="利用对称性"><a href="#利用对称性" class="headerlink" title="利用对称性"></a>利用对称性</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161343149.png" alt="image.png"></p><hr><h3 id="对坐标的线积分-第二类线积分"><a href="#对坐标的线积分-第二类线积分" class="headerlink" title="对坐标的线积分(第二类线积分)"></a>对坐标的线积分(第二类线积分)</h3><h4 id="定义与性质-1"><a href="#定义与性质-1" class="headerlink" title="定义与性质"></a>定义与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二类线积分，是对 位移x力 ,位移就是路径(曲线)上x方向位移 和y方向位移,位移是矢量有正有负，所以与路径方向有关</span><br><span class="line"></span><br><span class="line">分别对x、y方向的力求积分，分为两部分</span><br><span class="line"></span><br><span class="line">注意这里积分上下限，是看起点和终点，与x,y大小无关，只和是从哪个点开始，哪个点结束有关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161351198.png" alt="image.png"></p><hr><h4 id="计算方法-平面"><a href="#计算方法-平面" class="headerlink" title="计算方法(平面)"></a>计算方法(平面)</h4><h5 id="直接法-1"><a href="#直接法-1" class="headerlink" title="直接法"></a>直接法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于，要分别dx dy ，不统一，所以计算思路是转化为参数方程，将x,y写成关于t的函数，统一对t求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161358615.png" alt="image.png"></p><h5 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果曲线是封闭的，那么被积函数沿着边界曲线的“正向”--&gt;可以看成下面函数对曲线围成的积分域的二重积分</span><br><span class="line"></span><br><span class="line">&quot;正向&quot;是指，假如你沿着曲线的方向走，围成的区域始终在你的左边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161358973.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161359230.png" alt="image.png"></p><hr><h5 id="补线用格林公式"><a href="#补线用格林公式" class="headerlink" title="补线用格林公式"></a>补线用格林公式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当曲线没有围成一个封闭区域时，常常补充一条线，使其形成一个封闭区间，使用二重积分求解然后，减去这条补充线的曲线积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161420623.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161423198.png" alt="image.png"></p><hr><h5 id="利用线积分与路径无关"><a href="#利用线积分与路径无关" class="headerlink" title="利用线积分与路径无关"></a>利用线积分与路径无关</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.判定线积分是否与路径无关--&gt;∂P/∂y = ∂Q/∂x，则积分与路径无关</span><br><span class="line">2.计算：</span><br><span class="line">a.改换路劲</span><br><span class="line">b.利用原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161425310.png" alt="image.png"></p><hr><h4 id="两类积分的联系"><a href="#两类积分的联系" class="headerlink" title="两类积分的联系"></a>两类积分的联系</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161452946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161452430.png" alt="image.png"></p><hr><h4 id="计算方法-空间"><a href="#计算方法-空间" class="headerlink" title="计算方法(空间)"></a>计算方法(空间)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平面上有格林公式--&gt;将封闭线积分转化为内的平面积分</span><br><span class="line">空间上有斯托克公式--&gt;将封闭线积分，转化为以曲线为边界的曲面积分(只要求曲面/平面以线为边界)</span><br><span class="line"></span><br><span class="line">如何确定曲面的上下侧？</span><br><span class="line">以曲线方向，右手螺旋，大拇指朝向方向就是上侧，如果曲面的法向量与大拇指方向相同</span><br><span class="line">则该曲面是上侧，反之为下侧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161514735.png" alt="image.png"></p><hr><h3 id="常考题型-16"><a href="#常考题型-16" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="第一类曲线积分的计算"><a href="#第一类曲线积分的计算" class="headerlink" title="第一类曲线积分的计算"></a>第一类曲线积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.画出曲线，为一个下半圆</span><br><span class="line">2.被积函数x^2+y^2 沿着该曲线，则必然符合曲线的函数关系，--&gt;x^2+y^2=1</span><br><span class="line">3.被积函数=1，那么对曲线积分就=1*曲线长度=π</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161526216.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运用奇偶性做：</span><br><span class="line">1.画出积分曲线，为一个下半圆</span><br><span class="line">2.被积函数x是关于x轴的奇函数，沿着被积区域(曲线关于y轴对称)，所以积分=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161529192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这题奇偶性用不了，只能直接做</span><br><span class="line">怎么直接做，ds怎么做？</span><br><span class="line">1.换位参数方程x=cost，y=sint  (π&lt;=t&lt;=2π) ;</span><br><span class="line">2.利用参数方程公式，化为定积分计算</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161533073.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分曲线，为一个椭圆，是个对称图形</span><br><span class="line">2.被积函数中2xy是关于x轴的奇函数，所以该项为0</span><br><span class="line">3.剩下3x^2 + 4y^2 ,提出12，12(x^2/4 +y^2/3) ,沿着椭圆积分，有这样的函数关系，</span><br><span class="line">  x^2/4 +y^2/3 =1 , ==&gt; 等于12*  1*曲线长度= 12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161538228.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没办法利用奇偶性，因为积分曲线不对称,直接法计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161545522.png" alt="image.png"></p><hr><h4 id="第二类曲线积分"><a href="#第二类曲线积分" class="headerlink" title="第二类曲线积分"></a>第二类曲线积分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">1.判断是否是闭合曲线，不是</span><br><span class="line">2.接着判断是否与路径无关--&gt;∂P/∂y = ∂Q/∂x是否成立，不相等，与路径有关</span><br><span class="line">3.所以用直接法，先化为参数方程，然后计算</span><br><span class="line"></span><br><span class="line">方法2：补线法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161610103.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161623749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.分析曲线是否闭合，不闭合，不能直接格林公式</span><br><span class="line">2.看是否与路径有关，发现与路径有关</span><br><span class="line">3.补线法、直接求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161658463.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161658081.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看草稿</span><br><span class="line">常用结论∫(0-&gt;π) xf(sinx) dx = π/2∫(0-&gt;π) f(sinx) dx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742616.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742028.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742608.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">斯托克公式就是将一个封闭空间曲线转化为一个一该封闭曲线为边界的曲面或平面在xoz、xoy、yoz平面上的投影之和，注意的是投影方向要与曲线方向结合右手准则判定，方向一致才为正，否则为负，需要加负号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161815536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161815866.png" alt="image.png"></p><hr><h2 id="曲面积分"><a href="#曲面积分" class="headerlink" title="曲面积分"></a>曲面积分</h2><h3 id="对面积的面积分-第一类曲面积分"><a href="#对面积的面积分-第一类曲面积分" class="headerlink" title="对面积的面积分(第一类曲面积分)"></a>对面积的面积分(第一类曲面积分)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191544038.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191545364.png" alt="image.png"></p><hr><h3 id="对坐标的面积分-第二类面积分"><a href="#对坐标的面积分-第二类面积分" class="headerlink" title="对坐标的面积分(第二类面积分)"></a>对坐标的面积分(第二类面积分)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191546443.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191547169.png" alt="image.png"></p><hr><h3 id="常考题型-17"><a href="#常考题型-17" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="第一类曲面积分的计算"><a href="#第一类曲面积分的计算" class="headerlink" title="第一类曲面积分的计算"></a>第一类曲面积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用奇偶性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191549733.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191600468.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191608672.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191629733.png" alt="image.png"></p><hr><h4 id="第二类曲面积分的计算"><a href="#第二类曲面积分的计算" class="headerlink" title="第二类曲面积分的计算"></a>第二类曲面积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断曲面是否闭合，并且看曲面是外侧还是内侧</span><br><span class="line">2.外侧闭合，直接高斯公式，转化为对体积求三重积分</span><br><span class="line">3.由于这题使用球坐标比较方便，所以，考到了求坐标的转换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191632021.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191654285.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.曲面积分，并且是第二类曲面积分</span><br><span class="line">2.判断曲面是否闭合--&gt;闭合且都是外侧曲面，用高斯</span><br><span class="line">3.高斯公式，将题目转化为对球体的三重积分</span><br><span class="line">4.球坐标的转化</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191705256.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191704521.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断积分曲面是否闭合--&gt;不闭合--&gt;补面，用高斯</span><br><span class="line">2.减去补的面，注意，由于高斯公式对积分曲面都是外侧，所以补的面的外侧是下侧</span><br><span class="line">3.对下侧曲面的二类曲面积分，要注意方向是负的，要取负，所符号负负抵消了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191732579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191731078.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意看草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191818333.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191817551.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(二)</title>
      <link href="/undefined/3c47b44b.html"/>
      <url>/undefined/3c47b44b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107321.jpg" alt="ҹ· 小女孩 房屋 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="单链表的新建查找"><a href="#单链表的新建查找" class="headerlink" title="单链表的新建查找"></a>单链表的新建查找</h2><h3 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h3><p>链表的实现需要定义结点的结构体类型，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后需要创建一个头指针，用于指向链表的第一个结点，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 创建一个空链表</span></span><br></pre></td></tr></table></figure><p>接下来，可以通过动态分配内存的方式，创建新的结点，并将它们链接起来，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 创建一个新结点</span></span><br><span class="line">p-&gt;data = <span class="number">10</span>; <span class="comment">// 给数据域赋值</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 给指针域赋值</span></span><br><span class="line">head = p; <span class="comment">// 将头指针指向新结点</span></span><br></pre></td></tr></table></figure><p>这样就实现了一个只有一个结点的链表。如果要添加更多的结点，可以重复上述过程，并将新结点的地址赋给前一个结点的指针域，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 创建另一个新结点</span></span><br><span class="line">q-&gt;data = <span class="number">20</span>; <span class="comment">// 给数据域赋值</span></span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 给指针域赋值</span></span><br><span class="line">p-&gt;next = q; <span class="comment">// 将前一个结点的指针域指向新结点</span></span><br></pre></td></tr></table></figure><h3 id="链表的删除-插入-查找"><a href="#链表的删除-插入-查找" class="headerlink" title="链表的删除-插入-查找"></a>链表的删除-插入-查找</h3><p>例如，如果要删除链表中的第三个结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> head; <span class="comment">// temp 指向头结点</span></span><br><span class="line">temp = temp-&gt;next; <span class="comment">// temp 指向第二个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">del</span> =</span> temp-&gt;next; <span class="comment">// del 指向要删除的第三个结点</span></span><br><span class="line">temp-&gt;next = del-&gt;next; <span class="comment">// 将第二个结点的指针域指向第四个结点</span></span><br><span class="line"><span class="built_in">free</span>(del); <span class="comment">// 释放第三个结点的内存空间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如，如果要在链表中的第三个结点后插入一个新的结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">new</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 申请一个新的结点</span></span><br><span class="line">new-&gt;data = x; <span class="comment">// 将要插入的数据赋值给新结点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> head; <span class="comment">// temp 指向头结点</span></span><br><span class="line">temp = temp-&gt;next-&gt;next; <span class="comment">// temp 指向第三个结点</span></span><br><span class="line">new-&gt;next = temp-&gt;next; <span class="comment">// 将新结点的指针域指向第四个结点</span></span><br><span class="line">temp-&gt;next = new; <span class="comment">// 将第三个结点的指针域指向新结点</span></span><br></pre></td></tr></table></figure><p>例如，如果要在链表中查找第一个值为 x 的结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> head-&gt;next; <span class="comment">// p 指向首元结点</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// i 记录当前结点的位置</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == x) &#123; <span class="comment">// 如果找到值为 x 的结点</span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next; <span class="comment">// p 指向下一个结点</span></span><br><span class="line">    i++; <span class="comment">// i 加一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果遍历到尾部，仍未找到，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现顺序表-插入-删除"><a href="#实现顺序表-插入-删除" class="headerlink" title="实现顺序表 插入 删除"></a>实现顺序表 插入 删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">&#125;SqList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入到第二个的函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Put_arry</span><span class="params">(SqList &amp;L,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i = L.data[<span class="number">1</span>];  </span><br><span class="line">    <span class="type">int</span> j;  </span><br><span class="line">    <span class="keyword">for</span>(j=L.length;j&gt;<span class="number">1</span>;j--)&#123;  </span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.data[<span class="number">1</span>]=e;  </span><br><span class="line">    L.length++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印顺序表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(SqList L)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>,L.data[i]);<span class="comment">//&quot;%3表示打印的数字占3个空格  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//删除元素方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delet_arry</span><span class="params">(SqList &amp;L,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=e;i&lt;L.length;i++)&#123;  </span><br><span class="line">        L.data[i<span class="number">-1</span>]=L.data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.length--;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqList L;  </span><br><span class="line">    L.data[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    L.data[<span class="number">1</span>]=<span class="number">2</span>;  </span><br><span class="line">    L.data[<span class="number">2</span>]=<span class="number">3</span>;  </span><br><span class="line">    L.length=<span class="number">3</span>;  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);  </span><br><span class="line">    Put_arry(L,e);  </span><br><span class="line">    print_arr(L);  </span><br><span class="line">  </span><br><span class="line">    ElemType del;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;del);  </span><br><span class="line">    Delet_arry(L,del);  </span><br><span class="line">    print_arr(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插法新建链表"><a href="#头插法新建链表" class="headerlink" title="头插法新建链表"></a>头插法新建链表</h3><p>这段代码，实现头插法新建一个链表，每次新建一个结点，都是放到第一个结点（注意头结点不是第一个结点，头结点指向第一个结点），该链表存储int类型数据，通过scanf输入建立对应的存储结点，直到输入9999,结束创建，并且不会包含9999</p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032033156.png" alt="Snipaste_2023-03-07_17-01-14.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032032806.png" alt="Snipaste_2023-03-07_17-07-51.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法新建链表</span></span><br><span class="line"><span class="comment">//定义一个方法，申请头结点的空间  </span></span><br><span class="line"><span class="comment">//LNode*是结构体指针，与LinkList是完全等价的  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_head_insert</span><span class="params">(LNode* &amp;L)</span>&#123;  </span><br><span class="line">    L= (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//给L申请一个头结点结点空间  </span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;<span class="comment">//读取的第一个元素  </span></span><br><span class="line">    LinkList s;<span class="comment">//用来指向新节点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));<span class="comment">//给s申请一个新的空间  </span></span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//实现头插法，s成为第一个结点  </span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//L作为头结点，任然指向第一个结点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//读取x的值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_head_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法新建链表"><a href="#尾插法新建链表" class="headerlink" title="尾插法新建链表"></a>尾插法新建链表</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032042218.png" alt="Snipaste_2023-03-07_17-20-00.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点 ,将L赋给s,r ,相当于s,r,L都是头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  <span class="comment">//将s赋给r,r重新指向尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-按值查找-按位置查找"><a href="#链表-按值查找-按位置查找" class="headerlink" title="链表-按值查找-按位置查找"></a>链表-按值查找-按位置查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按值查找  </span></span><br><span class="line">LinkList <span class="title function_">GetEle_by_value</span><span class="params">(LinkList L,<span class="type">int</span> value)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(L)&#123;<span class="comment">//表示L不为空，循环  </span></span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data!=value)&#123;  </span><br><span class="line">            L=L-&gt;next;  </span><br><span class="line">        &#125;<span class="keyword">if</span>(L-&gt;data==value)&#123;  </span><br><span class="line">            <span class="keyword">return</span> L;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">  </span><br><span class="line">    LinkList pNode1 = GetEle_by_pos(L,<span class="number">3</span>);  </span><br><span class="line">    <span class="keyword">if</span>(pNode1!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nsearch by postion success\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the value is %d\n&quot;</span>,pNode1-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    LinkList pNode2 = GetEle_by_value(L, <span class="number">8</span>);  </span><br><span class="line">    <span class="keyword">if</span>(pNode2!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search by value success\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the value is %d\n&quot;</span>,pNode2-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-往第i-个位置插入元素"><a href="#链表-往第i-个位置插入元素" class="headerlink" title="链表 往第i 个位置插入元素"></a>链表 往第i 个位置插入元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入方法，往第i个位置插入元素  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListFrontInsert</span><span class="params">(LinkList L,<span class="type">int</span> i,<span class="type">int</span> insert)</span>&#123;  </span><br><span class="line">    <span class="comment">//先找到链表第i-1个位置，并指向  </span></span><br><span class="line">    LinkList p = GetEle_by_pos(L, i<span class="number">-1</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//定义一个新的结点  </span></span><br><span class="line">    LinkList q;  </span><br><span class="line">    q = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    q-&gt;next=p-&gt;next;  </span><br><span class="line">    q-&gt;data=insert;  </span><br><span class="line">    p-&gt;next=q;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line"></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    ListFrontInsert(L,<span class="number">2</span>,<span class="number">80</span>);  <span class="comment">//往第二个位置，插入80</span></span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><h3 id="单链表删除实战"><a href="#单链表删除实战" class="headerlink" title="单链表删除实战"></a>单链表删除实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032047101.png" alt="Snipaste_2023-03-08_22-06-07.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032048552.png" alt="Snipaste_2023-03-08_22-03-33.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line">LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="comment">//说明：L头结点的位置是0  </span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//单链表的删除方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_list</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  <span class="comment">//删除时，L是不会变得，所以不需要加引用</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">        LinkList p = GetEle_by_pos(L,pos - <span class="number">1</span>); <span class="comment">//拿到哟啊删除结点的前一个结点指针</span></span><br><span class="line">        LinkList q=p-&gt;next;  <span class="comment">//拿到要删除的结点指针</span></span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            p-&gt;next=q-&gt;next;  </span><br><span class="line">            <span class="built_in">free</span>(q);  <span class="comment">//释放被删除元素的空间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    delet_list(L,<span class="number">2</span>);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题，链表转置实战"><a href="#真题，链表转置实战" class="headerlink" title="真题，链表转置实战"></a>真题，链表转置实战</h3><p>转置图示<img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041933031.png" alt="image.png"></p><p>合并图解<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041933379.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//找中心结点  </span></span><br><span class="line"><span class="comment">//当链表奇数个结点取中间，偶数个结点取前一个  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_middle</span><span class="params">(LinkList L,LinkList &amp;L2)</span>&#123;<span class="comment">//L表示第一条链表头结点，L2表示第二条链表头结点  </span></span><br><span class="line">    L2=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    LinkList p,pp;<span class="comment">//双指针  </span></span><br><span class="line">    p=pp=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(pp)&#123;  </span><br><span class="line">        pp=pp-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)&#123;<span class="comment">//必须判断每一步是否为空，防止崩溃  </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        pp=pp-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    L2-&gt;next=p-&gt;next;  </span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//链表最后一个结点next要为空  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//找中心结点，while循环次数是n/2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//逆置方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(LinkList L2)</span>&#123;<span class="comment">//逆转是不改变头指针的  </span></span><br><span class="line">    LinkList r,s,t;  </span><br><span class="line">    r=L2-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)&#123;<span class="comment">//没有结点  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    s=r-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;<span class="comment">//一个结点  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    t=s-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(t)&#123;  </span><br><span class="line">        s-&gt;next=r;<span class="comment">//逆转  </span></span><br><span class="line">        r=s;  </span><br><span class="line">        s=t;  </span><br><span class="line">        t=t-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;next=r;  </span><br><span class="line">    L2-&gt;next-&gt;next=<span class="literal">NULL</span>;<span class="comment">//逆置后原链表第一个结点，变成最后一个结点，它的next=NULL;  </span></span><br><span class="line">    L2-&gt;next=s;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//逆转函数逆转的是L2链表，执行次数是n/2,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//合并方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LinkList L,LinkList L2)</span>&#123;  </span><br><span class="line">    LinkList pcur,p,q;  </span><br><span class="line">    pcur=L-&gt;next;  </span><br><span class="line">    p=pcur-&gt;next;  </span><br><span class="line">    q=L2-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        pcur-&gt;next=q;  </span><br><span class="line">        q=q-&gt;next;  </span><br><span class="line">        pcur=pcur-&gt;next;  </span><br><span class="line">        pcur-&gt;next=p;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        pcur=pcur-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//上面merge函数的while循环遍历次数是n/2,所以时间复杂度是O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;  </span><br><span class="line">    LinkList L2;  </span><br><span class="line">  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">  </span><br><span class="line">    find_middle(L,L2);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    print_LinKlist(L2);  </span><br><span class="line">  </span><br><span class="line">    reverse(L2);  </span><br><span class="line">    print_LinKlist(L2);  </span><br><span class="line">  </span><br><span class="line">    merge(L,L2);  </span><br><span class="line">    <span class="built_in">free</span>(L2);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"><span class="comment">//综上，merge、find_middle、reverse函数总的时间复杂度是1.5n,忽略首项系数O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ测试"><a href="#OJ测试" class="headerlink" title="OJ测试"></a>OJ测试</h3><p>作业说明<img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032107529.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LNOde,*Linklist;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(Linklist &amp;L)</span>&#123;  </span><br><span class="line">    L=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    Linklist s,r=L;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找的方法  </span></span><br><span class="line">Linklist <span class="title function_">getEle_by_pos</span><span class="params">(Linklist L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123; <span class="comment">//注意：while(i&lt;pos)&#123;&#125; 忽略了L为空 也不能循环 </span></span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置插入的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert</span><span class="params">(Linklist L,<span class="type">int</span> i,<span class="type">int</span> insert)</span>&#123;  </span><br><span class="line">    Linklist p = getEle_by_pos(L,i - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Linklist s;  </span><br><span class="line">  </span><br><span class="line">    s=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    s-&gt;next=p-&gt;next;  </span><br><span class="line">    s-&gt;data=insert;  </span><br><span class="line">    p-&gt;next=s;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_list</span><span class="params">(Linklist L)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(L)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    Linklist L;  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_list(L);  </span><br><span class="line">    list_insert(L,<span class="number">2</span>,<span class="number">99</span>);  </span><br><span class="line">    print_list(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="栈原理解析"><a href="#栈原理解析" class="headerlink" title="栈原理解析"></a>栈原理解析</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042113354.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042114958.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体(栈)</span></span><br><span class="line">typrdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Elemtype data[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时栈为空</span></span><br><span class="line">S.top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="comment">//前加加，先获取栈位置，在加元素</span></span><br><span class="line"><span class="comment">//S.top=S.top+1;</span></span><br><span class="line"><span class="comment">//S.data[S.top]=4;</span></span><br><span class="line">S.data[++S.top]</span><br><span class="line"></span><br><span class="line"><span class="comment">//前加加--&gt;先做加1，后做其他运算；</span></span><br><span class="line"><span class="comment">//后加加--&gt;先做其他运算，在做加1；</span></span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042114934.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="comment">//后减减，先拿到取出的元素</span></span><br><span class="line"><span class="comment">//x=S.data[S.top];</span></span><br><span class="line"><span class="comment">//S.top=S.top-1;</span></span><br><span class="line">x=S.data[S.top--]</span><br></pre></td></tr></table></figure></p><h3 id="初始化栈-入栈-出栈"><a href="#初始化栈-入栈-出栈" class="headerlink" title="初始化栈-入栈-出栈"></a>初始化栈-入栈-出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义栈结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ElemType data[Maxsize];<span class="comment">//栈空间  </span></span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//栈针  </span></span><br><span class="line">&#125;SqStack;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化栈方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(SqStack &amp;S)</span>&#123;  </span><br><span class="line">    S.top=<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//压栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==Maxsize<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//S.data[S.top++]=e; //先赋值，然后+</span></span><br><span class="line">    S.data[++S.top]=e;  <span class="comment">//先+，然后赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印栈的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_satck</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.top+<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,S.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断栈是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//弹栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=S.data[S.top--];<span class="comment">//拿完栈顶元素后，弹栈  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqStack S;  </span><br><span class="line">    innit(S);  </span><br><span class="line">      </span><br><span class="line">    Push(S,<span class="number">79</span>);  </span><br><span class="line">    Push(S,<span class="number">2</span>);  </span><br><span class="line">    Push(S,<span class="number">3</span>);  </span><br><span class="line">    print_satck(S);  </span><br><span class="line">  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    <span class="type">bool</span> flag;  </span><br><span class="line">    flag=Pop(S,e);  </span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">        print_satck(S);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列循环队列原理解析"><a href="#队列循环队列原理解析" class="headerlink" title="队列循环队列原理解析"></a>队列循环队列原理解析</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042117893.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">队列实现有两种常见方式：数组、链表</span><br><span class="line"></span><br><span class="line">特点：允许头部删除，尾部增加</span><br></pre></td></tr></table></figure><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">循环队列实现是通过数组的方式</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119873.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042144375.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119533.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119792.png" alt="image.png"></p><h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链式队列的实现通过链表</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042121691.png" alt="image.png"></p><h3 id="循环队列数组实现"><a href="#循环队列数组实现" class="headerlink" title="循环队列数组实现"></a>循环队列数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//循环队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ElemType data[Maxsize];<span class="comment">//数组，存储Maxsize-1个元素  </span></span><br><span class="line">    <span class="type">int</span> front,rear;<span class="comment">//队列头，队列尾  </span></span><br><span class="line">&#125;SqQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Innit</span><span class="params">(SqQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%Maxsize==Q.front)&#123;<span class="comment">//判断队列是否满了  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Q.data[Q.rear]=e;<span class="comment">//放入元素  </span></span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%Maxsize;<span class="comment">//改变队尾标记  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    x=Q.data[Q.front];<span class="comment">//拿到删除的元素  </span></span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%Maxsize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(SqQueue Q)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=Q.front;i&lt;Q.rear;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Q.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqQueue Q;  </span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    ElemType e; </span><br><span class="line">    </span><br><span class="line">    Innit(Q);  </span><br><span class="line">    EnQueue(Q,<span class="number">29</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">39</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">9</span>);  </span><br><span class="line">    print_queue(Q);  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    flag=OutQueue(Q,e); </span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop success ,the pop value is %d\n&quot;</span>,e);</span><br><span class="line">    &#125; </span><br><span class="line">    print_queue(Q);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042122600.png" alt="image.png"></p><h3 id="队列链表实现-1"><a href="#队列链表实现-1" class="headerlink" title="队列链表实现-1"></a>队列链表实现-1</h3><p>这是 带有头结点 的方式实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般队列的头结点是否有数据取决于队列的实现方式：</span><br><span class="line"></span><br><span class="line">-   如果队列是用数组实现的，那么头结点就是数组的第一个元素，它有数据；</span><br><span class="line">-   如果队列是用链表实现的，那么头结点可以是一个空结点，也可以是链表的第一个元素，这取决于是否使用带头结点的链表。如果使用带头结点的链表，那么头结点没有数据，只是一个指针；如果使用不带头结点的链表，那么头结点就是链表的第一个元素，它有数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemype;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>  </span><br><span class="line">    Elemype data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LinkNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    LinkList front,rear;<span class="comment">//链表头，链表尾  </span></span><br><span class="line">&#125;LinkQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//这是一种带头结点的实现方式</span></span><br><span class="line">    Q.rear-&gt;next</span><br><span class="line">    =<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数,尾部插入法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,Elemype x)</span>&#123;  </span><br><span class="line">    LinkList s;  </span><br><span class="line">    s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    s-&gt;data=x;  </span><br><span class="line">    Q.rear-&gt;next=s;  </span><br><span class="line">    Q.rear=s;<span class="comment">//注意这一步容易漏掉  </span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//判断一个元素也没有  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LinkList s=Q.front-&gt;next;  </span><br><span class="line">    Q.front-&gt;next=s-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==s)&#123;<span class="comment">//判断删除的是最后一个元素  </span></span><br><span class="line">        Q.rear=Q.front;<span class="comment">//队列为空  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkQueue Q;  </span><br><span class="line">    innit(Q);  </span><br><span class="line">  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">bool</span> ret;  </span><br><span class="line">    ret= OutQueue(Q);  </span><br><span class="line">    <span class="keyword">if</span>(ret)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pop success&quot;</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pop fail&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列链表的实现-2"><a href="#队列链表的实现-2" class="headerlink" title="队列链表的实现-2"></a>队列链表的实现-2</h3><ul><li>带头结点的队列，队列的头指针和尾指针都指向一个空的头结点，头结点的next指针指向第一个元素，尾结点的next指针为NULL。</li><li></li><li>不带头结点的队列，队列的头指针指向第一个元素，尾指针指向最后一个元素，尾结点的<br>不带头结点</li></ul><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042149365.png" alt="image.png"></p><p>不带头结点的链表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现不带头结点的链式队列*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> Status;</span><br><span class="line"><span class="comment">/*0.定义链式队列的基本结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">/*1.初始化链式队列 (不带头结点)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;<span class="comment">//初始时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.判断队列是为空（不带头结点）*/</span></span><br><span class="line">Status <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.入队 (不带头结点)*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>) <span class="comment">//在空的队列中插入第一元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">        Q.front = s; <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s; <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">        Q.rear = s; <span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*4.出队（不带头结点）*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue&amp; Q, ElemType&amp; x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//空队</span></span><br><span class="line">    LinkNode* p = Q.front; <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data; <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next; <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q.front = <span class="literal">NULL</span>; <span class="comment">//front指向NULL</span></span><br><span class="line">        Q.rear = <span class="literal">NULL</span>; <span class="comment">//rear指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    ElemType x = <span class="number">-1</span>;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q, <span class="number">3</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">6</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">8</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">9</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">7</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        DeQueue(Q, x);</span><br></pre></td></tr></table></figure></p><h3 id="OJ测试-1"><a href="#OJ测试-1" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042124302.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 5  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义一个栈结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> top;  </span><br><span class="line">&#125;SqStack;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义一个循环队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> front,rear;<span class="comment">//队列头，队列尾  </span></span><br><span class="line">&#125;SqQueue;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化栈方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(SqStack &amp;S)</span>&#123;  </span><br><span class="line">    S.top=<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    S.data[++S.top]=e;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=S.data[S.top--];  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印栈的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_stack</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;S.top+<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,S.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)&#123;<span class="comment">//判断队列是否满  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Q.data[Q.rear]=e;  </span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=Q.data[Q.front];  </span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(SqQueue Q)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=Q.front;i&lt;Q.rear;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Q.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqStack S;  </span><br><span class="line">    initStack(S);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i,num;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);  </span><br><span class="line">        Push(S,num);  </span><br><span class="line">    &#125;  </span><br><span class="line">    print_stack(S);  </span><br><span class="line">  </span><br><span class="line">    ElemType m;<span class="comment">//用来存放拿出来的元素  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">        Pop(S,m);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ride num is %d\n&quot;</span>,m);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    SqQueue Q;  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    initQueue(Q);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i2,num2;  </span><br><span class="line">    <span class="type">bool</span> flag;  </span><br><span class="line">    <span class="keyword">for</span>(i2=<span class="number">0</span>;i2&lt;<span class="number">5</span>;i2++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num2);  </span><br><span class="line">        flag=EnQueue(Q,num2);  </span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;flase Queue is full\n&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i2=<span class="number">0</span>;i2&lt;<span class="number">4</span>;i2++)&#123;  </span><br><span class="line">        OutQueue(Q,e);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,e);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的建树和遍历"><a href="#二叉树的建树和遍历" class="headerlink" title="二叉树的建树和遍历"></a>二叉树的建树和遍历</h2><h3 id="树与二叉树原理解析"><a href="#树与二叉树原理解析" class="headerlink" title="树与二叉树原理解析"></a>树与二叉树原理解析</h3><h4 id="树原理解析"><a href="#树原理解析" class="headerlink" title="树原理解析"></a>树原理解析</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042158536.png" alt="image.png"></p><h4 id="二叉树原理"><a href="#二叉树原理" class="headerlink" title="二叉树原理"></a>二叉树原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、满二叉树:每一层都放满了</span><br><span class="line"></span><br><span class="line">2、完全二叉树:除了最后一层，前面层数全部放满，最后一层从左往右，只能是右侧有空</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042159720.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042200909.png" alt="image.png"></p><h3 id="二叉树的层次建树"><a href="#二叉树的层次建树" class="headerlink" title="二叉树的层次建树"></a>二叉树的层次建树</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201927.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面层次建树的实现通过辅助队列实现</span><br><span class="line">每加一个元素，辅助队列就往队尾加一个元素</span><br><span class="line">而pcur指针判断结点的左右两侧都放满了时，才往后移动</span><br><span class="line">这样就实现了层次建树</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201587.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下代码实现了，输入abcdefgj一串连续字符，然后按层次建树存储</span><br><span class="line"></span><br><span class="line">这里的辅助队列有四个指针：front-rear-listpnew-pcur 起初都赋值为NULL,就是没有头结点得方式创建队列</span><br><span class="line"></span><br><span class="line">front指向第一个结点</span><br><span class="line">rear指向末尾结点</span><br><span class="line">listpnew指向新加元素</span><br><span class="line">pcur指向当前结点</span><br><span class="line"></span><br><span class="line">这里的二叉树有一个指针:pnew指向树的最新结点</span><br></pre></td></tr></table></figure><p>头文件  function.h 代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure></p><p>主文件 main.cpp 代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//赋值为NULL用于下面的if判断  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//但是二叉树没有头结点</span></span><br><span class="line">    <span class="comment">//第一个结点就是树根，用来存数据 </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur=<span class="literal">NULL</span>;<span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        <span class="comment">//if无论是否满足条件都会向下执行，else if只有在上一个条件不满足的情况下才会执行</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的-前中后-序遍历"><a href="#二叉树的-前中后-序遍历" class="headerlink" title="二叉树的-前中后-序遍历"></a>二叉树的-前中后-序遍历</h3><p>递归思想</p><pre><code>1前序遍历:PreOrder     前序遍历也叫深度优先遍历2中序遍历：InOrder3后序遍历：PostOrder</code></pre><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure></p><p>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历，先序遍历，也叫深度优先遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        PreOrder(p-&gt;lift);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(p-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        InOrder(p-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//后序遍历  </span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">PostOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        PostOrder(p-&gt;lift);  </span><br><span class="line">        PostOrder(p-&gt;right);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//用来指向树根  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    InOrder(root);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>也称广度优先遍历<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[二叉树的广度优先遍历是一种按层次遍历二叉树的方法，它的顺序是从上到下，从左到右，依次访问每一层的节点][。广度优先遍历的原则就是对每一层的节点依次访问，一层访问结束后，进入下一层，直到最后一个节点，每个节点都只访问一次]</span><br><span class="line">[二叉树的广度优先遍历的实现需要借助队列（Queue）这种数据结构，它的特点是先进先出。首先将根节点入队，然后循环执行以下操作，直到队列为空：从队列中取出一个节点，访问它，然后将它的左右子节点（如果有的话）入队]。</span><br><span class="line"></span><br><span class="line">例如，对于下图的二叉树，广度优先遍历的结果是 &#123;1，2，3，4，5，6，7，8，9，10&#125;，遍历过程如下：</span><br><span class="line"></span><br><span class="line">1.  将根节点1入队，队列为【1】</span><br><span class="line">2.  取出节点1，访问它，将它的左右子节点2和3入队，队列为【2，3】</span><br><span class="line">3.  取出节点2，访问它，将它的左右子节点4和5入队，队列为【3，4，5】</span><br><span class="line">4.  取出节点3，访问它，将它的右子节点6入队，队列为【4，5，6】</span><br><span class="line">5.  取出节点4，访问它，将它的左右子节点8和9入队，队列为【5，6，8，9】</span><br><span class="line">6.  取出节点5，访问它，将它的右子节点10入队，队列为【6，8，9，10】</span><br><span class="line">7.  取出节点6，访问它，没有子节点，队列为【8，9，10】</span><br><span class="line">8.  取出节点8，访问它，没有子节点，队列为【9，10】</span><br><span class="line">9.  取出节点9，访问它，没有子节点，队列为【10】</span><br><span class="line">10.  取出节点10，访问它，没有子节点，队列为空，遍历结束</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042208835.png" alt="image.png"></p><p>代码采用3给文件</p><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by 123 on 2023/3/11.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INC_1_TREE_FUNCTION_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INC_1_TREE_FUNCTION_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//树相关结构  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BiElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  </span><br><span class="line">    BiElemType c;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次建树的辅助队列  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次遍历的辅助队列相关结构  </span></span><br><span class="line"><span class="keyword">typedef</span> BiTree ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LinkNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    LinkList front,rear;<span class="comment">//链表头，链表尾  </span></span><br><span class="line">&#125;LinkQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>;  </span><br><span class="line"><span class="comment">//入队  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>;  </span><br><span class="line"><span class="comment">//出队  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>;  </span><br><span class="line"><span class="comment">//判断是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//INC_1_TREE_FUNCTION_H</span></span></span><br></pre></td></tr></table></figure></p><p>Queue.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by 123 on 2023/3/11.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line"><span class="comment">//初始化链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    Q.rear-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数,尾部插入法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;  </span><br><span class="line">    LinkList s;  </span><br><span class="line">    s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    s-&gt;data=x;  </span><br><span class="line">    Q.rear-&gt;next=s;  </span><br><span class="line">    Q.rear=s;<span class="comment">//注意这一步容易漏掉  </span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//判断一个元素也没有  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LinkList s=Q.front-&gt;next;  </span><br><span class="line">    x=s-&gt;data;  </span><br><span class="line">    Q.front-&gt;next=s-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==s)&#123;<span class="comment">//判断删除的是最后一个元素  </span></span><br><span class="line">        Q.rear=Q.front;<span class="comment">//队列为空  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历，先序遍历，也叫深度优先遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        PreOrder(p-&gt;lift);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(p-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        InOrder(p-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//后序遍历  </span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">PostOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        PostOrder(p-&gt;lift);  </span><br><span class="line">        PostOrder(p-&gt;right);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次遍历（广度优先遍历）  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="comment">//辅助队列  </span></span><br><span class="line">    LinkQueue Q;  </span><br><span class="line">    <span class="comment">//初始化队列  </span></span><br><span class="line">    innit(Q);  </span><br><span class="line">    BiTree p;<span class="comment">//获取出队元素  </span></span><br><span class="line">    <span class="comment">//树根入队  </span></span><br><span class="line">    EnQueue(Q,T);  </span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;  </span><br><span class="line">        <span class="comment">//出队列的同时，判断出去的这个元素，左右子树是否存在，存在就入队  </span></span><br><span class="line">        <span class="comment">//循环这个过程，直到队列为空  </span></span><br><span class="line">        OutQueue(Q,p);<span class="comment">//出队函数，能获得出队元素，切将出队元素赋值给p  </span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;c);  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lift!=<span class="literal">NULL</span>)&#123;<span class="comment">//入队左子树  </span></span><br><span class="line">            EnQueue(Q,p-&gt;lift);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)&#123;<span class="comment">//入队右子树  </span></span><br><span class="line">            EnQueue(Q,p-&gt;right);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//首先层次建树</span></span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//用来指向树根  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向队列的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);   <span class="comment">//前序遍历（深度优先遍历）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    InOrder(root);    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);   <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    LevelOrder(root);  <span class="comment">//广度优先遍历</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="真题-求带权路径长度"><a href="#真题-求带权路径长度" class="headerlink" title="真题-求带权路径长度"></a>真题-求带权路径长度</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042210307.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于与深度有关，可采用深度优先遍历方式(可以获取深度)，最后返回wpl</span><br></pre></td></tr></table></figure><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树的链表结点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure><br>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//int wpl=0;  </span></span><br><span class="line"><span class="comment">//全局变量，和静态局部变量都是放在数据段  </span></span><br><span class="line"><span class="comment">//静态局部变量只能局部访问，全局变量全局访问  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历,参数增加一个深度deep  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p,<span class="type">int</span> deep)</span>&#123;  </span><br><span class="line">    <span class="comment">//静态变量，只会初始化一次，递归的时候不会再次执行，直接访问  </span></span><br><span class="line">    <span class="comment">//只能局部访问，所以将其以返回值的形式返回  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lift==<span class="literal">NULL</span>&amp;&amp;p-&gt;right==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            wpl+=p-&gt;c*deep;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ele%c---deep%d\n&quot;</span>, p-&gt;c,deep);  </span><br><span class="line">        PreOrder(p-&gt;lift,deep+<span class="number">1</span>);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right,deep+<span class="number">1</span>);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> wpl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//这里赋值NULL用于下面的判断  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wpl=%d&quot;</span>,PreOrder(root,<span class="number">0</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OJ测试-2"><a href="#OJ测试-2" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042211919.png" alt="image.png"></p><p>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;  </span><br><span class="line"><span class="comment">//二叉树结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;TNode,*BiTree;  </span><br><span class="line"><span class="comment">//辅助队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span>  </span><br><span class="line">    BiTree p;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;QNode,*Queue;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);  </span><br><span class="line">        PreOreder(T-&gt;lift);  </span><br><span class="line">        PreOreder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ElemType c;  </span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;  </span><br><span class="line">    BiTree pnew;  </span><br><span class="line">  </span><br><span class="line">    Queue front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (TNode));  </span><br><span class="line">        pnew-&gt;data=c;  </span><br><span class="line">        listpnew=(Queue) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(QNode));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;  </span><br><span class="line">            front=rear=pcur=listpnew;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;next=listpnew;  </span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                pcur=pcur-&gt;next;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    PreOreder(root);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="顺序表查找原理及实战"><a href="#顺序表查找原理及实战" class="headerlink" title="顺序表查找原理及实战"></a>顺序表查找原理及实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ELemType* elem;<span class="comment">//整数型指针，申请的对空间起始地址存入elem  </span></span><br><span class="line">    <span class="type">int</span> TableLen;<span class="comment">//存储动态数组里边元素的个数  </span></span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_init</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    <span class="comment">//多申请一个位置，是为了存哨兵的，不用哨兵也可以的  </span></span><br><span class="line">    ST.TableLen=len+<span class="number">1</span>;  </span><br><span class="line">    ST.elem= (ELemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ELemType)*ST.TableLen);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//随机数生成  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;ST.TableLen;i++)&#123;<span class="comment">//因为第0个放的位置是哨兵，所以从1开始随机  </span></span><br><span class="line">        ST.elem[i]=rand() % <span class="number">100</span>;<span class="comment">//生成1-99之间的随机数  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">st_print</span><span class="params">(SSTable ST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;ST.TableLen;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ST.elem[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ELemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen<span class="number">-1</span>;ST.elem[i]!=e;--i)&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> i;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable ST;  </span><br><span class="line">    st_init(ST,<span class="number">9</span>);  </span><br><span class="line">    st_print(ST);  </span><br><span class="line">    ELemType key;  </span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input search by\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);  </span><br><span class="line">    pos=Search_Seq(ST,key);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the postion is %d&quot;</span>,pos);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找原理及实战"><a href="#二分查找原理及实战" class="headerlink" title="二分查找原理及实战"></a>二分查找原理及实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ELemType* elem;  </span><br><span class="line">    <span class="type">int</span> Tablelen;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_init</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    ST.Tablelen=len;  </span><br><span class="line">    ST.elem=(ELemType*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ELemType)*ST.Tablelen);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.Tablelen;i++)&#123;  </span><br><span class="line">        ST.elem[i]=rand() % <span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_print</span><span class="params">(SSTable ST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.Tablelen;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ST.elem[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二分查找方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(SSTable ST,<span class="type">int</span> key)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> mid;  </span><br><span class="line">    <span class="type">int</span> end=ST.Tablelen<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;  </span><br><span class="line">        mid=(begin+end)/<span class="number">2</span>;  </span><br><span class="line">        <span class="comment">//注意：是else if 不能写成if，并且三个判断只能执行一个  </span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid])&#123;  </span><br><span class="line">            end=mid<span class="number">-1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid])&#123;  </span><br><span class="line">            begin=mid+<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//函数名中存储的是函数入口地址，也是一个指针，是函数指针类型  </span></span><br><span class="line"><span class="comment">//qsort规定如果left指针指向的值，大于right指针指向的值,返回正值  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *left,<span class="type">const</span> <span class="type">void</span> *right)</span>&#123;<span class="comment">//固定形式，照着写就行  </span></span><br><span class="line">    <span class="comment">//要先强转成int类型指针然后取值 比较  </span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)left-*(<span class="type">int</span>*)right;<span class="comment">//从小到大排序  </span></span><br><span class="line">    <span class="comment">//return *(int*)right-*(int*)left;//从小到大排序  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable ST;  </span><br><span class="line">    <span class="type">int</span> key;  </span><br><span class="line">    st_init(ST,<span class="number">10</span>);<span class="comment">//初始化  </span></span><br><span class="line">    st_print(ST);<span class="comment">//打印  </span></span><br><span class="line">    qsort(ST.elem,ST.Tablelen,<span class="keyword">sizeof</span> (ELemType),compare);<span class="comment">//升序排序  </span></span><br><span class="line">    st_print(ST);<span class="comment">//打印  </span></span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the number that you want to search\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);  </span><br><span class="line">    pos=binary_search(ST,key);  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false,the number is not exit&quot;</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the pos is %3d&quot;</span>,pos);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树原理及建树"><a href="#二叉排序树原理及建树" class="headerlink" title="二叉排序树原理及建树"></a>二叉排序树原理及建树</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041946000.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BSNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树元素插入  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(BiTree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T= (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    BiTree p=T;<span class="comment">//p是用来遍历的  </span></span><br><span class="line">    BiTree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;<span class="comment">//指向p的父节点，以便追加加点  </span></span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;lift;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//开始申请新节点的空间  </span></span><br><span class="line">    BiTree pnew;  </span><br><span class="line">    pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="comment">//判断是加在parent结点的左子节点还是右子节点  </span></span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;lift=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;right=pnew;  </span><br><span class="line">    &#125;<span class="comment">//不用判断等于的情况，因为上面遍历树的时候当结点值相等时，该方法就结束了  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建二叉树  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_bstree</span><span class="params">(BiTree &amp;T,ElemType str[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    T=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        BST_insert(T,str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(T-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, T-&gt;key);  </span><br><span class="line">        InOrder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree T;  </span><br><span class="line">    ElemType str[<span class="number">9</span>]=&#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>&#125;;  </span><br><span class="line">    creat_bstree(T,str,<span class="number">9</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的删除实战"><a href="#二叉查找树的删除实战" class="headerlink" title="二叉查找树的删除实战"></a>二叉查找树的删除实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">left</span>,*<span class="title">righr</span>;</span>  </span><br><span class="line">&#125;BSNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(BiTree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    BiTree p=T;  </span><br><span class="line">    BiTree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;  </span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;left;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;righr;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//申请要加入元素的新节点空间  </span></span><br><span class="line">    BiTree pnew;  </span><br><span class="line">    pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;left=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;righr=pnew;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建二叉查找树的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_BSTree</span><span class="params">(BiTree &amp;T,ElemType str[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    T=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        BST_insert(T,str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历打印二叉树  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        InOrder(T-&gt;left);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,T-&gt;key);  </span><br><span class="line">        InOrder(T-&gt;righr);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树的查找方法  </span></span><br><span class="line">BiTree <span class="title function_">BS_Search</span><span class="params">(BiTree T,ElemType key)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;  </span><br><span class="line">            T=T-&gt;left;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            T=T-&gt;righr;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> T;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//删除二叉排序树元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_BSNode</span><span class="params">(BiTree &amp;root,ElemType x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(x&lt;root-&gt;key)&#123;  </span><br><span class="line">        delete_BSNode(root-&gt;left,x);  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;key)&#123;  </span><br><span class="line">        delete_BSNode(root-&gt;righr,x);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//查找到了要删的结点  </span></span><br><span class="line">        <span class="comment">//如果左子树为空，右结点顶上去  </span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            BiTree tempNode=root;  </span><br><span class="line">            root=root-&gt;righr;  </span><br><span class="line">            <span class="built_in">free</span>(tempNode);  </span><br><span class="line">            <span class="comment">//如果右子树为空，左节点顶上去  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;righr==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            BiTree tempNode=root;  </span><br><span class="line">            root=root-&gt;left;  </span><br><span class="line">            <span class="built_in">free</span>(tempNode);  </span><br><span class="line">            <span class="comment">//如果左右子树都不为空  </span></span><br><span class="line">            <span class="comment">//1-左子树最大顶上去；2-右子树最下顶上去  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            BiTree p=root-&gt;left;<span class="comment">//遍历左子树，寻找左子树最大  </span></span><br><span class="line">            <span class="keyword">while</span>(p-&gt;righr!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                p=p-&gt;righr;  </span><br><span class="line">            &#125;  </span><br><span class="line">            root-&gt;key=p-&gt;key;<span class="comment">//将p的值赋给root  </span></span><br><span class="line">            <span class="comment">//然后删除p  </span></span><br><span class="line">            delete_BSNode(root-&gt;left,p-&gt;key);  </span><br><span class="line">                <span class="comment">//这里得从左子树找，因为root的key也是和p一样  </span></span><br><span class="line">                <span class="comment">//这样可以略过根结点  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    BiTree T;  </span><br><span class="line">    ElemType str[<span class="number">8</span>]=&#123;<span class="number">13</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">95</span>,<span class="number">48</span>&#125;;  </span><br><span class="line">    ElemType key;  </span><br><span class="line">  </span><br><span class="line">    creat_BSTree(T,str,<span class="number">8</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ndelet 23\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    delete_BSNode(T,<span class="number">23</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ测试-3"><a href="#OJ测试-3" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041948855.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BSNode,*Bitree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(Bitree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T=(Bitree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Bitree p;<span class="comment">//p用来遍历树  </span></span><br><span class="line">    p=T;  </span><br><span class="line">    Bitree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;<span class="comment">//用来指向p的父节点  </span></span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;lift;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Bitree pnew;  </span><br><span class="line">    pnew=(Bitree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;lift=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;right=pnew;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_bstree</span><span class="params">(Bitree &amp;T,ElemType *str,<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">   T=<span class="literal">NULL</span>;  </span><br><span class="line">   <span class="type">int</span> i;  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">       BST_insert(T,str[i]);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历二叉树  </span></span><br><span class="line">ElemType* <span class="title function_">InOrder</span><span class="params">(Bitree T)</span>&#123;<span class="comment">//无法直接返回数组形式，但是可以返回一个数组形式的指针  </span></span><br><span class="line">    <span class="type">static</span> ElemType str2[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(T-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, T-&gt;key);  </span><br><span class="line">        str2[i]=T-&gt;key;  </span><br><span class="line">        i++;  </span><br><span class="line">        InOrder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">return</span> str2;<span class="comment">//返回一个指针  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二分查找的方法 ，返回元素下标 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(ElemType str[],<span class="type">int</span> x)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>,mid,end=<span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;  </span><br><span class="line">        mid=(begin+end)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(x==str[mid])&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;str[mid])&#123;  </span><br><span class="line">            begin=mid;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            end=mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    Bitree root;<span class="comment">//定义一个舒更  </span></span><br><span class="line">    ElemType str[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> k;<span class="comment">//存放输入的数据  </span></span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);  </span><br><span class="line">        str[i]=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    creat_bstree(root,str,<span class="number">10</span>);<span class="comment">//  </span></span><br><span class="line">    ElemType *pInt = InOrder(root);<span class="comment">//打印，并接收返回的排序后的数组指针  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    pos=binary_search(pInt,<span class="number">6</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,pos);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041948552.png" alt="image.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">排序算法分为 交换类排序、插入类排序、选择类排序、归并类排序</span><br><span class="line"></span><br><span class="line">交换类排序</span><br><span class="line"></span><br><span class="line">冒泡排序</span><br><span class="line">初冒泡排序,一般靠选择题，考大题几率小</span><br><span class="line">快速排序</span><br><span class="line">更重要，考大题</span><br><span class="line"></span><br><span class="line">插入类排序</span><br><span class="line"></span><br><span class="line">直接插入</span><br><span class="line"></span><br><span class="line">折半插入</span><br><span class="line"></span><br><span class="line">希尔排序，以上三种插入算法，一般考选择题，考大题概率低</span><br><span class="line">选择排序</span><br><span class="line"></span><br><span class="line">简单选择排序</span><br><span class="line"></span><br><span class="line">堆排序(重要)</span><br><span class="line">很有可能考大题</span><br></pre></td></tr></table></figure><h3 id="冒泡排序原理及实战"><a href="#冒泡排序原理及实战" class="headerlink" title="冒泡排序原理及实战"></a>冒泡排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041927093.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(ElemType arr[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="type">bool</span> flag;  <span class="comment">//用来标记是否发生了交换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环需要比较n-1次  </span></span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//内层循环  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);  </span><br><span class="line">                flag=<span class="literal">true</span>;<span class="comment">//有交换就返回true  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;<span class="comment">//如果这一趟没有比较，直接结束无须比较  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    <span class="type">int</span> len=<span class="number">9</span>;  </span><br><span class="line">    init_table(T,len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    bubble_sort(T.str,T.len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041926485.png" alt="image.png"></p><h3 id="快速排序原理及实战"><a href="#快速排序原理及实战" class="headerlink" title="快速排序原理及实战"></a>快速排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041930109.png" alt="Snipaste_2023-03-18_15-37-22.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个顺序表</span><br><span class="line">以第一个数为基准</span><br><span class="line">定义两个指针i j</span><br><span class="line">i从左往右找比3大的数，i停止</span><br><span class="line">j从右往左找比3小的数，j停止</span><br><span class="line">然后i j 对应的数完成一次交换，i j 继续前进</span><br><span class="line">循环..直到ij相遇</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实战<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//分割方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;<span class="comment">//用于存放分割界限数(选取数组第一个数）  </span></span><br><span class="line">    temp=str[low];<span class="comment">//相当于将low位置外一个坑，先让high往前放入元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="comment">//右指针用来找比分割数小的数  </span></span><br><span class="line">        <span class="comment">//停了说明找到了  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;str[high]&gt;=temp)&#123;  </span><br><span class="line">            high--;<span class="comment">//移动  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        str[low]=str[high];<span class="comment">//将找到的值给str[low],因为这时的str[low]赋给了temp  </span></span><br><span class="line">        <span class="comment">//左指针，用来找比分割数大的数  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;str[low]&lt;=temp)&#123;  </span><br><span class="line">            low++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str[high]=str[low];  </span><br><span class="line">    &#125;  </span><br><span class="line">    str[low]=temp;<span class="comment">//结束时，low位置是空的  </span></span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//快速排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;<span class="comment">//low high用来限定分割的范围  </span></span><br><span class="line">        <span class="type">int</span> postion = partition(str, low, high);<span class="comment">//partition方法是核心方法，是每一次分割的方法  </span></span><br><span class="line">        quick_sort(str, low, postion - <span class="number">1</span>);<span class="comment">//递归左边的数组  </span></span><br><span class="line">        quick_sort(str, postion + <span class="number">1</span>, high);<span class="comment">//递归数组右边  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    <span class="type">int</span> len=<span class="number">9</span>;  </span><br><span class="line">    init_table(T,len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    quick_sort(T.str,<span class="number">0</span>,T.len<span class="number">-1</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041930643.png" alt="image.png"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304191541637.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(ElemType *str,<span class="type">int</span> n)</span>&#123; <span class="comment">//n为数组长度 </span></span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        temp=str[i];<span class="comment">//暂时存目标元素  </span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;str[j]&gt;temp;j--)&#123;<span class="comment">//将比插入的数大的全部往后移一格  </span></span><br><span class="line">            str[j+<span class="number">1</span>]=str[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        str[j+<span class="number">1</span>]=temp;<span class="comment">//j来到了插入位置，将temp插入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304191608087.png" alt="image.png"></p><h3 id="OJ测试-4"><a href="#OJ测试-4" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041934190.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化顺序表，手动输入十个数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    T.str=(ElemType*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*T.len);  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;T.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">        T.str[i]=x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//================================================================================  </span></span><br><span class="line"><span class="comment">//交换的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;T.len<span class="number">-1</span>;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=T.len<span class="number">-1</span>;j&gt;i;j--)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(T.str[j]&gt;T.str[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(T.str[j],T.str[j<span class="number">-1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//==============================================================================</span></span><br><span class="line"><span class="comment">//分割方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">split</span><span class="params">(SSTable &amp;T,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    temp=T.str[low];  </span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;T.str[high]&gt;=temp)&#123;  </span><br><span class="line">            high--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[low]=T.str[high];  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;T.str[low]&lt;=temp)&#123;  </span><br><span class="line">            low++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[high]=T.str[low];  </span><br><span class="line">    &#125;  </span><br><span class="line">    T.str[low]=temp;  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//快速排序法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(SSTable &amp;T,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;  </span><br><span class="line">       <span class="type">int</span> pos;  </span><br><span class="line">       pos= split(T,low,high);  </span><br><span class="line">        quick_sort(T,low,pos<span class="number">-1</span>);  </span><br><span class="line">        quick_sort(T,pos+<span class="number">1</span>,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//================================================================================ </span></span><br><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;T.len;i++)&#123;  </span><br><span class="line">        temp=T.str[i];  </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;T.str[j]&gt;temp;j--)&#123;  </span><br><span class="line">            T.str[j+<span class="number">1</span>]=T.str[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[j+<span class="number">1</span>]=temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable SST;  </span><br><span class="line">    SST.len=<span class="number">10</span>;  </span><br><span class="line">    init_table(SST);  </span><br><span class="line">    print_table(SST);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * //冒泡排序  </span></span><br><span class="line"><span class="comment">    bubble_sort(SST);    print_table(SST);*/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    //快速排序  </span></span><br><span class="line"><span class="comment">    quick_sort(SST,0,9);    print_table(SST);*/</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//插入排序  </span></span><br><span class="line">    insert_sort(SST);  </span><br><span class="line">    print_table(SST);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序原理及实战"><a href="#选择排序原理及实战" class="headerlink" title="选择排序原理及实战"></a>选择排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041935436.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041935724.png" alt="image.png"></p><p>代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//选择排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_sort</span><span class="params">(ElemType *A,<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> min,i,j;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外循环,i只需要进行n-1轮就可以了  </span></span><br><span class="line">        min=i;  </span><br><span class="line">        <span class="keyword">for</span>(j=min+<span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">//内循环，j从左到右遍历最小  </span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;<span class="comment">//找到更小的  </span></span><br><span class="line">                min=j;<span class="comment">//交换下标数，意味着j下标表示的数更小，j赋值给min  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        swap(A[i],A[min]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;<span class="comment">//定义顺序表  </span></span><br><span class="line">    init_table(T,<span class="number">10</span>);<span class="comment">//初始化  </span></span><br><span class="line">    print_table(T);<span class="comment">//打印  </span></span><br><span class="line">  </span><br><span class="line">    select_sort(T.str,<span class="number">10</span>);<span class="comment">//选择排序  </span></span><br><span class="line">    print_table(T);<span class="comment">//再次打印，看排序效果  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041936675.png" alt="image.png"></p><h3 id="堆排序原理及实战"><a href="#堆排序原理及实战" class="headerlink" title="堆排序原理及实战"></a>堆排序原理及实战</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际上就是一个数组，并不是真正意义的树</span><br><span class="line">就是把数组，想象成一个树</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若父结点的值恒大于等于子结点的值，则该堆称为最大堆（max heap）。堆中最顶端的那个结点称为根结点（root node），根结点本身没有父结点（parent node）。平时在工作中，我们将最小堆称为小根堆或小顶堆，把最大堆称为大根堆或大顶堆</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041937290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆排序步骤：</span><br><span class="line">堆排序的步骤是首先把堆调整为大根堆，然后我们交换根部元素也就是A[0]，和最后一个元素，这</span><br><span class="line">样最大的元素就放到了数组最后，接着我们将剩余 9 个元素继续调整为大根堆，然后交换 A[0]和</span><br><span class="line">9 个元素的最后一个，循环往复，直到有序</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938126.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938535.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938986.png" alt="image.png"></p><p>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//调整单个子树为大根堆的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_down1</span><span class="params">(ElemType A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;<span class="comment">//k表示父节点位置，开始调整的位置  </span></span><br><span class="line">    <span class="type">int</span> dad=k;<span class="comment">//父节点的下标  </span></span><br><span class="line">    <span class="type">int</span> son=<span class="number">2</span>*dad+<span class="number">1</span>;<span class="comment">//子节点的下标  </span></span><br><span class="line">    <span class="keyword">while</span>(son&lt;len)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;len&amp;&amp;A[son]&lt;A[son+<span class="number">1</span>])&#123;<span class="comment">//左节点应该比右结点小,son+1且不能越界  </span></span><br><span class="line">            son++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(A[dad]&lt;A[son])&#123;  </span><br><span class="line">            swap(A[son],A[dad]);  </span><br><span class="line">            dad=son;  </span><br><span class="line">            son=<span class="number">2</span>*dad+<span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//堆排序的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(ElemType *A,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从最末尾的子树开始一个一个向前调整为大根堆  </span></span><br><span class="line">        adjust_down1(A,i,len);  </span><br><span class="line">    &#125;  </span><br><span class="line">    swap(A[<span class="number">0</span>],A[len<span class="number">-1</span>]);<span class="comment">//交换根结点和尾结点  </span></span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//剩余的数组进入循环  </span></span><br><span class="line">        adjust_down1(A,<span class="number">0</span>,i);<span class="comment">//从根结点开始重新调整为大堆根,此时数组长度变化-1  </span></span><br><span class="line">        swap(A[<span class="number">0</span>],A[i<span class="number">-1</span>]);<span class="comment">//交换根结点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    init_table(T,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    heap_sort(T.str,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041939457.png" alt="image.png"></p><h3 id="归并排序原理及实战"><a href="#归并排序原理及实战" class="headerlink" title="归并排序原理及实战"></a>归并排序原理及实战</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">归并排序是我们不断进行二分，最终各自剩余 1 个元素，自然有序，然后先将每两个元</span><br><span class="line">素进行合并，变为有序，然后再将两个小组合并，变为有序，循环往复，直到整个数组有序</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041939460.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041940642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归到最底部后，开始层层merge，low,high,mid任然对应分组时的位置</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041940894.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge的时候，需要三个指针,i指向A的有序的前半段，j指向A有序的后半段，k指向放入的数组的当前位置</span><br><span class="line"></span><br><span class="line">1、将A[] 元素全部复制放到B[] ，i ,j分别对应low\mid+1起始位置，k=i.</span><br><span class="line"></span><br><span class="line">2、i j 先比较，小的放入A[k],i++,j不动，k++</span><br><span class="line"></span><br><span class="line">3、直到有剩余，i到头了，j还没到头;或者j到头了，i还没到头。while循环将剩余的全部放入,k随着++</span><br></pre></td></tr></table></figure><p>代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="comment">//用额外的空间存放，避免原数组交换次数过多  </span></span><br><span class="line">    <span class="comment">//static修饰防止递归时，重复加载  </span></span><br><span class="line">    <span class="comment">//因为申请了额外的空间，所以空间复杂度是O(n),n是元素个数  </span></span><br><span class="line">    <span class="type">static</span> ElemType B[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> i,j,k;  </span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)&#123;<span class="comment">//复制元素到B中  </span></span><br><span class="line">        B[k]=A[k];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) &#123;<span class="comment">//合并两个有序数组  </span></span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;  </span><br><span class="line">            A[k] = B[i];  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            A[k] = B[j];  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//如果左半边数组有剩余接着放入  </span></span><br><span class="line">        A[k] = B[i];  </span><br><span class="line">        k++;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;<span class="comment">//如果右半边数组有剩余接着放入  </span></span><br><span class="line">        A[k] = B[j];  </span><br><span class="line">        k++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//归并排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;  </span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;  </span><br><span class="line">        merge_sort(A, low, mid);  </span><br><span class="line">        merge_sort(A, mid+<span class="number">1</span>,high);  </span><br><span class="line">        merge(A,low,mid,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    init_table(T,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    merge_sort(T.str,<span class="number">0</span>,<span class="number">9</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MergeSort 函数的递归 次数是 log 2 n， Merge 函数的循环了 n 次， 因此时间复杂度是 O(nlog 2 n)。</span><br><span class="line">归并排序最好、最坏、平均时间复杂度都是 O(nlog 2 n)。</span><br><span class="line">归并排序的空间复杂度是 O(n)，因为使用了数组 B，它的大小与 A 一样，占用 n 个元素的</span><br><span class="line">空间。</span><br></pre></td></tr></table></figure><h3 id="所有算法空间时间复杂度"><a href="#所有算法空间时间复杂度" class="headerlink" title="所有算法空间时间复杂度"></a>所有算法空间时间复杂度</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041941683.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obisidain图床</title>
      <link href="/undefined/7b58c309.html"/>
      <url>/undefined/7b58c309.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192341533.jpg" alt="赛博朋克 动漫女孩 è 雨 霓虹灯 城市灯光 瓶子 电脑高清壁纸_彼岸壁纸.jpg"></p><h1 id="github图床"><a href="#github图床" class="headerlink" title="github图床"></a>github图床</h1><h2 id="安装Picgo"><a href="#安装Picgo" class="headerlink" title="安装Picgo"></a>安装Picgo</h2><p>GitHub搜索picgo</p><h2 id="申请一个token"><a href="#申请一个token" class="headerlink" title="申请一个token"></a>申请一个token</h2><p>注意必须勾选仓库权限</p><h2 id="配置仓库信息"><a href="#配置仓库信息" class="headerlink" title="配置仓库信息"></a>配置仓库信息</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302333755.png" alt="image.png"></p><h2 id="使用CDN域名加速"><a href="#使用CDN域名加速" class="headerlink" title="使用CDN域名加速"></a>使用CDN域名加速</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022155952.png" alt="image.png"></p><p>1.直接引用格式<br><code>https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名/&lt;文件及路径&gt;</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 直接引用cdn域名加速默认加速master分支所以设定picgo存贮分支要改为master</span><br><span class="line">- 文件及路径可以不填,picgo上传会自动分配路径</span><br><span class="line">- 如果加速已存在的图片需要填写路径名</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>2.按分支/版本号格式<br><code>https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;@[分支/版本号]/&lt;文件及路径&gt;</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 可以指定加速的分支名或版本号</span><br></pre></td></tr></table></figure></p><h2 id="下载obsidian中的picgo插件"><a href="#下载obsidian中的picgo插件" class="headerlink" title="下载obsidian中的picgo插件"></a>下载obsidian中的picgo插件</h2><h2 id="设置几个插件选项"><a href="#设置几个插件选项" class="headerlink" title="设置几个插件选项"></a>设置几个插件选项</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302333597.png" alt="image.png"></p><h1 id="七牛云图床"><a href="#七牛云图床" class="headerlink" title="七牛云图床"></a>七牛云图床</h1><p>前置准备与上面一致，注册好七牛云后存储仓库每月10G免费上传空间，但是访问的域名是测试域名有效期30天，因此需要一个备案好的域名。</p><h2 id="设置picgo七牛云设置"><a href="#设置picgo七牛云设置" class="headerlink" title="设置picgo七牛云设置"></a>设置picgo七牛云设置</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302328938.png" alt="image.png"></p><h2 id="关于测试域名过期问题"><a href="#关于测试域名过期问题" class="headerlink" title="关于测试域名过期问题"></a>关于测试域名过期问题</h2><p>由于测试域名有效期只有30天，但是又不想花钱搞个域名，可以通过，连续创建新的存储空间，一直白嫖30天测试域名，再通过qshell工具将原空间的数据，拷贝到新的空间里</p><h3 id="qshell工具的使用"><a href="#qshell工具的使用" class="headerlink" title="qshell工具的使用"></a>qshell工具的使用</h3><p><a href="https://developer.qiniu.com/kodo/1302/qshell">官网下载</a></p><h4 id="闪退问题"><a href="#闪退问题" class="headerlink" title="闪退问题"></a>闪退问题</h4><p>下载好之后，对于windows系统来说，不要双击方式运行qshell.exe,通过进入文件夹，运行cmd命令，输入qshell.exe执行</p><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>1.窗口中输入 ```</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qshell listbucket 要复制的空间名 -o test.txt</span><br></pre></td></tr></table></figure><p>扒取要复制的空间的所有文件信息,前面两个是命令,不解释 后面一个是要复制的空间吗,-o之后是你要指定一个文件名</p><p>2.执行之后会生成test.txt文件<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302339821.png" alt="image.png"></p><p>生成的文件是这样的,这不是我们要的,ctrl+A复制全部,用Excel表格打开<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340692.png" alt="image.png"></p><p>只留下前面的名字,复制回原来的test.txt里,<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305010929090.png" alt="image.png"></p><p>只要这些,之后<br>命令行执行<br>qshell batchcopy —force —overwrite —success-list success.txt —failure-list failure.txt 源空间名 目标空间名 -i test.txt<br>解释:qshell batchcopy 执行的是复制操作,也可以改成qshell batchmove ,<br>–force,不加这个的话会给你手机发个验证码验证,会很久,还是加上,-<br>-overwrite 同名文件覆盖<br>–success-list success.txt —failure-list failure.txt:设置复制成功或者失败的文件放置位置,就是哪些文件成功了哪些失败了,都会列到你指定的文件<br>源空间名 目标空间名 :就是空间名称,源空间就是你要复制的那个,目标空间名就是要粘贴到的那个.<br>-i test.txt:上一条命令生成的文件</p><p>这样就复制过去了,底下的图是另一个账号授权的源空间<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340089.png" alt="image.png"></p><p>这里是我复制的空间<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340166.png" alt="image.png"></p><h4 id="图片换新链接"><a href="#图片换新链接" class="headerlink" title="图片换新链接"></a>图片换新链接</h4><p>由于换了一个新的测试域名，访问地址变化，但是知道保证复制之后的文件名称不变，只需要改变图url的域名位置，通过正则表达式批量修改，可以解决链接问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> obisidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术随想</title>
      <link href="/undefined/dfb8a81f.html"/>
      <url>/undefined/dfb8a81f.html</url>
      
        <content type="html"><![CDATA[<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><h2 id="Github-Pages-和-Hexo-搭建自己的独立博客"><a href="#Github-Pages-和-Hexo-搭建自己的独立博客" class="headerlink" title="Github Pages 和 Hexo 搭建自己的独立博客"></a><a href="https://anzhiy.cn/posts/ddae.html#Hexo-%E5%AE%89%E8%A3%85">Github Pages 和 Hexo 搭建自己的独立博客</a></h2><h2 id="一图流实现"><a href="#一图流实现" class="headerlink" title="一图流实现"></a><a href="https://zfe.space/post/65396.html">一图流实现</a></h2><h2 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a><a href="https://zhuanlan.zhihu.com/p/492207978">打字机效果</a></h2><h2 id="Hexo-Butterfly-一些常见问题"><a href="#Hexo-Butterfly-一些常见问题" class="headerlink" title="Hexo + Butterfly 一些常见问题"></a><a href="https://tzy1997.com/articles/hexo1612/#%E9%A6%96%E9%A1%B5%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C">Hexo + Butterfly 一些常见问题</a></h2><h2 id="Algolia搜索系统"><a href="#Algolia搜索系统" class="headerlink" title="Algolia搜索系统"></a><a href="https://www.fomal.cc/posts/d1927166.html">Algolia搜索系统</a></h2><h2 id="页面布局优化"><a href="#页面布局优化" class="headerlink" title="页面布局优化"></a><a href="">页面布局优化</a></h2><h2 id="右边按钮阅读进度"><a href="#右边按钮阅读进度" class="headerlink" title="右边按钮阅读进度"></a><a href="https://www.fomal.cc/posts/2d7ac914.html">右边按钮阅读进度</a></h2><h2 id="文章三栏"><a href="#文章三栏" class="headerlink" title="文章三栏"></a><a href="https://www.fomal.cc/posts/d739261b.html">文章三栏</a></h2><h2 id="为文章封面图片"><a href="#为文章封面图片" class="headerlink" title="为文章封面图片"></a>为文章封面图片</h2><p>要为每一篇文章的栏目配置图片，需要在文章的top_imge和cover标签传一个图片的url链接，注意不是图片链接<br>url链接通过上传至图床获取<br>文章的 markdown 文档上，在 添加 ，并填上要显示的图片地址。Front-mattercover<br>如果不配置 ，可以设置显示默认的 cover。cover<br>如果不想在首页显示 cover， 可以设置为 。false</p><h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a><a href="https://tzy1997.com/articles/hexo1605/">自定义字体</a></h2><h2 id="修改头像及网站图标"><a href="#修改头像及网站图标" class="headerlink" title="修改头像及网站图标"></a>修改头像及网站图标</h2><p>改网站图标：修改主题文件找到favicon,修改本地的图片<br>改头像：修改主题配置文件找到avater，修改图片url</p><h2 id="双栏修改"><a href="#双栏修改" class="headerlink" title="双栏修改"></a><a href="https://zfe.space/post/hexo-butterfly-article-double-row.html">双栏修改</a></h2><h2 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a><a href="https://anzhiy.cn/posts/52d8.html">加载动画</a></h2><p>遇到问题：按照流程，发现存在半屏加载页面不消失的情况，于是换用4.4版本的步骤，解决了上述问题。所以butterfly版本只最为参考，实际还是按照实际情况判断选择哪种方式</p><h2 id="利用clion修改本地文件存在的问题"><a href="#利用clion修改本地文件存在的问题" class="headerlink" title="利用clion修改本地文件存在的问题"></a>利用clion修改本地文件存在的问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用clion修改本地博客配置文件，无法检测到stly,pug,文件的改动，导致推送时漏掉上述类型配置文件</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>放弃用clion修改配置文件，换用其他编辑器；或者，直接在文件夹执行git操作</p><h2 id="Hexo-github-netlify快速搭建"><a href="#Hexo-github-netlify快速搭建" class="headerlink" title="Hexo+github+netlify快速搭建"></a><a href="https://blog.csdn.net/qq_34769162/article/details/107687755?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168070747016800180693297%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168070747016800180693297&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-107687755-null-null.142^v81^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=github%20netlify%20%E5%8D%9A%E5%AE%A2&amp;spm=1018.2226.3001.4187">Hexo+github+netlify快速搭建</a></h2><h2 id="github-action自动部署"><a href="#github-action自动部署" class="headerlink" title="github action自动部署"></a><a href="https://anzhiy.cn/posts/asdx.html">github action自动部署</a></h2><h2 id="博客迁移到新电脑"><a href="#博客迁移到新电脑" class="headerlink" title="博客迁移到新电脑"></a><a href="https://www.fomal.cc/posts/d1927166.html">博客迁移到新电脑</a></h2><h2 id="hexo中插入pdf"><a href="#hexo中插入pdf" class="headerlink" title="hexo中插入pdf"></a><a href="https://zhuanlan.zhihu.com/p/550626417">hexo中插入pdf</a></h2><p>1-下载插件<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></p><p>2-建立存放pdf文件夹</p><pre><code>在source文件夹下创建一个叫pdf的文件夹，把xxx.pdf文件放在这里</code></pre><p>3-引用<br>    在_post文件夹中的xxx.md直接使用<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf /pdf/xxx.pdf %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用本地图片"><a href="#使用本地图片" class="headerlink" title="使用本地图片"></a>使用本地图片</h2><ul><li>修改配置文件<code>_config.yml</code> ,中的<code>post_asset_folder: true</code>，设为true</li><li>注意图片文件夹位置，如果是与其处于同一级路径例如：<code>source/_post  与source/_img</code><br> 那么要引用同级的img,直接<code>/img/xxx</code>;</li></ul><h1 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h1><h2 id="服务器的使用"><a href="#服务器的使用" class="headerlink" title="服务器的使用"></a><a href="https://blog.csdn.net/weixin_57024510/article/details/126292491?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168070719016800182115444%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168070719016800182115444&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126292491-null-null.142^v81^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&amp;spm=1018.2226.3001.4187">服务器的使用</a></h2><h3 id="甲骨文云服务器"><a href="#甲骨文云服务器" class="headerlink" title="甲骨文云服务器"></a><a href="https://www.youtube.com/watch?v=X9sexl1wXyE">甲骨文云服务器</a></h3><h1 id="静态主机"><a href="#静态主机" class="headerlink" title="静态主机"></a>静态主机</h1><h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><p><a href="https://wenjie.org/archives/netlify">https://wenjie.org/archives/netlify</a> 博客地址</p><h1 id="windows触控板手势"><a href="#windows触控板手势" class="headerlink" title="windows触控板手势"></a>windows触控板手势</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.一根手指单击或按压触控板的左下部分：鼠标左键</span><br><span class="line">2.两根手指单击或按压触控板右下部分：鼠标右键</span><br><span class="line">3.双指放开或者捏合，即可控制页面的放大和缩小</span><br><span class="line">4.双指上下滑可以让页面垂直滚动</span><br><span class="line">5.三指单击，可以调出搜索框搜索</span><br><span class="line">6.三指左右滑动，可切换不同任务界面</span><br><span class="line">7.三指向下滑动，可以最小化所有软件</span><br><span class="line">8.三指向上滑动即可恢复原样</span><br><span class="line">9.三指再向上滑动可以调出任务视图</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"风起之时`Blog","short_name":"风起之时","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @ce {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: normal;}/*div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    !* 可以定义图标大小 *!    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}!* bilibli番剧插件 *!#article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;}!* 解决artitalk的图标问题 *!#uploadSource > svg {    width: 1.19em;    height: 1.5em;}!*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 *!#page-header:not(.not-top-img):before {    background-color: transparent !important;}!* 首页文章卡片 *!#recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);}!* 首页侧栏卡片 *!#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}!* 文章页面正文背景 *!div#post {    background: rgba(255, 255, 255, 0.9);}!* 分页页面 *!div#page {    background: rgba(255, 255, 255, 0.9);}!* 归档页面 *!div#archive {    background: rgba(255, 255, 255, 0.9);}!* 标签页面 *!div#tag {    background: rgba(255, 255, 255, 0.9);}!* 分类页面 *!div#category {    background: rgba(255, 255, 255, 0.9);}!*夜间模式伪类遮罩层透明*![data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}*//* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside > div > button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 7px;    height: 7px;}::-webkit-scrollbar-thumb {    background-color: #8be9fd;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/*!* 音乐播放器 *!!* .aplayer .aplayer-lrc {  display: none !important;} *!.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    !* 默认情况下缩进左侧66px，只留一点箭头部分 *!}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    !* 鼠标悬停是左侧缩进归零，完全显示按钮 *!}.aplayer.aplayer-fixed {    z-index: 999999 !important;}*//* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}/* 归档样式 */span.card-archive-list-count {    width: auto;    text-align: left;    font-size: 1.5rem;    line-height: 0.9;    font-weight: 700;}.card-archive-list-count-group {    display: flex;    flex-direction: row;    align-items: baseline;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:last-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:last-child {    width: fit-content;    margin-left: 4px;}span.card-archive-list-count {    width: auto;    text-align: left;    font-size: 1.1rem;    line-height: 0.9;    font-weight: 700;}.card-archive-list-date {    font-size: 14px;    opacity: 0.6;}li.card-archive-list-item {    width: 100%;    flex: 0 0 48%;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,#aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {    color: var();    background-color: var(--btn-bg);    box-shadow: var(--btn-bg);    border-radius: 8px;    padding-left: 0.5rem;    padding-right: 0.5rem;}@media screen and (min-width: 1300px) {    #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,    #aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {        transform: scale(1.03);    }    #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:active,    #aside-content .card-categories ul.card-category-list > .card-category-list-item a:active {        transform: scale(0.97);    }}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a,#aside-content .card-categories ul.card-category-list > .card-category-list-item a {    border-radius: 8px;    margin: 4px 0;    display: flex;    flex-direction: column;    align-content: space-between;    border: var(--style-border);}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:first-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:first-child {    width: auto;    flex: inherit;}#aside-content .card-archives ul.card-archive-list,#aside-content .card-categories ul.card-category-list {    display: flex;    flex-direction: row;    justify-content: space-between;    flex-wrap: wrap;}/*渐变条*/.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/*魔改菜单栏*//* 一级菜单居中 *//*#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}*//* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {    left: -125px;}/*名片渐变色*//* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(            -45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/*loading动画*/.loading-img {    background: url(https://s1.ax1x.com/2023/04/01/ppWibxf.jpg) no-repeat center center;    background-size: cover;}/*黑夜霓虹灯*//* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {    animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/*侧边栏最近文章修改*/#aside-content .aside-list > .aside-list-item .content > time {    display: none;}#aside-content .aside-list > .aside-list-item .content > .title {    -webkit-line-clamp: 3;    font-weight: 700;    padding: 2px 0;}#aside-content .aside-list > .aside-list-item {    padding: 8px;    padding-top: 6px !important;    padding-bottom: 6px !important;    border-radius: 12px;    transition: 0.3s;    margin: 4px 0;    cursor: pointer;}@media screen and (min-width: 1300px) {    #aside-content .aside-list > .aside-list-item:hover {        transform: scale(1.03);    }    #aside-content .aside-list > .aside-list-item:active {        transform: scale(0.97);    }}#aside-content .aside-list > .aside-list-item:hover .thumbnail > img {    transform: scale(1);}#aside-content .aside-list > .aside-list-item:not(:last-child) {    border-bottom: 0 dashed var(--anzhiyu-background) !important;}#aside-content .aside-list > .aside-list-item .thumbnail {    border-radius: 8px;    border: var(--style-border);}#aside-content .aside-list > .aside-list-item:hover {    background: var(--anzhiyu-blue-main);    color: var(--anzhiyu-white);    transition: 0.3s;    box-shadow: var(--anzhiyu-shadow-main);}#aside-content .aside-list > .aside-list-item:hover a {    color: var(--anzhiyu-white) !important;}.card-widget.card-recent-post {    padding: 0.4rem 0.6rem !important;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {    -webkit-animation: ccc 4s linear infinite;    animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}@keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}/* 设置风车颜色 */#content-inner.layout h1::before {    color: #ef50a8;    margin-left: -1.55rem;    font-size: 1.3rem;    margin-top: -0.23rem;}#content-inner.layout h2::before {    color: #fb7061;    margin-left: -1.35rem;    font-size: 1.1rem;    margin-top: -0.12rem;}#content-inner.layout h3::before {    color: #ffbf00;    margin-left: -1.22rem;    font-size: 0.95rem;    margin-top: -0.09rem;}#content-inner.layout h4::before {    color: #a9e000;    margin-left: -1.05rem;    font-size: 0.8rem;    margin-top: -0.09rem;}#content-inner.layout h5::before {    color: #57c850;    margin-left: -0.9rem;    font-size: 0.7rem;    margin-top: 0rem;}#content-inner.layout h6::before {    color: #5ec1e0;    margin-left: -0.9rem;    font-size: 0.66rem;    margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {    color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {    color: var(--theme-color);    -webkit-animation: ccc 6s linear infinite;    animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/readPercent.css"/>
      <url>/css/readPercent.css</url>
      
        <content type="html"><![CDATA[/* 返回顶部 */button#go-up #percent {    display: none;    font-weight: bold;    font-size: 15px !important;}button#go-up span {    font-size: 12px!important;    margin-right: -1px;}/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i {    display: block !important;}button#go-up:hover #percent {    display: none !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[!(function (c) {    var l,        h,        a,        t,        i,        v =            '<svg><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1129 1024"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75H212.377a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" ></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" ></path></symbol><symbol id="icon-yinle" viewBox="0 0 1024 1024"><path d="M512.2976 0a531.2 531.2 0 0 0-512 548.48V960h128V548.48a398.72 398.72 0 0 1 384-411.52 398.72 398.72 0 0 1 384 411.52V960h128V548.48A531.2 531.2 0 0 0 512.2976 0z" fill="#5c8add" ></path><path d="M64.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path><path d="M704.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path></symbol><symbol id="icon-icon-test-copy" viewBox="0 0 1024 1024"><path d="M512 512m-229.517241 0a229.517241 229.517241 0 1 0 459.034482 0 229.517241 229.517241 0 1 0-459.034482 0Z" fill="#5c8add" ></path><path d="M512 1024A512 512 0 1 1 1024 512 512 512 0 0 1 512 1024z m0-141.241379A370.758621 370.758621 0 1 0 141.241379 512 370.758621 370.758621 0 0 0 512 882.758621z" fill="#5c8add" ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M1012.47774251 492.58192592L544.94137566 87.22962963a49.96686561 49.96686561 0 0 0-65.88275132 0L11.63784127 492.6975097c-21.03624691 18.26223633-23.3479224 49.93219048-5.08568606 70.96843739 18.03106878 21.03624691 49.93219048 23.3479224 70.96843738 5.08568607L512 191.83294532l434.71057495 376.91868784c9.47786949 8.20644797 21.26741446 12.25188008 32.82579189 12.13629629 14.10122046 0 27.97127337-5.77918871 38.02706173-17.33756613 18.14665256-20.92066314 15.95056084-52.70620106-5.08568606-70.9684374z" fill="#5c8add" ></path><path d="M109.30613051 567.59579541V896.89396825c0 42.53482892 34.90629982 77.44112875 77.44112875 77.44112875h220.76500882V666.30433862c0-25.54401411 20.92066314-46.46467725 46.46467724-46.46467724h116.16169313c25.54401411 0 46.46467725 20.92066314 46.46467725 46.46467724V974.335097h220.76500882c42.53482892 0 77.44112875-34.90629982 77.44112874-77.44112875l0.11558377-329.29817284L512 218.18604586 109.30613051 567.59579541zM848.00203175 197.49655027h-63.91782716c-12.82979894 0-23.23233862 10.40253968-23.23233863 23.23233862v24.27259259l110.49808818 95.70336508V220.72888889h-0.11558377c0-12.82979894-10.40253968-23.23233862-23.23233862-23.23233862zM905.44716754 83.18419754s-34.90629982 56.86721693-89.11508994 100.32671603c152.68616579 13.98563668 127.83565432-133.26809171 127.83565432-133.2680917-134.07717813-10.28695591-132.92134039 102.29164021-131.072 127.83565432 20.92066314-20.92066314 49.70102293-62.64640564 92.35143562-94.89427865zM798.53217637 174.61096297c-19.64924162-16.52847972-40.56990476-43.45949912-51.203612-53.97762258 0 0 32.94137566 20.57391182 56.40488184 49.3542716 2.42725926-18.37782011 6.47269135-93.3916896-93.16052205-85.3008254 0 0-13.98563668 104.71889947 87.95925221 89.92417638z" fill="#5c8add" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1167 1024"><path d="M41.201759 463.52493L1110.665064 30.117647c10.32605-4.159104 21.942857 0.860504 26.101961 11.043137 1.434174 3.728852 1.864426 7.744538 1.003921 11.616807L949.033691 978.823529c-2.151261 10.89972-12.764146 17.927171-23.663865 15.632493-2.72493-0.573669-5.306443-1.721008-7.601121-3.298599L634.80624 789.79944l-163.065546 133.951821c-16.492997 13.62465-40.87395 11.186555-54.498599-5.306443-3.011765-3.728852-5.306443-7.887955-6.884034-12.477311l-102.973669-313.080112-265.178712-91.787115c-10.469468-3.585434-16.062745-15.058824-12.333893-25.528291 1.864426-5.44986 6.023529-9.895798 11.329972-12.047059z" fill="#FCFDFC" ></path><path d="M929.385512 1023.569748c-3.155182 0-6.453782-0.286835-9.752381-1.003922-6.740616-1.434174-12.907563-4.015686-18.50084-8.031372L635.953579 825.940616l-146.142297 120.040336c-13.911485 11.473389-31.408403 16.779832-49.335574 15.058824-17.927171-1.721008-34.133333-10.32605-45.463305-24.237535-5.306443-6.453782-9.322129-13.768067-11.903642-21.79944l-98.527731-299.598879-251.697479-87.19776c-12.333894-4.302521-22.229692-13.05098-27.966386-24.811204s-6.453782-24.954622-2.151261-37.288515c4.589356-13.337815 14.771989-23.9507 27.82297-29.257143L1099.908761 3.585434c24.954622-10.039216 53.351261 2.007843 63.533894 26.819048 3.585434 8.891877 4.445938 18.644258 2.581513 28.109804L977.143495 984.560224c-4.732773 23.090196-25.098039 39.009524-47.757983 39.009524z m-294.579272-233.770308l282.962465 201.357983c2.294678 1.577591 4.87619 2.72493 7.601121 3.298599 10.89972 2.151261 21.512605-4.87619 23.663865-15.632493L1137.914364 52.777591c0.860504-3.872269 0.430252-7.887955-1.003922-11.616807-4.159104-10.32605-15.919328-15.202241-26.101961-11.043137L41.201759 463.52493c-5.306443 2.151261-9.465546 6.597199-11.47339 12.047059-1.721008 5.019608-1.434174 10.469468 0.860505 15.345658 2.294678 4.87619 6.453782 8.461625 11.473389 10.182633l265.178711 91.787115L410.214644 905.967507c1.434174 4.589356 3.872269 8.748459 6.884033 12.477311 6.597199 8.031373 15.919328 12.907563 26.101961 13.911485 10.32605 1.003922 20.365266-2.007843 28.396639-8.605042l163.208963-133.951821z" fill="#4A4A4A" ></path><path d="M307.097557 592.743978l105.698599 316.091876c6.310364 18.787675 26.532213 28.970308 45.319888 22.659944 4.159104-1.434174 7.887955-3.442017 11.186555-6.166946l164.786555-133.951821-165.360224-118.892997c297.017367-287.982073 447.462185-433.980952 451.191036-437.853222 0.573669-0.573669 2.581513-3.442017 0.430252-7.027451-1.290756-1.577591-3.298599-3.298599-7.027451-2.15126-202.218487 120.327171-404.293557 242.805602-606.22521 367.291877z" fill="#CAE0EE" ></path><path d="M446.786072 934.794398c-5.736695 0-11.329972-1.290756-16.636414-3.872269-8.891877-4.445938-15.632493-12.047059-18.787675-21.512605L305.376549 592.313725l1.003921-0.573669C507.308201 467.684034 711.391114 344.058263 912.60568 224.161345l0.286835-0.143418c3.585434-1.147339 6.310364-0.286835 8.605042 2.581513l0.143417 0.143417c2.438095 4.015686 0.573669 7.457703-0.573669 8.74846-3.872269 4.015686-155.177591 150.87507-450.043698 436.705882l165.503642 119.036414-166.220728 135.09916c-3.442017 2.868347-7.457703 5.019608-11.760225 6.453782-3.728852 1.290756-7.744538 2.007843-11.760224 2.007843z m-137.967507-341.333334l105.268348 314.944538c2.868347 8.748459 9.035294 15.77591 17.210084 19.935014 8.17479 4.159104 17.496919 4.732773 26.245378 1.864426 3.872269-1.290756 7.60112-3.298599 10.756302-5.880112l163.352381-132.804482L466.434252 672.627451l1.290756-1.147339C763.308201 384.932213 915.043775 237.642577 918.772627 233.626891c0 0 2.007843-2.294678 0.286835-5.306443-1.003922-1.290756-2.438095-2.438095-5.306443-1.577591-200.784314 119.610084-404.293557 242.94902-604.934454 366.718207z" fill="#CAE0EE" ></path><path d="M460.840974 924.898599l7.457703-253.561904 165.933894 119.896918-168.658824 135.959664c-1.290756 1.003922-3.011765 0.860504-4.015686-0.430252-0.430252-0.430252-0.717087-1.147339-0.717087-1.864426z" fill="#94C3E2" ></path><path d="M463.709322 929.344538c-1.290756 0-2.438095-0.573669-3.2986-1.577591-0.573669-0.860504-1.003922-1.864426-1.003921-2.868348l7.60112-256.286834 169.519328 122.621848-1.434174 1.147339-168.658823 135.959664c-0.860504 0.717087-1.721008 1.003922-2.72493 1.003922z m6.023529-255.282913l-7.457703 250.836974c0 0.286835 0.143417 0.717087 0.286835 1.003922 0.430252 0.573669 1.434174 0.717087 2.007843 0.286835l167.22465-134.812325-162.061625-117.315406z" fill="#94C3E2" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1079 1024"><path d="M695.355535 432.666896c-0.553495-1.10699-0.885592-2.186305-1.383737-3.265619-0.193723-0.193723-0.193723-0.359772-0.359771-0.719543-12.508983-26.318678-39.436506-43.366319-69.325226-41.013966-39.076734 3.265619-68.439634 39.021384-65.312388 79.841627 0.857917 10.516401 3.653066 20.147211 7.998 28.83708 19.78744 46.659613 11.097571 103.448181-25.377737 141.750022l-191.094085 199.950001a118.088119 118.088119 0 0 1-171.998513 0c-47.434506-49.537786-47.434506-130.098956 0-179.636742l71.234782-74.389703-0.52582-0.553494a75.911814 75.911814 0 0 0 24.326097-61.880721c-3.127246-40.820243-37.3609-71.51153-76.437634-68.24591a69.463599 69.463599 0 0 0-46.908685 23.966325l-0.166049-0.193723-72.618519 75.856464c-103.226783 107.793115-103.226783 282.36538 0 390.158495 103.171433 107.793115 270.299193 107.793115 373.498301 0l191.619904-200.1714c80.256748-83.992838 97.636485-208.307773 52.83108-310.289193z" fill="#5c8add" ></path><path d="M1002.047012 80.865592c-103.226783-107.82079-270.382217-107.82079-373.581325 0l-191.619905 200.199075c-80.284423 83.854464-97.66416 208.197074-52.997128 310.233843 0.52582 1.079315 0.857917 2.15863 1.383737 3.26562 0.166048 0.166048 0.166048 0.359772 0.332097 0.719543 12.536658 26.291004 39.46418 43.366319 69.3529 41.013966 39.076734-3.265619 68.439634-39.021384 65.312388-79.869302a78.679288 78.679288 0 0 0-7.998-28.864755c-19.78744-46.631938-11.097571-103.448181 25.377737-141.750022l191.287808-199.839302a118.088119 118.088119 0 0 1 172.026188 0c47.434506 49.537786 47.434506 130.126631 0 179.692091l-71.234782 74.417378 0.52582 0.553495a75.939489 75.939489 0 0 0-24.353772 61.88072c3.15492 40.847917 37.3609 71.51153 76.465309 68.245911a69.463599 69.463599 0 0 0 46.908685-23.938651l0.166049 0.166048 72.646194-75.856464c103.03306-107.82079 103.03306-282.642127 0-390.269194z" fill="#5c8add" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1171 1024"><path d="M1068.71699 0.243751H102.193768C46.228437 0.243751 0.500666 45.045267 0.500666 99.74309v696.251622c0 54.697824 45.727771 99.450589 101.693102 99.450589h329.113198l120.851966 114.465677a48.652788 48.652788 0 0 0 66.641644 0l120.851966-114.465677h329.064448c55.965331 0 101.741852-44.752765 101.741852-99.450589V99.74309C1170.458842 45.045267 1124.682321 0.243751 1068.71699 0.243751z m-439.776354 596.849784h-370.989696c-27.933915 0-50.846551-22.425133-50.846551-49.774045 0-27.348912 22.912636-49.725294 50.846551-49.725294h370.989696c27.933915 0 50.846551 22.376382 50.846551 49.725294 0 27.348912-22.912636 49.774045-50.846551 49.774045z m287.18795-211.381252H254.782171a50.456549 50.456549 0 0 1-50.846551-49.725294c0-27.397662 22.912636-49.774045 50.846551-49.774045h661.346415c27.933915 0 50.846551 22.376382 50.846551 49.774045 0 27.348912-22.912636 49.725294-50.846551 49.725294z" fill="#5C8ADD" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1400 1024"><path d="M1301.63733163 214.78520234a207.81921797 207.81921797 0 0 1 7.02423018 52.42036465v489.73590176a205.10753818 205.10753818 0 0 1-205.05853125 205.05853125H283.05853124A205.15654424 205.15654424 0 0 1 77.99999999 756.79444971V267.20556699a201.36672685 201.36672685 0 0 1 7.02423106-52.42036465L586.24393329 562.1905874c69.44187217 51.96297217 146.36536612 49.13694404 214.1736961 0zM1103.60303056 62.0000167H283.05853124A204.50312753 204.50312753 0 0 0 106.37462518 163.41030547l489.71956641 335.75823018c62.43397646 50.77048623 127.85733457 50.31309463 194.62019765 0L1280.28693749 163.41030547A204.68281729 204.68281729 0 0 0 1103.60303056 62.0000167z m0 0" fill="#5c8add" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#18ACFC" ></path><path d="M500.113 228.39c118.396-1.518 178.924 61.004 201 156 3.497 15.048 0.15 34.807 0 50 27.143 5.682 33.087 60.106 10 75v1h1c8.26 14.33 19.04 28.125 26 44 7.332 16.723 9.306 35.16 14 55 4.024 17.01-2.287 51.505-10 57-0.771 0.683-2.231 1.312-3 2-14.601-3.016-30.377-16.865-38-27-3.065-4.074-5.275-9.672-10-12-0.395 21.568-12.503 41.15-22 55-3.514 5.123-14.073 13.217-14 18 3.691 2.836 8.305 2.956 13 5 10.513 4.577 25.449 13.168 32 22 2.334 3.146 5.548 7.555 7 11 16.193 38.414-36.527 48.314-63 54-27.185 5.839-77.818-10.224-92-19-8.749-5.414-16.863-18.573-29-19-3.666 2.389-14.438 1.132-20 1-16.829 32.804-101.913 47.868-148 31-14.061-5.146-43.398-17.695-38-40 4.437-18.327 19.947-29.224 35-37 5.759-2.975 18.915-4.419 22-10-13.141-8.988-24.521-28.659-31-44-3.412-8.077-4.193-25.775-9-32-7.789 12.245-32.097 36.91-52 33-3.071-4.553-7.213-9.097-9-15-4.792-15.835-1.81-40.379 2-54 8.117-29.02 16.965-50.623 32-72 4.672-6.643 11.425-12.135 16-19-8.945-9.733-6.951-37.536-1-49 4.002-7.709 9.701-7.413 10-20-1.92-3.022-0.071-8.604-1-13-4.383-20.75 3.273-47.552 9-63 19.8-53.421 53.712-90.466 105-112 11.986-5.033 25.833-7.783 39-11 5.322-1.3 11.969 0.518 16-2z" fill="#FFFFFF" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M749.61196492 908.06119793C749.61196492 560.41848146 463.58151854 274.36328126 115.93880207 274.36328126V115.93880207c434.50388795 0 792.12239584 357.61850789 792.12239586 792.12239586zM224.55858562 690.72261555a108.91682943 108.91682943 0 0 1 108.69404499 108.74355267C333.25263061 859.29616292 284.24005737 908.06119793 224.31104736 908.06119793 164.48105265 908.06119793 115.96355592 859.41993206 115.96355592 799.46616822s48.69077351-108.71879883 108.61978351-108.74355267zM641.01693522 908.06119793h-153.96879069c0-203.60020956-167.50913289-371.13409627-371.10934246-371.13409629v-153.96879068c288.03550619 0 525.07813313 237.11688843 525.07813315 525.10288697z" fill="#FFA500" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M583.60666667 972h-68.08c-8.43333333 0-15.33333333-6.9-15.33333334-15.33333333V609.52c0-8.43333333 6.9-15.33333333 15.33333334-15.33333333h68.08c8.43333333 0 15.33333333 6.9 15.33333333 15.33333333V956.66666667c0 8.43333333-6.9 15.33333333-15.33333333 15.33333333z" fill="#629FF9" ></path><path d="M294.42 167c-113.62 0-205.77333333 92-205.77333333 205.31333333v336.72h411.39333333V372.31333333c0.15333333-113.31333333-92-205.31333333-205.62-205.31333333z" fill="#2166CC" ></path><path d="M519.97333333 627H216.98666667c-25.45333333 0-46-20.54666667-46-46V393.78c0-25.45333333 20.54666667-46 46-46h302.98666666c25.45333333 0 46 20.54666667 46 46V581c0 25.45333333-20.54666667 46-46 46z" fill="#D2E4FF" ></path><path d="M565.97333333 397a49.22 49.22 0 0 0-49.37333333-49.22H220.36c-27.29333333 0-49.37333333 22.08-49.37333333 49.22v10.27333333l179.4 94.60666667c11.34666667 5.98 24.84 5.98 36.18666666 0l179.4-94.60666667v-10.27333333z" fill="#FFFFFF" ></path><path d="M730.5 167h-427.8v0.46c109.78666667 4.29333333 197.49333333 94.3 197.49333333 205.00666667v336.72h411.39333334c27.29333333 0 49.37333333-22.08 49.37333333-49.22V397c0-126.96-103.19333333-230-230.46-230z" fill="#4E8DF6" ></path><path d="M845.80666667 52H681.12666667c-9.04666667 0-16.40666667 7.36-16.40666667 16.40666667v336.72a24.67133333 24.67133333 0 1 0 49.37333333 0V134.18666667h131.71333334c9.04666667 0 16.40666667-7.36 16.40666666-16.40666667V68.40666667c0-9.04666667-7.36-16.40666667-16.40666666-16.40666667z" fill="#2166CC" ></path><path d="M896.25333333 659.81333333h-35.11333333c-8.43333333 0-15.33333333-6.9-15.33333333-15.33333333v-35.11333333c0-8.43333333 6.9-15.33333333 15.33333333-15.33333334h35.11333333c8.43333333 0 15.33333333 6.9 15.33333334 15.33333334v35.11333333c0 8.58666667-6.9 15.33333333-15.33333334 15.33333333z" fill="#FFFFFF" ></path><path d="M88.8 709.18666667l-24.22666667 131.40666666c-9.66 54.43333333 26.83333333 98.59333333 81.26666667 98.59333334h213.9c54.58666667 0 106.56666667-44.16 116.22666667-98.59333334l23.15333333-131.40666666H88.8z" fill="#2974CE" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1049 1024"><path d="M523.6581816 52C262.83923907 52 52 262.8401375 52 523.6581816c0 208.49703047 135.09433812 384.97758117 322.50789391 447.44906532 23.42658172 4.68531653 32.01647887-10.15136894 32.01647796-22.64584583 0-10.93210574-0.78163433-48.41463703-0.78163433-87.45953855-131.18885996 28.11189824-158.5200223-56.22379738-158.52002231-56.22379739-21.08437312-54.66232469-52.3201152-68.71827336-52.3201152-68.71827335-42.94858371-28.89353348 3.12384382-28.89353348 3.12384384-28.89353348 47.63479867 3.12384382 72.62285398 48.41643391 72.62285398 48.4164339 42.16784782 71.84121875 110.10538527 51.53758242 137.43654672 39.04400399 3.90457972-30.45500618 16.3990566-51.5393793 29.67427028-63.25222094-104.64023039-10.93300418-214.74561566-51.53848086-214.74561657-232.70524742 0-51.53848086 18.74126609-93.70632867 48.4164339-126.50444187-4.68621496-11.71284164-21.08527156-60.12837711 4.6844181-124.94207075 0 0 39.82563922-12.49447688 129.62738726 48.41463704 37.48253129-10.15136894 78.08980484-15.61742227 117.91454562-15.61742137s80.43201433 5.46605242 117.91454473 15.61742137c89.80264648-60.90911391 129.62828571-48.41463703 129.62828571-48.41463704 25.76879122 64.81369363 9.37063305 113.22922911 4.68531651 124.94207075 30.45410773 32.79721477 48.41463703 74.96506258 48.41463703 126.50444187 0 181.16676656-110.10538527 220.99150644-215.52545401 232.70524742 17.1797934 14.83668547 32.01647887 42.94858371 32.01647886 87.45953946 0 63.25222094-0.78163433 114.009965-0.78163523 129.62738636 0 12.49447688 8.59079468 27.33116234 32.01737731 22.64584583 187.41265734-62.4705866 322.50699547-238.95203574 322.50699546-447.44996375C995.31636231 262.8401375 783.69369203 52 523.6581816 52z" fill="#663399" ></path><path d="M230.82365863 729.03136735c-0.7807359 2.34310703-4.68531653 3.12384382-7.80916035 1.56237113s-5.46605242-4.68531653-3.90368129-7.02842356c0.7807359-2.34220859 4.68531653-3.12384382 7.80826192-1.56147269s4.68531653 4.68531653 3.90457972 7.02752512z m18.7412661 21.08437312c-2.34220859 2.34220859-7.02752512 0.78163433-9.37063305-2.34310703-3.12294539-3.12294539-3.90457972-7.80826192-1.5614727-10.15136894 2.34220859-2.34220859 6.24678922-0.7807359 9.37063305 2.34310702 3.12384382 3.90457972 3.90457972 8.58899782 1.5614727 10.15136895zM268.30618992 777.44690281c-3.12294539 2.34220859-7.80826192 0-10.15136895-3.90457972-3.12384382-3.90457972-3.12384382-9.37063305 0-10.93210574 3.12384382-2.34310703 7.80916035 0 10.15226739 3.90457972 3.12294539 3.90368129 3.12294539 8.58899782 0 10.93210574z m25.76968965 26.55042555c-2.34220859 3.12294539-7.80916035 2.34220859-12.49447688-1.56237113-3.90457972-3.90368129-5.46605242-9.37063305-2.34220859-11.71284164 2.34220859-3.12384382 7.80826192-2.34310703 12.49447687 1.56147269 3.90368129 3.12384382 4.68531653 8.58989625 2.3422086 11.71374008z m35.1403227 14.83668637c-0.78163433 3.90457972-6.24768766 5.46605242-11.71374008 3.90457972-5.46605242-1.5614727-8.58899782-6.24768766-7.80916036-9.37063305 0.78163433-3.90457972 6.24768766-5.46605242 11.71374009-3.90457972 5.46605242 1.5614727 8.58899782 5.46605242 7.80916035 9.37063305z m38.26416562 3.12384382c0 3.90457972-4.68621496 7.02752512-10.15226738 7.02752512-5.46605242 0-10.15226738-3.12294539-10.15226739-7.02752512s4.68621496-7.02842356 10.15226739-7.02842445c5.46605242 0 10.15226738 3.12384382 10.15226738 7.02842445z m35.92016106-6.24768766c0.78163433 3.90457972-3.12384382 7.80916035-8.58899872 8.58989625-5.46695086 0.78163433-10.15226738-1.5614727-10.93390172-5.46605241-0.77983747-3.90457972 3.12384382-7.80916035 8.5907947-8.58899872 5.46605242-0.78163433 10.15136894 1.56057426 10.93210574 5.46515488z m0 0" fill="#663399" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M832.61667555 181.33447111h-164.32545185l74.45617778-74.45617778c12.84020148-12.84020148 12.84020148-30.8140563 0-43.65425778-12.84020148-12.84020148-30.8140563-12.84020148-43.65425778 0L573.2882963 189.04101925H450.04420741L324.2272237 63.23617185c-10.26730667-12.84020148-25.68040297-15.40096-41.08136295-7.70654815-2.57289482 0-2.57289482 2.57289482-5.13365334 5.13365333-12.84020148 12.84020148-12.84020148 30.8140563 0 43.65425779l77.02907259 77.02907259h-164.32545185c-89.86927408 0-164.32545185 74.45617778-164.32545185 164.32545184v408.24073483c0 87.29637925 74.45617778 161.75255703 164.32545185 161.75255703h25.68040296c0 30.8140563 25.68040297 53.92156445 53.92156444 53.92156444s53.92156445-25.68040297 53.92156445-53.92156444H704.23893333c2.57289482 30.8140563 28.24116148 53.92156445 59.05521778 51.34866964 28.24116148-2.57289482 48.78791111-23.10750815 51.34866964-51.34866964h20.53461333c89.86927408 0 164.32545185-74.45617778 164.32545184-164.32545186V343.09916445c-2.56075852-89.86927408-77.02907259-161.76469333-166.88621037-161.76469334z m-5.13365333 634.19429926H200.99527111c-33.37481482 0-59.05521778-28.24116148-61.61597629-61.61597629l-2.57289482-415.94728297c0-33.37481482 28.24116148-61.6159763 61.6159763-61.61597629h626.48775111c33.37481482 0 59.05521778 28.24116148 61.61597629 61.61597629l2.57289482 415.94728297c-2.57289482 35.93557333-28.24116148 61.6159763-61.6159763 61.61597629z" fill="#ff7299" ></path><path d="M403.82919111 417.55534222l15.40096 77.0290726-205.40681481 38.50846815-15.40096-77.0290726 205.40681481-38.50846815z m197.70026667 77.0290726l15.40096-77.0290726 205.40681481 38.50846815-15.40096 77.0290726-205.40681481-38.50846815z m41.08136297 161.75255703c0 2.57289482 0 7.70654815-2.57289483 10.26730667-12.84020148 28.24116148-41.08136297 46.2150163-74.45617777 48.78791111-20.53461333 0-41.08136297-10.26730667-53.92156445-25.68040296-15.40096 15.40096-33.37481482 25.68040297-53.92156445 25.68040296-30.8140563-2.57289482-59.05521778-20.53461333-74.45617777-48.78791111 0-2.57289482-2.57289482-5.13365333-2.57289481-10.26730667 0-10.26730667 7.70654815-17.97385482 17.97385481-20.53461333h2.57289482c7.70654815 0 12.84020148 2.57289482 15.40096 10.26730666 0 0 20.53461333 28.24116148 38.50846815 28.24116149 35.94770963 0 35.94770963-30.8140563 56.48232296-53.92156445 23.10750815 25.68040297 23.10750815 53.92156445 56.48232296 53.92156445 23.10750815 0 38.50846815-28.24116148 38.50846815-28.24116149 2.57289482-5.13365333 10.26730667-10.26730667 15.40096-10.26730666 10.26730667-2.57289482 17.97385482 5.13365333 20.53461333 15.40096v5.13365333h0.0364089z" fill="#ff7299" ></path></symbol></svg>',        o = (o = document.getElementsByTagName("script"))[o.length - 1].getAttribute("data-injectcss"),        p = function (c, l) {            l.parentNode.insertBefore(c, l);        };    if (o && !c.__iconfont__svg__cssinject__) {        c.__iconfont__svg__cssinject__ = !0;        try {            document.write(                "<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>"            );        } catch (c) {            console && console.log(c);        }    }    function d() {        i || ((i = !0), a());    }    function m() {        try {            t.documentElement.doScroll("left");        } catch (c) {            return void setTimeout(m, 50);        }        d();    }    (l = function () {        var c,            l = document.createElement("div");        (l.innerHTML = v),            (v = null),        (l = l.getElementsByTagName("svg")[0]) &&        (l.setAttribute("aria-hidden", "true"),            (l.style.position = "absolute"),            (l.style.width = 0),            (l.style.height = 0),            (l.style.overflow = "hidden"),            (l = l),            (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l));    }),        document.addEventListener            ? ~["complete", "loaded", "interactive"].indexOf(document.readyState)            ? setTimeout(l, 0)            : ((h = function () {                document.removeEventListener("DOMContentLoaded", h, !1), l();            }),                document.addEventListener("DOMContentLoaded", h, !1))            : document.attachEvent &&            ((a = l),                (t = c.document),                (i = !1),                m(),                (t.onreadystatechange = function () {                    "complete" == t.readyState && ((t.onreadystatechange = null), d());                }));})(window);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.js"/>
      <url>/js/runtime/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    var t = new Date("03/29/2023 00:00:00");    now.setTime(now.getTime() + 250);    var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a,        r = Math.floor(n);    1 == String(r).length && (r = "0" + r);    var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s);    1 == String(i).length && (i = "0" + i);    var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o);    1 == String(l).length && (l = "0" + l);    let g = "";    g = r < 18 && r >= 9        ? `<br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>` : `<br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g)}setInterval((() => {    createtime()}), 250);]]></content>
      
    </entry>
    
    
  
</search>
