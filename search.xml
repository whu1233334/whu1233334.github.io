<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于一阶线性微分方程绝对值问题</title>
      <link href="/undefined/10a45d8c.html"/>
      <url>/undefined/10a45d8c.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>在做某些微分方程问题时，有些题目的标准答案要加上绝对值，有些又不用加。按理说凡是涉及 ln 的我全加上就好了，但是加上绝对值又不便下一步计算，为此特地查阅一些资料，将考研数学微分方程中绝对值相关问题整理记录。</p><h1 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h1><p>开头提到的微分方程中绝对值问题其实本质上就是不定积分中对 <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021805380.png" alt="image.png">中绝对值的去留问题。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021806141.png" alt="image.png"></p><h1 id="分析与讨论"><a href="#分析与讨论" class="headerlink" title="分析与讨论"></a>分析与讨论</h1><p>对于<strong>例1</strong>很好分析，我们按照常规方式来求解。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021807007.png" alt="图片alt"> </p><p>此时由于 y= ±e<sup>C<sub>1</sub></sup>|x|，而如果我们令 ±e<sup>C<sub>1</sub></sup> =C<sub>2</sub>，此时上式可以写为 y=C<sub>2</sub>x，也就是说绝对值可以去掉，且C<sub>2</sub>≠0。<br>但是上述讨论不具有一般性，不够严谨，我们还可以通过判断<strong>函数族</strong>是否相同的方式来判断两个解函数是否为相等。<br><strong><em>那么现在问题描述如下：</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021815711.png" alt="image.png"></p><p>如此一来对于经过积分运算，得到形如 (1) 式的微分方程的通解，是否去掉绝对值，取决于我们的选择，若去掉绝对值（即表示为 (2) 式的形式）则需要先将对数函数变为指数函数，再更改C<sub>2</sub>的范围由任意常数到非零常数。</p><p>对于<strong>例2</strong>，求得的通解形式为 ln|y|<sup>2</sup> = ln|x| + C ,此时取对数y<sup>2</sup> = e<SUP>C&lt;/sup&gt;|x|，显然绝对值是无法直接去掉的</p><p>但是对于<strong>例3</strong>却并不能用上述结论，因为一阶线性微分方程的解</p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021824603.png" alt="图片alt"> </p><br>的函数族不同于 (1) 式确定的函数族。那么当我们遇到 这种情况，绝对值是否可以省？</p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021826510.png" alt="图片alt"> </p><br>下面经过分类讨论来证明 (6) 式中 e 右上角的对数函数内的绝对值符号可以省去，不影响一阶线性微分方程的解。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830584.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309021830314.png" alt="image.png"><br>所以<strong>例3</strong>中的绝对值可以去掉。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>对形如 l n ∣ g ( x , y ) ∣ = φ ( x , y ) + C 的微分方程，可以通过变对数为指数，同时改变常数​C<sub>2</sub>的取值范围来去掉绝对值。对一阶线性微分方程通解同时，可以对 e 的右上角的指数同时去绝对值。</p>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线代强化</title>
      <link href="/undefined/df063bf9.html"/>
      <url>/undefined/df063bf9.html</url>
      
        <content type="html"><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p><mark>主对角线与副对角线矩阵的值</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：主对角线的矩阵的值等于对角线元素相乘，而副对角线矩阵的值等于-1<sup>n(n-1)/2 </sup>a<sub>1,n </sub>a<sub>2,n-1 </sub>a<sub>3,n-2</sub>....a<sub>n,1</sub></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt=""></p><p><mark>含有x的行列式的求导数，等于逐行求导，相加</mark></p><div style="background-color: #fffacd;padding:20px;"> 证明过程很简单，不过不重要</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241044514.png" alt="Uploading file...x8n1s"></p><p><mark>爪型行列式的计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：爪型行列式的特点是，只有第一行，第一列全部不为0，像一个箭头，这种行列式转化为上三角或下三角矩阵</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241112575.png" alt="image.png"></p><p><mark>“么”型行列式计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 么型行列式按照，展开""么"那一“横”，计算就十分简单</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241130123.png" alt="image.png"></p><p><mark>加边法计算行列式</mark></p><div style="background-color: #fffacd;padding:20px;"> "加边法"适合<font color="#FF0000">有规律的数</font>当加一行可以消去很多的行时，可以用加边法</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241136486.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241137978.png" alt="image.png"></p><p><mark style="background-color: #FFB6C1;">梭型行列式计算</mark></p><div style="background-color: #fffacd;padding:20px;"> 按照第一行展开D<sub>n</sub>=4D<sub>n-1</sub> - 3D<sub>n-2</sub> 得到 D<sub>n</sub>-D<sub>n-1</sub>=3(D<sub>n-1</sub> - D<sub>n-2</sub>) 。递推得到<br>D<sub>n</sub>-D<sub>n-1</sub>=3<sup></sup>(D<sub>n-1</sub>- D<sub>n-2</sub>)<br>D<sub>n-1</sub>-D<sub>n-2</sub>=3<sup></sup>(D<sub>n-2</sub>- D<sub>n-3</sub>)<br>.......<br>D<sub>3</sub>- D<sub>2</sub>=3<sup></sup>(D<sub>2</sub>- D<sub>1</sub>)<br><font color="#FF0000">所以D<sub>n</sub>-D<sub>n-1</sub>=3<sup>n-2</sup>(D<sub>2</sub> - D<sub>1</sub>)=3<sup>n</sup></font><br>D<sub>n</sub>-D<sub>n-1</sub>=3<sup>n</sup><br>D<sub>n-1</sub>-D<sub>n-2</sub>=3<sup>n-1</sup><br>.......<br>D<sub>3</sub>- D<sub>2</sub>=3<sup>3</sup><br>D<sub>2</sub>- D<sub>1</sub>=3<sup>2</sup><br><font color="#FF0000">等比数列相加得D<sub>n</sub> - D<sub>1</sub> 即可计算出D<sub>n</sub> </font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241237733.png" alt=""></p><h1 id="矩阵的基本运算"><a href="#矩阵的基本运算" class="headerlink" title="矩阵的基本运算"></a>矩阵的基本运算</h1><p><mark>错误命题</mark></p><div style="background-color: #fffacd;padding:20px;"> 倒推并不成立，下面是一个反例</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241530903.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241532838.png" alt="image.png"></p><p><mark>坍缩矩阵</mark> </p><font color="#FF0000">坍缩矩阵每次与自己相乘，有效信息都会被往外挤一次</font><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241645861.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;">利用坍缩矩阵性质求下列问题？</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241645221.png" alt="image.png"></p><p><mark>秩为1的矩阵</mark></p><div style="background-color: #fffacd;padding:20px;">矩阵秩为1，对应每一行都成比例，有下面这样的一个结论 <br><center>A<sup>n</sup>= <cite>l</cite><sup>n-1</sup>A </center><li><cite>l</cite> 是A对角线元素之和</li></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308241650052.png" alt="image.png"></p><p><mark>求一个矩阵与另一个矩阵的逆矩阵相乘AP<sup>-1</sup></mark></p><div style="background-color: #fffacd;padding:20px;">已知矩阵A、P但是P的逆矩阵未知，所以可以先求出P<sup>-1</sup>,再矩阵相乘。不过更好的方法是将P/A 竖的写在一起，将P通过列变换为E ,对于A来说，相当于乘了一个P<sup>-1</sup>,那么A就变成了B</div><p><mark>结论A<sup>T</sup>+B<sup>T</sup>= (A+B)<sup>T</sup></mark></p><p><mark style="background-color: #FFB6C1;">向量的线性组合写成矩阵的乘法，</mark></p><div style="background-color: #ffe599;padding:15px;"> B是A的线性组合，写成两矩阵相乘形式，可以直观分离出矩阵A和所做的线性变换</div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242056948.png" alt="Uploading file...q2o0q"></p><p><mark>伴随矩阵的重要性质</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>A<sup>*</sup>A=AA<sup>*</sup>=|A| E  <mark style="background-color: #FFB6C1;">=></mark> A<sup>*</sup>= |A| A<sup>-1</sup></li><li>伴随矩阵的秩  n  、1 、 0</li></div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242119009.png" alt="image.png"></p><p><mark>抽象矩阵求逆</mark> <mark style="background-color: #FFB6C1;">有难度</mark></p><div style="background-color: #fffacd;padding:20px;"> 抽象矩阵求逆，题目中要求 (A+E)<sup>-1</sup><br>必然需要能通过题目得到一个等式 (A+E)(....)=E<br><li>(...)里的必然与A有关，相乘必然得到A<sup>2</sup>,所以先求A<sup>2</sup></li><li>求出A<sup>2</sup>-4A=-3E，利用多项式除法凑出括号里的因式</li></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242151041.png" alt="image.png"></p><p><mark>综合表</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308242202685.png" alt="image.png"></p><h1 id="初等矩阵、秩、分块矩阵"><a href="#初等矩阵、秩、分块矩阵" class="headerlink" title="初等矩阵、秩、分块矩阵"></a>初等矩阵、秩、分块矩阵</h1><p><mark>初等矩阵</mark>是<mark>单位矩阵</mark>经过<mark>一次初等变化后得到的矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> <li>初等对换矩阵E<sub>i,j</sub> : 由单位矩阵，交换i,j行或列得到</li><li>初等倍乘矩阵E<sub>i</sub>(k) ：由单位矩阵，第i行或列乘k倍得到(k!=0)</li><li>初等倍乘矩阵E<sub>i,j</sub>(k)：由单位矩阵，第i行+k*第j行得到 或 第 j列+k*第i列</li><br><mark style="background-color: #FFB6C1;">重要</mark>：E<sub>i,j</sub>(k)A是对A做 行变化；AE<sub>i,j</sub>(k)是对A做 列变化</div><div style="background-color: #fffacd;padding:20px;"> <li> E<sub>i,j</sub><sup>-1</sup> = E<sub>i,j</sub></li><li>E<sub>i</sub>(k)<sup>-1</sup>=E<sub>i</sub>(1/k)</li><li>E<sub>i,j</sub>(k)<sup>-1</sup>=E<sub>i,j</sub>(-k)</li><br><li> E<sub>i,j</sub><sup>T</sup> = E<sub>i,j</sub></li><li>E<sub>i</sub>(k)<sup>T</sup>=E<sub>i</sub>(k)</li><li>E<sub>i,j</sub>(k)<sup>T</sup>=E<sub>j,i</sub>(k)</li></div><p><mark>AB=O</mark></p><div style="background-color: #fffacd;padding:20px;">正规证明： 当矩阵A、B相乘得到零矩阵，可以想象A<sub>(mxn)</sub>是系数矩阵，B<sub>(nxm)</sub>是解向量矩阵；<font color="#FF0000">一个齐次线性方程组的线性无关解向量数=n-r(A)</font> <br>简便记忆：标准型记忆法</div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281134787.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281241592.png" alt="图片alt"> </p><p><strong>例题</strong>：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281240608.png" alt="image.png"></p><p><mark>重要结论：r(AA<sup>T</sup>)=r(A<sup>T</sup>A)=r(A)</mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281150001.png" alt="图片alt"> </p><p><mark style="background-color: #FFB6C1;">分块矩阵的结论</mark></p><div style="background-color: #fffacd;padding:20px;"> 合理利用矩阵分块，将矩阵分块成更小的方阵，可以简便计算</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281311896.png" alt="image.png"></p><p><mark style="background-color: #FFB6C1;">二阶矩阵的逆矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> 主 对调；副 变号</div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281407149.png" alt="图片alt"> </p><p><mark>左行右列，BA=C</mark></p><div style="background-color: #fffacd;padding:20px;"> 将矩阵B看做一种线性变换。<br>BA可由 A经过B行变换得到；<br>但是反过来A不一定可由BA经过B<sup>-1</sup>行变换得到，因为B不一定可逆。<br>所以下面这个式子中，BA可以被上面的A经过行变换后逐项消去</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281449983.png" alt="image.png"></p><p><strong>例题</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281624716.png" alt="image.png"></p><h1 id="向量组"><a href="#向量组" class="headerlink" title="向量组"></a>向量组</h1><p><mark>向量组等价</mark></p><div style="background-color: #fffacd;padding:20px;"> 矩阵等价，只需要两矩阵秩相等；<br>向量组等价，需要两向量组A: α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>...α<sub>n</sub>与向量组B：β<sub>1</sub>,β<sub>2</sub>,β<sub>3</sub>...β<sub>m</sub>,可以互相线性表示，也就是r(A,B)=r(A)=r(B),对于A来说B的任何一个向量加入都是混子，对于B来说A的任何一个向量加入都是混子</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308281954916.png" alt="image.png"></p><p><mark>问题：已知α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>线性无关，判断下列是否线性无关？</mark></p><div style="background-color: #ffe599;padding:15px;"> 请判断α<sub>1</sub>+α<sub>2</sub>+α<sub>3</sub>，α<sub>1</sub>+2α<sub>2</sub>-3α<sub>3</sub>，α<sub>1</sub>+5α<sub>3</sub>是否线性无关？<br><br><font color="#FF0000">思路1：</font>凑系数k1,k2,k3，当只有k1,k2,k3全为0时才满足k1(α<sub>1</sub>+α<sub>2</sub>+α<sub>3</sub>)+k2(α<sub>1</sub>+2α<sub>2</sub>-3α<sub>3</sub>)+k3(α<sub>1</sub>+5α<sub>3</sub>)=0,这时向量组就是线性无关的，都是无法相互消去的<br><br><font color="#FF0000">思路2：</font>像这种比较难凑，写成矩阵相乘，将线性变换用矩阵写出，然后根据r(α<sub>1</sub>,α<sub>2</sub>,α<sub>3</sub>)=3，所以相乘矩阵的秩=后面的线性变换矩阵的秩，计算行列式，如果不等于0，说明满秩，从而向量组线性无关</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308282128367.png" alt="image.png"></p><p><mark>用定义法证明向量组线性无关</mark> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291034365.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;">解：令k<sub>1</sub>α<sub>1</sub>+k<sub>2</sub>α<sub>2</sub>+k<sub>3</sub>α<sub>3</sub>=0 ① <br><center>两边同乘A</center>    k<sub>1</sub>Aα<sub>1</sub> + k<sub>2</sub>Aα<sub>2</sub> + k<sub>3</sub>Aα<sub>3</sub>= k<sub>1</sub>α<sub>1</sub> + k<sub>2</sub>(α<sub>1</sub> + α<sub>2</sub>) + k<sub>3</sub>(α<sub>2</sub>+α<sub>3</sub>)=0  ②<center>②-①得</center>k<sub>2</sub>α<sub>1</sub> + k<sub>3</sub>α<sub>2</sub>=0 ③ <center>两边再次同乘A</center>k<sub>2</sub>Aα<sub>1</sub> + k<sub>3</sub>Aα<sub>2</sub>= k<sub>2</sub>α<sub>1</sub> + k<sub>3</sub>(α<sub>1</sub>+α<sub>2</sub>) =0 ④ <center>④-③得</center>k<sub>3</sub>α<sub>1</sub>=0，由于α<sub>1</sub>!=0,所以k<sub>3</sub>=0,往回代入，求得k<sub>2</sub>=0，k<sub>1</sub>=0,所以三个向量线性无关</div><mark>求一个向量在以另一组向量作为基底下，的坐标</mark><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291233458.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;">就是求x<sub>1</sub>α<sub>1</sub> + x<sub>2</sub>α<sub>2</sub> + x<sub>3</sub>α<sub>3</sub> = α，α在基底下的坐标就是(x<sub>1</sub>,x<sub>2</sub>,x<sub>3</sub>)<br>1.可以直接列方程解；2.也可以作为非齐次方程求解<br><br><font color="#FF0000">注：一组基，一定是一组线性无关的向量</font></div><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291247167.png" alt="图片alt"> </p><p><mark>过渡矩阵</mark></p><div style="background-color: #fffacd;padding:20px;"> AP=B,则称，A过渡到B的过渡矩阵是P </div><h1 id="线性方程组求解"><a href="#线性方程组求解" class="headerlink" title="线性方程组求解"></a>线性方程组求解</h1><p><mark>典型例题</mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291500199.png" alt="图片alt"> </p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291709453.png" alt="图片alt"> </p><p><mark>若AB=O,则r(A)+r(B)≤n  </mark></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291629673.png" alt="图片alt"> </p><p><mark>典型例题2</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291757672.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308291901198.png" alt="图片alt"> </p></div><p><mark>两个方程有公共解问题</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292048495.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292120045.png" alt="图片alt"> </p></div><p><mark>两个方程组有同解问题</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292156785.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> ①两方程组，同解，那么基础解系个数一定相等，分别求出两线性方程矩阵的秩；<br>②然后再根据其中一个方程，求出解系，代入另外一个方程，使得等式恒成立<br>③求出结果，带回去验证秩是否符合<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308292159880.png" alt="图片alt"> </p></div>]]></content>
      
      
      <categories>
          
          <category> 线代 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构打卡</title>
      <link href="/undefined/11e6645a.html"/>
      <url>/undefined/11e6645a.html</url>
      
        <content type="html"><![CDATA[<h1 id="树的应用"><a href="#树的应用" class="headerlink" title="树的应用"></a><em>树的应用</em></h1><h2 id="二叉树的定义、性质、画图"><a href="#二叉树的定义、性质、画图" class="headerlink" title="二叉树的定义、性质、画图"></a>二叉树的定义、性质、画图</h2><h3 id="总结二叉树的度、树高、结点数等属性之间的关系"><a href="#总结二叉树的度、树高、结点数等属性之间的关系" class="headerlink" title="总结二叉树的度、树高、结点数等属性之间的关系"></a>总结二叉树的度、树高、结点数等属性之间的关系</h3><blockquote><p>通过王道书 5.2.3 课后小题来复习“二叉树的性质”</p></blockquote><h3 id="定义顺序存储的二叉树—下标从1开始"><a href="#定义顺序存储的二叉树—下标从1开始" class="headerlink" title="定义顺序存储的二叉树—下标从1开始"></a><em>定义顺序存储的二叉树—下标从1开始</em></h3><blockquote><p>二叉树顺序存储的数据结构定义，需要注意以下两点：<br> 1 .二叉树的结点用数组存储，每个结点需要标记“是否为空”<br> 2.各结点的数组下标隐含结点关系，要能根据一个结点的数组下标 i，计算出其父节点、左孩子、右孩子的数组下标</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">若顺序二叉树从数组下标1开始存储结点，则：</span><br><span class="line"></span><br><span class="line">● 结点 i 的父结点编号为 i/2</span><br><span class="line">● 结点 i 的左孩子编号为 i*2</span><br><span class="line">● 结点 i 的右孩子编号为 i*2+1</span><br><span class="line"></span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data; <span class="comment">//结点中的数据元素</span></span><br><span class="line"><span class="type">bool</span> isEmpty; <span class="comment">//结点是否为空</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序存储的二叉树，所有结点标记为&quot;空&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqBiTree</span> <span class="params">(TreeNode t[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">   t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现函数，找到结点-i-的父结点、左孩子、右孩子"><a href="#实现函数，找到结点-i-的父结点、左孩子、右孩子" class="headerlink" title="实现函数，找到结点 i 的父结点、左孩子、右孩子"></a><em>实现函数，找到结点 i 的父结点、左孩子、右孩子</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断下标为 index 的结点是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= length || index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//下标超出合法范围</span></span><br><span class="line"><span class="keyword">return</span> t[index].isEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的左孩子，并返回左孩子的下标，如果没有左孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> lChild = index * <span class="number">2</span>; <span class="comment">//如果左孩子存在，则左孩子的下标一定是 index * 2</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, lChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//左孩子为空</span></span><br><span class="line"><span class="keyword">return</span> lChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的右孩子，并返回右孩子的下标，如果没有右孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> rChild = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//如果右孩子存在，则右孩子的下标一定是 index * 2 + 1</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, rChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//右孩子为空</span></span><br><span class="line"><span class="keyword">return</span> rChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的父节点，并返回父节点的下标，如果没有父节点，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFather</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//根节点没有父节点</span></span><br><span class="line"><span class="type">int</span> father = index / <span class="number">2</span>; <span class="comment">//如果父节点存在，则父节点的下标一定是 index/2，整数除法会自动向下取整</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, father)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> father;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用上述三个函数，实现先-中-后序遍历"><a href="#利用上述三个函数，实现先-中-后序遍历" class="headerlink" title="利用上述三个函数，实现先/中/后序遍历"></a><em>利用上述三个函数，实现先/中/后序遍历</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从下标为 index 的结点开始先序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">PreOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">InOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//中序遍历左子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">InOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PostOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//后序遍历左子树</span></span><br><span class="line">PostOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//后序遍历右子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...在空二叉树中插入数据</span></span><br><span class="line"><span class="comment">//...略</span></span><br><span class="line">InOrderSqTree (t, <span class="number">100</span>, <span class="number">1</span>); <span class="comment">//从根节点1出发，进行中序遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义顺序存储的二叉树（从数组下标0开始存储）"><a href="#定义顺序存储的二叉树（从数组下标0开始存储）" class="headerlink" title="定义顺序存储的二叉树（从数组下标0开始存储）"></a><em>定义顺序存储的二叉树（从数组下标0开始存储）</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">与 上面思路相同，只不过结点编号的计算有些区别而已</span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><h3 id="定义链式存储的二叉树"><a href="#定义链式存储的二叉树" class="headerlink" title="定义链式存储的二叉树"></a><em>定义链式存储的二叉树</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##  树的定义、性质、画图</span><br><span class="line"></span><br><span class="line">### *用双亲表示法定义顺序存储的树*</span><br><span class="line">![image.png](https:<span class="comment">//cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231706440.png)</span></span><br><span class="line">###  使用“孩子表示法”，定义链式存储的树（以及森林）</span><br><span class="line">![image.png](https:<span class="comment">//cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231733631.png)</span></span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="comment">//Child表示下一个孩子的信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Child&#123;</span><br><span class="line"><span class="type">int</span> index; <span class="comment">//孩子编号</span></span><br><span class="line"><span class="keyword">struct</span> Child * next; <span class="comment">//下一个孩子</span></span><br><span class="line">&#125; Child;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TreeNode用于保存结点信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> TreeNode &#123;</span><br><span class="line"><span class="type">char</span> data; <span class="comment">//结点信息</span></span><br><span class="line">    Child * firstChild; <span class="comment">//指向第一个孩子</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode tree[<span class="number">10</span>]; <span class="comment">//定义一棵拥有10个结点的树（孩子表示法）</span></span><br></pre></td></tr></table></figure><h3 id="使用“孩子兄弟表示法”，定义链式存储的树（以及森林）"><a href="#使用“孩子兄弟表示法”，定义链式存储的树（以及森林）" class="headerlink" title="使用“孩子兄弟表示法”，定义链式存储的树（以及森林）"></a>使用“孩子兄弟表示法”，定义链式存储的树（以及森林）</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231733226.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">ElemType data;     <span class="comment">//数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span> <span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h2 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h2><h3 id="总结树的度、树高、结点数等属性之间的关系"><a href="#总结树的度、树高、结点数等属性之间的关系" class="headerlink" title="总结树的度、树高、结点数等属性之间的关系"></a>总结树的度、树高、结点数等属性之间的关系</h3><blockquote><p>通过王道书 5.1.4、5.4.4 课后小题来复习“树和森林的性质”</p></blockquote><h2 id="树的定义、性质、画图"><a href="#树的定义、性质、画图" class="headerlink" title="树的定义、性质、画图"></a>树的定义、性质、画图</h2><h2 id="并查集的应用"><a href="#并查集的应用" class="headerlink" title="并查集的应用"></a>并查集的应用</h2><h3 id="实现并查集的数据结构定义，并实现-Union、Find-两个基本操作"><a href="#实现并查集的数据结构定义，并实现-Union、Find-两个基本操作" class="headerlink" title="实现并查集的数据结构定义，并实现 Union、Find 两个基本操作"></a>实现并查集的数据结构定义，并实现 Union、Find 两个基本操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE]; <span class="comment">//用一个数组表示并查集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;SIZE;i++)</span><br><span class="line">        S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Find “查”操作，找x所属集合（返回x所属根结点）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>) <span class="comment">//循环寻找x的根</span></span><br><span class="line">        x=S[x];</span><br><span class="line"><span class="keyword">return</span> x; <span class="comment">//根的S[]小于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Union “并”操作，将两个集合合并为一个</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">   <span class="comment">//要求Root1与Root2是不同的集合</span></span><br><span class="line">   <span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">   <span class="comment">//将根Root2连接到另一根Root1下面</span></span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可采取“小树合并到大树”的策略优化 Union操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Union “并”操作，小树合并到大树</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(S[Root2]&gt;S[Root1]) &#123; <span class="comment">//Root2结点数更少</span></span><br><span class="line">       S[Root1] += S[Root2]; <span class="comment">//累加结点总数</span></span><br><span class="line">       S[Root2]=Root1; <span class="comment">//小树合并到大树</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">S[Root2] += S[Root1]; <span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root1]=Root2; <span class="comment">//小树合并到大树      </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可采取“路径压缩”的策略优化 Find 操作</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Find “查”操作优化，先找到根节点，再进行“压缩路径”</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> root = x;</span><br><span class="line"><span class="keyword">while</span>(S[root]&gt;=<span class="number">0</span>)  root=S[root]; <span class="comment">//循环找到根</span></span><br><span class="line"><span class="keyword">while</span>(x!=root)&#123; <span class="comment">//压缩路径</span></span><br><span class="line"><span class="type">int</span> t=S[x]; <span class="comment">//t指向x的父节点</span></span><br><span class="line">S[x]=root; <span class="comment">//x直接挂到根节点下</span></span><br><span class="line">x=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root; <span class="comment">//返回根节点编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计一个例子，对10个元素-Union"><a href="#设计一个例子，对10个元素-Union" class="headerlink" title="设计一个例子，对10个元素 Union"></a>设计一个例子，对10个元素 Union</h3><p>假设初始长度为 10 （ 0 ～ 9 ）的并查集，按 1-2、3-4、5-6、7-8、 0-5 、1-9、9-3、8-0、4-6 的顺序进行Union操作<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232246922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232247420.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232247735.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232248314.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232248446.png" alt="image.png"></p><h3 id="基于上述例子，进行若干次-Find，并完成“压缩路径”"><a href="#基于上述例子，进行若干次-Find，并完成“压缩路径”" class="headerlink" title="基于上述例子，进行若干次 Find，并完成“压缩路径”"></a>基于上述例子，进行若干次 Find，并完成“压缩路径”</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232249488.png" alt="image.png"></p><h1 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a><em>图的应用</em></h1><h2 id="图数据结构的定义"><a href="#图数据结构的定义" class="headerlink" title="图数据结构的定义"></a><em>图数据结构的定义</em></h2><h3 id="写代码：定义一个顺序存储的图（邻接矩阵实现）"><a href="#写代码：定义一个顺序存储的图（邻接矩阵实现）" class="headerlink" title="写代码：定义一个顺序存储的图（邻接矩阵实现）"></a>写代码：定义一个顺序存储的图（邻接矩阵实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                  <span class="comment">//顶点最大数目</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> Vex[MaxVertexNum];               <span class="comment">//顶点</span></span><br><span class="line"><span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//边</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum;                    <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h3 id="写代码：定义一个链式存储的图（邻接表实现）"><a href="#写代码：定义一个链式存储的图（邻接表实现）" class="headerlink" title="写代码：定义一个链式存储的图（邻接表实现）"></a>写代码：定义一个链式存储的图（邻接表实现）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> vexIndex;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="type">int</span> weight;            <span class="comment">//该弧的权值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;  <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">VNode vex[N]       <span class="comment">//N个顶点</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum; <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph;              <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br></pre></td></tr></table></figure><h3 id="自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权无向图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231819084.png" alt="image.png"></p><h3 id="自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权有向图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231820810.png" alt="image.png"></p><h2 id="图的应用：最小生成树"><a href="#图的应用：最小生成树" class="headerlink" title="图的应用：最小生成树"></a><em>图的应用：最小生成树</em></h2><h3 id="自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子"><a href="#自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子" class="headerlink" title="自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子"></a>自己设计一个不少于6个结点的带权无向连通图，并画出其邻接矩阵、邻接表的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231830567.png" alt="image.png"></p><h3 id="基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"><a href="#基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价" class="headerlink" title="基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"></a>基于上述无向连通图，使用Prim算法生成MST，画出算法执行过程的示意图，并计算MST的总代价</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从顶点0开始，运行 Prim 算法的过程如下：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231834367.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从顶点7开始，运行 Prim 算法的过程如下。这里想强调的是：当同时有两个代价相同的顶点时，优先将编号小的顶点加入MST。如：第 1 轮从顶点7出发，与其相连的顶点3、顶点5代价都是最小的，优先选择编号更小的顶点3。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231835740.png" alt="image.png"></p><h3 id="基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"><a href="#基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价" class="headerlink" title="基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价"></a>基于上述无向连通图，使用Kruskal算法生成MST，画出算法执行过程的示意图，并计算MST的总代价</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231837287.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Kruskal 算法的执行过程是：先将各条边按照权值递减的排序，再按顺序依次检查是否将这些边加入MST。各条边排序结果如下：</span><br><span class="line"></span><br><span class="line">( 2 ,4 ) ——权值 1</span><br><span class="line"></span><br><span class="line">( 2, 5 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 3, 7 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 5, 7 ) ——权值 3</span><br><span class="line"></span><br><span class="line">( 0, 3 ) ——权值 5</span><br><span class="line"></span><br><span class="line">( 6, 7 ) ——权值 5</span><br><span class="line"></span><br><span class="line">( 5, 6 ) ——权值 6</span><br><span class="line"></span><br><span class="line">( 1, 2 ) ——权值 9</span><br><span class="line"></span><br><span class="line">可见，当多条边的权值相同时，“起点”编号更小的边排在前面。因此，在Kruskal算法的第2轮中，虽然有3条边 (2,5) (3,7) (5,7) 的权值都是最小的，但算法会优先选择将排序靠前的 (2,5) 加入MST。</span><br></pre></td></tr></table></figure><h2 id="图的应用：最短路径"><a href="#图的应用：最短路径" class="headerlink" title="图的应用：最短路径"></a><em>图的应用：最短路径</em></h2><h3 id="基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程"><a href="#基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程" class="headerlink" title="基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程"></a>基于你设计的带权有向图，从某一结点出发，执行Dijkstra算法求单源最短路径。用文字描述每一轮执行的过程</h3><blockquote><p>下面将从顶点1出发，执行 Dijkstra 算法<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232118172.png" alt="image.png"></p></blockquote><p>注1：如果题目让你描述迪杰斯特拉算法的执行过程，可以试着模仿王道书画一张表。如下所示。你会发现这个表画起来很崩溃，复杂的飞起。相信我，老师改卷也不愿意改这么复杂的答案。因此，考场上不太可能让你画这么复杂的表。</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>顶点（这一列不包含起点）</td><td>第 1 轮</td><td>第 2 轮</td><td>第 3 轮</td><td>第 4 轮</td><td>第 5 轮</td><td>第 6 轮</td><td>第 7 轮</td></tr><tr><td>0</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td></tr><tr><td>2</td><td>4<br><br>1→2</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>3</td><td>∞</td><td>∞</td><td>7<br><br>1→5→3</td><td>7<br><br>1→5→3</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>4</td><td>∞</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>13<br><br>1→2→4</td><td>已完成</td><td>已完成</td></tr><tr><td>5</td><td>5<br><br>1→5</td><td>5<br><br>1→5</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>6</td><td>5<br><br>1→6</td><td>5<br><br>1→6</td><td>5<br><br>1→6</td><td>已完成</td><td>已完成</td><td>已完成</td><td>已完成</td></tr><tr><td>7</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>∞</td><td>14<br><br>1→2→4→7</td><td>已完成</td></tr><tr><td>集合S</td><td>{1, 2}</td><td>{1,2,5}</td><td>{1,2,5,6}</td><td>{1,2,5,6,3}</td><td>{1,2,5,6,3,4}</td><td>{1,2,5,6,3,4,7}</td><td>{1,2,5,6,3,4,7,0}</td></tr></tbody></table></div><p>注2：以下是一种更适合考试的“简洁答题方法”。自己打草稿，快速确定每一轮Dijkstra算法的运行结果，然后按下面这种方式答题到试卷上。</p><blockquote><p>答：<br>从顶点1出发，运行迪杰斯特拉算法的过程如下：<br>第一轮：顶点1到2的最短路径为 1→2，距离为4<br>第二轮：顶点1到5的最短路径为 1→5，距离为5<br>第三轮：顶点1到6的最短路径为 1→6，距离为5<br>第四轮：顶点1到3的最短路径为 1→5→3，距离为7<br>第五轮：顶点1到4的最短路径为 1→2→4，距离为13<br>第六轮：顶点1到7的最短路径为 1→2→4→7，距离为14<br>第七轮：不存在顶点1到0的路径，距离为∞</p></blockquote><h2 id="图的应用：拓扑排序"><a href="#图的应用：拓扑排序" class="headerlink" title="图的应用：拓扑排序"></a><em>图的应用：拓扑排序</em></h2><h3 id="自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子"><a href="#自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子" class="headerlink" title="自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子"></a>自己设计一个不少于6个结点的带权有向无环图，并画出其邻接矩阵的样子</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231849895.png" alt="image.png"></p><h3 id="用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储"><a href="#用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储" class="headerlink" title="用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储"></a>用一维数组将你设计的有向无环图的邻接矩阵进行压缩存储</h3><p><em>注：有向无环图，一定可以转化为一个上三角或下三角矩阵。但是需要调整顶点的编号。</em><br><em>如果要用上三角矩阵表示有向无环图的邻接矩阵，<strong>可以对图进行拓扑排序，按照拓扑排序序列，重新调整各个顶点的编号。这样可以确保，所有的弧都是从小编号顶点指向大编号顶点，从而也就保证了邻接矩阵可以转化为“上三角矩阵”</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231852642.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231851554.png" alt="image.png"></p><p>“上三角矩阵”可以按行优先压缩存储，如下所示：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231852474.png" alt="image.png"></p><h3 id="基于你设计的带权有向无环图，写出所有合法的拓扑排序序列"><a href="#基于你设计的带权有向无环图，写出所有合法的拓扑排序序列" class="headerlink" title="基于你设计的带权有向无环图，写出所有合法的拓扑排序序列"></a>基于你设计的带权有向无环图，写出所有合法的拓扑排序序列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231854808.png" alt="image.png"></p><p>拓扑排序序列1：0,1,2,3,4,5,6,7</p><p>拓扑排序序列2：0,1,2,3,5,4,6,7</p><p>拓扑排序序列3：0,1,2,4,3,5,6,7</p><p>拓扑排序序列4：0,1,4,2,3,5,6,7</p><h3 id="文字描述：拓扑排序的过程"><a href="#文字描述：拓扑排序的过程" class="headerlink" title="文字描述：拓扑排序的过程"></a>文字描述：拓扑排序的过程</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231854579.png" alt="image.png"></p><h2 id="图的应用：关键路径"><a href="#图的应用：关键路径" class="headerlink" title="图的应用：关键路径"></a><em>图的应用：关键路径</em></h2><h3 id="基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度"><a href="#基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度" class="headerlink" title="基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度"></a>基于你设计的带权有向无环图，写出所有合法的关键路径，并算出关键路径总长度</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231856300.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用手算的方式求关键路径，就是要找到从起点到终点的所有路径中最长的那条。</span><br><span class="line"></span><br><span class="line">在上面这个图中，起点是0，终点是7，从0到7最长的路径是 0→1→2→3→5→6→7，关键路径总长度为 25</span><br></pre></td></tr></table></figure><h3 id="文字描述：关键路径总长度的现实意义是什么？"><a href="#文字描述：关键路径总长度的现实意义是什么？" class="headerlink" title="文字描述：关键路径总长度的现实意义是什么？"></a>文字描述：关键路径总长度的现实意义是什么？</h3><p>AOE网可以表示一个项目，每个顶点表示事件，每个有向边表示活动。关键路径的总长度为25，意味着从启动项目到完成该项目，时间开销至少需要25。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231858516.png" alt="image.png"></p><h1 id="查找算法的分析和应用"><a href="#查找算法的分析和应用" class="headerlink" title="查找算法的分析和应用"></a>查找算法的分析和应用</h1><blockquote><p>考研大纲中，要求我们掌握的查找算法是：</p></blockquote><ol><li>顺序查找</li><li>分块查找</li><li>折半查找</li><li>树形查找（二叉查找树、平衡二叉树、红黑树）</li><li>B树</li><li>散列查找</li><li>字符串的模式匹配</li></ol><p>其中，顺序查找过于简单，不可能在应用题中专门考察；红黑树、B树难度较大，也不太可能在应用题中专门考察；字符串的模式匹配通常以小题考察为主。因此，在应用题中最有可能专门考察的是 分块查找、折半查找、二叉查找树、平衡二叉树、散列查找。其中，二叉查找树、平衡二叉树的可能考法已在本文档的 3.6 有详细介绍。接下来我们主要训练 分块查找、折半查找、散列查找在应用题中的可能考法</p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><h3 id="自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引"><a href="#自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引" class="headerlink" title="自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引"></a>自己设计一个分块查找的例子，不少于15个数据元素，并建立分块查找的索引</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232009538.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><font color="FF0000">上图中，共有15个元素，计算查找成功时的平均查找长度ASL，每个元素被查找的概率相同，都是 1/15。每个元素的查找都需要先查分块索引，再顺序查找分块内各个元素。</font>查找元素9时，查找长度为 1+1查找元素7时，查找长度为 1+2查找元素10时，查找长度为 1+3查找元素2时，查找长度为 1+4查找元素19时，查找长度为 2+1查找元素14时，查找长度为 2+2查找元素15时，查找长度为 2+3查找元素20时，查找长度为 3+1查找元素25时，查找长度为 3+2查找元素22时，查找长度为 3+3查找元素30时，查找长度为 3+4查找元素43时，查找长度为 4+1查找元素36时，查找长度为 4+2查找元素55时，查找长度为 4+3查找元素40时，查找长度为 4+4综上，查找成功的ASL=(2+3+4+5+3+4+5+4+5+6+7+5+6+7+8)×1/15=4.933<font color="FF0000">对于查找失败的情况，题目不太可能让你分析查找失败的平均查找长度ASL（因为查找失败的情形很多，我们无法预估出现每一种失败情形的概率）。因此，如果分块查找要考察“查找失败”的情形，很有可能是给你一个特定的关键字，让你分析该关键字查找失败时的查找长度。</font><p>例：如下图所示，查找元素 29（查找失败）时，首先顺序查找分块索引；确认元素29属于第三个分块，该分块在数组中下标范围是 7~10；紧接着在数组中查找下标为 7~10 的几个元素，所有元素和目标关键字都不匹配，最终可确定查找失败。<br>综上，查找元素 29（查找失败）时，总计对比关键字7次。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232040248.png" alt="image.png"></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树"><a href="#自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树" class="headerlink" title="自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树"></a>自己设计一个折半查找的例子，不少于10个数据元素，画出对应的查找分析树</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232044612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232044221.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL-1"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL-1" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232045710.png" alt="image.png"></p><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突"><a href="#自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突" class="headerlink" title="自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突"></a>自己设计一个散列表，总长度由你决定，并设计一个合理的散列函数，使用线性探测法解决冲突</h3><font color="FF0000">设散列表长度为<mark>16</mark>，采用线性探测法解决冲突，从空表开始，依次插入关键字 {19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，散列函数 <mark>H(key)=key%13</mark><mark>注：散列表的长度可以比散列函数的映射范围更大，散列函数的映射范围是 0~12，散列表的后面几个位置 13~15 不可能被散列函数直接映射，但是在线性探测法处理冲突时，可能被使用到</mark></font>![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232058651.png)![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232059087.png)### 基于上述例子，计算查找成功的ASL、查找失败ASL<font color="FF0000">考虑查找成功的所有情况。各元素查找成功时的查找长度如下：</font><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232100921.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232101576.png" alt="image.png"></p><p><font color="FF0000">考虑查找失败的所有情况。若目标元素的散列值为0，则只需对比位置0的关键字即可确定查找失败，查找长度为1；若目标元素的散列值为1，采用线性探测法，需对比位置#1~#13，才能确定查找失败，查找长度是13；若目标元素的散列值为2，采用线性探测法，需对比位置#2~#13，才能确定查找失败，查找长度是12；其他散列值同理。</font><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232103235.png" alt="image.png"></p><h3 id="基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）"><a href="#基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）" class="headerlink" title="基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）"></a>基于上述散列表，设计不少于10个元素的插入序列，依次插入散列表，画出散列表最终的样子（插入过程至少发生4次冲突）</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232111869.png" alt="image.png"></p><h3 id="基于上述例子，计算查找成功的ASL、查找失败的ASL-2"><a href="#基于上述例子，计算查找成功的ASL、查找失败的ASL-2" class="headerlink" title="基于上述例子，计算查找成功的ASL、查找失败的ASL"></a>基于上述例子，计算查找成功的ASL、查找失败的ASL</h3><p>考虑查找成功的所有情况。元素 14、68、19、29、23、11 的查找长度为1；元素1、55、84、10 的查找长度为2；元素27的查找长度为3；元素79的查找长度为4，因此：<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232112214.png" alt="image.png"></p><p>考虑查找失败的所有情况。若目标元素的散列值为0，则无需对比任何关键字即可确定查找失败，查找长度为0；若目标元素的散列值为1，则需要依次对比关键字14、1、27、79才能确定查找失败，查找长度为4；其他散列值同理。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232112216.png" alt="image.png"></p><h1 id="排序算法的分析和应用"><a href="#排序算法的分析和应用" class="headerlink" title="排序算法的分析和应用"></a>排序算法的分析和应用</h1><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态"><a href="#自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态" class="headerlink" title="自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态"></a>自己设计一个长度不小于10的乱序数组，用希尔排序，自己设定希尔排序参数画出每一轮希尔排序的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232113983.png" alt="image.png"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态"><a href="#自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态" class="headerlink" title="自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态"></a>自己设计一个长度不小于10的乱序数组，用快速排序，最终要生成升序数组画出每一轮快速排序的状态</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232115754.png" alt="image.png"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h4 id="自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0-99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表"><a href="#自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0-99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表" class="headerlink" title="自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0~99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表"></a>自己设计一个长度不小于15的乱序链表，每个数据元素取值范围0~99，用基数排序，最终要生成升序链，画出每一轮基数排序的状态表</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232121150.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/undefined/d04bd5bc.html"/>
      <url>/undefined/d04bd5bc.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171023019.png" alt="image.png"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a><em>操作系统的基本概念</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171040837.png" alt="image.png"></p><h3 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a><em>操作系统的定义</em></h3><ol><li>操作系统是系统资源的管理者</li><li>向上提供方便使用的服务</li><li>是最接近硬件的一层软件<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171043675.png" alt="image.png"></li></ol><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a><em>操作系统的功能</em></h3><h4 id="1-作为系统资源管理者"><a href="#1-作为系统资源管理者" class="headerlink" title="1.作为系统资源管理者"></a><strong><em>1.作为系统资源管理者</em></strong></h4><ul><li><em>处理机管理</em></li><li><em>存储器管理</em></li><li><em>文件管理</em></li><li><em>设备管理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171044644.png" alt="image.png"></li></ul><h4 id="2-向上提供方便易用的服务"><a href="#2-向上提供方便易用的服务" class="headerlink" title="2.向上提供方便易用的服务"></a><strong><em>2.向上提供方便易用的服务</em></strong></h4><p><em>操作系统把一些丑陋的硬件功能<strong>封装成简单易用的服务</strong>，使用户能更方便地使用计算机，用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</em></p><p><em>向上提供服务：</em></p><ul><li><em>给普通用户提供的：GUI、命令接口(联机、脱机)</em></li><li><em>给程序员提供的：程序接口(系统调用)</em></li></ul><blockquote><p><em>例如GUI图形化用户接口：用户可以直观理解界面进行操作，方便用户使用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171047670.png" alt="image.png"></p><p><em>例如联机命令接口，也称交互式命令接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171049719.png" alt="image.png"></p><p><em>例如脱机命令接口，也称批处理命令接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171050983.png" alt="image.png"></p><p><em>例如程序接口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171051366.png" alt="image.png"></p></blockquote><h4 id="3-作为最接近硬件的层次"><a href="#3-作为最接近硬件的层次" class="headerlink" title="3.作为最接近硬件的层次"></a><em>3.作为最接近硬件的层次</em></h4><p><em>没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171056491.png" alt="image.png"></p><h3 id="操作系统的四个特征"><a href="#操作系统的四个特征" class="headerlink" title="操作系统的四个特征"></a><em>操作系统的四个特征</em></h3><p><em>没有并发性和共享性，就谈不上虚拟和异步，因此并发和异步是操作系统最基本的两个特征</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171141733.png" alt="image.png"></p><h4 id="1-并发性"><a href="#1-并发性" class="headerlink" title="1.并发性"></a><strong><em>1.并发性</em></strong></h4><ul><li><em>并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</em></li><li><em>并行：指两个或多个事件在同一时刻同时发生。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171142677.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171143447.png" alt="image.png"></p><h4 id="2-共享性"><a href="#2-共享性" class="headerlink" title="2.共享性"></a><strong><em>2.共享性</em></strong></h4><p><em>共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</em></p><p>(1)<strong>资源共享根据属性可分为两种形式：</strong></p><ul><li>互斥共享形式:（当资源被程序A占用时,其他想使用的话只能等待，只有进程A使用完以后,其他进程才可以使用该资源）</li><li>同时访问形式 :（某种资源在一段时间内并发地被多个程序访问，这种“同时”是宏观的,从宏观去看该资源可以被同时访问,<strong>本质是一种微观的互斥共享</strong>）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171146597.png" alt="image.png"></p><p>(2)<strong>并发性与共享性互为存在条件</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171147935.png" alt="image.png"></p><h4 id="3-虚拟性"><a href="#3-虚拟性" class="headerlink" title="3.虚拟性"></a><em>3.虚拟性</em></h4><ul><li><em>虚拟：是把一个物理上的实体变为若干逻辑上的对应物。</em></li><li><em>物理实体（前者）是实际存在的；而后者是虚的，是用户感觉上的事务</em></li><li><em>虚拟技术：用于实现虚拟的技术</em></li><li><em>虚拟处理器（CPU）：通过多道程序设计技术，采用让多道程序并发执行的方法，分时来使用一个CPU，实际物理上只有一个CPU，但是用户感觉到有多个CPU</em></li><li><em>虚拟存储器：从逻辑上扩充存储器容量，用户感觉到的但实际不存在的存储器</em></li><li><em>虚拟设备：将一台物理设备虚拟为逻辑上的多台设备，使多个用户在同一时间段内访问同一台设备，即同时共享，用户宏观上感觉是同时的，但实际上是微观交替访问同一台设备的</em></li><li><em>操作系统的虚拟技术科归纳为：</em><ul><li>时分复用技术：如处理器的分时共享；一个单核的计算机，却可以同时运行多个程序（<strong>虚拟处理器技术 —— 时分复用技术</strong>）</li><li>空间复用技术：如虚拟存储器；一个 4 GB 内存的电脑，却可以运行远大于 4 GB 内存的程序（<strong>虚拟存储技术 —— 空分复用技术</strong>）</li></ul></li></ul><h4 id="4-异步性"><a href="#4-异步性" class="headerlink" title="4.异步性"></a><em>4.异步性</em></h4><p><em>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</em></p><h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a><em>操作系统的发展与分类</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171355528.png" alt="image.png"></p><h3 id="手工操作阶段"><a href="#手工操作阶段" class="headerlink" title="手工操作阶段"></a><em>手工操作阶段</em></h3><p><em>手工操作阶段主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低，手工装卸纸带的时间占了大部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171401918.png" alt="image.png"></p><h3 id="批处理阶段"><a href="#批处理阶段" class="headerlink" title="批处理阶段"></a><em>批处理阶段</em></h3><blockquote><p>批处理阶段又分为<strong>单道批处理系统</strong>和<strong>多道批处理系统</strong></p></blockquote><p><strong><em>1.单道批处理系统</em></strong><br><em>引入脱机输入/输出技术（用外围机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出；通过外围机把程序提前存到磁带里</em></p><ul><li><em>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升</em></li><li><em>主要缺点：内存中<strong>仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171406543.png" alt="image.png"></li></ul><p><strong><em>2.多道批处理系统</em></strong><br><em>每次往内存中读入多道程序，操作系统正式诞生，用于支持多道程序并发运行</em></p><ul><li><em>主要优点：多道程序<strong>并发执行</strong>，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大</em></li><li><em>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。eg：无法调试程序/无法在程序运行过程中输入一些参数）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171409395.png" alt="image.png"></li></ul><h3 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a><em>分时操作系统</em></h3><p><em>计算机以时间片为单位轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。</em></p><ul><li><em>主要优点：<strong>用户请求可以被即时响应，解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</em></li><li><em>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171411274.png" alt="image.png"></li></ul><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a><em>实时操作系统</em></h3><p><em>实时操作系统要求计算机系统在接收到外部信号后及时进行处理，并且要在严格的时间内处理完事件，其主要特点是<strong>及时性</strong>和<strong>可靠性</strong>。</em></p><ul><li><em>主要优点：<strong>能够优先响应一些紧急任务</strong>，某些紧急任务不需时间片排队</em></li></ul><blockquote><p><em>实时操作系统又分为<strong>硬实时系统和软实时系统。</strong></em></p></blockquote><p><strong><em>1.硬实时系统</em></strong><br><em>硬实时系统必须在绝对严格的规定时间内完成处理，比如导弹控制系统、自动驾驶系统等。</em></p><p><strong><em>2.软实时系统</em></strong><br><em>软实时系统能够接受偶尔违反时间的规定，例如订票系统。</em></p><h3 id="其他几种操作系统"><a href="#其他几种操作系统" class="headerlink" title="其他几种操作系统"></a><em>其他几种操作系统</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171416513.png" alt="image.png"></p><h2 id="操作系统运行环境"><a href="#操作系统运行环境" class="headerlink" title="操作系统运行环境"></a><em>操作系统运行环境</em></h2><h3 id="操作系统的运行机制"><a href="#操作系统的运行机制" class="headerlink" title="操作系统的运行机制"></a><em>操作系统的运行机制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171448145.png" alt="image.png"></p><h4 id="程序时如何运行的？"><a href="#程序时如何运行的？" class="headerlink" title="程序时如何运行的？"></a><em>程序时如何运行的？</em></h4><p><em>程序运行的过程其实就是CPU执行一条一条的机器指令的过程</em><br><em>很多人习惯把 Linux、Windows、MacOS 的“小黑框”中使用的命令也称为“令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171451468.png" alt="image.png"></p><h4 id="内核程序vs应用程序"><a href="#内核程序vs应用程序" class="headerlink" title="内核程序vs应用程序"></a><em>内核程序vs应用程序</em></h4><ul><li><em>普通程序员写的程序就是“应用程序”</em></li><li><em>微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”</em></li></ul><blockquote><p><em>由很多内核程序组成了“操作系统内核”，或简称“内核（Kernel）”内核是操作系统最重要最核心的部分，也是最接近硬件的部分甚至可以说，一个操作系统只要有内核就够了（eg：Docker—&gt;仅需Linux内核）<br>操作系统的功能未必都在内核中，如图形化用户界面 GUI</em></p></blockquote><h4 id="特权指令vs非特权指令"><a href="#特权指令vs非特权指令" class="headerlink" title="特权指令vs非特权指令"></a><em>特权指令vs非特权指令</em></h4><ul><li><em>应用程序只能使用“<strong>非特权指令</strong>”，如：加法指令、减法指令等</em></li><li><em>操作系统内核作为 “管理者”，有时会让CPU执行一些<strong>特权指令</strong> ，如：内存清零指令。这些指令影响重大，只允许“管理者”——即操作系统内核来使用</em></li></ul><h4 id="内核态vs用户态"><a href="#内核态vs用户态" class="headerlink" title="内核态vs用户态"></a><em>内核态vs用户态</em></h4><p><em>CPU 有两种状态，“内核态”和“用户态”<br>处于<strong>内核态</strong>时，说明此时正在运行的是内核程序，此时可以执行特权指令<br>处于<strong>用户态</strong>时，说明此时正在运行的是应用程序，此时只能执行非特权指令</em></p><blockquote><p><em>拓展：CPU 中有一个寄存器叫 程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”<br><strong>别名：内核态=核心态=管态；用户态=目态</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171503005.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171504734.png" alt="image.png"></p><h3 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a><em>中断和异常</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171558465.png" alt="image.png"></p><h4 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a><em>中断的作用</em></h4><p>“中断”是让操作系统内核夺回CPU使用权的唯一途径如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序。</p><blockquote><p><strong>内核态-&gt;用户态</strong>：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。<br><strong>用户态-&gt;内核态</strong>：由“中断”引发，硬件自动完成变态过程，触发中断信号意味着操作系统将强行夺回CPU的使用权。</p></blockquote><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a><em>中断的分类</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171601329.png" alt="image.png"></p><h4 id="中断机制的基本原理"><a href="#中断机制的基本原理" class="headerlink" title="中断机制的基本原理"></a><em>中断机制的基本原理</em></h4><p>不同的中断信号，需要用不同的<strong>中断处理程序来处理</strong>。当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。</p><p>显然，中断处理程序一定是内核程序，需要运行在“内核态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171602489.png" alt="image.png"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a><em>系统调用</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171635635.png" alt="image.png"></p><h4 id="什么是系统调用？"><a href="#什么是系统调用？" class="headerlink" title="什么是系统调用？"></a><em>什么是系统调用？</em></h4><p><strong>Linux内核中设置了一组用于实现各种系统功能的子程序，称为系统调用</strong>。用户可以通过系统调用命令在自己的应用程序中调用它们。<br>从某种角度来看，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。</p><h4 id="系统调用与库函数的区别？"><a href="#系统调用与库函数的区别？" class="headerlink" title="系统调用与库函数的区别？"></a><em>系统调用与库函数的区别？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171629803.png" alt="image.png"></p><h4 id="为什么系统调用时必须的？"><a href="#为什么系统调用时必须的？" class="headerlink" title="为什么系统调用时必须的？"></a><em>为什么系统调用时必须的？</em></h4><p>计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，<strong>为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制</strong>。 也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的系统调用（System Call）。</p><h4 id="什么功能需要系统调用？"><a href="#什么功能需要系统调用？" class="headerlink" title="什么功能需要系统调用？"></a><em>什么功能需要系统调用？</em></h4><p>应用程序通过系统调用请求操作系统的服务。而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作</strong>（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以<strong>保证系统的稳定性和安全性，防止用户进行非法操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171633407.png" alt="image.png"></p><h4 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a><em>系统调用的过程</em></h4><p>传递系统调用参数—&gt;执行陷入指令（用户态） —&gt;执行相应的内请求核程序处理系统调用（核心态） —&gt;返回应用程序<br>【注意】：</p><ol><li>陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态。</li><li>发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171635515.png" alt="image.png"></li></ol><h2 id="操作系统体系结构"><a href="#操作系统体系结构" class="headerlink" title="操作系统体系结构"></a><em>操作系统体系结构</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171703375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171849554.png" alt="image.png"></p><h3 id="操作系统的内核"><a href="#操作系统的内核" class="headerlink" title="操作系统的内核"></a><em>操作系统的内核</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171706701.png" alt="image.png"></p><h4 id="操作系统的内核是什么？"><a href="#操作系统的内核是什么？" class="headerlink" title="操作系统的内核是什么？"></a><em>操作系统的内核是什么？</em></h4><p>内核是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。<strong><em>内核是一个操作系统的核心。它负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，决定着系统的性能和稳定性。是连接应用程序和硬件的桥梁。</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171714480.png" alt="image.png"></p><h4 id="内核分为大内核和微内核"><a href="#内核分为大内核和微内核" class="headerlink" title="内核分为大内核和微内核"></a><em>内核分为大内核和微内核</em></h4><p><strong><em>大内核</em></strong></p><blockquote><p>特性思想：功能包括，时钟管理、中断处理、原语(设备驱动、CPU切换)、进程管理、存储器管理、设备管理等功能。所有的系统功能都放在内核里（大内核结构的OS通常也采用了”模块化“的设计思想）</p></blockquote><ul><li>优点：<ol><li>高性能，内核各种功能都能直接相互调用</li></ol></li><li>缺点：<ol><li>内核代码庞大，结构混乱，难以维护。</li><li>大内核中某个功能模块出错，就可能导致整个系统崩渍</li></ol></li></ul><p><strong><em>微内核</em></strong></p><blockquote><p>特性思想：功能包括，时钟管理、中断处理、原语。只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态</p></blockquote><ul><li>优点：<ol><li>内核功能少，结构清晰，方便维护；</li><li>内核外的某个功能模块出错不会导致整个系统崩溃</li></ol></li><li>缺点：<ol><li>性能低，需要频繁的切换用户态/核心态。</li><li>用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信.</li></ol></li></ul><blockquote><p><em>如果使用大内核操作系统，应用程序请求操作系统的服务，那么只需要用户态-&gt;内核态，内核态-&gt;用户态，总共两次变态</em><br><em>如果使用的是微内核，上述需要6次变态</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171719529.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171722329.png" alt="image.png"></p><h3 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h3><blockquote><p><em>特性思想：内核分多层，每层可单向调用更低一层提供的接口</em></p></blockquote><p><em>优点：</em></p><ol><li>便于调试和验证，自底向上逐层测试验证</li><li>易扩充和维护，各层之间调用接口清晰固定<br><em>缺点：</em></li><li>仅可调用相邻低层，难以合理定义各层的边界</li><li>效率低，不可跨层调用，系统调用执行时间长<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171840327.png" alt="image.png"></li></ol><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a><em>模块化</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171901517.png" alt="image.png"></p><blockquote><p>特性思想：将内核划分为多个模块，各模块之间相互协作。<br>内核=主模块+可加载内核模块<br>主模块：只负责核心功能，如进程调度、内存管理<br>可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171854395.png" alt="image.png"></p><h3 id="外核"><a href="#外核" class="headerlink" title="外核"></a><em>外核</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171904125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308171942853.png" alt="image.png"></p><h2 id="操作系统的引导-开机过程-Boot"><a href="#操作系统的引导-开机过程-Boot" class="headerlink" title="操作系统的引导(开机过程/Boot)"></a><em>操作系统的引导(开机过程/Boot)</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172014896.png" alt="image.png"></p><h3 id="什么是操作系统的引导？"><a href="#什么是操作系统的引导？" class="headerlink" title="什么是操作系统的引导？"></a><em>什么是操作系统的引导？</em></h3><p>操作系统引导（boot）——开机的时候，怎么让操作系统运行起来？</p><h3 id="磁盘里面有哪些相关数据？"><a href="#磁盘里面有哪些相关数据？" class="headerlink" title="磁盘里面有哪些相关数据？"></a><em>磁盘里面有哪些相关数据？</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172015330.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172016247.png" alt="image.png"></p><h3 id="操作系统引导过程"><a href="#操作系统引导过程" class="headerlink" title="操作系统引导过程"></a><em>操作系统引导过程</em></h3><p><code>BIOS(Basic Input/Output System):基本输入输出系统</code><br>操作系统引导：<br>①CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（先进行硬件自检，再开机）<br>②将磁盘的第一块——主引导记录 读入内存，执行磁盘引导程序，扫描分区表<br>③从活动分区（又称主分区，即安装了操作系统的分区—C盘）读入分区引导记录，执行其中的程序<br>④从根目录下找到完整的操作系统初始化程序（即 启动管理器）并执行，完成“开机”的一系列动作</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172019273.png" alt="image.png"></p><blockquote><p><em>拓展</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308172021369.png" alt="image.png"></p></blockquote><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a><em>虚拟机</em></h2><h3 id="什么是虚拟机和虚拟机管理程序？"><a href="#什么是虚拟机和虚拟机管理程序？" class="headerlink" title="什么是虚拟机和虚拟机管理程序？"></a><em>什么是虚拟机和虚拟机管理程序？</em></h3><p><strong><em>虚拟机—VM</em></strong><br>使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统</p><p><strong><em>虚拟机管理程序—VMM</em></strong><br>虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor；是创建和运行虚拟机的软件。管理程序允许一台主机通过虚拟共享其资源（例如内存和处理器）来支持多个虚拟机(VM)。由于虚拟机独立于主机硬件，因此虚拟机管理程序可以使用更多系统的可用资源，并提供更大的 IT 移动性。这意味着它们可以轻松地在不同服务器之间移动。</p><h3 id="两类管理程序"><a href="#两类管理程序" class="headerlink" title="两类管理程序"></a><em>两类管理程序</em></h3><blockquote><p>有两种主要的管理程序类型，称为“类型 1”（或“裸机”）和“类型 2”（或“托管”）。</p></blockquote><ul><li><strong>类型 1 也称裸机管理程序</strong>，它就像一个轻量级操作系统，直接在主机硬件上运行。</li><li><strong>类型 2 也称托管管理程序</strong>，它是一个软件层，运行在一个操作系统上，就像其他计算机程序一样。</li></ul><blockquote><p><em>第1类和第2类虚拟机管理程序的区别</em></p></blockquote><p>虽然第 1 类和第 2 类虚拟机监控器的共同目标是运行和协调虚拟机（VM），但它们之间有一些显著差异。<br> <strong>资源分配</strong><br>第 1 类虚拟机监控器<strong><em>直接访问底层计算机资源</em></strong>。这些虚拟机监控器可以实施自己的自定义资源分配策略来为虚拟机提供服务。<br>第 2 类虚拟机监控器与<strong><em>操作系统协商资源分配</em></strong>，这会使流程变慢且效率降低。</p><p><strong>易于管理</strong><br>管理第 1 类虚拟机监控器序及其虚拟机配置需要具备系统管理员级别的知识，因为此类管理相对复杂。<br>相比之下，可以将第 2 类虚拟机监控器作为应用程序在操作系统上安装和管理。即使是非技术型用户也可以操作这些应用程序。</p><p> <strong>性能</strong><br>第 1 类虚拟机监控器可为其虚拟机提供更卓越的性能。这是因为这些虚拟机监控器不需要与操作系统协商资源，也不需要穿过操作系统层。第 1 类虚拟机监控器无需进行任何协商即可提供专用的底层资源。<br>第 2 类虚拟机监控器只能使用操作系统愿意提供的资源。</p><p> <strong>隔离</strong><br>第 1 类虚拟机监控器为每种虚拟环境提供更高程度的隔离。因此，在此类环境中没有共享层，而第 2 类虚拟机监控器则以操作系统作为共享层。这使得在第 1 类虚拟机监控器上运行的虚拟机本质上更加安全。但是，更新和修补虚拟机操作系统就成为一项关键的安全活动。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308180952142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181052696.png" alt="image.png"></p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程与线程-1"><a href="#进程与线程-1" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程的概念、组成和特征"><a href="#进程的概念、组成和特征" class="headerlink" title="进程的概念、组成和特征"></a><em>进程的概念、组成和特征</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181056630.png" alt="image.png"></p><h4 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a><em>进程的概念</em></h4><ul><li><strong>*程序</strong>：是静态的，就是个存放在磁盘里的可执行文件，如：QQ.exe*</li><li><strong>*进程</strong>：是动态的，是程序的一次执行过程，如：可同时启动多次QQ程序，同一个程序多次执行会对应多个进程*</li></ul><h4 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a><em>进程的组成</em></h4><p>进程（进程实体）由<code>程序段</code>、<code>数据段</code>、<code>PCB</code> 三部分组成。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181125594.png" alt="image.png"></p><blockquote><p><strong><em>进程组成—PCB(进程控制块)</em></strong></p></blockquote><p>当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号”—— PID（Process ID，进程ID）。<strong>PCB是进程存在的唯一标志</strong>，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p><p>PCB(进程控制块)是一个数据结构，记录了如下的信息：</p><ul><li><em>操作系统要记录PID、进程所属用户ID（UID，基本的进程描述信息，可以<br>让操作系统区分各个进程。</em></li><li><em>还要记录给进程分配了哪些资源（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件，可用于实现操作系统对资源的管理。</em></li><li><em>还要记录进程的运行情况（如：CPU使用时间、磁盘使用情况、网络流量使用情况等）可用于实现操作系统对进程的控制、调度。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181103067.png" alt="image.png"></p><blockquote><p><strong><em>进程的组成—程序段、数据段</em></strong></p></blockquote><ul><li><em>程序段，程序代码即存放在此</em></li><li><em>数据段，程序运行时使用、产生的运算数据。如全局变量、局部变量、宏定义的常量就存放在数据段内</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181117444.png" alt="image.png"></li></ul><h4 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a><em>进程的特征</em></h4><p><code>动态性试进程最基本特征</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181127194.png" alt="image.png"></p><h3 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a><em>进程的状态与转换</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181150472.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181156795.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181158647.png" alt="image.png"></p><blockquote><p><em>! 当一个进程被阻塞时,它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。</em></p></blockquote><h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a><em>进程的组织</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181159329.png" alt="image.png"></p><blockquote><p><em>链接方式</em></p></blockquote><p><em>按照进程状态，将PCB分为多个队列；操作系统维持有指向各个队列的指针</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181201974.png" alt="image.png"></p><blockquote><p><em>索引方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181202612.png" alt="image.png"></p><h3 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a><em>进程的控制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181551528.png" alt="image.png"></p><h4 id="什么是进程控制？"><a href="#什么是进程控制？" class="headerlink" title="什么是进程控制？"></a><em>什么是进程控制？</em></h4><p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><p>简化理解：反正进程控制就是要实现进程状态转换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181553266.png" alt="image.png"></p><h4 id="如何实现进程控制？"><a href="#如何实现进程控制？" class="headerlink" title="如何实现进程控制？"></a><em>如何实现进程控制？</em></h4><blockquote><p><em>进程控制必须是一气呵成的</em></p></blockquote><p><em>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181558800.png" alt="image.png"></p><blockquote><p><em>如何实现进程控制一气呵成，不受中断信号的影响呢？</em></p></blockquote><p><strong><em>原语</em></strong><br>原语是一种<strong>特殊的程序</strong>，它的执行具有原子性。也就是说，这段程序的运行必须一气呵成，不可中断。原语通常是由底层硬件直接实现的。原语(Primitive)指的是操作系统或编程语言提供的最基本的操作单元。原语不能再细分拆分,必须由硬件直接执行。</p><p><strong><em>原语的原子性</em></strong><br>原语的执行具有原子性，即执行过程只能一气呵成，期间不允许被中断。可以用 “<strong>关中断指令”和“开中断指令</strong>”这两个特权指令实现原子性。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181602882.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181604840.png" alt="image.png"></p><h4 id="进程控制相关原语"><a href="#进程控制相关原语" class="headerlink" title="进程控制相关原语"></a><em>进程控制相关原语</em></h4><blockquote><p><em>进程的创建—创建原语</em></p></blockquote><p><em>操作系统创建一个进程时使用的原语</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181609558.png" alt="image.png"></p><blockquote><p><em>进程的终止—撤销原语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181611603.png" alt="image.png"></p><blockquote><p><em>进程的阻塞和唤醒</em></p></blockquote><p><em>阻塞原语和唤醒原语必须成对使用，被阻塞了必须要被唤醒</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181613808.png" alt="image.png"></p><blockquote><p><em>进程的切换—切换原语</em></p></blockquote><p><em>进程运行环境，就是进程运行过程，执行指令产生的各种数据暂时存放在寄存器中(PC 程序计数器、通用寄存器等存放着一些该进程运行的数据)，但是当时间片用完，或者其他原因，需要让下一个进程运行，那么寄存器里面的内容就会被覆盖，当进程重新得到时间片时，就无法从中断处继续。所以就需要将<strong>运行环境信息</strong>存入PCB</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181615929.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181622645.png" alt="image.png"></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181738454.png" alt="image.png"></p><h4 id="什么是进程通信？"><a href="#什么是进程通信？" class="headerlink" title="什么是进程通信？"></a><em>什么是进程通信？</em></h4><p>进程间通信（Inter-Process Communication， IPC）是指两个进程之间产生数据交互，类似于，我用微博将消息分享到微信的过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181740317.png" alt="image.png"></p><h4 id="为什么进程通信需要操作系统支持？"><a href="#为什么进程通信需要操作系统支持？" class="headerlink" title="为什么进程通信需要操作系统支持？"></a><em>为什么进程通信需要操作系统支持？</em></h4><p>各个进程被分配了，相互独立的地址空间，但是这些进程只能访问自己的地址空间，无法访问别的进程地址空间，这样是为了保证安全<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181743324.png" alt="image.png"></p><h4 id="进程通信三种方式"><a href="#进程通信三种方式" class="headerlink" title="进程通信三种方式"></a><em>进程通信三种方式</em></h4><blockquote><p><em>1.共享存储</em></p></blockquote><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>为了在多个进程间交换信息，内核专门留出了一块内存区，<strong>可以由需要访问的进程将其映射到自己的私有地址空间</strong>。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的<strong>同步及互斥</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181750956.png" alt="image.png"></li></ul><p><em>两类共享存储方式：</em><code>基于数据结构的共享、基于存储区的共享</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181751732.png" alt="image.png"></p><blockquote><p><em>2.消息传递</em></p></blockquote><p>进程间的数据交换以<strong>格式化的消息（Message）为单位</strong>。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181832664.png" alt="image.png"></p><p><strong><em>1.直接通信方式</em></strong><br><em>消息发送进程要指明接收进程的ID</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181834479.png" alt="image.png"></p><p><strong><em>2.间接通信方式</em></strong><br><em>通过“信箱”间接地通信。因此又称“信箱通信方式”</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181834010.png" alt="image.png"></p><blockquote><p><em>管道通信</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308181837173.png" alt="image.png"></p><ol><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各进程要互斥地访问管道（由操作系统实现）</li><li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程。</li><li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程。</li><li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案：①一个管道允许多个写进程，一个读进程（2014年408真题高教社官方答案）；②允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux 的方案）。</li></ol><h3 id="线程的概念与特点"><a href="#线程的概念与特点" class="headerlink" title="线程的概念与特点"></a><em>线程的概念与特点</em></h3><h4 id="为什么引入线程？"><a href="#为什么引入线程？" class="headerlink" title="为什么引入线程？"></a><em>为什么引入线程？</em></h4><ul><li>可以把线程理解为“轻量级进程”。</li><li><strong>线程是一个基本的CPU执行单元</strong>，也是程序执行流的最小单位。</li><li>引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）</li><li>引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。<strong>线程则作为处理机的分配单元</strong>。</li></ul><p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来<strong>增加并发度</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191025557.png" alt="image.png"></p><h4 id="引入线程后的变化"><a href="#引入线程后的变化" class="headerlink" title="引入线程后的变化"></a><em>引入线程后的变化</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191029801.png" alt="image.png"></p><p>【注：系统开销减小，是因为线程并发减少了进程之间的切换，也就减少了进程运行环境的切换，所以开销减小】</p><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a><em>线程的属性</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191032300.png" alt="image.png"></p><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><em>线程的实现方式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191043598.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191108611.png" alt="image.png"></p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a><em>用户级线程</em></h4><p>早期的操作系统（如：早期Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。这种线程实现方式被称为“用户级线程”。</p><ol><li>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责（包括线程切换）。</li><li>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</li><li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。“用户级线程”就是“从用户视角看能看到的线程”</li><li>处理机的分配单元是进程，所以时间片是按照进程分配，其中一个线程阻塞，整个进程就阻塞(该进程下的其他进程也相应无法执行)，所以这种线程并发度不高。</li><li>优缺点</li></ol><ul><li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li><li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191046222.png" alt="image.png"></li></ul><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a><em>内核级线程</em></h4><ol><li>内核级线程的管理工作由操作系统内核完成。</li><li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</li><li>操作系统会为每个内核级线程建立相应的TCB（Thread Control Block，线程控制块），通过TCB对线程进行管理。“内核级线程”就是“从操作系统内核视角看能看到的线程”。</li><li>处理机的分配单元是内核级线程，时间片按照线程分配，一个内核线程阻塞，该进程下其他内核线程任然可以获得时间片，执行下去，并发度高。</li><li>优缺点</li></ol><ul><li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li><li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191059723.png" alt="image.png"></li></ul><blockquote><p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p></blockquote><h5 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a><em>一对一模型</em></h5><p>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。<br><strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191101082.png" alt="image.png"></p><h5 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a><em>多对一模型</em></h5><p>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。</p><p><strong>优点</strong>：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。<br><strong>缺点</strong>：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</p><p><code>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191102668.png" alt="image.png"></p><h5 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a><em>多对多模型</em></h5><p>多对多模型：n 用户及线程映射到 m 个内核级线程（n &gt;= m）。每个用户进程对应 m 个内核级线程。</p><p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191107042.png" alt="image.png"></p><h3 id="线程的状态与转换"><a href="#线程的状态与转换" class="headerlink" title="线程的状态与转换"></a><em>线程的状态与转换</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191354458.png" alt="image.png"></p><blockquote><p><em>线程状态转换</em></p></blockquote><p><em>与进程的状态转换差不多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191356107.png" alt="image.png"></p><blockquote><p><em>线程的组成</em></p></blockquote><p><em>线程控制块TCB，类似于进程控制块</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191357118.png" alt="image.png"></p><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a><em>处理机调度</em></h2><h3 id="调度的概念、层次"><a href="#调度的概念、层次" class="headerlink" title="调度的概念、层次"></a><em>调度的概念、层次</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191402481.png" alt="image.png"></p><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a><em>调度的基本概念</em></h4><p>当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a><em>调度的三个层次</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191544856.png" alt="image.png"></p><ol><li><p><strong><em>高级调度（作业调度）</em></strong><br><code>作业：一个具体的任务。</code><br><code>用户向系统提交一个作业 ≈ 用户让操作系统启动一个程序（来处理一个具体的任务）</code></p><blockquote><p><em>&lt;创建进程&gt;</em><br>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程(建立PCB),以使它（们）获得竟争处理机的权利。高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB,作业调出时才撤销PCB。<code>高级调度主要是指调入的问题</code>，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p></blockquote></li></ol><ol><li><strong><em>中级调度（内存调度）</em></strong></li></ol><blockquote><p><em>&lt;将已有进程，调出/入内存，缓解内存不足&gt;</em><br>为了使内存中的内存不至于太多，有时需要把某些进程从内存中调到外存，暂时调到外存等待的进程状态为挂起状态。被挂起的进程PCB会被组织成挂起队列。在内存使用情况紧张时，将一些暂时不能运行的进程从内存中对换到外存中等待。当内存有足够的空闲空间时，再将合适的进程重新换入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191429994.png" alt="image.png"></p><ol><li><strong><em>低级调度（进程调度/处理机调度）</em></strong><blockquote><p><em>&lt;给进程分配处理机，时间片&gt;</em><br>主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p></blockquote></li></ol><p><strong><em>回顾</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191553260.png" alt="image.png"></p><h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a><em>调度算法的评价指标</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191554650.png" alt="image.png"></p><h4 id="CPU利用率"><a href="#CPU利用率" class="headerlink" title="CPU利用率"></a><em>CPU利用率</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191556060.png" alt="image.png"></p><h4 id="系统吞吐量"><a href="#系统吞吐量" class="headerlink" title="系统吞吐量"></a><em>系统吞吐量</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191558772.png" alt="image.png"></p><h4 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a><em>周转时间</em></h4><blockquote><p><em>周转时间，是指从<strong>作业被提交给系统开始</strong>，到作业完成为止的这段时间间隔。</em><br>它包括四个部分：作业在外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次。</p></blockquote><p><code>只有作业真正提交/到达，进入外存后备队列开始，才算进程开始周转</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191603979.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于周转时间相同的两个作业，实际运行时</span><br><span class="line">间长的作业在相同时间内被服务的时间更多，</span><br><span class="line">带权周转时间更小，用户满意度更高。</span><br><span class="line"></span><br><span class="line">对于实际运行时间相同的两个作业，周转时</span><br><span class="line">间短的带权周转时间更小，用户满意度更高</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191605602.png" alt="image.png"></p><blockquote><p><em>eg</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201025453.png" alt="image.png"></p></blockquote><h4 id="等待时间"><a href="#等待时间" class="headerlink" title="等待时间"></a><em>等待时间</em></h4><p>计算机的用户希望自己的作业尽可能少的等待处理机。等待时间，指进程/作业处于<strong><em>等待处理机状态时间之和</em></strong>，等待时间越长，用户满意度越低。</p><ul><li>对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的(被CPU服务)，所以不计入等待时间。</li><li>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</li></ul><blockquote><p>对于等待I/O完成的进程,操作系统确实会视其为在运行状态,因为这只是一种阻塞的等待,进程仍在内核态运行。就进程而言,它发出了I/O请求后,并不知道具体的等待时间,只能被动等待通知,所以从进程角度来看,它仍是运行状态。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191614084.png" alt="image.png"></p></blockquote><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a><em>响应时间</em></h4><p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。响应时间，指从用户提交请求到首次产生响应所用的时间</p><h3 id="进程调度-低级调度"><a href="#进程调度-低级调度" class="headerlink" title="进程调度(低级调度)"></a><em>进程调度(低级调度)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191704700.png" alt="image.png"></p><h4 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a><em>进程调度的时机</em></h4><p>进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p><p><strong>一、需要进程调度与切换的情况</strong></p><ol><li>当前运行的进程主动放弃处理机：<ul><li>进程正常终止</li><li>运行过程中发生异常而终止</li><li>进程主动请求阻塞（如 等待I/O）</li></ul></li><li>当前运行的进程被动放弃处理机：<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如 I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ol><p><strong>二、不能进行进程调度与切换的情况</strong></p><ol><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在操作系统<strong><em>内核程序临界区中</em></strong>。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ol><blockquote><p><em>扩展</em><br><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。<br><strong>临界区</strong>：访问临界资源的那段代码。<br><strong>内核程序临界区</strong>：一般是用来访问某种内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成）</p><p><strong><em>进程在操作系统内核程序临界区中不能进行调度与切换</em></strong>；<br>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191714892.png" alt="image.png"></p><p><strong><em>进程处于临界区时能进行处理机调度</em></strong><br>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进行调度与切换。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191717378.png" alt="image.png"></p></blockquote><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a><em>进程调度的方式</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191745572.png" alt="image.png"></p><h4 id="进程调度与切换"><a href="#进程调度与切换" class="headerlink" title="进程调度与切换"></a><em>进程调度与切换</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191746352.png" alt="image.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><em>总结</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308191747879.png" alt="image.png"></p><h3 id="调度器和闲逛进程"><a href="#调度器和闲逛进程" class="headerlink" title="调度器和闲逛进程"></a><em>调度器和闲逛进程</em></h3><h4 id="调度器-调度程序"><a href="#调度器-调度程序" class="headerlink" title="调度器/调度程序"></a><em>调度器/调度程序</em></h4><p><em>调度程序实现的是就绪态和运行态之间的切换，而不包括与阻塞态转换。</em></p><blockquote><p>什么事件会触发”调度程序“？<br><em>1.创建新进程：新的进程计入就绪队列，并需调度程序，决定是否进入运行态</em><br><em>2. 进程退出：进程结束，需要调度程序，决定哪个就绪进程运行</em><br><em>3.运行进程阻塞：阻塞，需要进程顶上</em><br><em>4.非抢占式调度策略：只有运行阻塞，或完后退出才能发生调度</em><br><em>5. 抢占式调度策略：每个时钟周期(时钟中断)，进程时间片重新被争夺，需要调度就绪-&gt;运行</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308200958066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">调度程序的调度对象是进程还是线程，取决于操作系统是否支持内核级线程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201013710.png" alt="image.png"></p><h4 id="闲逛进程"><a href="#闲逛进程" class="headerlink" title="闲逛进程"></a><em>闲逛进程</em></h4><p><em>仅仅作为备胎，当没有进程能够运行时，就运行闲逛进程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201015373.png" alt="image.png"></p><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><em>调度算法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201126098.png" alt="image.png"></p><h4 id="批处理系统调度算法"><a href="#批处理系统调度算法" class="headerlink" title="批处理系统调度算法"></a><em>批处理系统调度算法</em></h4><h5 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h5><p><strong><em>Fisrt Come First Serve</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201126403.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201127783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201128037.png" alt="image.png"></p><h5 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h5><p><strong><em>Short Job First</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201130542.png" alt="image.png"></p><blockquote><p><em>非抢占式-例子</em></p></blockquote><p><em>严格来说，用于进程调度应该称为 短进程优先调度算法（ SPF ）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201134217.png" alt="image.png"></p><blockquote><p><em>抢占式-例子</em></p></blockquote><p>严格来说，抢占式的短作业优先算法又称“最短剩余时间优先算法（SRTN）“<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201136734.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201136027.png" alt="image.png"></p><blockquote><p><em>注意区分</em></p></blockquote><ol><li>如果题目中未特别说明，所提到的“短作业/进程优先算法”<strong><em>默认是非抢占式的</em></strong></li><li>很多书上都会说“SJF 调度算法的平均等待时间、平均周转时间最少”严格来说，这个表述是错误的，不严谨的。之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少应该加上一个条件“在所有进程同时可运行时，采用SJF调度算法的平均等待时间、平均周转时间最少”；或者说“在所有进程都几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”；如果不加上述前提条件，则应该说“抢占式的短作业/进程优先调度算法（最短剩余时间优先, SRNT算法）的平均等待时间、平均周转时间最少”</li><li>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，但相比于其他算法（如 FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间</li><li>如果选择题中遇到“SJF 算法的平均等待时间、平均周转时间最少”的选项，那最好判断其他选项是不是有很明显的错误，如果没有更合适的选项，那也应该选择该选项</li></ol><h5 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h5><p><strong><em>High Response High Ratio Next</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201141228.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201143104.png" alt="image.png"></p><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><em>总结</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201146459.png" alt="image.png"><br>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，<strong>交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。</p><h4 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a><em>交互式系统的调度算法</em></h4><h5 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a><em>时间片轮转算法</em></h5><p><strong><em>RR, Round-Robin</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201249395.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><strong>*特点</strong>：常用于分时操作系统，更注重“响应时间”，因而此处不计算周转时间；*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201250160.png" alt="image.png"></p><p>0时刻（P1(5)）:0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片。<br>2时刻（P2(4) -&gt;P1(3)）-&gt;2时刻 P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意： 2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况， 默认 新到达的进程先进入就绪队列）。<br>4时刻（P1(3) -&gt; P3(1) -&gt; P2(2)）:4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾。<br>5时刻（P3(1) -&gt; P2(2) -&gt; P4(6)）:5时刻，P4到达插到就绪队尾（注意：由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中）。<br>6时刻（P3(1) -&gt; P2(2) -&gt; P4(6) -&gt; P1(1)）：6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度<br>7时刻（P2(2) -&gt; P4(6) -&gt; P1(1)）：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。<br>9时刻（P4(6) -&gt; P1(1)）：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机。<br>11时刻（P1(1) -&gt; P4(4) ）：P4时间片用完，重新回到就绪队列。P1上处理机。<br>12时刻（P4(4) ）：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机。<br>14时刻（）：就绪队列为空，因此让P4接着运行一个时间片。<br>16时刻：所有进程运行结束。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">！注意：</span><br><span class="line">如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</span><br><span class="line">另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比</span><br></pre></td></tr></table></figure></p><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a><em>优先级调度算法</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201307199.png" alt="image.png"></p><blockquote><p><em>非抢占式—例子</em></p></blockquote><p><strong>*特点</strong>：用优先级区分紧急程度，适用于实时操作系统*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201424709.png" alt="image.png"></p><blockquote><p><em>抢占式—例子</em></p></blockquote><p><strong>*特点</strong>：用优先级区分紧急程度，适用于实时操作系统*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201308329.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级</span><br><span class="line">高的进程排在更靠近队头的位置</span><br><span class="line">根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种。</span><br><span class="line">静态优先级：创建进程时确定，之后一直不变。(非抢占式)</span><br><span class="line">动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。(抢占式)</span><br><span class="line"></span><br><span class="line">系统进程优先级 高于 用户进程</span><br><span class="line">前台进程优先级 高于 后台进程</span><br><span class="line">操作系统更偏好 I/O型进程（或称 I/O繁忙型进程）</span><br><span class="line">注：与I/O型进程相对的是计算型进程（或称 CPU繁忙型进程）</span><br></pre></td></tr></table></figure><h5 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a><em>多级反馈队列算法</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201423858.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201421945.png" alt="image.png"></p><blockquote><p><em>例子</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201422214.png" alt="image.png"></p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><em>总结</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201246490.png" alt="image.png"><br>比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）</p><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a><em>同步与互斥</em></h2><h3 id="同步与互斥的基本概念"><a href="#同步与互斥的基本概念" class="headerlink" title="同步与互斥的基本概念"></a><em>同步与互斥的基本概念</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201542327.png" alt="image.png"><br><strong><em>进程互斥</em></strong><br>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201549332.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">临界区是进程中访问临界资源的代码段。</span><br><span class="line">进入区和退出区是负责实现互斥的代码段。</span><br><span class="line">临界区也可称为“临界段”</span><br><span class="line"></span><br><span class="line">如果一个进程暂时不能进入临界区，</span><br><span class="line">那么该进程是否应该一直占着处理</span><br><span class="line">机？该进程有没有可能一直进不了</span><br><span class="line">临界区？</span><br><span class="line"></span><br><span class="line">为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</span><br><span class="line">1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</span><br><span class="line">2. 忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</span><br><span class="line">3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</span><br><span class="line">4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</span><br></pre></td></tr></table></figure></p><p><strong><em>进程同步</em></strong><br>是指散步在不同进程之间的若干程序片断，它们的运行必须严格按照规定的 某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。显然，同步是一种更为复杂的互斥，而互斥是一种特殊的同步。也就是说互斥是两个线程之间不可以同时运行，他们会相互排斥，必须等待一个线程运行完毕，另一个才能运行，而同步也是不能同时运行，但他是必须要安照某种次序来运行相应的线程（也是一种互斥）！<br><strong><em>为什么需要进程同步</em></strong><br>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。操作系统要提供“进程同步机制”来解决异步问题。</p><h3 id="软件实现与硬件实现的概念"><a href="#软件实现与硬件实现的概念" class="headerlink" title="软件实现与硬件实现的概念"></a><em>软件实现与硬件实现的概念</em></h3><p>硬件实现是直接在硬件电路上实现功能,软件实现是通过软件代码进行模拟或者抽象来间接实现功能。</p><p>硬件实现的特点是:</p><ul><li>直接在数字逻辑电路或者模拟电路上对功能进行设计,实现速度很快。</li><li>不需要指令的翻译和调度,执行效率高。</li><li>硬件电路功能一旦实现就固化了,不太容易修改。</li></ul><p>软件实现的特点是:</p><ul><li>使用编程语言编写代码,通过代码逻辑来模拟实现功能。</li><li>需要将高级语言翻译成机器指令,存在一定的执行开销。</li><li>可以通过修改代码来调整功能实现,更加灵活。</li><li>可以通过软件在不同硬件上运行,更加通用。<h3 id="进程互斥的软件实现方法"><a href="#进程互斥的软件实现方法" class="headerlink" title="进程互斥的软件实现方法"></a><em>进程互斥的软件实现方法</em></h3></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201722851.png" alt="image.png"></p><h4 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a><em>单标志法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">算法思想：两个进程在 访问完临界区后 会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</span><br><span class="line"></span><br><span class="line">turn 的初值为 0，即刚开始只允许 0 号进程进入临界区。</span><br><span class="line">若 P1 先上处理机运行，则会一直卡在 ⑤。直到 P1 的时间片用完，发生调度，切换 P0 上处理机运行。代码 ① 不会卡住 P0，P0 可以正常访问临界区，在 P0 访问临界区期间即时切换回 P1，P1依然会卡在 ⑤。只有 P0 在退出区将 turn 改为 1 后，P1才能进入临界区。</span><br><span class="line">因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”</span><br><span class="line"></span><br><span class="line">只能按 P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt;……这样轮流访问。这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是 P0，而 P0 一直不需要访问临界区，那么虽然此时临界区空闲，但是并不允许 P1 访问。</span><br><span class="line">因此，单标志法存在的主要问题是：违背“空闲让进”原则。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201725094.png" alt="image.png"></p><h4 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a><em>双标志先检查法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">算法思想：设置一个布尔型数组 flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如“flag[0] = ture”意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志 flag[i] 设为 true，之后开始访问临界区。</span><br><span class="line"></span><br><span class="line">若按照 ①⑤②⑥③⑦….的顺序执行，P0 和 P1 将会同时访问临界区。</span><br><span class="line">因此，双标志先检查法的主要问题是：违反“忙则等待”原则。</span><br><span class="line">原因在于，进入区的“检查”和“上锁” 两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201734331.png" alt="image.png"></p><h4 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a><em>双标志后检查法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">算法思想：双标志先检查法的改版。前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题</span><br><span class="line"></span><br><span class="line">若按照 ①⑤②⑥….的顺序执行，P0 和 P1 将都无法进入临界区</span><br><span class="line">因此，双标志后检查法虽然解决了“忙则等待”的问题，但是又违背了“空闲让进”和“有限等待”原则，会因各进程都长期无法访问临界资源而产生“饥饿”现象。</span><br><span class="line">两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201740280.png" alt="image.png"></p><h4 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a><em>Peterson算法</em></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”（谦让）。做一个有礼貌的进程。</span><br><span class="line"></span><br><span class="line">Peterson 算法用软件方法解决了进</span><br><span class="line">程互斥问题，遵循了空闲让进、忙</span><br><span class="line">则等待、有限等待 三个原则，但是</span><br><span class="line">依然未遵循让权等待的原则。</span><br><span class="line">Peterson 算法相较于之前三种软件</span><br><span class="line">解决方案来说，是最好的，但依然</span><br><span class="line">不够好。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201741666.png" alt="image.png"></p><h3 id="进程互斥的硬件实现方法"><a href="#进程互斥的硬件实现方法" class="headerlink" title="进程互斥的硬件实现方法"></a><em>进程互斥的硬件实现方法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201817781.png" alt="image.png"></p><h4 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a><em>中断屏蔽方法</em></h4><p>利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）</p><p><strong>优点</strong>：简单、高效<br><strong>缺点</strong>：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险</p><h4 id="TeatAndSet指令"><a href="#TeatAndSet指令" class="headerlink" title="TeatAndSet指令"></a><em>TeatAndSet指令</em></h4><p><code>注意：TestAndSet指令是通过硬件实现的，这里将指令用代码表示，是为了描述逻辑，硬件实现的内容，本质上并不是用代码实现的</code></p><p>简称TS指令，也有地方称为TestAndSetLock指令，或TSL指令。<br><strong><em>TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成</em></strong>。以下是用c语言描述的逻辑<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201826526.png" alt="image.png"></p><p><em>若刚开始lock 是 false，则TSL返回的old值为 false，while循环条件不满足，直接跳过循环，进入临界区。若刚开始lock 是true，则执行TLS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</em><br><strong><em>相比软件实现方法，TSL指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</em></strong></p><p><strong>优点</strong>：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞;适用于多处理机环境(当一个进程陷入等待，等待任然占用着处理机，如果是单核处理机，那么其他进程就一直没办法得到处理机，无法执行别的进程)<br><strong>缺点</strong>：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h4 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a><em>Swap指令</em></h4><p>有的地方也叫 Exchange 指令，或简称 XCHG 指令。Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用C语言描述的逻辑。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308201826713.png" alt="image.png"><br>逻辑上来看 Swap 和 TSL 并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在 old 变量上），再将上锁标记 lock 设置为 true，最后检查 old，如果 old 为 false 则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。<br><strong>优点</strong>：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境<br><strong>缺点</strong>：不满足“让权等待”原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><em>互斥锁</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211008173.png" alt="image.png"><br>特性：<br>• 需忙等，进程时间片用完才下处理机，违反“让权等待”<br>• 优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则    等待代价很低<br>• 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区<br>• 不太适用于单处理机系统，忙等的过程中不可能解锁<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211009131.png" alt="image.png"></p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a><em>信号量机制</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211114104.png" alt="image.png"></p><h4 id="为什么需要信号量机制？"><a href="#为什么需要信号量机制？" class="headerlink" title="为什么需要信号量机制？"></a><em>为什么需要信号量机制？</em></h4><p><em>进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）</em></p><ol><li>在双标志先检查法中，进入区的“检查”、“上锁” 操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；</li><li>所有的解决方案都无法实现“让权等待”</li></ol><p><em>所以，1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法——信号量机制</em></p><h4 id="信号量机制的实现"><a href="#信号量机制的实现" class="headerlink" title="信号量机制的实现"></a><em>信号量机制的实现</em></h4><p><strong>信号量</strong>其实就是一个变量 ，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为 1 的信号量。</p><p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。<strong>原语是由关中断/开中断指令实现的</strong>。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能<strong>把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题</strong>。</p><p>一对原语：wait(S) 原语和 signal(S) 原语，可以把原语理解为我们自己写的函数，函数名分别为 wait和 signal，括号里的信号量 S 其实就是函数调用时传入的一个参数。wait、signal 原语常简称为 P、V操作（来自荷兰语 proberen 和<br>verhogen）。因此，做题的时候常把wait(S)、signal(S) 两个操作分别写为<br>P(S)、V(S)</p><h4 id="整数型信号量"><a href="#整数型信号量" class="headerlink" title="整数型信号量"></a><em>整数型信号量</em></h4><ol><li>整数型信号量S是一个int 整数，直接记录资源数量</li><li>检查和上锁一气呵成，避免并发、异步导致的临界资源同时访问的问题</li><li>不满足“让权等待”，陷入自旋实际上还是占用着处理机<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">// 整型信号量S，表示某种资源的数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// wait原语</span></span><br><span class="line"><span class="keyword">while</span>(S &lt;= <span class="number">0</span>); <span class="comment">// 资源数不足，循环等待</span></span><br><span class="line">S = S - <span class="number">1</span>; <span class="comment">// 占用资源</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> S)</span> &#123; <span class="comment">// signal原语</span></span><br><span class="line">S = S + <span class="number">1</span>;<span class="comment">// 释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a><em>记录型信号量</em></h4><ol><li>记录型信号量S是一个结构体，里面包含着，资源数量和等待队列的信息</li><li>满足让权等待，资源不足时，直接bloack进入阻塞(并非循环)，此时不占用处理机。它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">int</span> value; <span class="comment">// 某种资源的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">process</span> *<span class="title">L</span>;</span> <span class="comment">// 等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(semaphore S)</span> &#123; <span class="comment">// wait原语</span></span><br><span class="line">S.value--;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">bloack(S.L); <span class="comment">// 阻塞进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">signal</span><span class="params">(semaphore S)</span> &#123; <span class="comment">// signal原语</span></span><br><span class="line">S.value++;</span><br><span class="line"><span class="keyword">if</span>(S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">wakeup(S.L); <span class="comment">// 唤醒进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211113344.png" alt="image.png"></li></ol><h3 id="信号量机制实现进程互斥、同步、前驱关系"><a href="#信号量机制实现进程互斥、同步、前驱关系" class="headerlink" title="信号量机制实现进程互斥、同步、前驱关系"></a><em>信号量机制实现进程互斥、同步、前驱关系</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211206401.png" alt="image.png"></p><ul><li><em>默认使用记录型信号量</em></li></ul><h4 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a><em>信号量实现进程互斥</em></h4><ol><li>分析并发进程的关键活动，划定临界区（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 mutex，初值为 1</li><li>在进入区 P(mutex)——申请资源</li><li>在退出区 V(mutex)——释放资源</li></ol><p>【对不同的临界资源需要设置不同的互斥信号量。P、V操作必须成对出现。缺少P(mutex) 就不能保证临界资源的互斥访问。缺少 V(mutex) 会导致资源永不被释放，等待进程永不被唤醒。】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211211699.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化semaphore mutex =1 是伪代码，实际上是对结构体内的value赋值为1</span><br><span class="line">这里简写了</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211210890.png" alt="image.png"></p><h4 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a><em>信号量实现进程同步</em></h4><ol><li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）</li><li>设置同步信号量 S, 初始为 0</li><li>在“前操作”之后执行 V(S)</li><li>在“后操作”之前执行 P(S)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">理解：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，</span><br><span class="line">而又只能由P1产生这种资源</span><br><span class="line"></span><br><span class="line">若先执行到 V(S) 操作，则 S++ 后 S=1。之后当执行到 P(S) 操作时，由于 S=1，表示有可用资源，会执行 S--，S 的值变回 0，P2 进程不会执行 block 原语，而是继续往下执行代码4。</span><br><span class="line"></span><br><span class="line">若先执行到 P(S) 操作，由于 S=0，S-- 后 S=-1，表示此时没有可用资源，因此P操作中会执行 block 原语，主动请求阻塞。之后当执行完代码2，继而执行 V(S) 操,S++，使 S 变回 0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V操作中执行 wakeup 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4 了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211215280.png" alt="image.png"></p><h4 id="信号量机制实现前驱关系"><a href="#信号量机制实现前驱关系" class="headerlink" title="信号量机制实现前驱关系"></a><em>信号量机制实现前驱关系</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211223105.png" alt="image.png"></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a><em>管程</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211320578.png" alt="image.png"></p><h4 id="什么是管程？"><a href="#什么是管程？" class="headerlink" title="什么是管程？"></a><em>什么是管程？</em></h4><blockquote><p><em>概念</em></p></blockquote><p>管程(Monitor)从概念上更接近一个类,而不是一个函数。</p><p>管程有以下特点:</p><ul><li>管程包含了数据字段(属性)和过程(方法)。这与面向对象编程中的类非常类似。</li><li>管程的数据字段和过程是绑定在一起的,对管程的访问需要通过其公开的过程,不能直接访问其内部数据,这提供了封装性。类也有相同的封装特性。</li><li>管程有其独立的实例,每个管程实例包含独立的私有数据,这也是类的一个特征。</li><li>管程的过程(方法)共享管程的私有数据,不同实例的数据相互隔离,这符合类的设计。</li></ul><p>而如果将管程看作一个函数,则不太恰当:</p><ul><li>函数通常没有内部状态(属性),只有输入输出参数。但管程有自己的内部状态。</li><li>函数不具备多实例的特性。管程可以创建多个实例。</li><li>函数的调用不具备互斥和同步特性。管程通过互斥锁和条件变量可实现复杂的同步。</li></ul><p>所以,从面向对象设计的角度,管程更接近一个类,它提供了封装性、数据隐藏、实例化等关键特征。<br>当然,管程也有与类不同的地方,它直接内置了同步和互斥的语义。但是从软件设计抽象的层面,管程是对一个同步对象的封装,可以看作是一个同步类。</p><blockquote><p><em>特征</em></p></blockquote><p>管程的基本特征：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问；</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li><li>每次仅允许一个进程在管程内执行某个内部过程。</li></ol><h4 id="为什么要引入管程？"><a href="#为什么要引入管程？" class="headerlink" title="为什么要引入管程？"></a><em>为什么要引入管程？</em></h4><p><em>主要是因为，编写程序时，每一个进程与进程之间P、V操作都要单独编写考虑，太过麻烦，且容易出错，所以引入管程，将内部逻辑封装，直接调用就可以逻辑自洽</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211323126.png" alt="image.png"></p><h4 id="管程解决生产者消费者问题"><a href="#管程解决生产者消费者问题" class="headerlink" title="管程解决生产者消费者问题"></a><em>管程解决生产者消费者问题</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211327231.png" alt="image.png"></p><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a><em>生产者-消费者问题</em></h3><p><strong><em>1.问题描述</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211454074.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211503162.png" alt="image.png"></p><ol><li><em>隐含两对同步</em><br>生产者、消费者共享一个初始为空、大小为n的缓冲区。<br>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。<br>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li><em>互斥性</em><br>缓冲区是临界资源，各进程必须互斥地访问。</li></ol><p><strong><em>3.如何实现</em></strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mutex是互斥信号量，用于实现互斥访问，初始=1</span><br><span class="line">empty=n是同步信号量，表示空闲区数目，用于实现仓库满时，生产等待消费先完成</span><br><span class="line">full=0是同步信号量，表示产品数量，用于实现仓库空是，消费等待生产先完成</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211458064.png" alt="image.png"></p><p><strong><em>4.能否改变相邻 P 、 V 操作的顺序？</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211503373.png" alt="image.png"></p><p><strong>P不能互换顺序</strong><br>若此时缓冲区内已经放满产品，则 empty=0，full=n。<br>则生产者进程执行① 使mutex变为0，再执行②，由于已没有空闲缓冲区，因此生产者被阻塞。由于生产者阻塞，因此切换回消费者进程。消费者进程执行③，由于mutex为0，即生产者还没释放对临界资源的“锁”，因此消费者也被阻塞。这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者释放临界区的情况，生产者和消费者循环等待被对方唤醒，出现“死锁”。因此，实现互斥的P操作一定要在实现同步的P操作之后</p><p><strong>V可以互换顺序</strong><br>V操作不会导致进程阻塞，因此两个V操作顺序可以交换。</p><h3 id="多生产者-多消费者问题"><a href="#多生产者-多消费者问题" class="headerlink" title="多生产者-多消费者问题"></a><em>多生产者-多消费者问题</em></h3><blockquote><p><em>”多“，只的是一个仓库，“多类产品和多类消费者“，并不是指“多个”。与上一个问题的区别，在于，产品类别有多个类，消费者也有多种</em></p></blockquote><p><strong><em>1.问题描述</em></strong><br>爸爸专向盘子中放苹果，妈妈专向盘子中放橘子。<br>儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。<br>只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211622711.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong></p><p><strong>互斥关系</strong>：（mutex = 1）<br>对缓冲区（盘子）的访问要互斥地进行</p><p><strong>同步关系（一前一后）</strong>：</p><ol><li>父亲将苹果放入盘子后，女儿才能取苹果</li><li>母亲将橘子放入盘子后，儿子才能取橘子</li><li>只有盘子为空时，父亲或母亲才能放入水果</li></ol><p><strong><em>3.如何实现</em></strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本题中的缓冲区大小为1，在任何时刻，apple、orange、plate 三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区…所以即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</span><br><span class="line"></span><br><span class="line">如果容量是2，就必须专门设置互斥变量mutex.</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211631853.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211633643.png" alt="image.png"></p><p><strong><em>4.总结</em></strong><br>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。<br>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。<br>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：</p><ul><li>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果</li><li>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果<br>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？<br>正确的分析方法应该从“事件”的角度来考虑，我们可以把上述四对“进程行为的前后关系”抽象为一对“事件的前后关系”<br>盘子变空事件-&gt;放入水果事件。“盘子变空事件”既可由儿子引发，也可由女儿引发；“放水果事件”既可能是父亲执行，也可能是母亲执行。这样的话，就可以用一个同步信号量解决问题了<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211636726.png" alt="image.png"></li></ul><h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a><em>吸烟者问题</em></h3><p><strong><em>1.问题描述</em></strong><br>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。<br>供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供<br>应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211702567.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br>本质上这题也属于“生产者-消费者”问题，更详细的说应该是“可生产多种产品的单生产者-多消费者”<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211704490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211705087.png" alt="image.png"></p><p><strong><em>3.如何实现</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211707985.png" alt="image.png"></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a><em>读者-写者问题</em></h3><p><strong><em>1.问题描述</em></strong><br>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<br>因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者<br>往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211752201.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong><br>两类进程：写进程、读进程<br>互斥关系：写进程—写进程、写进程—读进程。读进程与读进程不存在互斥问题。</p><p><strong><em>3.如何实现</em></strong><br><em>其核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用count 的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。另外，对 count 变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">若两个读进程并发执行，则 count=0时两个进程也许都能满足 if 条件，都会执行</span><br><span class="line">P(rw)，从而使第二个读进程阻塞的情况。如何解决：出现上述问题的原因在于对count 变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count 的访问是互斥的。</span><br><span class="line"></span><br><span class="line">潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。因此，这种算法中，读进程是优先的。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211755529.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改进：</span><br><span class="line">在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是相对公平的先来先服务原则。有的书上把这种算法称为“读写公平法”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211801533.png" alt="image.png"></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a><em>哲学家进餐问题</em></h3><p><strong><em>1.问题描述</em></strong><br>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211905578.png" alt="image.png"></p><p><strong><em>2.问题分析</em></strong></p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li><li>整理思路。<strong><em>这个问题中只有互斥关系</em></strong>，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。<strong><em>如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</em></strong></li><li>信号量设置。定义互斥信号量数组chopstick[5]={1,1,1,1,1} 用于实现对5个筷子的互斥访问。并对哲学家按0~4编号，哲学家 i 左边的筷子编号为 i，右边的筷子编号为 (i+1)%5。</li></ol><p><strong><em>3.如何实现</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211907670.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211908557.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308211908147.png" alt="image.png"></p><p><strong><em>5.总结</em></strong><br>哲学家进餐问题的关键在于解决进程死锁。<br>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。<br>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。可以参考哲学家就餐问题解决死锁的三种思路</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><em>死锁</em></h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a><em>死锁的概念</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221047994.png" alt="image.png"></p><blockquote><p>! <em>补充：当一个进程被阻塞时,它只是释放了对CPU的占用,进入了等待状态,而不会自动释放它已获得的其他资源(如内存、文件等)。这也是为什么会产生死锁（记录型信号量机制，只是会使进程阻塞释放CPU,但是对其他已经申请的资源保持占有）</em></p><p>! <em>补充：未必发生循环等待就一定死锁，但死锁一定发生循环等待</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221116933.png" alt="image.png"></p><h3 id="死锁处理策略—预防死锁"><a href="#死锁处理策略—预防死锁" class="headerlink" title="死锁处理策略—预防死锁"></a><em>死锁处理策略—预防死锁</em></h3><p><em>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。是一种<strong>静态的策略</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221220785.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221128419.png" alt="image.png"></p><h4 id="破坏“互斥条件”"><a href="#破坏“互斥条件”" class="headerlink" title="破坏“互斥条件”"></a><em>破坏“互斥条件”</em></h4><p>就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。</p><blockquote><p>缺点：但一般来说在所列的四个条件中，“互斥”条件是无法破坏的。因此，在死锁预防里主要是破坏其他几个必要条件，而不去涉及破坏“互斥”条件。</p></blockquote><h4 id="破坏“不剥夺条件”"><a href="#破坏“不剥夺条件”" class="headerlink" title="破坏“不剥夺条件”"></a><em>破坏“不剥夺条件”</em></h4><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。<br>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</p><blockquote><p>缺点：</p><ol><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol></blockquote><h4 id="破坏“请求和保持条件”"><a href="#破坏“请求和保持条件”" class="headerlink" title="破坏“请求和保持条件”"></a><em>破坏“请求和保持条件”</em></h4><p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。<br>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。</p><blockquote><p><em>缺点：有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿。</em></p></blockquote><h4 id="破坏“循环等待条件”"><a href="#破坏“循环等待条件”" class="headerlink" title="破坏“循环等待条件”"></a><em>破坏“循环等待条件”</em></h4><p>破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁(死锁发生只可能是大编号往小编号申请，但是违反了规则不会出现，所以死锁不会发生)。</p><blockquote><p>缺点：</p><ol><li>不方便增加新的设备，因为可能需要重新分配所有的编号；</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；</li><li>必须按规定次序申请资源，用户编程麻烦</li></ol></blockquote><h3 id="死锁处理策略—避免死锁"><a href="#死锁处理策略—避免死锁" class="headerlink" title="死锁处理策略—避免死锁"></a><em>死锁处理策略—避免死锁</em></h3><p><em>避免死锁： 用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221221115.png" alt="image.png"></p><h4 id="什么是安全序列？安全状态？"><a href="#什么是安全序列？安全状态？" class="headerlink" title="什么是安全序列？安全状态？"></a><em>什么是安全序列？安全状态？</em></h4><p>所谓<strong>安全序列</strong>，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，安全序列可能有多个。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p><strong>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁</strong>（处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态）因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221228929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221232296.png" alt="image.png"></p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a><em>银行家算法</em></h4><p>银行家算法：是荷兰学者 Dijkstra 为银行系统设计的，以确保银行在发放现金贷款时，不会发生不能满足所有客户需要的情况。后来该算法被用在操作系统中，用于<strong>避免死锁</strong>。</p><blockquote><p>核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。</p></blockquote><p><strong>例子</strong><br><em>资源总数 (10, 5, 7)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221239776.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时系统是否处于安全状态？</span><br><span class="line">思路：尝试找出一个安全序列…</span><br><span class="line">依次检查剩余可用资源 (3, 3, 2) 是否能满足各进程的需求</span><br><span class="line">可满足P1需求，将 P1 加入安全序列，并更新剩余可用资源值为 (5, 3, 2)</span><br><span class="line">依次检查剩余可用资源 (5, 3, 2) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求可满足P3需求，将 P3 加入安全序列，并更新剩余可用资源值为 (7, 4, 3)</span><br><span class="line">依次检查剩余可用资源 (7, 4, 3) 是否能满足剩余进程（不包括已加入安全序列的进程）的需求…………</span><br><span class="line">以此类推，共五次循环检查即可将5个进程都加入安全序列中，最终可得一个安全序列。该算法称为安全性算法。可以很方便地用代码实现以上流程，每一轮检查都从编号较小的进程开始检查。实际做题时可以更快速的得到安全序列。</span><br></pre></td></tr></table></figure></p><h4 id="银行家算法实现"><a href="#银行家算法实现" class="headerlink" title="银行家算法实现"></a><em>银行家算法实现</em></h4><p>数据结构：<br>长度为 m 的一维数组 Available 表示还有多少可用资源<br>nxm 矩阵 Max 表示各进程对资源的最大需求数<br>nxm 矩阵 Allocation 表示已经给各进程分配了多少资源<br>Max – Allocation = Need 矩阵表示各进程最多还需要多少资源<br>用长度为 m 的一位数组 Request 表示进程此次申请的各种资源数</p><p>银行家算法步骤：<br>①检查此次申请是否超过了之前声明的最大需求数<br>②检查此时系统剩余的可用资源是否还能满足这次请求<br>③试探着分配，更改各数据结构<br>④用安全性算法检查此次分配是否会导致系统进入不安全状态</p><p>安全性算法步骤：<br>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设系统中有 n 个进程，m 种资源.每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n*m 的矩阵（可用二维数组实现）表示所有进程对各种资源的最大需求数。不妨称为 最大需求矩 阵 Max，Max[i, j]=K 表示进程 Pi 最多需要 K 个资源</span><br><span class="line">Rj。同理，系统可以用一个 n*m 的 分配矩 阵 Allocation表示对所有进程的资源分配情况。Max – Allocation =Need 矩 阵 ，表示各进程最多还需要多少各类资源。另外，还要用一个 长 度为 m 的一 维 数 组 Available 表示当前系统中还有多少可用资源。某进程Pi向系统申请资源，可用一个长度为m的一维数组 Request i 表示本次申请的各种资源量。</span><br><span class="line"></span><br><span class="line">可用银行家算法预判本次分配是否会导致系统进入不安全状态：</span><br><span class="line">①如果 Request i [j]≤Need[i, j] (0≤j≤m)便转向②；否则认为出错。</span><br><span class="line">②如果 Request i [j]≤Available[j] (0≤j≤m)，便转向③ ；否则表示尚无足够资源，Pi必须等待。</span><br><span class="line">③系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判）：</span><br><span class="line">Available = Available - Request i ;</span><br><span class="line">Allocation[i, j] = Allocation[i, j] + Request i [j];</span><br><span class="line">Need[i, j] = Need[i, j] – Request i [j]</span><br><span class="line">④操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221251516.png" alt="image.png"></p><h3 id="死锁处理策略—检测和解除"><a href="#死锁处理策略—检测和解除" class="headerlink" title="死锁处理策略—检测和解除"></a><em>死锁处理策略—检测和解除</em></h3><p><em>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221414947.png" alt="image.png"></p><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a><em>死锁的检测</em></h4><p>为了能对系统是否已发生了死锁进行检测，必须：<br>①用某种数据结构来保存资源的请求和分配信息；<br>②提供一种算法，利用上述信息来检测系统是否已进入死锁状态。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221416320.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221416384.png" alt="image.png"></p><blockquote><p><em>绿色边，代表已经被分配出去的一个资源，蓝色边代表还需要申请的资源<br>资源足够时，进程结束会将资源归还，从而消除这些边，如果能将所有边消除就称这个图是<strong>可完全简化的</strong>此时一定没有发生死锁（相当于能找到一个安全序列）如果最终不能消除所有边，那么此时就是发生了死锁。</em></p></blockquote><p><em>1.可以消除所有的边说明没有发生死锁</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221419926.png" alt="image.png"></p><p><em>2.不可以消除所有的边，说明发生死锁</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221419782.png" alt="image.png"></p><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a><em>死锁的解除</em></h4><p>一旦检测出死锁的发生，就应该立即解除死锁。<br>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程。</p><p><em>解除死锁的主要方法有：</em></p><ol><li><strong>资源剥夺法</strong>。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li><strong>撤销进程法（或称终止进程法）</strong>。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。</li><li><strong>进程回退法</strong>。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221426075.png" alt="image.png"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221426118.png" alt="image.png"></p><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存的基础知识"><a href="#内存的基础知识" class="headerlink" title="内存的基础知识"></a>内存的基础知识</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251038806.png" alt="image.png"></p><h2 id="内存管理的概念"><a href="#内存管理的概念" class="headerlink" title="内存管理的概念"></a>内存管理的概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251058031.png" alt="image.png"></p><p><mark>操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？</mark></p><div style="background-color: #fffacd;padding:20px;"> 1. 操作系统负责<mark style="background-color: #FFB6C1;">内存空间的分配与回收</mark><br></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251105578.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;">2. 操作系统需要提供某种技术从逻辑上 对<mark style="background-color: #FFB6C1;">内存空间进行扩充</mark></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251107271.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 3.操作系统需要提供地址转换功能，负责程序的<mark style="background-color: #FFB6C1;">逻辑地址</mark>与<mark style="background-color: #FFB6C1;">物理地址</mark>的转换 </div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251108361.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 4.操作系统需要提供内存保护 功能。保证各进程只能访问自己进程所在的内存空间，不干扰其他进程 </div><blockquote><p><strong>内存保护</strong>可以采取两种方式：</p></blockquote><ul><li><p>方法1：在CPU中设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251119698.png" alt="image.png"></p></li><li><p>方法2：采用<font color="#FF0000">重定位寄存器</font>（又称<font color="#FF0000">基址寄存器</font>）和<font color="0000FF">界地址寄存器</font>（又称<font color="0000FF">限长寄存器</font>）进行越界检查。重定位寄存器中存放的是进程的<font color="#FF0000">起始物理地址</font>。界地址寄存器中存放的是进程的<font color="0000FF">最大逻辑地址.</font><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251120552.png" alt="image.png"></p></li></ul><h2 id="进程的内存映像"><a href="#进程的内存映像" class="headerlink" title="进程的内存映像"></a>进程的内存映像</h2><p><mark>这是一段代码，分别对应存储在不同的内存区域当中</mark></p><div style="background-color: #fffacd;padding:20px;"> <li><mark style="background-color: #808080;">操作系统内核区</mark> :存进程控制块PCB</li><li><mark style="background-color: #FFB6C1;">用户栈(stack)</mark>：存局部变量以及传递参数</li><li><mark style="background-color: #ffe599;">共享库的存储映射区</mark>：被调用的库函数，如：<code>#include  studio.h头文件包括的库函数</code></li><li><mark style="background-color: #00FFFF;">堆（heap）</mark>：由 malloc/free 分配、回收的数据</li><li><mark style="background-color: #00FF00;">读/写数据</mark>：定义在函数外的全局变量、由 static 关键字修饰的变量</li><li><mark style="background-color:#CCCCFF;">只读代码/数据</mark>：程序代码、由 const 关键字修饰的常量</li><br><font color="#FF0000">注意：#define X 1024 宏定义的常量不专门分配存储空间，在预编译阶段就将程序中所有X都想替换成了1024</font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251427815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251424521.png" alt=""></p><blockquote><p><em>32位系统的，内存空间是4GB。32位是MAR位数，指的是最多有2<sup>32</sup>个内存地址，按照字节寻址，所以总容量就是2<sup>32</sup>B=4GB</em></p></blockquote><h2 id="内存管理-1"><a href="#内存管理-1" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311059270.png" alt="image.png"></p><h3 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251536268.png" alt="image.png"></p><h4 id="进程的覆盖技术与交换技术"><a href="#进程的覆盖技术与交换技术" class="headerlink" title="进程的覆盖技术与交换技术"></a>进程的覆盖技术与交换技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251530850.png" alt="image.png"></p><p><strong><em>1.覆盖技术</em></strong><br>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存。内存中分为<font color="#FF0000">一个“固定区”</font>和<font color="#FF0000">若干个“覆盖区”。</font>需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251540297.png" alt="image.png"></p><blockquote><p>缺点：<mark>必须由程序员声明覆盖结构</mark>，操作系统完成自动覆盖。<mark>对用户不透明，增加了用户编程负担</mark>。覆盖技术只用于早期的操作系统中，现在已成为历史。</p></blockquote><p><strong><em>2.交换技术</em></strong><br>交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存（以进程为单位进行交换,），把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度），<font color="#FF0000">中级调度(内存调度)</font>实现。暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251544003.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> 交换技术需要考虑的问题<br>1. 应该在外存（磁盘）的什么位置保存被换出的进程？<br>2. 什么时候应该交换？<br>3. 应该换出哪些进程？</div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251547948.png" alt="image.png"></p><ol><li>具有对换功能的操作系统中，通常把磁盘空间分为<mark>文件区</mark>和<mark style="background-color: #00FFFF;">对换区</mark>两部分。<font color="#FFA500">文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；</font><font color="#0000FF">对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式</font>（学过文件管理章节后即可理解）。总之，对换区的I/O速度比文件区的更快。</li><li>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出。</li><li>可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间…（注意：PCB 会常驻内存，不会被换出外存）</li></ol><h4 id="虚拟存储技术"><a href="#虚拟存储技术" class="headerlink" title="虚拟存储技术"></a><em>虚拟存储技术</em></h4><p>虚拟存储技术是通过把内存扩展到外部存储设备,让程序可以获得比实际内存更大的逻辑地址空间。它通过把内存分页,并与外部存储建立页面映射表,当需要访问不在内存的页面时,通过页面置换算法将其换入内存。</p><div style="background-color: #fffacd;padding:20px;"> <mark>虚拟存储技术与交换技术的区别？</mark><font size="3"><br>1. 虚拟存储以页面为单位,交换技术以进程为单位。<br>2. 虚拟存储需要建立地址映射表,维护页面与外存地址的对应关系。交换技术不需要。<br>3. 虚拟存储发生页面异常时才发生换页,交换技术在进程切换时就进行。<br>4. 虚拟存储对程序是透明的,程序不必关心页面访问,交换技术程序需要关心整个进程的换入换出。<br>5. 虚拟存储可以同时维持多个进程/程序的工作集,交换技术每次只能有一个进程在运行。</font><br><br> <mark>虚拟存储技术与覆盖技术的区别？</mark><br><font size="3">1. 工作方式不同<br>虚拟存储是把内存扩展到外部存储设备,建立页面映射表,实现地址映射和自动页面调度。数据按需换入换出。<br>覆盖技术是在内存中维持多个覆盖程序,只加载当前需要执行的覆盖程序到内存。数据不会自动调度,需要程序员控制。<br>2. 程序个数不同<br>虚拟存储可以同时维持多个进程在内存和外存的工作集。<br>覆盖技术每次只能加载一个覆盖程序到内存执行。<br>3. 对程序的影响不同<br>虚拟存储对运行程序透明,程序不必关心页面调度。<br>覆盖技术程序员必须控制程序的覆盖和重定位。<br>4. 实现难度不同<br>虚拟存储实现较复杂,需要建立地址映射、页面置换算法等机制。<br>覆盖技术原理简单,直接通过程序员控制实现。<br>5. 使用范围不同<br>虚拟存储广泛用于各种通用操作系统。<br>覆盖技术只适用于特定的嵌入式系统。</div></font>>*具体会在3.5中作详细介绍*### 内存空间的分配与回收#### 连续分配管理方式<mark>连续分配是指为用户分配的必须是连续的一段内存空间</mark>![image.png](https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251611336.png)##### ***1.单一连续分配***在单一连续分配方式中，内存被分为<mark>系统区</mark>和<mark>用户区</mark>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。<mark>内存中只能有一道用户程序，用户程序独占整个用户区空间。</mark>>**优点**：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护（eg：早期的 PC 操作系统 MS-DOS）。>**缺点**：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低<div style="background-color: #ffe599;padding:15px;"> 注：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”</div> <p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251614067.png" alt="image.png"></p><h5 id="2-固定分区分配"><a href="#2-固定分区分配" class="headerlink" title="2.固定分区分配"></a><strong><em>2.固定分区分配</em></strong></h5><p>出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是<mark>将整个用户空间划分为若干个固定大小的分区</mark>，在每个分区中只装入一道作业，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。</p><p><mark style="background-color: #00FFFF;">分区大小相等</mark>：缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合（比如：钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）<br><mark style="background-color: #00FFFF;">分区大小不等</mark>：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分比如：划分多个小分区、适量中等分区、少量大分区）</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251650375.png" alt="image.png"></p><div style="background-color: #ffe599;padding:15px;"> 这些分区，用什么方式记录管理分配呢？ </div> <p>操作系统需要建立一个数据结构——分区说明表，来实现各个分区的分配与回<br>收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的<br>大小、起始地址、状态（是否已分配）。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251656124.png" alt="image.png"><br>当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，<br>从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状<br>态为“已分配”</p><blockquote><p><strong>优点</strong>：实现简单，<font color="#FF0000">无外部碎片。</font><br><strong>缺点</strong>：a. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采<br>用覆盖技术来解决，但这又会降低性能；b. <font color="#FF0000">会产生内部碎片</font>，内存利用率低。</p></blockquote><p><mark>注</mark>：<em>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。 外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</em></p><h5 id="3-动态分区分配"><a href="#3-动态分区分配" class="headerlink" title="3.动态分区分配"></a><strong><em>3.动态分区分配</em></strong></h5><p>动态分区分配又称为可变分区分配。<mark>这种分配方式不会预先划分内存分区</mark>，而是在进程装入内存时，<mark>根据进程的大小动态地建立分区</mark>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。（eg：假设某计算机内存大小为 64MB，系统区 8MB，用户区共 56 MB…）</p><ol><li><p>系统要用什么样的数据结构记录内存的使用情况？<br>答：空闲分区表和空闲分区链（记录的都是空闲内存区域）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251704694.png" alt="image.png"></p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？应该用最大的分区进行分配 ？还 是用最小的分区进行分配 ？ 又或是用地址最低 的部分进行分配?<br>答：下一节讨论</p></li><li><p>如何进行分区的分配与回收操作？<br>答：相邻的空闲分区合并为一个</p></li></ol><blockquote><p>动态分区分配没有内部碎片，但是有外部碎片。<br>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片。</p></blockquote><h5 id="（动态分区分配算法）"><a href="#（动态分区分配算法）" class="headerlink" title="!（动态分区分配算法）"></a>!（动态分区分配算法）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251845899.png" alt="image.png"></p><p><strong>引入</strong><br>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？</p><p><strong>1.首次适应算法</strong><br><strong><em>算法思想</em></strong>：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。<br><strong><em>如何实现</em></strong>：空闲分区以<strong>地址递增的次序排列</strong>。每次分配内存时顺序查找<strong>空闲分区链</strong>（或<strong>空闲分区表</strong>），找到大小能满足要求的第一个空闲分区。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251847680.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251849013.png" alt="image.png"></p><p><strong>2.最佳适应算法</strong><br><strong><em>算法思想</em></strong>：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。<br><strong><em>如何实现</em></strong>：空闲分区按<strong>容量递增次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><blockquote><p>缺点：每次都是选取最小的分区进行分配，会留下越来越多，很小的难以利用的内存块，因此会产生很多的外部碎片<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251850723.png" alt="image.png"></p></blockquote><p><strong>3.最坏适应算法</strong><br><strong><em>算法思想</em></strong>：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。<br><strong><em>如何实现</em></strong>：空闲分区按<strong>容量递减次序链接</strong>。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><blockquote><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251854915.png" alt="image.png"></p><p><strong>4.邻近适应算法</strong><br><strong><em>算法思想</em></strong>：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。<br><strong><em>如何实现</em></strong>：空闲分区以<strong>地址递增的顺序排列</strong>（可排成一个循环链表）。每次分配内存时<strong>从上次查找结束的位置开始查找空闲分区链</strong>（或空闲分区表），找到大小能满足要求的第一个空闲分区。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251857013.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251858752.png" alt="image.png"></p><p><strong>总结</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308251859958.png" alt="image.png"></p><h4 id="非连续非配管理方式"><a href="#非连续非配管理方式" class="headerlink" title="非连续非配管理方式"></a>非连续非配管理方式</h4><p><mark>非连续分配是指为用户分配的可以是一些分散的内存空间</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261122291.png" alt="image.png"></p><h5 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a><strong><em>基本分页存储管理</em></strong></h5><p><strong><em>1.什么是分页存储？</em></strong><br>将内存空间分为一个个大小相等的分区（比如：每个分区4KB），每个分区就是一个“页框”（页框=页帧=内存块=物理块=物理页面）。每个页框有一个编号，即“页框号”（页框号=页帧号=内存块号=物理块号=物理页号），<strong><em>页框号从 0 开始</em></strong></p><p>将进程的逻辑地址空间也分为 与页框大小相等 的一个个部分，每个部分称为一个“页”或“页面” 。每个页面也有一个编号，即“页号”，<strong><em>页号也是 从 0 开始 。</em></strong></p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中。</p><blockquote><p>注：进程的最后一个页面可能没有一个页框那么大。也就是说，分页存储有可能产生内部碎片，因此页框不能太大，否则可能产生过大的内部碎片造成浪费</p></blockquote><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261131317.png" alt="图片alt"> </p><p><strong><em>2.分页存储的逻辑地址结构</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262117101.png" alt="image.png"></p><p><strong><em>3.页表</em></strong><br>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。【注：页表通常存在PCB（进程控制块）中】</p><ol><li>一个进程对应一张页表。</li><li>进程的每个页面对应一个页表项。</li><li>每个页表项由“页号”和“块号”组成。</li><li>页表记录进程页面和实际存放的内存块之间的映射关系。</li><li>每个页表项的长度是相同的。</li></ol><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261138273.png" alt="图片alt"> </p><p><strong><em>4.每个页表项占多少个字节？</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261142588.png" alt="image.png"></p><blockquote><p>注：页表项连续存放，因此页号可以是隐含的，不占存储空间（类比数组）</p></blockquote><p><em>假设页表中的各页表项从内存地址为 X 的地方开始连续存放…如何找到页号为 i 的页表项？（按字节编址）</em></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261356850.png" alt="图片alt"> </p><p>i 号页表项的存放地址 = X + 3 * I 因此，页表中的页号可以是隐含的，即页号不占用存储空间。通过页号结合页表项长度，计算得出块号存放起始地址，然后就可以取得块号，最后将取得的块号与逻辑偏移量拼接就得到物理地址了</p><p><strong><em>5.如何实现地址转换？</em></strong><br>将进程地址空间 分页 之后，操作系统该如何实现逻辑地址到物理地址的转换？</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261149066.png" alt="image.png"></p><blockquote><p>在计算机内部，地址是用二进制表示的，如果页面大小 刚好是 2 的整数幂，则计算机硬件可以很快速的把逻辑地址拆分成（页号，页内偏移量）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261348326.png" alt="image.png"></p><p><strong>总结：页面大小 刚好是 2 的整数幂有什么好处？</strong><br>①逻辑地址的拆分更加迅速——如果每个页面大小为 2 K B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面的大小为 2 的整数幂，计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度。<br>②物理地址的计算更加迅速——根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261349033.png" alt="image.png"></p><h5 id="（基本地址变换机构）"><a href="#（基本地址变换机构）" class="headerlink" title="!（基本地址变换机构）"></a>!（基本地址变换机构）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261433939.png" alt="image.png"></p><p><strong><em>地址变换过程</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261448746.png" alt="image.png"></p><blockquote><p>通常会在系统中设置一个<strong>页表寄存器（PTR）</strong>，存放页表在内存中的起始地址F 和页表长度M。进程未执行时，<strong><em>页表的始址和页表长度</em></strong> 放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。</p></blockquote><p>设页面大小为L，逻辑地址A到物理地址E的变换过程如下：<br>①计算页号 P 和页内偏移量W（ 如果用十进制数手算，则 P=A/L，W=A%L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）。<br>②比较页号P 和页表长度M，若 P≥M，则产生越界中断，否则继续执行。（注意：页号是从0开始的，而页表长度至少是1，因此 P=M 时也会越界）。<br>③页表中页号P对应的页表项地址 = 页表起始地址F + 页号P <em> 页表项长度，取出该页表项内容b，即为内存块号。（<font color="#FF0000">注意区分页表项长度、页表长度、页面大小的区别。<mark>页表长度指的是这个页表中总共有几个页表项，即总共有几个页</mark>；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间</font>）。<br>④计算 E = b </em> L + W，用得到的物理地址E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261453894.png" alt="image.png"></p><h5 id="（具有快表的地址变换机构）"><a href="#（具有快表的地址变换机构）" class="headerlink" title="!（具有快表的地址变换机构）"></a>!（具有快表的地址变换机构）</h5><p><strong><em>1.什么是快表？</em></strong><br>快表，又称联想寄存器（TLB， translation lookaside buffer ），是一种访问速度比内存快很多的高速缓存（TLB不是内存！），用来存放最近访问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。</p><blockquote><p>TLB 和 普通 Cache 的区别——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p></blockquote><p><strong><em>2.引入快表后，地址变换过程</em></strong><br>① CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。<br>② 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。<br>③ 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261532866.png" alt="图片alt"> </p><p>例：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p><p>(1+100) <em> 0.9 + (1+100+100) </em> 0.1 = 111 us<br>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) <em> 0.9 + (100+100) </em> 0.1 =110.9 us<br>若未采用快表机制，则访问一个逻辑地址需要 100+100 = 200us<br>显然，引入快表机制后，访问一个逻辑地址的速度快多了。</p><blockquote><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到 90% 以上。</p></blockquote><p><strong><em>3.什么是局部性原理？</em></strong></p><p><strong>时间局部性</strong>：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）<br><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261539092.png" alt="图片alt"> </p><p><strong><em>4.区别</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261558477.png" alt="image.png"></p><h5 id="（两级页表）"><a href="#（两级页表）" class="headerlink" title="!（两级页表）"></a>!（两级页表）</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261912045.png" alt="image.png"></p><p><strong><em>1.单页表存在的问题</em></strong></p><p>问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。<br>问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308261915514.png" alt="image.png"></p><p><strong><em>2.如何解决单级页表的问题</em></strong></p><p>解决问题一：把<strong>页表再分页并离散存储</strong>，然后再建立一张页表记录页表各个部分的存放位置，称为<strong>页目录表</strong>，或称<strong>外层页表</strong>，或称<strong>顶层页表</strong>。</p><p>解决问题二：可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存。若想访问的页面不在内存中，则产生缺页中断（内中断/异常），然后将目标页面从外存调入内存。</p><p><strong><em>3.二级页表的原理、地址结构</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262011315.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262012145.png" alt="image.png"></p><p><strong><em>4.如何实现地址变换</em></strong><br>①按照地址结构将逻辑地址拆分成三部分<br>②从PCB 中读出页目录表始址，再根据一级页号查页目录<br>表，找到下一级页表在内存中的存放位置<br>③根据二级页号查二级页表，找到最终想访问的内存块号<br>④结合页内偏移量得到物理地址</p><p>例：将逻辑地址 (0000000000,0000000001,111111111111) 转换为物理地址（用十进制表示）。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262019570.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262022937.png" alt="image.png"></p><p><strong><em>5.需要注意的几个细节</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262027027.png" alt="image.png"></p><h5 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h5><p>与“分页”最大的区别就是——离散分配时所分配地址空间的基本单位不同。在分页当中，每个页面的大小是相同的；分段当中，每个段的大小是不同的。</p><p><strong><em>1.什么是分段存储？</em></strong><br>进程的地址空间：按照程序自身的逻辑关系划分为若干个大小不一的段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从0开始编址内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262112169.png" alt="image.png"></p><p><strong><em>2.分段存储的逻辑地址结构</em></strong><br>分段系统的&lt;&gt;逻辑地址&lt;&gt;结构由段号（段名）和段内地址（段内偏移量）所组成。如：</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262118933.png" alt="image.png"><br>在上述例子中，若系统是按字节寻址的，<br>则段号占16位，因此在该系统中，每个进程最多有 2 16 = 64K 个段。<br>段内地址占 16位，因此每个段的最大长度是 2 16 = 64KB。</p><p><strong><em>3.段表</em></strong></p><ol><li><strong>每个段对应一个段表项</strong>，其中记录了该段在内存中的起始位置（又称“基址”）和段的长度。（由于主存中的分段大小不一，所以不能只存块号，应直接存基址）</li><li><strong>各个段表项的长度是相同的</strong>。例如：某系统按字节寻址，采用分段存储管理，逻辑地址结构为（段号16位, 段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占 16+32 = 48位，即6B。由于段表项长度相同，因此段号可以是隐含的，不占存储空间。若段表存放的起始地址为 M，则 K号段对应的段表项存放的地址为 M + K * 6</li></ol><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262122760.png" alt="图片alt"> </p><p><strong><em>4.如何实现地址转换?</em></strong></p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262126386.png" alt="图片alt"> </p><p><strong><em>5.分段与分页管理的对比</em></strong></p><div style="background-color: #fffacd;padding:20px;"> <font color="#FF0000">页是信息的物理单位</font>。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，<font color="#FF0000">对用户是不可见的</font>。<br><font color="#FF0000">段是信息的逻辑单位</font>。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。<font color="#FF0000">分段对用户是可见的</font>，用户编程时需要显式地给出段名。页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序。<br><br><font color="#FF0000">分页</font> 的用户进程<font color="#FF0000">地址空间是一维的</font>，程序员只需给出一个记忆符即可表示一个地址。<br><font color="#FF0000">分段</font> 的用户进程<font color="#FF0000">地址空间是二维的</font>，程序员在标识一个地址时，既要给出段名，也要给出段内地址。<br><br>访问一个逻辑地址需要几次访存？<br>分页（单级页表）：第一次访存——查内存中的页表，第二次访存——访问目标内存单元。总共两次访存。<br>分段：第一次访存——查内存中的段表，第二次访存——访问目标内存单元。总共两次访存与分页系统类似，分段系统中也可以引入快表机构，将近期访问过的段表项放到快表中，这样可以少一次访问，加快地址变换速度。<mark>分段比分页更容易实现信息的共享和保护</mark></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如要共享进程中绿色部分信息：</span><br><span class="line"></span><br><span class="line">如果进程是分段存储管理，很容易将这部分共享信息单独分一个段出来，设置为可共享。</span><br><span class="line"></span><br><span class="line">如果进程是分页存储管理，由于每一个页面大小固定，本分割放到两个不同的块中，由于绿色部分需要实现共享，但是其他部分信息不应该共享，这样就使得信息共享变得困难，也使得很难用页表实现信息保护</span><br></pre></td></tr></table></figure><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262140725.png" alt="图片alt"> </p><p><strong><em>6.总结</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308262147649.png" alt="image.png"></p><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a><em>虚拟内存管理</em></h2><h3 id="虚拟内存管理基本概念"><a href="#虚拟内存管理基本概念" class="headerlink" title="虚拟内存管理基本概念"></a><em>虚拟内存管理基本概念</em></h3><h4 id="传统存储管理方式的特征"><a href="#传统存储管理方式的特征" class="headerlink" title="传统存储管理方式的特征"></a>传统存储管理方式的特征</h4><p>上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：</p><ol><li>一次性<br>作业必须一次性全部装入内存后，方能开始运行。这会导致两种情况发生：<ul><li>当作业很大，不能全部被装入内存时，将使该作业无法运行；</li><li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li></ul></li></ol><ol><li>驻留性<br>作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待I/O而被阻塞，可能处于长期等待状态。  </li></ol><p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311107301.png" alt="图片alt"> </p><h4 id="虚拟内存的定义和特征"><a href="#虚拟内存的定义和特征" class="headerlink" title="虚拟内存的定义和特征"></a><em>虚拟内存的定义和特征</em></h4><ul><li><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）</p></li><li><p>空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）</p></li></ul><p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。<br>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存</p><p>虚拟内存有一下三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li></ul><h4 id="如何实现虚拟内存技术"><a href="#如何实现虚拟内存技术" class="headerlink" title="如何实现虚拟内存技术"></a><em>如何实现虚拟内存技术</em></h4><blockquote><p>虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在<mark>离散分配</mark>的内存管理方式基础上。虚拟内存的实现有以下三种方式：</p></blockquote><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311114432.png" alt="图片alt"> </p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311115631.png" alt="image.png"></p><h3 id="请求分页管理方式"><a href="#请求分页管理方式" class="headerlink" title="请求分页管理方式"></a>请求分页管理方式</h3><p><strong>请求分页系统</strong>是建立在基本分页的基础上的，为了能支持<strong>虚拟存储器</strong>功能而增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能。<br>相应地，每次<strong>调入</strong>和<strong>换出</strong>的基本单位都是长度固定的页面，这使得请求分页系统在实现上要比请求分段系统简单。<br>请求分段系统在换进和换出时是<strong>可变长度的段</strong>因此，请求分页便成为目前最常用的一种实现虚拟存储器的方式</p><p><strong><em>请求分页中的硬件支持</em></strong><br>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一台具有一定容量的内存及外存的计算机系统外，还需要有<strong>页表机制</strong>、<strong>缺页中断机构</strong>以及<strong>地址变换机构</strong></p><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a><mark>页表机制</mark></h4><p>在请求分页系统中所需要的主要<strong>数据结构</strong>是<strong>页表</strong>。其基本作用仍然是将<strong>用户空间</strong>中的<strong>逻辑地址</strong>变换为<strong>内存空间</strong>中的<strong>物理地址</strong>。<br>由于只将应用程序的<strong>一部分调入内存</strong>，还有一部分仍在盘上，故需在页表中再<font color="#FF0000">增加4个字段</font>，供程序（数据）在换进、换出时参考。</p><p>请求分页系统中的每个页表项如下所示：</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311254870.png" alt="图片alt"> </p><ul><li><strong>状态位P</strong>：用于指示该页<strong>是否已调入内存</strong>，供<strong>程序访问</strong>时参考。</li><li><strong>访问字段A</strong>：用于记录本页在<strong>一段时间内被访问的次数</strong>，或记录本页最近已有多长时间未被访问，供选择<strong>换出页面</strong>时参考。</li><li><strong>修改位M</strong>：表示该页在调入内存后是否被修改过。供<strong>置换页面</strong>时参考。由于内存中的每一页都在<strong>外存上有一份副本</strong>，因此，若<strong>未被修改</strong>，在置换该页时就<strong>不需要</strong>将该页写回到外存上，以减少<strong>系统的开销</strong>和<strong>启动磁盘</strong>的次数；若<strong>已被修改</strong>，则必须将该页<strong>重写到外存</strong>上，以保证外存中所保留的始终是最新副本。</li><li><strong>外存地址</strong>：用于指出该页在外存上的地址</li></ul><h4 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a><mark>缺页中断机制</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311334123.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311335392.png" alt="image.png"></p><h4 id="地址变换机制"><a href="#地址变换机制" class="headerlink" title="地址变换机制"></a><mark>地址变换机制</mark></h4><div style="background-color: #fffacd;padding:20px;"><font color="#FF0000">请求分页存储管理与基本分页存储管理的主要区别:</font> <font size="3"><br>1.操作系统要提供请求调页功能，将缺失页面从外存调入内存<br>2.操作系统要提供页面置换的功能，将暂时用不到的页面换出外存<br><br><font color="#FF0000">在具有快表机构的请求分页系统中访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</font><br>查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元<br><br>补充细节<br>①只有“写指令”才需要修改“修改位”。并且，一般来说只需修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数。<br>②和普通的中断处理一样，缺页中断处理依然需要保留CPU现场<br>③需要用某种“页面置换算法”来决定一个换出页面（下节内容）<br>④换入/换出页面都需要启动慢速的I/O操作，可见，如果换入/换出太频繁，会有很大的开销<br>⑤页面调入内存后，需要修改慢表(页表)，同时也需要将表项复制到快表中</font></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308311341324.png" alt="image.png"></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a><em>页面置换算法</em></h3><p>请求分页存储管理与基本分页存储管理的主要区别：<br>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。<font color="#FF0000">用页面置换算法决定应该换出哪个页面</font></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011838965.png" alt="image.png"></p><h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a><mark>最佳置换算法(OPT)</mark></h4><p>最佳置换算法（OPT，Optimal）：每次选择淘汰的页面将是<font color="#FF0000">以后永不使用</font>，或者在<font color="#FF0000">最长时间内不再被访问的页面</font>，这样可以保证最低的缺页率。<br>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。<font color="#FF0000">操作系统无法提前预判页面访问序列</font>。因此，<font color="#FF0000">最佳置换算法是无法实现的</font>。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011900075.png" alt="image.png"></p><h4 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a><mark>先进先出置换算法(FIFO)</mark></h4><p>先进先出置换算法（FIFO）：每次<font color="#FF0000">选择淘汰的页面是最早进入内存的页面</font><br>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011904558.png" alt="image.png"></p><div style="background-color: #fffacd;padding:20px;"> <font color="#FF0000">Belady 异常</font>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011905761.png" alt="图片alt"> </p><font color="#FF0000">只有 FIFO 算法会产生 Belady 异常</font>。另外，FIFO算法虽然实现简单，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，<font color="#FF0000">算法性能差</font></div><h4 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法(LRU)"></a><mark>最近最久未使用置换算法(LRU)</mark></h4><p>最近最久未使用置换算法（LRU，least recently used）：<font color="#FF0000">每次淘汰的页面是最近最久未使用的页面</font>。<br>实现方法：赋予每个页面对应的页表项中，用<font color="#FF0000">访问字段记录</font>该页面自上次被访问以来所经历的时间t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面。(<strong>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</strong>)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011913528.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011914280.png" alt="image.png"></p><h4 id="时针置换算法-CLOCK"><a href="#时针置换算法-CLOCK" class="headerlink" title="时针置换算法(CLOCK)"></a><mark>时针置换算法(CLOCK)</mark></h4><p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用。置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算(NRU，NotRecently Used)。</p><p><font color="#FF0000">简单的CLOCK 算法实现方法</font>：为每个页面设置一个<font color="#FF0000">访问位</font>，再将内存中的页面都通过<font color="#FF0000">链接指针链接成一个循环队列</font>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。<br>如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，<font color="#FF0000">因此简单的CLOCK 算法选择一个淘汰页面最多会经过两轮扫描</font>）</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011940090.png" alt="image.png"></p><h4 id="改进型的时钟置换算法"><a href="#改进型的时钟置换算法" class="headerlink" title="改进型的时钟置换算法"></a><mark>改进型的时钟置换算法</mark></h4><p><font color="#FF0000">简单的时钟置换算法</font>仅考虑到一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行I/O操作写回外存。<font color="#FF0000">只有被淘汰的页面被修改过时，才需要写回外存</font>。<br>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，<font color="#FF0000">避免I/O操作</font>。这就是改进型的时钟置换算法的思想。</p><p>修改位=0，表示页面没有被修改过；修改位=1，表示页面被修改过。<br>为方便讨论，用（访问位，修改位）的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011943937.png" alt="图片alt"> </p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011943702.png" alt="image.png"></p><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309011945804.png" alt="image.png"></p><h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a><em>页面分配策略</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309012117487.png" alt="image.png"></p><h4 id="驻留集"><a href="#驻留集" class="headerlink" title="驻留集"></a><mark>驻留集</mark></h4><p>指请求分页存储管理中<mark style="background-color: #FFB6C1;">给进程分配的物理块的集合</mark>。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少；驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应大小合理</p><div style="background-color: #fffacd;padding:20px;"> 考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页。</div><h4 id="页面分配、置换策略"><a href="#页面分配、置换策略" class="headerlink" title="页面分配、置换策略"></a><mark>页面分配、置换策略</mark></h4><p><mark style="background-color: #FFB6C1;">分配</mark></p><ul><li><strong>固定分配</strong>：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，驻留集大小不变</li><li><strong>可变分配</strong>：先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，驻留集大小可变</li></ul><p><mark style="background-color: #FFB6C1;">置换</mark></p><ul><li><strong>局部置换</strong>：发生缺页时只能选进程自己的物理块进行置换。</li><li><strong>全局置换</strong>：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。</li></ul><div style="background-color: #fffacd;padding:20px;"> 所以，驻留集是固定分配时，只能局部置换；驻留集是可变分配时，可以全局、也可以局部置换<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309012129658.png" alt="图片alt"> </p></div><p><font color="#FF0000">固定分配局部置换</font>：<strong>系统为每个进程分配一定数量的物理块</strong>，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p><p><font color="#FF0000">可变分配全局置换</font>：<strong>刚开始会为每个进程分配一定数量的物理块</strong>。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</p><p><font color="#FF0000">可变分配局部置换</font>：<strong>刚开始会为每个进程分配一定数量的物理块</strong>。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</p><h4 id="调入页面的时机"><a href="#调入页面的时机" class="headerlink" title="调入页面的时机"></a><mark>调入页面的时机</mark></h4><ol><li><p>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略<font color="#FF0000">主要用于进程的首次调入</font>，由程序员指出应该先调入哪些部分。<mark>运行前调入</mark></p></li><li><p>请求调页策略：<font color="#FF0000">进程在运行期间发现缺页时才将所缺页面调入内存</font>。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/O操作，因此I/O开销较大。<mark>运行时调入</mark></p></li></ol><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a><mark>从何处调入页面</mark></h4><ol><li><font color="#FF0000">系统拥有足够的对换区空间</font>：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022206236.png" alt=""></li></ol><ol><li><font color="#FF0000">系统缺少足够的对换区空间</font>：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022208007.png" alt="image.png"></li></ol><ol><li><font color="#FF0000">UNIX 方式</font>：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022208479.png" alt="image.png"></li></ol><h4 id="抖动现象"><a href="#抖动现象" class="headerlink" title="抖动现象"></a><mark>抖动现象</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022211970.png" alt="image.png"></p><h4 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a><mark>工作集</mark></h4><p>驻留集：指请求分页存储管理中给进程分配的内存块的集合。<br>工作集：指在某段时间间隔里，进程实际访问页面的集合。</p><p>操作系统会根据“窗口尺寸”来算出工作集。例：<br>某进程的页面访问序列如下，窗口尺寸为 4，各时刻的工作集为？</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022213330.png" alt="图片alt"> </p><p><font color="#FF0000">工作集大小可能小于窗口尺寸</font>，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。<br>如：窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么<font color="#FF0000">说明该进程有很好的局部性</font>，可以给这个进程分配3个以上的内存块即可满足进程的运行需要。<br>一般来说，<font color="#FF0000">驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页</font>。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><mark>总结</mark></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202309022216598.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高数严选题</title>
      <link href="/undefined/c037e1e7.html"/>
      <url>/undefined/c037e1e7.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272246971.png" alt="image.png"></p><h1 id="1-函数极限连续"><a href="#1-函数极限连续" class="headerlink" title="1.函数极限连续"></a>1.函数极限连续</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>开区间连续，两端点单侧极限存在，是函数有界的充分条件，而不是必要条件</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201100161.png" alt="image.png"></p><p><em>相乘的极限存在，不想代表，各自都有极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201114713.png" alt="image.png"></p><p><em>利用夹逼定理，单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201121973.png" alt="image.png"></p><p><em>极限要求趋向于0，但不等于0，没有说明φ(x)不等于0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201126863.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201131884.png" alt="image.png"></p><p><em>1.注意加减关系不能直接等价代换，等价代换实质上是一种精度不太高的泰勒展开(低阶展开)，当f(x)与g(x)存在加减关系时，例如这题是相加关系，如果f(x)与g(x)的低阶无穷小相互抵消(limf(x)/g(x)=-1),那么就需要比较高阶的无穷小；但是等价代换就没有高阶项，所以精度丢失- - -&gt;</em><br><em>2.拆成两项极限求和的前提是—&gt;两项极限都存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201145234.png" alt="image.png"></p><p><em>确定变上限积分函数，无穷小的阶数—&gt;N(M+1)原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201358107.png" alt="image.png"></p><p><em>1.当a=2,arctanx-sin2x可以分别等价代换，为什么？不是说加减不能等价代换吗？ —&gt;等价代换实质就是一次低阶泰勒展开，当展开之后，最低阶的无穷小两者不相等时，意味着相减，不会消去这个低阶无穷小，就不需要比较高阶无穷小，那么就可以直接等价代换 ；arctanx-sin2x ~ x-2x</em></p><p><em>2.当a=1时，arctanx-sinx不能分别等价为x-x，因为低阶无穷小项，互相消去，需要比较高阶无穷小，但是arctanx的泰勒展开不熟悉，只能通过arctanx-x~-1/3 x³  ,sinx-x~ -1/6 x³  ;</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201404411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201415098.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201424934.png" alt="image.png"></p><p><em>极限x-&gt;1不需要讨论1+,1-，因为极限保号性；同理x-&gt; -1; 但是x-&gt;0,时，考虑0+,0-,因为两侧正负不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201429124.png" alt="image.png"></p><p><em>最关键的还是，幂指函数指数化 来处理幂指函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201454848.png" alt="image.png"></p><p><em>考察了基本极限x^n ,e^nx</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201505101.png" alt="image.png"></p></blockquote><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>对于这种分母中含有两根号相减的，—&gt;1.是有理化  2.是拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201511419.png" alt="image.png"></p><p><em>考察知识点很综合<br>1.导数几何意义<br>2.基本极限求极限1^∞型<br>3.洛必达法则<br>4.变上限积分求导<br>5.导数的定义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201528282.png" alt="image.png"></p><p><em>ln(x+√1+x²) ~ x</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201543906.png" alt="image.png"></p><p><em>1.利用到了ln(x+√1+x²) ~ x,判断时1^∞型<br>2.写基本极限标准型lim (1+a(x))^β(x) =e^ a(x)β(x)</em><br><em>3.利用等价代换(1+a(x))^β(x) -1 ~ a(x)β(x) </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201549785.png" alt="image.png"></p><p><em>1.n项连乘 直接夹逼不出来，化为对数<br>2.关键再利用基本常用不等式<br>3.再夹逼</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201602526.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201607237.png" alt="image.png"></p></blockquote><h2 id="解答题"><a href="#解答题" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>0/0型</em><br><em>1)洛必达法则<br>2)等价无穷小代换<br>3)泰勒公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201614121.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201620034.png" alt="image.png"></p><p><em>1.第一眼看，我想用1^∞型极限，但是这里不能拆开求极限因为，右半部分的极限不存在，所以不能1^∞极限直接做<br>2.正确的做法是将幂指函数，化为指数，然后将整个分子，e^x -1 ~ x等价代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201708362.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201735817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201754350.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201801518.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201900306.png" alt="image.png"><br><em>用到拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201903837.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201909167.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915159.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201915846.png" alt="image.png"></p><p><em>1.自平方项，前n项和，公式要记住<br>2.到底是选择夹逼，还是定积分定义，看每一项变化的那个地方，看是占大头(同量级，选择定积分定义)，还是小头(变化对分母整体量影响不大，用夹逼)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201920638.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201925221.png" alt="image.png"></p><p><em>分子变化部分相对于主体是次量级，用夹逼；分母变化部分相对于主体是同量级，用定积分定义</em><br><em>对分子放大—&gt;所有项分子=n+1/n;  缩小—&gt;所有项分子=n+1</em><br><em>对分母提出1/n，可爱因子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201932498.png" alt="image.png"></p><p><em>经典的找间断点，和类型题目</em><br><em>在求间断点的极限时，是否要分开考虑左右极限，是根据，左右会不会对函数正负性有影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201938018.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307201944583.png" alt="image.png"></p><p><em>极限存在一般根据极限存在准则：<br>1.夹逼定理<br>2.单调有界准则<br>该题只需要证明极限存在，只需单调有界就可证明极限存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202046598.png" alt="image.png"></p><p><em>1.先看递推式函数是否单调增<br>2.函数单调增说明数列有单调性，再根据x1,x2判断数列单调增还是减<br>3.假设极限=A，根据递推式代入A求出A<br>5.再证明有界且界限=A</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202055627.png" alt="image.png"></p><p><em>1.先看递推式函数，是否单调增,如果单调减则数列没有单调性<br>2.接着没有单调性则，直接证明xn-√2的极限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202103715.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202114022.png" alt="image.png"></p><p><em>零点定理—证明区间两端点异号，则区间内必有一点=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202123672.png" alt="image.png"></p><p><em>介值定理—函数值介于最大与最小之间，必有一点,f(β)=该值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202128724.png" alt="image.png"></p></blockquote><h1 id="2-一元函数微分"><a href="#2-一元函数微分" class="headerlink" title="2.一元函数微分"></a>2.一元函数微分</h1><h2 id="填空题-1"><a href="#填空题-1" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>既要趋近于0，又要同时趋近0+,0-，才能判定该点导数存在</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231415896.png" alt="image.png"></p><p><em>考察连续的概念、导数的概念、导函数连续的概念</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231422649.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231431041.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231509976.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231525936.png" alt="image.png"></p><p><em>1.拆开求导。2.求得导数等于0的点，用二阶导数判定是极小还是极大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231553956.png" alt="image.png"></p><p><em>求得二阶导数=0，继续代入求三阶导数，看二阶导数是否单调，如果单调，那么该点就是拐点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231627232.png" alt="image.png"></p><p><em>求斜或水平渐近线，直接将原式改写，为y=ax+b形式，利用x-&gt;∞极限求出a,b</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231643077.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231648475.png" alt="image.png"></p></blockquote><h2 id="填空题-2"><a href="#填空题-2" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>不能用洛必达，没有一阶可导条件，并且数列不是函数，不连续</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231657600.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231701991.png" alt="image.png"></p><p><em>利用链导法，而不是将所有表达式求出来，再求导，那样太麻烦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231726425.png" alt="image.png"></p><p><em>反函数的导数，注意反函数是对y求导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231735491.png" alt="image.png"></p><p><em>高阶导数具体点导数—用泰勒展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232115462.png" alt="image.png"></p><p><em>求高阶导数—总结规律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232114368.png" alt="image.png"></p><p><em>根据罗尔定律</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232121848.png" alt="image.png"></p><p><em>解一元三次方程=0，一般方法，凑1,2,3,4…整数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232146981.png" alt="image.png"></p></blockquote><h2 id="解答题-1"><a href="#解答题-1" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307232220253.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241057847.png" alt="image.png"></p><p><em>1.积分上限用变量代换<br>2.定积分定义求0点导数<br>3.求x-&gt;0，导数极限看是否=0点导数<br>4.运用到了积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241123900.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241141774.png" alt="image.png"></p><p><em>这种参数方程求积分问题，要注意变换积分上下限</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241347626.png" alt="image.png"></p><p><em>单中值—微分中值定理证明题，主要是微分中值定理的构造</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241611635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241626811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241829186.png" alt="image.png"></p><p><em>运用柯西定理、拉格朗日中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307241854086.png" alt="image.png"></p><p><em>双中值—两中值点没有要求不同<br>分开两部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242018794.png" alt="image.png"></p><p><em>双中值—要求中值点不同<br>1.先将【0,1】段用c分开，假设存在一点c，使得…</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242027225.png" alt="image.png"></p><p><em>证明中值，含有高阶导数—泰勒展开，在给出信息最多的那一点展开</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242131657.png" alt="Uploading file...swyug"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242134232.png" alt="image.png"></p></blockquote><h1 id="3-一元函数积分学"><a href="#3-一元函数积分学" class="headerlink" title="3.一元函数积分学"></a>3.一元函数积分学</h1><h2 id="选择题-1"><a href="#选择题-1" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>原函数是否存在判定<br>1.函数连续，一定存在原函数<br>2.函数有第一类间断点，就一定没有原函数（证明：通过原函数的定义或者导函数的介值定理，F(X)在a,b可导，则其导数在[a，b]内不会有第一类间断。）<br>3.有第二类间断点，可能有原函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242146129.png" alt="image.png"></p><p><em>直接判断导函数是否连续，如果有第一类间断点，那么原函数必定不可导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307242237240.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251023049.png" alt="image.png"></p><p><em>积分区域相同，比较被积函数，被积函数大，积分就大</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251028390.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251033971.png" alt="image.png"></p><p><em>旋转体体积问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251046107.png" alt="image.png"></p></blockquote><h2 id="填空题-3"><a href="#填空题-3" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>简单有理函数积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251137183.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251151287.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251249954.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251433037.png" alt="image.png"></p><p><em>对称区间，奇偶性判断</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251449741.png" alt="image.png"></p><p><em>1.取根号，要注意加绝对值，分区间计算<br>2.善用结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251458855.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251631501.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251642326.png" alt="image.png"></p><p><em>1.利用定积分定义，转化为定积分的计算<br>2.利用几何意义，想象为，一个半圆的面积的积分，直接求面积<br>3.也可以将x=sint，左变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251651125.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251707587.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251718611.png" alt="image.png"></p><p><em>多项式分数，根式里面一次，一般变量代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251906680.png" alt="image.png"></p><p><em>根式含有平方项，三角代换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251907971.png" alt="image.png"></p><p><em>边界曲线，用极坐标给出，求面积的问题<br>可以直接套公式，<br>任然还有问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251922342.png" alt="image.png"><br><em>对比着看</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261610407.png" alt="image.png"></p><p><em>运用弧长积分公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307251926365.png" alt="image.png"></p><p><em>通过分部积分法，将f(x)写成导数计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252055735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252126968.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307252153239.png" alt="image.png"></p></blockquote><h2 id="解答题-2"><a href="#解答题-2" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261042264.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261116190.png" alt="image.png"></p><p><em>积分中值定理+介值定理+两次罗尔定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261131711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261205973.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261235506.png" alt="image.png"></p><p><em>方法1.利用介值定理，介于最大最小值之间</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261329751.png" alt="image.png"><br><em>方法2.利用构造辅助函数，常规方法，然后再说明有两个点，辅助函数值相等(罗尔定理)，就证明等式成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261334817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261400953.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261417494.png" alt="image.png"></p><p><em>难题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261443061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261446496.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261506664.png" alt="image.png"></p><p><em>长条中质心的积分计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261509020.png" alt="image.png"></p><p><em>典型，积分求旋转体体积</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261604721.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261607358.png" alt="image.png"></p></blockquote><h1 id="4-常微分方程"><a href="#4-常微分方程" class="headerlink" title="4.常微分方程"></a>4.常微分方程</h1><h2 id="选择题-2"><a href="#选择题-2" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292225471.png" alt="image.png"></p><blockquote><p><em>直到三阶常系数齐次线性微分方程的特解，直接从特解中看出特征根，然后根据特征根写出特征方程，即可</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292150830.png" alt="image.png"></p><p><em>非齐次解具有叠加性，可以拆开分析</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292154652.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292200338.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292214416.png" alt="image.png"></p></blockquote><h2 id="填空题-4"><a href="#填空题-4" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301428202.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301530231.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301545683.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301551914.png" alt="image.png"></p><h2 id="解答题-3"><a href="#解答题-3" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>1.三个线性无关特解，两两相减=通解<br>2.然后通过消去系数得到最终方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301634920.png" alt="image.png"></p><p><em>不属于已知的类型，通过x,y对调,令y’ =1/x’,化为x为函数，y为自变量的函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301638682.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301713823.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916345.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307301916774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302054499.png" alt="image.png"></p><p><em>通过导数定义，构建微分方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307302136747.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307310953433.png" alt="image.png"></p><p><em>微分方程与全微分结合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311007885.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311033425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311047528.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311409647.png" alt="image.png"></p></blockquote><h1 id="5-二重积分"><a href="#5-二重积分" class="headerlink" title="5.二重积分"></a>5.二重积分</h1><h2 id="选择题-3"><a href="#选择题-3" class="headerlink" title="选择题"></a>选择题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311421096.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311647617.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311656049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311710142.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311713317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311750227.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311754610.png" alt="image.png"></p><p><em>二重积分是一个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311805140.png" alt="image.png"></p><p><em>区域相同，比较被积函数大小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311808151.png" alt="image.png"></p><p><em>轮换对称性、奇偶性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311816485.png" alt="image.png"></p><p><em>经典</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311824085.png" alt="image.png"></p></blockquote><p>&gt;</p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307311827837.png" alt="image.png"></p><p><em>累次积分对t求导<br>1.通过转换积分次序，使得只有外层积分保留t<br>2.将外层0~t积分对应微分的变量，在内层用t替换</em><br><em>例1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312059190.png" alt="image.png"><br><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011156555.png" alt="image.png"><br><em>例3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011228116.png" alt="image.png"></p></blockquote><h2 id="填空题-5"><a href="#填空题-5" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312129808.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312156656.png" alt="image.png"></p><p><em>拆开、奇偶性、轮换对称性、极坐标法<br>太妙了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307312207638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011058407.png" alt="image.png"></p><p><em>此时极坐标方便—&gt;换位直角坐标，然后(x-1)关于(1,0)点的奇函数，利用奇偶性；最后计算简单</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011107023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222340.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011222036.png" alt="image.png"></p></blockquote><h2 id="解答题-4"><a href="#解答题-4" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>数列n项和，转化为定积分定义，最终得到一个累次积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011224321.png" alt="image.png"></p><p><em>题目给的积分不好积分，就交换积分次序<br>1.先画域<br>2.重新确定积分次序，就可以简便积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011402509.png" alt="image.png"></p><p><em>该题很有规律，不要硬算，算不出来</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417984.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011417329.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011438457.png" alt="image.png"></p><p><em>没想到的，极坐标不好用，换成极坐标</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011518588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529261.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011529642.png" alt="image.png"></p><p><em>利用奇偶性、对称性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011538891.png" alt="image.png"></p><p><em>圆形不再原点的，通过平移，使得圆心在原点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011636328.png" alt="image.png"></p><p><em>注意奇函数乘偶函数=奇函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012100835.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012128361.png" alt="image.png"></p><p><em>积分的绝对值&lt;=绝对值的积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012138798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012151775.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308012150173.png" alt="image.png"></p></blockquote><h1 id="6-多元函数微分学"><a href="#6-多元函数微分学" class="headerlink" title="6.多元函数微分学"></a>6.多元函数微分学</h1><h2 id="选择题-4"><a href="#选择题-4" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>求偏导数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021328671.png" alt="image.png"></p><p><em>D.正确<br>从x方向趋向于x0,的极限，而y0固定的，相当于一个一元函数从x方向的一元函数，由于x方向的偏导数存在=a, 再根据一元函数可导必定连续，说明该函数极限就等于函数值f(x0,y0) ;同理y方向趋向于y0极限也存在也等于f(x0,y0)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021336253.png" alt="image.png"></p><p><em>1.首先证明偏导数存不存在(用定义法)<br>2.判断出两个偏导数都存在，接着通过可微判断式，判断是否等于0<br>3.最终式子如下，利用y=kx（其中一个方向趋向于y0）,看极限手否与趋向的方向无关(也就是如果极限与k有关，那么极限就不存在)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021351399.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021420120.png" alt="image.png"></p><p><em>偏x方向导数&gt;0,所以延x方向是增加的，同理延y方向减小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021422359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021430141.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021507965.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021520285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021527756.png" alt="image.png"></p><p><em>极限保号性，既然当x-&gt;0,y-&gt;0时 f(x,y)&gt;0, 且f(0,0)=0,所以f(0,0)就是极小值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021532707.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031454924.png" alt="image.png"></p></blockquote><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031502939.png" alt="image.png"></p><blockquote><p><em>AC-B^2 &lt;0 所以内部无极值点，那么由于这是一个有界区域，所以最值位于边界上的点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031505371.png" alt="image.png"></p></blockquote><h2 id="填空题-6"><a href="#填空题-6" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031537091.png" alt="image.png"></p><p><em>知道偏导，求函数本身—&gt;偏积分法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031542061.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031600766.png" alt="image.png"></p><p>*公式法，将x,y,z看做独立的变量，而不用再将z看做x,y的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031607224.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031654172.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031721585.png" alt="image.png"></p></blockquote><h2 id="解答题-5"><a href="#解答题-5" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031728679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031736577.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032041935.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032100874.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308032321526.png" alt="image.png"></p><p><em>AC-B^2=0，不能确定是否有极值，需要通过定义判定<br>1.极值的定义是，一个极小区域内无论函数从哪个方向趋向于极值点，函数值都是要么都同号，不会有正负都出现的情况</em><br><em>2.所以分别从y=x方向与y=-x方向趋向于(0,0)点，发现两个方向趋向于该点，一个方向值为+，一个方向为-，就说明该点不是极值点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041021953.png" alt="image.png"></p><p><em>我做错了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041154395.png" alt="image.png"></p><p><em>数形结合，起始就是求z坐标绝对值的最大值，由于|z|不好求，所以改为求z^2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041507215.png" alt="image.png"></p><p><em>1.利用齐次方程，有非零解时，系数行列式=0的特点<br>2.求长半轴与短半轴长度之比，实际就是求椭球距离原点最长最短距离之比</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041515026.png" alt="image.png"></p><p><em>把证明不等式的问题，转化为证明一个条件下，最大最小值的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041519753.png" alt="image.png"></p></blockquote><h1 id="7-无穷级数"><a href="#7-无穷级数" class="headerlink" title="7-无穷级数"></a>7-无穷级数</h1><h2 id="选择题-5"><a href="#选择题-5" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061036658.png" alt="image.png"></p><p><em>(1)好理解<br>(2)采用比值法，需要取极限，而不是单单相除，例如(1/n+1) / (1/n) &lt;1 但是取极限就是=1，而1/n级数是发散的<br>(3)比值法，前提是两个都是正项级数<br>(4)  0&lt;=bn-an&lt;=cn-an ; $\sum<em>{n=1}^{\infty}a_n$ 与$\sum</em>{n=1}^{\infty}c<em>n$都收敛，所以$\sum</em>{n=1}^{\infty}c_n-a_n$ 收敛<br>大收则小收，bn-an也收敛，因为bn = (bn-an)+an,两个收敛相加依然收敛，故bn收敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061054853.png" alt="image.png"></p><p><em>关键：级数与函数有关，函数连续，想到函数必定有界，设M</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061135473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061209429.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061211017.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061348192.png" alt="image.png"></p><p><em>A. an-&gt;0,所以anbn&lt;bn ,大收则小收，但是不确定bn是正项级数还是有负的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061354692.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061415331.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061416527.png" alt="image.png"></p></blockquote><h2 id="填空题-7"><a href="#填空题-7" class="headerlink" title="填空题"></a>填空题</h2><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122547.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072122923.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072200181.png" alt="image.png"></p><p>*级数$\sum<em>{n=1}^{\infty}a_n$ 是等价于 $\sum</em>{n=1}^{\infty}\frac{1}{ln n}$,是发散的，<br>原级数$\sum<em>{n=1}^{\infty}\frac{(-1)^na_n}{n}(x+1)^n$ 看做是$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$逐项求导，收敛半径不变。<br>$\sum</em>{n=1}^{\infty}(-1)^na<em>n(x+1)^n$将x=0代入，是$\sum</em>{n=1}^{\infty}(-1)^na_n$条件收敛<br>又因为幂级数条件收敛的点只可能发生在收敛区间端点，所以0是区间一个端点，所以收敛半径=1；收敛区间（-2,0）<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072207881.png" alt="image.png"></p><p><em>我的方法是直接代入，x=3,-3(根据直觉)，发现x=-3时条件收敛，那么x=-3一定是收敛区间端点，接着就能找出收敛域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308080950111.png" alt="image.png"></p></blockquote><h2 id="解答题-6"><a href="#解答题-6" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><em>考察对各类级数敛散性判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081000284.png" alt="image.png"></p><p><em>x的范围一定要写，原公式-1&lt;x&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081018049.png" alt="image.png"></p><p><em>像是arctan，的幂级数展开，一般是求导，展开，再积分<br>积分是要变上限积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081039482.png" alt="image.png"></p><p><em>省略二次求导，再积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081122483.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081144158.png" alt="image.png"></p><p><em>这种题，和函数的导四次，回到原来的和函数，建立微分方程，求解<br>【注意通解中含有4个变量，需要四个函数值，0! =1,所以y(0)=1,y’(0)=0….】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130847.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081130620.png" alt="image.png"></p><p><em>求常数项级数的求和，借助幂级数，写成常用的展开的形式，再代入x=1（这题来说代入x=1,恢复原来式子）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081236378.png" alt="image.png"></p><p><em>这种微分方程不好解，那只能代入方程，将x化为同次幂，关注其常数项系数=0，就能找出幂级数系数的关系式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081342834.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081343735.png" alt="image.png"></p><p><em>与上面一样的做法，将x化为同次幂，找幂级数系数的关系</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081350959.png" alt="image.png"></p><p><em>S’(x)，和函数的导数，这个导数幂级数要从n=1开始，因为n=0的项是常数a0,求导之后没了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081407634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452179.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081452832.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081504136.png" alt="image.png"></p><p><em>运用到了柯西积分不等式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081513995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081512357.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081532609.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081533525.png" alt="image.png"></p><p><em>傅里叶级数展开的系数问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081547512.png" alt="image.png"></p></blockquote><h1 id="8-向量代数与空间几何"><a href="#8-向量代数与空间几何" class="headerlink" title="8-向量代数与空间几何"></a>8-向量代数与空间几何</h1><h2 id="选择题-6"><a href="#选择题-6" class="headerlink" title="选择题"></a>选择题</h2><blockquote><p><em>直线L2由两个平面相交给出，；</em><br><em>1.求出两条直线的方向向量，【L2,方向向量，由两平面法向量叉乘得出】</em><br><em>2.方向向量知道，就能求出余弦</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141322734.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141323837.png" alt="image.png"></p><p><em>曲面和平面的法线都是将函数写成F(x,y,z)=0,的形式，法线向量坐标都是对x,y,z求偏导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141419054.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141423635.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141427969.png" alt="image.png"></p><p><em>梯度计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141430332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141430693.png" alt="image.png"></p></blockquote><h2 id="填空题-8"><a href="#填空题-8" class="headerlink" title="填空题"></a>填空题</h2><blockquote><p><em>混合积有轮换对称性质</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141442031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141443127.png" alt="image.png"></p></blockquote><h2 id="解答题-7"><a href="#解答题-7" class="headerlink" title="解答题"></a>解答题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141637104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141644925.png" alt="image.png"></p><p><em>方向导数最大时，就是延梯度的方向且方向导数的最大值是梯度的模</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141707509.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141734592.png" alt="image.png"></p><p><em>投影直线绕某坐标轴转所得到的旋转面的方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141801003.png" alt="image.png"></p><p><em>直线L的方向向量是(2,1,-1),而不是(2,1,-2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141829609.png" alt="image.png"></p><p><em>根据两面写出平面束方程（经过该直线的所有平面），然后利用平面法向量垂直于该直线方向向量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142038188.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142038826.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142054263.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142054491.png" alt="image.png"></p><p><em>梯度向量是空间曲面在平面上的投影的水平方向的向量</em><br><em>这题就是利用了水滴会延梯度向量方向(平面向量)流动，并且流动轨迹xoy面投影的切线向量就是梯度向量方向</em><br><em>解微分方程，求出了投影曲线的柱面方程，联立球面方程，就是路线方程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142117410.png" alt="image.png"></p></blockquote><h1 id="9-多元积分的应用"><a href="#9-多元积分的应用" class="headerlink" title="9-多元积分的应用"></a>9-多元积分的应用</h1><blockquote><p><em>在竖着的椭圆内是正的，在外边积分是负的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152123987.png" alt="image.png"></p><p><em>这题，先拆开利用奇偶性，消去部分项，然后，分别对三项积分，只积分其中一项，(中间利用椭圆面积=πab),然后推出其他两项的积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152151016.png" alt="image.png"></p><p><em>画出积分域，交换积分次序</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308152227715.png" alt="image.png"></p><p><em>我做出来了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308160928731.png" alt="image.png"></p><p>**<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308160938156.png" alt="image.png"></p><p><em>这题是对空间平面的积分，一般有几种方法：1,斯托克公式，2.化为一维平面(降维)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161028846.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161048379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161048465.png" alt="image.png"></p><p><em>形心计算公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161530603.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线代</title>
      <link href="/undefined/43e039bd.html"/>
      <url>/undefined/43e039bd.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191206306.png" alt="image.png"></p><h1 id="01-行列式的定义与性质"><a href="#01-行列式的定义与性质" class="headerlink" title="01-行列式的定义与性质"></a>01-行列式的定义与性质</h1><h2 id="行列式背景"><a href="#行列式背景" class="headerlink" title="行列式背景"></a>行列式背景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于一个二元方程组，每次都要求解就特别麻烦。</span><br><span class="line">为了更加快速的找到方程的解，人们寻找规律，发现解的通式如下</span><br><span class="line">但是通式难以记忆，所以将这种计算规律用行列式表示，规定行列式计算方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301231233.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301500559.png" alt="image.png"></p><h2 id="逆序数"><a href="#逆序数" class="headerlink" title="逆序数"></a>逆序数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论:一个排列中任意的两个元素对换，排列的奇偶性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301509795.png" alt="image.png"></p><h2 id="n阶行列式的定义"><a href="#n阶行列式的定义" class="headerlink" title="n阶行列式的定义"></a>n阶行列式的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行列式是一个数</span><br><span class="line">行列式计算方法是：</span><br><span class="line">1.取数相乘: 取n个不同行不同列的数 相乘 --&gt; 所以n!种取法，就有n!项</span><br><span class="line">2.冠以符号: 每一项(n个数相乘),将里面的元素，按列排好，然后数 列序号的逆序数τ，</span><br><span class="line">-(1)^τ</span><br><span class="line">3.全部相加: 将所有项n!项相加   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301521315.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">按照行列式定义，因为行列式的每一项都是有不同行不同列的n个数相乘</span><br><span class="line">假如取1行1列的数--&gt;x</span><br><span class="line">那么画个十字线，十字线上的数都不能再取</span><br><span class="line">题目要求行列式结果中x^3的系数</span><br><span class="line"></span><br><span class="line">排除法:</span><br><span class="line">假如先取1，画十字线，发现其他行最多只能取到两个x，构不成x^3</span><br><span class="line">假如先取2，同理不行</span><br><span class="line">所以只能取x或x+3</span><br><span class="line"> 取x+3,只有一种情况，可行</span><br><span class="line"> 取x,第二行只能取x,第三行只能取x,第四行只能取x，那么x^4不符合。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301535080.png" alt="image.png"></p><p><mark>主对角线与副对角线矩阵的值</mark></p><div style="background-color: #fffacd;padding:20px;"> 注：主对角线的矩阵的值等于对角线元素相乘，而副对角线矩阵的值等于-1<sup>n(n-1)/2 </sup>a<sub>1,n </sub>a<sub>2,n-1 </sub>a<sub>3,n-2</sub>....a<sub>n,1</sub></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301555219.png" alt="image.png"></p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a><em>转置</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301557471.png" alt="image.png"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a><em>交换</em></h3><p><strong>交换一行实际上是对每一项的逆序数发生改变，导致全部项的正负性改变</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301600178.png" alt="image.png"></p><h3 id="倍乘"><a href="#倍乘" class="headerlink" title="倍乘"></a><em>倍乘</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301619501.png" alt="image.png"></p><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a><em>拆分</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301620199.png" alt="image.png"></p><blockquote><p><em>倍加</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301623438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301627820.png" alt="image.png"></p><hr><h1 id="02-行列式的计算与代数余子式"><a href="#02-行列式的计算与代数余子式" class="headerlink" title="02-行列式的计算与代数余子式"></a>02-行列式的计算与代数余子式</h1><h2 id="分块矩阵的行列式计算"><a href="#分块矩阵的行列式计算" class="headerlink" title="分块矩阵的行列式计算"></a>分块矩阵的行列式计算</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301645404.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301654171.png" alt="image.png"></p><h2 id="行列式按行-列-展开"><a href="#行列式按行-列-展开" class="headerlink" title="行列式按行(列)展开"></a>行列式按行(列)展开</h2><h3 id="展开定理"><a href="#展开定理" class="headerlink" title="展开定理"></a>展开定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">余子式M 是特殊的情况，恰好第一行第一个数不是0,该行其余都是0,行列式的值=a11xM11。</span><br><span class="line">代数余子式A是讨论,不是特殊情况时，要考虑符号问题。</span><br><span class="line">就是不断的交换将aij逐行逐列的移到第一个的位置(交换一次改变一次正负号),aij列需要j次</span><br><span class="line">交换，行需要i次交换。所以符号-(1)^i+j x Mij = Aij </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301724746.png" alt="image.png"></p><blockquote><p><em>“么”型通法，按横展开</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306301750483.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302120137.png" alt="Uploading file...havyy"></p><h3 id="代数余子式"><a href="#代数余子式" class="headerlink" title="代数余子式"></a>代数余子式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302138234.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302217822.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302141433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302143275.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302148080.png" alt="image.png"></p><h2 id="范德门行列式"><a href="#范德门行列式" class="headerlink" title="范德门行列式"></a>范德门行列式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">像这种第一行(或列)是1，第二行(列)是x1,x2..xn;第三行(列)是x1^2,x2^2..xn^2;...第n行(列)是...</span><br><span class="line">这种形式的就是范德蒙行列式，它的值有如下规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302222870.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.加边法</span><br><span class="line">与范德蒙行列式相似的，可以加边使其成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302228111.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.提公因子</span><br><span class="line">每一行提一个公因子，使得第一列的全为1，成为范德蒙行列式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302230815.png" alt="image.png"></p><hr><h1 id="03矩阵及其运算"><a href="#03矩阵及其运算" class="headerlink" title="03矩阵及其运算"></a>03矩阵及其运算</h1><h2 id="矩阵及分块的概念"><a href="#矩阵及分块的概念" class="headerlink" title="矩阵及分块的概念"></a>矩阵及分块的概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">矩阵的提出主要源自于数学中的三个问题:</span><br><span class="line">1.线性变换:用于表示未知数的变换关系</span><br><span class="line">2.线性方程组:用于表示方程组各个未知数的系数</span><br><span class="line">3.二次型:方便表示二次型，x^2,y^2,xy,出现的个数</span><br></pre></td></tr></table></figure><blockquote><p><em>数表来源</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302253439.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302255227.png" alt="image.png"></p><blockquote><p><em>特殊矩阵及分块矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302314484.png" alt="image.png"></p><h2 id="矩阵及分块矩阵的计算"><a href="#矩阵及分块矩阵的计算" class="headerlink" title="矩阵及分块矩阵的计算"></a>矩阵及分块矩阵的计算</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">矩阵加减法要求</span><br><span class="line">1.同型矩阵，m,n相同</span><br><span class="line">2.对应每个元素相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302321222.png" alt="image.png"></p><h3 id="数乘"><a href="#数乘" class="headerlink" title="数乘"></a>数乘</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302346561.png" alt="image.png"></p><h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">矩阵乘法，实质是将由x-&gt;y的线性变换通过y-&gt;z的变化 转到x-&gt;z的线性变换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306302349135.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011521217.png" alt="image.png"></p><hr><blockquote><p><em>对角矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011524350.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵的幂</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011527225.png" alt="image.png"></p><blockquote><p><em>坍缩矩阵练习</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排列与组合区别在于，组合不要求内部顺序，所以要除以顺序个数</span><br><span class="line"></span><br><span class="line">将A矩阵拆分为--&gt; 单位E矩阵 + “坍缩矩阵”B </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011532335.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011534905.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011535161.png" alt="image.png"></p><blockquote><p><em>成比例矩阵的幂</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每行成比例的矩阵，可以写为如下</span><br><span class="line">成比例矩阵n次幂就可以拆为如下</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011559846.png" alt="image.png"></p><blockquote><p><em>与伴随矩阵相乘</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AxA* --&gt; 乘错行导致只有对应行的与其对应的代数余子式相乘结果才为|A|--&gt;也就是只有对角线上是|A| </span><br><span class="line"></span><br><span class="line">为什么代数余子式，乘错行会=0？ </span><br><span class="line">因为,乘错行，可以看做求一个具有两行相元素的行列式的值--&gt;两行相同元素的行列式=0</span><br><span class="line"></span><br><span class="line">为什么两行相同元素的行列式值是0?</span><br><span class="line">因为，利用交换一次行,矩阵正负性改变,两行相同交换后不变，但正负性改变，那么只能是0</span><br><span class="line"></span><br><span class="line">为什么交换两行元素，矩阵正负性要改变?</span><br><span class="line">因为，交换两行之后，导致每一项列排序发生一次交换--&gt;逆序数奇偶性变化--&gt;正负性改变</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011615201.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011741250.png" alt="image.png"></p><hr><h3 id="转置-1"><a href="#转置-1" class="headerlink" title="转置"></a>转置</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011730342.png" alt="image.png"></p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743537.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011743180.png" alt="image.png"></p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><h3 id="逆矩阵定义"><a href="#逆矩阵定义" class="headerlink" title="逆矩阵定义"></a><em>逆矩阵定义</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011859511.png" alt="image.png"></p><h3 id="逆矩阵充要条件"><a href="#逆矩阵充要条件" class="headerlink" title="逆矩阵充要条件"></a><em>逆矩阵充要条件</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011901315.png" alt="image.png"></p><blockquote><p><em>原矩阵行列式=0 =&gt;伴随矩阵行列式=0</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011907635.png" alt="image.png"></p><blockquote><p><em>求二阶矩阵的逆矩阵方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011939266.png" alt="image.png"></p><blockquote><p><em>分块矩阵求逆矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307011948103.png" alt="image.png"></p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012256386.png" alt="image.png"></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求可对角化的矩阵的幂--&gt;先将矩阵写为下列形式，然后相乘，中间可以相互抵消为E(单位矩阵)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012257657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012300822.png" alt="image.png"></p><h2 id="题型通法总结"><a href="#题型通法总结" class="headerlink" title="题型通法总结"></a>题型通法总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012305438.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012312191.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012314168.png" alt="image.png"></p><hr><h1 id="04初等变换与初等矩阵"><a href="#04初等变换与初等矩阵" class="headerlink" title="04初等变换与初等矩阵"></a>04初等变换与初等矩阵</h1><h2 id="初等变换、矩阵的行阶梯、行最简、标准形"><a href="#初等变换、矩阵的行阶梯、行最简、标准形" class="headerlink" title="初等变换、矩阵的行阶梯、行最简、标准形"></a>初等变换、矩阵的行阶梯、行最简、标准形</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">化为行阶梯型矩阵--&gt;自上而下化简</span><br><span class="line">化为最简型矩阵--&gt;自下而上化简</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012324531.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">矩阵A只进行行变换到B,称A与B 行等价</span><br><span class="line">矩阵A只进行列变换到B,称A与B 列等价</span><br><span class="line">如果即行又列，称A与B 等价 </span><br><span class="line"></span><br><span class="line">不管行等价，列等价，等价 --&gt;其秩都相等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012335843.png" alt="image.png"></p><h2 id="初等矩阵的定义性质"><a href="#初等矩阵的定义性质" class="headerlink" title="初等矩阵的定义性质"></a>初等矩阵的定义性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初等矩阵可以传递三种操作:</span><br><span class="line">1.交换: 左行右列 Eij --&gt;交换第i、j行(列)</span><br><span class="line">2.倍乘: 左行右列 Ei(k) --&gt; 第i行(列) 乘k倍</span><br><span class="line">3.倍加: 左行由列 Eij(k) --&gt; (左)将第i行加上j行的k倍;(右)将第j列加上第i行的k倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307012358129.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307020005020.png" alt="image.png"></p><h2 id="初等矩阵的逆"><a href="#初等矩阵的逆" class="headerlink" title="初等矩阵的逆"></a>初等矩阵的逆</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031442490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031446780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031452285.png" alt="image.png"></p><h2 id="可逆矩阵都可初等变换化为单位阵"><a href="#可逆矩阵都可初等变换化为单位阵" class="headerlink" title="可逆矩阵都可初等变换化为单位阵"></a>可逆矩阵都可初等变换化为单位阵</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031514917.png" alt="image.png"></p><h2 id="初等变换求逆矩阵-解可逆矩阵方程"><a href="#初等变换求逆矩阵-解可逆矩阵方程" class="headerlink" title="初等变换求逆矩阵-解可逆矩阵方程"></a>初等变换求逆矩阵-解可逆矩阵方程</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031520619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.A逆在左，行变换，所以可逆矩阵方程A,B要行摆放</span><br><span class="line">2.A逆在右，列变换，所以可逆矩阵方程A,B要列摆放</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031537723.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031547781.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031553549.png" alt="image.png"></p><hr><h1 id="05-矩阵的秩与线性方程组"><a href="#05-矩阵的秩与线性方程组" class="headerlink" title="05-矩阵的秩与线性方程组"></a>05-矩阵的秩与线性方程组</h1><h2 id="秩"><a href="#秩" class="headerlink" title="秩"></a>秩</h2><h3 id="矩阵的秩的定义"><a href="#矩阵的秩的定义" class="headerlink" title="矩阵的秩的定义"></a>矩阵的秩的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初等变换不会改变秩的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031709329.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031717376.png" alt="image.png"></p><h3 id="行阶形求秩"><a href="#行阶形求秩" class="headerlink" title="行阶形求秩"></a>行阶形求秩</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031713196.png" alt="image.png"></p><h3 id="秩的结论"><a href="#秩的结论" class="headerlink" title="秩的结论"></a>秩的结论</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.矩阵的秩不会超过行数也不会超过列数，因为逆矩阵的秩就是阶梯个数，阶梯怎么画都不会   超过行和列</span><br><span class="line">2.转置矩阵的秩不变很好理解</span><br><span class="line">3.等价的矩阵秩一定相等--&gt;等价的矩阵实际就是在一个矩阵基础上经过若干初等变换得到的   两个矩阵，初等变换不会影响秩的大小</span><br><span class="line">4.P,Q可逆--&gt;P,Q是若干初等矩阵的乘积--&gt;相当于对A经过若干初等行变换+列变换--&gt;秩不变</span><br><span class="line">5.(A,B)矩阵的秩R(A,B)min/max --&gt; A,B都化为标准型之后，看斜对角线</span><br><span class="line">6.矩阵相加的秩，化标准型理解</span><br><span class="line">7.矩阵相乘的秩，化标准型理解(特殊:矩阵与其转置矩阵相乘，秩不变)</span><br><span class="line">8.两矩阵相乘为0矩阵--&gt;标准型中1刚好错开，那么R(A)+R(B)&lt;=n</span><br><span class="line">9.伴随矩阵的秩与原矩阵的秩的关系...</span><br><span class="line">10....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031725785.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031745903.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031749579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031751055.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031755979.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.R(Amxn) =n --&gt;列满秩 ;所以A的标准型是上面E,下面O ; --&gt; 标准型左边乘以可逆矩阵P(等效为若干初等变换) 得到A --&gt; A标准型=PA ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031800370.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031819833.png" alt="image.png"></p><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><h3 id="解的判定"><a href="#解的判定" class="headerlink" title="解的判定"></a>解的判定</h3><blockquote><p><em>齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031839448.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031838230.png" alt="image.png"></p><hr><blockquote><p><em>非齐次线性</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031850780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031852539.png" alt="image.png"></p><h3 id="具体方程组的求解"><a href="#具体方程组的求解" class="headerlink" title="具体方程组的求解"></a>具体方程组的求解</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031859530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307031900387.png" alt="image.png"></p><h1 id="06-向量组的线性相关性"><a href="#06-向量组的线性相关性" class="headerlink" title="06-向量组的线性相关性"></a>06-向量组的线性相关性</h1><h2 id="向量及向量空间"><a href="#向量及向量空间" class="headerlink" title="向量及向量空间"></a>向量及向量空间</h2><blockquote><p><em>(a1，a2，β)向量组，其中如果三个向量共平面【其中一个向量，可以由另外两个向量通过线性运算：k1a1+k2a2 =β,得到，那么称为这组向量线性相关】<br>如果三个向量，不不再同一个平面，那么无法通过线性运算得到第三个向量，则线性无关</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101707649.png" alt="image.png"></p><h2 id="线性表示"><a href="#线性表示" class="headerlink" title="线性表示"></a>线性表示</h2><h3 id="线性表示-1"><a href="#线性表示-1" class="headerlink" title="线性表示"></a>线性表示</h3><blockquote><p><em>加入一个新的向量b，原矩阵的秩如果不变，说明向量b没有开拓新的维度<br>，就是可以用前面的向量线性表示出来，与其他向量线性相关，就是一个混子向量，没有作用<br>反之，若果秩增加，说明，是骨干向量，在几何上表现为翘了起来，开拓了新的维度，与之前的向量线性无关</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101741794.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101821801.png" alt="image.png"></p></blockquote><h3 id="向量组等价"><a href="#向量组等价" class="headerlink" title="向量组等价"></a>向量组等价</h3><p><em>两个向量组能够互相线性表示，那么这两个向量组等价</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101828818.png" alt="image.png"></p><p><em>两个矩阵等价，只要求矩阵秩相等；<br>1.所以矩阵等价，推不出向量组等价，因为向量组1，和向量组2表示的平面不一定是同一个平面；<br>2.同理，向量组等价，推不出矩阵等价，因为向量组等价可以不同型，比如一个3列，一个2列，虽然向量组等价(多了一个混子向量)，但是矩阵不等价(矩阵等价需要同行同列)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111027220.png" alt="image.png"></p><blockquote><p><em>例题</em><br><em>1.将两向量组和成一个，看维度是多少(秩是多少)<br>2.发现秩=2，且向量组1的秩也等于2，说明向量组2的加入没有增加维度，<br>3.继续看向量组2的秩=2，说明向量组1的加入没有增加2的维度<br>4.所以两个向量组可以互相线性表示，是等价的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111035825.png" alt="image.png"></p><p><em>推论</em></p></blockquote><p><em>1.如果向量组A可由B线性表示，那么R(A)&lt;=R(B)<br>反之不成立，因为如果R(A=1,一条线；R(B)=2,一个面，线不再面上，无法被B线性表示</em></p><h2 id="线性相关性-齐次线性方程组有无非零解问题"><a href="#线性相关性-齐次线性方程组有无非零解问题" class="headerlink" title="线性相关性(齐次线性方程组有无非零解问题)"></a>线性相关性(齐次线性方程组有无非零解问题)</h2><p><em>k不全为0，满足下列方程，那么可以互相消去，说明有混子向量，所以有非零解，线性相关的<br>k全为0，才满足下列等式，那么无法互相消去，全都是不重复的骨干向量，只有全0才成立</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111047039.png" alt="image.png"></p><blockquote><p><em>例题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111058837.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111100449.png" alt="image.png"></p><p><em>推论</em><br><em>特别对于第二个结论：向量的维度，就是向量的坐标轴个数，一个三维向量，就是x,y,z坐标轴，最多三个骨干向量（分别表示x,y,z方向），再多一个都是混子，重复；同理四维向量，有4个坐标轴，最多四个骨干向量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111108087.png" alt="image.png"></p></blockquote><h2 id="向量组的极大无关组"><a href="#向量组的极大无关组" class="headerlink" title="向量组的极大无关组"></a>向量组的极大无关组</h2><p><em>就是向量组的骨干组，但凡多一个都是混子，所以极大无关组的向量个数也就是向量组的秩</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111112705.png" alt="image.png"></p><h2 id="线性方程组解的结构与判定"><a href="#线性方程组解的结构与判定" class="headerlink" title="线性方程组解的结构与判定"></a>线性方程组解的结构与判定</h2><h3 id="基础解系"><a href="#基础解系" class="headerlink" title="基础解系"></a><em>基础解系</em></h3><ul><li><em>基础解系个数=自由变量的个数=未知数个数-主元的个数=n-r(A)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111403819.png" alt="image.png"></li></ul><h3 id="解的结构"><a href="#解的结构" class="headerlink" title="解的结构"></a><em>解的结构</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111406790.png" alt="image.png"></p><p><strong><em>例题</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111352578.png" alt="image.png"></p><h3 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a><em>向量空间</em></h3><blockquote><p><em>基于坐标</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111502596.png" alt="image.png"></p><blockquote><p><em>过渡矩阵</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111503426.png" alt="image.png"></p><h1 id="07-矩阵的特征值与特征向量"><a href="#07-矩阵的特征值与特征向量" class="headerlink" title="07-矩阵的特征值与特征向量"></a>07-矩阵的特征值与特征向量</h1><p><strong><em>1.定义</em></strong><br><em>设  A 是 n 阶矩阵，如果存在数 λ和n 维非零 列向量 α成立使 <strong>Aα=λα</strong><br>那么称 λ为方阵A的一个特征值，α 称为 A 的对应于特征值λ的 特征向量.</em></p><ul><li><em>转化为求齐次方程有非零解的问题，系数方程是λE-A，解向量是α</em></li><li><em>有非零解—&gt;系数矩阵秩&lt;n,所以矩阵的行列式=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111523447.png" alt="image.png"></li></ul><p><strong><em>例题</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111530978.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111532815.png" alt="image.png"></p><p><strong><em>2.性质</em></strong></p><ul><li><em>特征值的和=矩阵对角线系数的和</em></li><li><em>特征值的积=矩阵行列式的值</em></li><li><em>不同特征值对应的特征向量线性无关</em></li><li><em>n重根的特征值对应的线性无关的特征向量,最多n个</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111542797.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111546245.png" alt="image.png"></li></ul><p><strong><em>3.与A相关的矩阵的特征值与特征向量</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111601614.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111602079.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111604997.png" alt="image.png"></p><p><strong><em>例题</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308111608623.png" alt="image.png"></p><h1 id="08-相似矩阵与相似对角化"><a href="#08-相似矩阵与相似对角化" class="headerlink" title="08-相似矩阵与相似对角化"></a>08-相似矩阵与相似对角化</h1><h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><p><strong><em>1.定义</em></strong><br><strong><em>两矩阵相似，可以推出以下5个推论</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112016067.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112016218.png" alt="image.png"></p><p><strong><em>2.性质</em></strong></p><ul><li><em>相似矩阵特征值相同，但是特征值相同的矩阵不一定相似</em></li><li><em>相似矩阵秩相等(利用初等变换理解)，但是秩相等的不一定相似</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112025588.png" alt="image.png"></li></ul><h2 id="相似对角化"><a href="#相似对角化" class="headerlink" title="相似对角化"></a>相似对角化</h2><ul><li><em>若n阶矩阵A与对角矩阵相似，pAp^-1 = ∧ ，那么对角线上的n个值就是A的n个特征值</em></li><li><p><em>证明如下：矩阵A一定能写成Aα=λα，那么A(α1,α2,α3)=(Aα1,Aα2,Aα3)=(λ1α1,λ2α2,λ3α3) ; 假设P=(α1,α2,α3)且可逆，那么AP=P∧ ，这个对角矩阵∧对角线上的值就是特征值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112031274.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112034083.png" alt="image.png"></p></li><li><p><em>判断一个矩阵可不可以对角化，就是看他的特征向量组成的矩阵是不是线性无关的—&gt;可逆的</em></p></li><li><em>因为矩阵|A|=特征值相乘—&gt;那么将A进行初等变换不改变矩阵行列式的值—&gt;对角化相当于对A进行初等变换，行列式的值不变，那么得到pAp^-1 = ∧，<br>|∧|=特征值相乘，所以对角线上就是特征值；进而可知，这个P矩阵就是特征向量矩阵（α1，α2，α3），如果这个P矩阵可逆，就说明相似矩阵∧(对角矩阵）存在，那么就是可对角化；如果P不可逆，说明pAp^-1 = ∧不成立，A 与<br>∧不相似，就是不可对角化。</em></li><li><em>所以，需要证明一个矩阵A可不可以对角化</em><br><em>1.就是要先求出所有特征值。<br>2.分为三种情况讨论：<br>(1). λ1 != λ2 != λ3,分别所对应的特征向量α1，α2，α3)线性无关，P=（α1，α2，α3）一定可逆，所以A与∧相似，可对角化；<br>(2) λ1 = λ2 != λ3，可以确定α2，α3线性无关，接着判定α1，α2是否线性无关即可，如果不是线性无关,那么P就不可逆，相似不成立；<br>(3) λ1 = λ2 = λ3，….</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308112057256.png" alt="image.png"></p><ul><li><em>定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121106054.png" alt="image.png"></li></ul><p><strong><em>例题1</em></strong></p><ul><li><em>计算特征值，可以<strong>展开某一行</strong>，也可以直接算，然后通过<strong>多项式除法</strong>化为因式相乘</em></li><li><em>代入特征值，解齐次线性方程得出对应特征向量</em></li><li><em>注意P向量中特征向量与对角矩阵中特征值的位置顺序要对应</em></li><li><em>令P=(α2，-α1，2α3)  ,A的对角矩阵中对角线上的特征值还是原来，只是换了位置，【λ是替代的A,与特征向量倍数无关】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121110355.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121115003.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121121835.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131955578.png" alt="image.png"></li></ul><p><strong><em>例题2</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121131338.png" alt="image.png"></p><p><strong><em>结论1</em></strong></p><ul><li><em>n阶方阵A的秩&lt;n,则A一定有特征值=0，|A||α|=λ|α|</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121157839.png" alt="image.png"></li></ul><h1 id="09-对称矩阵的对角化"><a href="#09-对称矩阵的对角化" class="headerlink" title="09-对称矩阵的对角化"></a>09-<em>对称矩阵的对角化</em></h1><h2 id="1-对称矩阵的性质"><a href="#1-对称矩阵的性质" class="headerlink" title="1.对称矩阵的性质"></a><strong><em>1.对称矩阵的性质</em></strong></h2><ul><li><em>对称矩阵特征值一定是实数</em></li><li><em>对称矩阵两个不同特征值对应的特征向量是正交的</em></li><li><em>对称矩阵一定可以对角化</em></li><li><em>对称矩阵，一定有正交矩阵可以与其相似对角化和合同对角化</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121227448.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121243861.png" alt="image.png"></li></ul><blockquote><p><em>例题1</em><br><em>1.对称矩阵，且三个特征值互不相等，所以三特征向量正交，互相内积为0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121235970.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121241038.png" alt="image.png"></p></blockquote><h2 id="2-正交矩阵与合同对角化"><a href="#2-正交矩阵与合同对角化" class="headerlink" title="2.正交矩阵与合同对角化"></a><strong><em>2.正交矩阵与合同对角化</em></strong></h2><p><strong><em>正交矩阵</em></strong><br><strong>*与自己的转置矩阵相乘=单位矩阵的矩阵，称为正交矩阵</strong>，顾名思义，正交矩阵，里面的向量两两正交；另外需要满足，<strong>正交矩阵的向量都是单位向量*</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131918495.png" alt="image.png"></p><p><strong><em>合同的定义</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131922372.png" alt="image.png"></p><p><strong><em>合同对角化的步骤</em></strong></p><p><em>一般只讨论对称矩阵的合同对角化</em></p><ol><li><em>将对称矩阵合同对角化，就是求出P矩阵，可使得P^TAP=∧；</em></li><li><em>要求出P，由于讨论的是对称矩阵A，所以就是求可以使得A相似对角化的可逆矩阵P，同时必须满足P是正交矩阵</em></li><li><em>所以步骤依旧是：求出特征值，分别算出特征向量</em><ul><li>当λ1 != λ2 != λ3，则对于对称矩阵，特征向量一定两两正交</li><li>当λ1 = λ2 != λ3，α1、α2都与α3正交，但α1与α2不正交。这时需要假定其中一个不动，再平面上组合取一个与其正交的特征向量即可【只有同一个特征值对应的几个特征向量才能互相组合，组合后还是特征向量】</li><li>当λ1 = λ2 = λ3，不会考这种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132034395.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132051582.png" alt="image.png"></li></ul></li></ol><blockquote><p><em>例题1</em><br><em>单位化和正交化</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132158933.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132158918.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308132159244.png" alt="image.png"></p></blockquote><h1 id="10-二次型及其标准型"><a href="#10-二次型及其标准型" class="headerlink" title="10-二次型及其标准型"></a>10-二次型及其标准型</h1><h2 id="二次型及其系数矩阵"><a href="#二次型及其系数矩阵" class="headerlink" title="二次型及其系数矩阵"></a><em>二次型及其系数矩阵</em></h2><ul><li><em>系数矩阵要求是对称矩阵</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141016752.png" alt="image.png"></li></ul><h2 id="正交变换化二次型为标准型"><a href="#正交变换化二次型为标准型" class="headerlink" title="正交变换化二次型为标准型"></a><em>正交变换化二次型为标准型</em></h2><ul><li><em>二次型的系数矩阵是对称矩阵，二次型的标准型是只有平方项，也就是说，标准型是对角矩阵</em></li><li><em>要化系数矩阵A为标准型的矩阵∧，就是进行对角化</em></li><li><em>这种题目一般是要求一个<strong>正交变换</strong>，使得系数矩阵能够化为标准型</em></li><li><em>首先要知道，任何一个二次型,都可以用矩阵方式表示X^T A X  </em></li><li><strong>*正交变换</strong>，是指存在一个正交矩阵P,进行x=Py的线性变化使得系数矩阵化为标准型*</li><li><em>要求这个正交变换，实质就是进行相似对角化，求特征值，得出特征向量，写出P,正交化，单位化，这个P就是正交变换</em></li><li><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141052467.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141029622.png" alt="image.png"></p><h2 id="配方法化二次型为标准型"><a href="#配方法化二次型为标准型" class="headerlink" title="配方法化二次型为标准型"></a><em>配方法化二次型为标准型</em></h2><p><em>配出来的P矩阵要验证是否可逆，不需要P是单位阵，也不需要是正交矩阵，只需要可逆即可，因为这没有利用相似化做</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141058649.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141059748.png" alt="image.png"></p><blockquote><p><em>例题1</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141129771.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141140917.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141140862.png" alt="image.png"></p></blockquote><h2 id="规范型"><a href="#规范型" class="headerlink" title="规范型"></a><em>规范型</em></h2><p><em>规范型，就是标准型，系数都为1，只保留符号正负</em><br><em>由于标准型系数五花八门，标准不统一，所以化为规范型，好阅卷</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141145399.png" alt="image.png"></p><h2 id="二次型的正定性"><a href="#二次型的正定性" class="headerlink" title="二次型的正定性"></a><em>二次型的正定性</em></h2><p><em>判断一个对称矩阵是否正定：</em></p><ol><li>正交变换法化为标准型，看得到标准型矩阵，对角线的特征值是否都&gt;0</li><li>配方法化标准型，看得到的标准型矩阵，对角线的数是否都&gt;0</li><li>看正惯性指数，看是否全都是正的</li><li>看A的各阶主子式是否都为正<br><em>判断一个对称矩阵是否负定：</em></li><li>前三条与上面正好相反</li><li>看A的各阶主子式，奇数阶为负，偶数阶为正，那么就是负定<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141156228.png" alt="image.png"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141157090.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141204541.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308141208397.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 线代 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘不限速下载</title>
      <link href="/undefined/d1267184.html"/>
      <url>/undefined/d1267184.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191204247.png" alt="image_2022-11-16_11-48-14.png"></p><h2 id="创建链接"><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h2><p>选择需要下载的文件，右键分享然后创建链接，接着复制链接及邀请码<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181136945.png" alt="image.png"></p><h2 id="打开解析网站"><a href="#打开解析网站" class="headerlink" title="打开解析网站"></a>打开解析网站</h2><p><a href="https://pan.qsbaidu.com/">点击跳转解析网站</a>（<a href="https://pan.qsbaidu.com/）。">https://pan.qsbaidu.com/）。</a></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181139806.png" alt="image.png"></p><p>点击解析分享链接后跳转该界面，点击下载按钮。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181141184.png" alt="image.png"></p><p>之后跳转该界面，推荐使用NDM下载器下载。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181142387.png" alt="image.png"></p><h2 id="NDM下载及配置"><a href="#NDM下载及配置" class="headerlink" title="NDM下载及配置"></a>NDM下载及配置</h2><p>1.官网<a href="http://www.neatdownloadmanager.com/index.php/en/">下载链接</a>（<a href="http://www.neatdownloadmanager.com/index.php/en/）">http://www.neatdownloadmanager.com/index.php/en/）</a></p><ol><li>初次使用要先配置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181147528.png" alt="image.png"></li></ol><p>3.复制上述用户代理名，打开NDM点击设置，将用户代理名填入默认用户代理<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181148592.png" alt="image.png"></p><p>4.配置好后，点击新建，将之前的下载链接复制粘贴下载即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181150249.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈为什么从高地址往低地址分配内存</title>
      <link href="/undefined/e44ea15d.html"/>
      <url>/undefined/e44ea15d.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191207287.png" alt="image.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>栈的栈顶在低地址，栈底在高地址这样设计有什么意义呢？</p><p>计算机内存分了代码段（<code>.text</code>段）、初始化的数据段（<code>.data</code>段）、未初始化的数据段（<code>.bss</code>段）、堆空间（<code>heap</code>）、栈空间（<code>stack</code>）和命令行参数和环境变量区域。</p><p>程序计数器(<code>Program Counter</code>，简称<code>PC</code>)的缺省指向0地址，计算机开机后从程序计数器指向的地址开始执行程序，每执行完一条指令后， 程序计数器自动加1。</p><p>因此很自然的，代码段从低地址区间开始加载，向高地址区间扩展；</p><p>heap从低地址向高地址扩展，做内存管理相对要简单些，为了避免栈空间和代码段冲突，最大利用地址空间，很自然的，我们会选择把栈底设置在高地址区间，然后让栈向下增长。</p><p>这是来自apue里一张经典的ｃ程序内存分布图，着重看一下heap和stack的内存分布。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142320352.png" alt="image.png"></p><hr><h2 id="栈由高地址向低地址扩展的优点"><a href="#栈由高地址向低地址扩展的优点" class="headerlink" title="栈由高地址向低地址扩展的优点"></a>栈由高地址向低地址扩展的优点</h2><p><code>stack</code>从高地址向低地址扩展，这样栈空间的起始位置就能确定下来。动态的调整栈空间大小也不需要移动栈内的数据，如果是从低地址到高地址的扩展，结尾的地址是固定的，如果要扩大或缩小，则需要移动整个栈的数据。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142351623.png" alt="image.png"></p><p>并且<strong>这样设计可以使得堆和栈能够充分利用空闲的地址空间。</strong>如果栈向上涨的话，我们就必须得指定栈和堆的一个严格分界线，但这个分界线怎么确定呢？平均分？但是有的程序使用的堆空间比较多，而有的程序使用的栈空间比较多。</p><p>所以就可能出现这种情况：一个程序因为栈溢出而崩溃的时候，其实它还有大量闲置的堆空间呢，但是我们却无法使用这些闲置的堆空间。所以呢，最好的办法就是让堆和栈一个向上涨，一个向下涨，这样它们就可以最大程度地共用这块剩余的地址空间，达到利用率的最大化</p><hr><h2 id="现在-CPU-指令集的设计"><a href="#现在-CPU-指令集的设计" class="headerlink" title="现在 CPU 指令集的设计"></a>现在 CPU 指令集的设计</h2><p>大部分CPU指令集设计了函数调用架构，定义了专用的调用/返回指令，并在指令中隐含规定栈的方向。</p><ul><li>主流1：向低地址扩展：x86，MIPS</li><li>主流2：自由选择：Arm（但个别指令仅支持向低）</li><li>罕见：向高地址扩展：PA-RISC，操作系统Multics</li><li>非主流：System z，栈是个链表[2]</li></ul><hr><h2 id="其他解释"><a href="#其他解释" class="headerlink" title="其他解释"></a>其他解释</h2><p><strong>1.栈内内存是连续分配</strong></p><pre><code>因位栈空间内存分配连续，如果给一个数组或对象分配内存，栈会优先选择还没有分配的最小的内存地址给数组，数组中的地址是从低地址到高地址依次分配。所以数组的第一个元素的起始地址就是给数组分配的最低地址</code></pre><p><strong>2.栈的栈顶指针ESP默认指向栈顶</strong></p><pre><code>对数组的访问一般都是对一个数组的起始地址进行操作，也就是说我们需要的是数组的起始地址-&gt;也就是低地址，由于栈顶指针默认指向的是栈顶元素，那么只能是栈顶指针指向低地址值--&gt;这样便于对数组的访问。如果栈还是采用从低地址到高地址的扩展，那么就不会默认指向数组的起始地址(数组指针)，不便于访问。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LaTaX语言</title>
      <link href="/undefined/31c326ac.html"/>
      <url>/undefined/31c326ac.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191217069.png" alt="image.png"></p><p><code>1.求和表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;n=0&#125;^&#123;\infty&#125;n$$</span><br><span class="line"></span><br><span class="line">其中，\sum表示求和符号，n表示要累加的变量，0表示起始索引，\infty表示末尾索引。所以，上述表达式表示了从0开始到正无穷的所有整数之和。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\sum_{n=0}^{\infty}n</script><hr><p><code>2.积分表达式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\int_&#123;-\pi&#125;^&#123;\pi&#125;f(x)dx$$</span><br><span class="line"></span><br><span class="line">其中，$\int$ 表示积分符号，$f(x)$ 表示要积分的函数，$dx$ 表示积分的变量（即积分变量），$-\pi$ 和 $\pi$ 分别表示积分的下限和上限。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\int_{-\pi}^{\pi}f(x)dx</script><hr><p><code>3.分式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$\frac&#123;a&#125;&#123;b&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$a$ 表示分子，$b$ 表示分母。它表示了 $a$ 与 $b$ 之间的比率关系，也可以理解为 $a$ 中包含了 $b$ 的多少倍。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\frac{a}{b}</script><hr><p><code>4.下标</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$a_i$$</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">$$x_&#123;i,j&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$i$ 和 $j$ 是变量的下标，它们用于表示该变量的某个特定元素。在第一个例子中，$a$ 中的 $i$ 表示 $a$ 数组中的第 $i$ 个元素；在第二个例子中，$x$ 中的 $i$ 和 $j$ 分别表示一个二维数组 $x$ 中的第 $i$ 行第 $j$ 列的元素。</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">a_i</script><script type="math/tex; mode=display">x_{i,j}</script><hr><p><code>5.向量</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$\vec&#123;v&#125;$ 表示向量，“$$\begin&#123;pmatrix&#125; v_1 \\ v_2 \\ \vdots \\ v_n \end&#123;pmatrix&#125;$$” 表示以列的形式表示的向量，$v_1$、$v_2$、$\ldots$、$v_n$ 是向量中的元素。如果向量是一个二维向量，那么它还可以写成如下形式：</span><br><span class="line"></span><br><span class="line">$$\vec&#123;v&#125; = \begin&#123;pmatrix&#125; x \\ y \end&#123;pmatrix&#125;$$</span><br><span class="line"></span><br><span class="line">其中，$x$ 和 $y$ 分别是二维向量 $\vec&#123;v&#125;$ 的 $x$ 和 $y$ 分量</span><br></pre></td></tr></table></figure></p><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n\end{pmatrix}</script><script type="math/tex; mode=display">\vec{v} = \begin{pmatrix} x \\ y \end{pmatrix}</script><hr><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<script type="math/tex">公式内容</script>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<script type="math/tex">$公式内容$$$，如：</script>xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>&#123;&#125;</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号``，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\&#123; \&#125;</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum<em>{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A</em>{k<em>0}A</em>{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li>平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li><li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li><li>矩阵，符号：<script type="math/tex">\left[ \begin{array}{ccc} 1 & 0 & 0\\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{array} \right]</script><br>$\left[ \begin{array}{ccc} 1 &amp; 0 &amp; 0\ 0 &amp; 1 &amp; 0 \ 0 &amp; 0 &amp; 1 \end{array} \right]$<br>$\left[ \begin{array}{ccc} a &amp; b \ c &amp; d \end{array} \right]^{-1}$= $\left[ \begin{array}{ccc} d &amp; -b \ -c &amp; a \end{array} \right]$<br>$\left[ \begin{array}{ccc} 1 &amp; 1 &amp; 0\ 1 &amp; 0 &amp; 1 \ 0 &amp; 1 &amp; 1 \end{array} \right]$ · $\left[ \begin{array}{ccc} x1\ x2\ x3 \end{array} \right]$ = $\left[ \begin{array}{ccc} 2\ 0\ 0 \end{array} \right]$ ——&gt; $\left[ \begin{array}{ccc} 1 &amp; 1 &amp; 0 &amp; 2\ 1 &amp; 0 &amp; 1 &amp; 0 \ 0 &amp; 1 &amp; 1 &amp; 0 \end{array} \right]$ </li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code></li><li>自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> LaTax </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多地址指令实际访存次数</title>
      <link href="/undefined/7566551b.html"/>
      <url>/undefined/7566551b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191205540.png" alt="image.png"></p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><code>指令</code></h4><p>机器指令按照含有的地址数目可以分为1,2,3,4地址指令。<br>其中指令中存放的地址都是虚拟地址，不是实际物理地址。</p><h4 id="一般访存次数"><a href="#一般访存次数" class="headerlink" title="一般访存次数"></a><code>一般访存次数</code></h4><p>一般来说，举个例子:三地址指令<br>(A1)OP(A2)-&gt;A3<br>访存了4次：取指令-&gt;读A1-&gt;读A2-&gt;写到A3<br>这是最好的情况，考虑到需要访问的页表项，都在”快表TLB”之中可以找到，因此转换地址都不需要访存。</p><h4 id="实际访存次数"><a href="#实际访存次数" class="headerlink" title="实际访存次数"></a><code>实际访存次数</code></h4><p>三地址指令需要访存次数和一地址指令类似，也要考虑TLB、页表、磁盘之间的命中情况。</p><p>如果TLB中存在对应的页表项，那么就可以直接访问内存，不需要再查询页表。这时候，三地址指令需要访存4次：一次是读取指令，两次是读取操作数，一次是写入结果。</p><p>如果TLB中不存在对应的页表项，那么就需要查询页表，这时候就要多访问两次内存：一次是读取页表项，一次是读取数据。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，三次是读取页表项，一次是写入结果。</p><p>如果页表中也不存在对应的页表项，那么就发生缺页，需要从磁盘中读取数据到内存，并更新页表和TLB。这时候就要多访问一次磁盘。这时候，三地址指令需要访存7次：一次是读取指令，两次是读取操作数，两次是读取页表项，一次是写入结果，一次是从磁盘读取数据。</p><p>所以，三地址指令需要访存次数和TLB、页表、磁盘之间的命中情况有关，不一定是7次。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>english</title>
      <link href="/undefined/2c830200.html"/>
      <url>/undefined/2c830200.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191220297.png" alt="image.png"></p><h1 id="五大基本句型"><a href="#五大基本句型" class="headerlink" title="五大基本句型"></a>五大基本句型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Words and sentences</span><br><span class="line">conquere征服、trun to求助于、subscribe to相信、</span><br><span class="line">subscribe this magazine订阅这个杂质</span><br><span class="line">preside over主持</span><br><span class="line">cliff悬崖、revenge报复</span><br><span class="line">cores:</span><br><span class="line">五大基本句型</span><br><span class="line">1.主谓</span><br><span class="line">2.主谓宾</span><br><span class="line">3.主谓宾1 宾2</span><br><span class="line">4.主谓宾 宾补</span><br><span class="line">5.主系表</span><br><span class="line">importance:</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081145229.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081146754.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081149432.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081151379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081152440.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081153475.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081154782.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">例句：</span><br><span class="line">This conclusion oversimplifies..过于简单</span><br><span class="line">My heart aches.</span><br><span class="line">His words sparkle.</span><br><span class="line">The crisis vanishes.</span><br><span class="line">We survive.</span><br><span class="line">The rule protects the taxpayer.</span><br><span class="line">He advocated freedom.</span><br><span class="line">We should adhere to the direction.</span><br><span class="line">The economists subscribe to this theory.</span><br><span class="line">The action violated the Constitution.</span><br><span class="line">My mom cooked a lunch for me.</span><br><span class="line">My mom cooked me a lunch.</span><br><span class="line">The congress throws this dilemma to the White House.</span><br><span class="line">The congress throws the White House this dilemma.</span><br><span class="line">The authorities prefer the public to stay at home.</span><br><span class="line">The globalization has college graduates facing fiercer competition.</span><br><span class="line">The social media leaves senior citizens vulnerable to the fake news.</span><br><span class="line">The courage renders life worth living</span><br><span class="line">A flower stands in the sunshine.</span><br><span class="line">The affair rests a mystery.</span><br><span class="line">This dish tastes good.</span><br><span class="line">He seems rather agitated.​</span><br><span class="line"></span><br><span class="line">我的心疼痛。</span><br><span class="line">他的话闪闪发光。</span><br><span class="line">危机消失了。</span><br><span class="line">我们生存下来。</span><br><span class="line">这条规则保护了纳税人。</span><br><span class="line">他主张自由。</span><br><span class="line">我们应该坚持这个方向。</span><br><span class="line">经济学家们赞同这个理论。</span><br><span class="line">这一行为违反了宪法。</span><br><span class="line">我妈妈为我做了一顿午餐。</span><br><span class="line">我妈妈给我做了个午饭。</span><br><span class="line">国会把这一困境推给了白宫。</span><br><span class="line">国会让白宫抛出了这一困境。</span><br><span class="line">当局更希望公众呆在家里。</span><br><span class="line">全球化使大学毕业生面临着更激烈的竞争。</span><br><span class="line">社交媒体让老年人很容易受到假新闻的攻击。</span><br><span class="line">勇气使生活值得活下去</span><br><span class="line">一朵花站在阳光下。</span><br><span class="line">这件事仍然是个谜。</span><br><span class="line">这道菜味道好极了。</span><br><span class="line">他似乎很激动。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">经典：</span><br><span class="line">I never forgive, but I always forget.</span><br><span class="line">Darkness cannot drive out darkness; only light can do that.</span><br><span class="line">Hate cannot drive out hate; only love can do that.</span><br><span class="line">Hell is empty and all the devils are here.</span><br></pre></td></tr></table></figure></p><h1 id="定语、状语、同位语、插入语"><a href="#定语、状语、同位语、插入语" class="headerlink" title="定语、状语、同位语、插入语"></a>定语、状语、同位语、插入语</h1><hr><p>简单句的语言障碍来源于1.定语 2.状语  3.同位语  4.插入语</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a><strong>定语</strong></h2><p><em>hypocritical虚伪的、spectacle壮观的场面、intense激烈的、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101551813.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101554207.png" alt="image.png"></p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a><strong>状语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101557527.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101601989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101602896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101604269.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101629436.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101630473.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101631375.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101609313.png" alt="image.png"></p><h2 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a><strong>同位语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101611122.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101614717.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101613124.png" alt="image.png"></p><h2 id="插入语"><a href="#插入语" class="headerlink" title="插入语"></a><strong>插入语</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101618180.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101619431.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101621256.png" alt="image.png"><br>笑炸了！家人们<br>I am the best teacher  我是最好的老师<br>改为万能插入语<br>I ,rather than anyone else,<br>am,rather than will be,<br>the best,rather than good,<br>teacher,rather than policeman(cop)<br>我而不是别人，是而不是将要是，最好的而不仅仅是好的，老师而不是警察(条子)</p><h1 id="连接词"><a href="#连接词" class="headerlink" title="连接词"></a>连接词</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conmence 毕业典礼、开始</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162327530.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162328895.png" alt="image.png"></p><h2 id="句子之间的连接方式"><a href="#句子之间的连接方式" class="headerlink" title="句子之间的连接方式"></a>句子之间的连接方式</h2><h3 id="并列"><a href="#并列" class="headerlink" title="并列"></a>并列</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162329883.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162349412.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306170009789.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162352377.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306162354284.png" alt="image.png"></p><h3 id="主从复合句"><a href="#主从复合句" class="headerlink" title="主从复合句"></a>主从复合句</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207495.png" alt="image.png"></p><h4 id="状语从句-副词性从句"><a href="#状语从句-副词性从句" class="headerlink" title="状语从句(副词性从句)"></a>状语从句(副词性从句)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181207245.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181217682.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.It doesn&#x27;t feel like a human or democratic relationship,even if both sides</span><br><span class="line">benefit.</span><br><span class="line">即使双方都受益，也不是人与人之间平等的关系</span><br><span class="line"></span><br><span class="line">2.As the cost to everyone else has become clearer,politicians have begun to</span><br><span class="line">clamp down.</span><br><span class="line">因为每个人所承受的代价变得显而易见了，政客们已经开始施压了</span><br><span class="line">....</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181225896.png" alt="image.png"></p><h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><h5 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">That the seas are being over fished has been known for years--&gt;主语从句</span><br><span class="line"></span><br><span class="line">--&gt;一般会改写为形式主语--&gt; it has been knows for years that...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181304536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181305134.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181306845.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181312445.png" alt="image.png"></p><h5 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181441584.png" alt="image.png"></p><h5 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181444199.png" alt="image.png"></p><h5 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181449900.png" alt="image.png"></p><h5 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181601408.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181608655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181612050.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181613273.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181619664.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181620104.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306181625756.png" alt="image.png"></p><h1 id="层次化阅读和主干隔离"><a href="#层次化阅读和主干隔离" class="headerlink" title="层次化阅读和主干隔离"></a>层次化阅读和主干隔离</h1><h2 id="层次化阅读法"><a href="#层次化阅读法" class="headerlink" title="层次化阅读法"></a>层次化阅读法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052224384.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042239593.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042240478.png" alt="image.png"></p><p><em>substance 物质  、clinical nutirtion 临床营养学 、utilize 利用 、distinct 明显的、essential 必要的 、agent 介质、constituent 组成部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042245516.png" alt="image.png"></p><h2 id="主干隔离法"><a href="#主干隔离法" class="headerlink" title="主干隔离法"></a>主干隔离法</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052225973.png" alt="image.png"></p><blockquote><p><em>将主语与谓语连在一起读，中间部分调整语序</em></p></blockquote><p>*artisans 工匠、artists 艺术家、machanic 技工、establishment 机构、组织</p><p>The notion - 这个观念、这个想法</p><p>that learning should have in it an element of inspired play - 观念认为学习应该融入受启发的游戏元素</p><p>would seem - 似乎</p><p>to the greater part of the academic establishment - 对大部分有学术性的机构或组织(如学校、大学等)</p><p>merely silly - 只是一个愚蠢的想法*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052227844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052229938.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052236404.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052237748.png" alt="image.png"></p><h1 id="非谓语动词和独立主格结构"><a href="#非谓语动词和独立主格结构" class="headerlink" title="非谓语动词和独立主格结构"></a>非谓语动词和独立主格结构</h1><h2 id="非谓语动词"><a href="#非谓语动词" class="headerlink" title="非谓语动词"></a>非谓语动词</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060933764.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060942180.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060946157.png" alt="image.png"></p><h2 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h2><p><em>带有主语的非谓语动词</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060953217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307060956043.png" alt="image.png"><br><em>Media 媒体 、epidemic 流行病、cigarette 香烟、liken 比作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061003195.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061007239.png" alt="image.png"></p><h1 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061012037.png" alt="image.png"></p><blockquote><p><em>部分倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061019182.png" alt="image.png"></p><blockquote><p><em>完全倒装</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061023671.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061046014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061049074.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061050328.png" alt="image.png"></p><h1 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061056945.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061107064.png" alt="image.png"></p><p><em>individual 个体 、maximaize 最大化、profits利润、coupled with 以及(相等于and)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061121649.png" alt="image.png"></p><h1 id="省略句"><a href="#省略句" class="headerlink" title="省略句"></a>省略句</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061131321.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061130607.png" alt="image.png"></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061140766.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061141718.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061142254.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061148829.png" alt="image.png"></p><h1 id="实战解析"><a href="#实战解析" class="headerlink" title="实战解析"></a>实战解析</h1><p><em>cognitive认知 、caregiver看护者</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061158889.png" alt="image.png"></p><p><em>imposter 冒牌者   、file(ing) cabinet  文件柜、 fraught 充满 、reconcile 调和、和解 、<br>designate 指定、指派(职务)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071032339.png" alt="image.png"></p><p><em>overwhelming 巨大到无法应付的。指某事物之多、之严重以至于无法有效应对。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071556623.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071614505.png" alt="image.png"></p><p><em>Come to a halt的含义是停止;停顿下来。<br>它表示某物停止了运动或工作。强调运动或行为的终止。<br>例句:<br>The car came to a sudden halt.<br>那辆车突然停了下来 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071621176.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071625167.png" alt="image.png"></p><p><em>quantum computers 量子计算机 、crack 破解、encryption加密</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071639372.png" alt="image.png"></p><p><em>mutually 互相、composed of 由..组成  、composed 镇定的，有条理的、simulate模拟<br>interactions 相互影响</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071727387.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071728023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071804873.png" alt="image.png"></p><hr><blockquote><p>!!!</p></blockquote><p>proportion 的意思是:</p><p>比例,部分,成比例</p><ol><li>proportion 指在整体中所占的百分比或比例。例如:</li></ol><ul><li><p>What proportion of your income do you spend on rent? 你的收入中有多大比例用于支付房租?</p></li><li><p>Only a small proportion of applicants are admitted to this school. 只有一小部分申请者能被这所学校录取。</p></li></ul><ol><li>proportion 也可以表示一个量与另一个量之间的比较关系,指成比例。例如:</li></ol><ul><li><p>Mix the ingredients in the proper proportion. 按正确的比例混合这些材料。</p></li><li><p>The model was built in exact proportion to the original building. 这个模型按原建筑的精确比例建造的。</p></li></ul><ol><li>proportion 还可以指大小、范围或重要性的程度。例如:</li></ol><ul><li><p>The cost overrun was of massive proportion. 造价超支的规模巨大。</p></li><li><p>An issue of such proportion requires careful thought. 这么重大的问题需要慎重考虑。</p></li></ul><p><strong>literacy 的意思是:</strong></p><p>识字能力,读写能力</p><p>literacy 指一个人阅读和写作的基本能力,特别是在 mother tongue(母语)中的读写能力。</p><p>一些关于literacy的例子:</p><ul><li><p>Improving literacy is a priority, as it helps break the cycle of poverty. 提高识字率是优先事项,这有助于打破贫困循环。</p></li><li><p>The government has launched a campaign to boost literacy among adults. 政府启动了一个运动来提高成人的读写能力。</p></li><li><p>Children’s literacy skills develop through reading books and stories. 儿童的读写能力通过读书和故事得到发展。</p></li><li><p>Digital literacy is increasingly important in the internet age. 在互联网时代,数字读写能力越来越重要。</p></li><li><p>Functional literacy refers to the basic skills needed to function in society. 功能性识字能力是指一个人在社会中基本需求的读写能力。</p></li></ul><p><em>institution 机构、制度、组织  ， soild 坚固的、扎实的、牢固的，souvenir 纪念品<br>quill 鹅毛笔</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091525945.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>fitigue 的意思是疲劳,疲惫。</p><p>它是一个来自法语的英语词汇,常见的用法有:</p><ol><li><p>身体上的疲劳,疲惫 例句:After a long run, I felt fatigue in my legs. 长时间跑步后,我腿感到了疲劳。</p></li><li><p>精神上的疲惫 例句:Mental fatigue built up after hours of study. 坐了几个小时后精神上感到了疲惫。</p></li><li><p>金属疲劳 例句:The metal wing suffered fatigue after many flights. 金属机翼在多次飞行后出现了金属疲劳。</p></li><li><p>造成疲劳的因素或过程 例句:Sleep deprivation leads to increased fatigue. 睡眠不足会导致疲劳加剧。</p></li></ol><p>poll 有以下几层常见意思:</p><ol><li>民意调查;选举投票</li></ol><p>例句:The latest polls show he has a slim lead over his opponent. 最新民调显示他比对手略占优势。</p><ol><li>票数;票汇总</li></ol><p>例句:After the polls closed, vote counting began immediately. 在投票结束后,票票汇总工作立即开始。</p><ol><li>投票站;选区</li></ol><p>例句:There were long lines at the polls this morning. 今天早晨投票站前有长长的队伍。</p><ol><li>票选,投票</li></ol><p>例句:About 60% of voters polled today. 大约有60%的选民今天参与了投票。</p><ol><li>统计,调查</li></ol><p>例句:Let’s take a poll of everyone’s opinion on this matter. 让我们统计一下每个人对这个问题的看法。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152210940.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217622.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152217842.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>acknowledge 的意思是:</p><ol><li>承认,认可</li></ol><p>例句:He acknowledged that he had made a mistake. 他承认了自己犯了一个错误。</p><ol><li>感谢,表达谢意</li></ol><p>例句:I acknowledge all the staff for their hard work. 我对全体员工的辛勤工作表示感谢。</p><ol><li>回复,对…作出响应</li></ol><p>例句:She acknowledged my email with a quick reply. 她很快回复了我的电子邮件。</p><ol><li>收到,收悉</li></ol><p>例句:Please acknowledge receipt of this document. 收到此文件请回执。</p><p><em>cut adrift 被抛弃、sector行业，领域、self-critical自我批判、landlord房东</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307152225925.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>dynamic 的常见意思有:</p><ol><li>动态的,不断变化的</li></ol><p>例句:a dynamic economy 动态变化的经济</p><ol><li>积极有活力的</li></ol><p>例句:a dynamic young leader 一个精力充沛的年轻领导者</p><ol><li>(音量)强弱变化的</li></ol><p>例句:the dynamic range of the music 音乐的动态范围</p><ol><li>(力学术语)动力学的</li></ol><p>例句:dynamic equilibrium 动态平衡</p><ol><li>动力的,与动力相关的</li></ol><p>例句:a dynamic microphone 动力麦克风</p><p>所以,dynamic的意思是“动态的、变化的”,强调不断变化和活力,与“static”相对。可以广泛地应用于许多领域</p><p><em>publishing industry出版行业</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161009103.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>casino 是赌场的意思。</p><p>例句:</p><ol><li><p>There are many large casinos in Las Vegas. 拉斯维加斯有许多大型赌场。</p></li><li><p>He lost a lot of money gambling in the casino. 他在赌场赌博损失了很多钱。</p></li><li><p>The new casino brought in tourism revenue for the city. 新的赌场为这座城市带来了旅游收入。</p></li><li><p>She always plays blackjack when she visits casinos. 她每次去赌场都会玩二十一点。</p></li><li><p>The casino was open 24 hours and full of slot machines. 这个赌场24小时营业,里面满是老虎机。</p></li></ol><p>综上所述,casino 代表赌场这个场所,里面有各种赌博游戏,例如扑克、轮盘、老虎机等。赌场主要为赌博提供场所,通常还有酒店、餐厅、商场等设施和娱乐活动。</p><hr><p>gambling 的意思是赌博、赌钱。</p><p>常见的词义包括:</p><ol><li><p>赌博活动 例句:Gambling is illegal in some countries. 在一些国家赌博是非法的。</p></li><li><p>赌钱 例句:Many people lose a lot of money through gambling. 很多人通过赌博损失了大量金钱。</p></li><li><p>冒险 例句:Changing jobs now would be a gamble. 现在换工作将是一次冒险。</p></li><li><p>对…抱有希望 例句:I’m gambling that the weather will be nice tomorrow. 我抱着明天天气会好的希望。</p></li><li><p>孜孜不倦地追求 例句:He is gambling for fame and reputation. 他孜孜不倦地追求名誉和声望。</p></li></ol><p>综上所述,gambling 意思是赌博、赌钱,通常涉及金钱的风险投机。延伸意思是冒险以及抱有希望。</p><hr><p>coasting on 意思是“依靠,利用(之前的成就或努力)”。</p><p>这是一个常见的英语习语,意思是指一个人或组织停止努力,而是依靠或利用过去的成就和努力来维持当前的状态或成功。</p><p>例句:</p><ol><li><p>After the company’s initial success, the CEO has just been coasting on its reputation rather than innovating. 在公司最初成功之后,CEO一直依靠其声誉,而不是创新。</p></li><li><p>The actor admitted to coasting on his previous roles and hasn’t taken up new challenges lately. 这位演员承认自己近期沿用老角色,没有接受新挑战。</p></li><li><p>The professor seems to be coasting on her book’s popularity rather than producing new research. 这位教授似乎依靠她书籍的畅销,而不是进一步研究。</p></li><li><p>Successful entrepreneurs cannot afford to coast on past achievements. 成功的企业家不能依赖过去的成就。</p></li></ol><p>综上所述,coasting on 意味着依靠过去努力的成果,而不是继续付出努力。通常有负面的含义,意味着一个人或组织变得自满和懒惰。</p><hr><p>pan out 是一个英语习语,意思是“结果变成,发展成”。</p><p>例句:</p><ol><li><p>His business idea didn’t pan out as he had hoped. 他的商业想法结果没有如他所愿。</p></li><li><p>We’re still waiting to see how this new project pans out. 我们仍在观望这个新项目的发展。</p></li><li><p>I don’t think this relationship is going to pan out after all. 我认为这段关系结果不会太理想。</p></li><li><p>If their date pans out, they might start a relationship. 如果他们的约会进展顺利,他们可能会开始一段关系。</p></li><li><p>His career as a musician never really panned out. 他作为音乐家的职业生涯结果并不成功。</p></li></ol><p>综上所述,pan out 意思是经过发展或等待结果后,事情的结果最后如何,是否成功或达到预期。也可以表示事情最终结果的好坏。</p><p><em>enormous revenues 意思是“巨大的收入”或“极高的营收”、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161019158.png" alt="image.png"><br><em>big advance 巨额预付金、preexisting先前存在的、frenzy狂热、疯狂失控</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161025712.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>contexts 是名词,复数形式,主要有以下几层含义:</p><ol><li>文章或谈话中的语言环境,提供理解词语或行为的额外信息。<br>例句:You can’t understand what he meant without looking at the wider context of the conversation. 如果不考虑谈话的更广泛语境,你就无法理解他的意思。</li><li>事件或行为发生的背景情况。<br>例句:In the context of high unemployment, the policy makes sense. 在高失业率的背景下,这项政策有意义。</li><li>程序运行或操作的环境。<br>例句:This function behaves differently depending on the software context. 这个功能的运行取决于软件环境的不同而有区别。</li><li>论证或思考的前提条件或框架。<br>例句:Examine the problem in the context of the limitations we face. 在我们面临的限制条件下审视这个问题。</li></ol><hr><p>constraining 的意思是“限制的、约束的”。它来源于动词constrain,意为“限制、抑制”。</p><p>constraining 作为形容词,常用于以下场合:</p><ol><li>限制行为或活动的规则或条件。</li></ol><p>例句:The new policy imposes constraining regulations on business. 新政策对企业施加了限制性规定。</p><ol><li>限制思维或创造力的框架或因素。</li></ol><p>例句:We need to think outside constraining traditional paradigms. 我们需要跳出限制思维的传统模式。</p><ol><li>限制行动或发展的不利环境或因素。</li></ol><p>例句:Poverty is a constraining factor that traps people in disadvantage. 贫穷是一个制约因素,让人们无法摆脱劣势。</p><ol><li>紧缚的、禁锢的衣物或配饰。</li></ol><p>例句:She refused to wear constraining clothes that restricted her movement. 她拒绝穿会限制行动的紧身衣服。</p><hr><p>pertaining 的意思是“关于”,“与…有关”。它是一个正式用语,通常用于描述某人或某事与特定主题、事件或情况有关。</p><p>例句:</p><ol><li><p>All documents pertaining to the legal case must be submitted to the court. 所有与此法律案件有关的文件都必须提交给法院。</p></li><li><p>The police asked questions pertaining to the accident. 警察问了一些关于这起事故的问题。</p></li><li><p>The manager sent a memo pertaining to the new company policy. 经理发了一则与新公司政策相关的备忘录。</p></li><li><p>The museum has a collection of artifacts pertaining to ancient Egypt. 博物馆有一个关于古埃及的藏品收集。</p></li><li><p>I need some advice pertaining to filing my taxes this year. 我需要一些建议,关于今年报税的事宜。</p></li></ol><hr><p>labor 的意思是“劳动,劳力”。它是一个常用词,主要有以下几层含义:</p><ol><li>工作,尤其是体力劳动。</li></ol><p>例句:Farming is hard labor. 农活是体力劳动。</p><ol><li>工人阶级,劳动者。</li></ol><p>例句:The new policy protects the rights of labor. 这项新政策保护劳动者的权益。</p><ol><li>分娩的努力和痛苦,即生产过程。</li></ol><p>例句:The mother was in labor for 10 hours. 这位母亲经历了10小时的分娩过程。</p><ol><li>工作结果,劳动成果。</li></ol><p>例句:The Pyramids are an amazing labor of ancient Egyptians. 金字塔是古埃及人惊人的劳动成果。</p><ol><li>具有特定功能的工作或任务。</li></ol><p>例句:Every part has its own labor in the workings of a machine. 在机器运转中,每个部件都有其特定的功能。</p><p><em>curtail 削弱、缩短、限制、 seek 寻找、pursue追求、 oppressive压迫的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161034961.png" alt="image.png"></p><p><em>vaccine 疫苗、corporate regulation企业监管、 labor劳工、劳动力、civil民事的、公民的 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161043329.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>extract 的意思是“提取;摘录”,是个常用词,主要有以下几层含义:</p><ol><li>从某物中提取或分离出某个成分、物质等。</li></ol><p>例句:extract oil from coal 从煤中提取油</p><ol><li>摘录,选取某文献中的段落或内容。</li></ol><p>例句:extract key passages from the book 从书中摘录主要段落</p><ol><li>获取、套取(信息等)。</li></ol><p>例句:extract a confession from him 从他那里套取口供</p><ol><li>引出,推断出(结论等)。</li></ol><p>例句:extract meaning from the data 从数据中推断出意义</p><ol><li>移去,拔出(牙齿等)。</li></ol><p>例句:The dentist extracted two teeth. 牙医拔除了两颗牙。</p><p>所以,extract 的基本意思是从某物中提取出某部分或物质;也可以指获取一些隐藏或不容易觉察的信息。</p><hr><p>vantage</p><ol><li>有利条件,优势。</li></ol><p>例句:a good vantage point to watch birds 观察鸟类的有利位置</p><ol><li>视野,视力范围。</li></ol><p>例句:Beyond my vantage, I could see the lake. 在我的视野范围之外,我可以看到湖泊。</p><ol><li>预见,预知。</li></ol><p>例句:He plans with vantage for the future. 他预见未来做计划。</p><ol><li>利益,好处。</li></ol><p>例句:I have no personal vantage in this. 这对我没有任何个人利益。</p><hr><p><em>scramble 的基本意思是匆忙或火急火燎的样子、crucial至关重要的、fossil fuels化石燃料、 tear up 撕碎的弄破的、plants植物、工厂、设备、 rural农村的、urban城市的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161330773.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331989.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161331524.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>dwell 停留、居住、 atmosphere大气、气氛、环境、plain平坦的、平淡的、 dull迟钝的、无聊的·、 version版本 、notification通知、通告、storm风暴</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422007.png" alt="image.png"><br>￼<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161422229.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>critics 评论家、 stand as is 保持原样、penguin企鹅</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432549.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161432535.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>reframe 的意思是“重新塑造,重构”,reframe 是由前缀 re- (再次)和 frame(框架)组合而成的词。</p><p>reframe 作为动词,主要有以下含义:</p><ol><li>重新组织,调整结构或框架。</li></ol><p>例句:We need to reframe our business strategy. 我们需要重新组织我们的商业战略。</p><ol><li>以新的观点或角度重新审视。</li></ol><p>例句:Let’s reframe this issue in a more positive light. 让我们以更正面的视角来重新审视这个问题。</p><ol><li>重新描绘,重述。</li></ol><p>例句:He reframed his experiences more constructively. 他以更建设的方式重述了他的经历。</p><ol><li>调整态度,换种思维方式。</li></ol><p>例句:Reframing problems as opportunities. 将问题重塑为机遇。</p><p>所以,reframe 意思是把事情放在一个新的框架或视角中进行重新思考,以产生新的结构、见解或态度。</p><hr><p>spectrum 的意思是“范围, 光谱”。主要有以下几层含义:</p><ol><li>范围,系列,一系列邻接的事物。</li></ol><p>例句:There is a wide spectrum of opinions on the issue. 这个问题有广泛的观点范围。</p><ol><li>光谱,按波长顺序排列的电磁波颜色范围。</li></ol><p>例句:Sunlight contains all the wavelengths of the visible light spectrum. 阳光包含了可见光谱中所有的波长。</p><ol><li>分类,按顺序或级别排列的系统。</li></ol><p>例句:the whole political spectrum from left to right 政治光谱上的全部派别</p><ol><li>范围,多种选择或可能性。</li></ol><p>例句:We offer a spectrum of investment options. 我们提供一系列投资选择。</p><ol><li>范畴,领域。</li></ol><p>例句:The issue falls outside the spectrum of this committee. 这个问题超出了委员会的范畴。</p><p><em>beaming面带灿烂笑容、scrolling 滚动、浏览</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161442818.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>physician 的意思是“医生”,尤其是指正式的医学执业医师。</p><p>一些关键点:</p><ol><li><p>physician 指经过长时间医学训练和执业资格认证的医生。</p></li><li><p>它与 doctor 的含义基本相同,但physician 表示更专业和正式的医生身份。</p></li><li><p>physician 通常需要接受8年以上的医学院教育和临床实习。</p></li><li><p>主治医生(attending physician)和内科医生(physician)是两种常见的physician。</p></li><li><p>physician可以自主开业,也可以在医院、诊所、学术机构等工作。</p></li><li><p>与physician对应的是医疗助理职业,如护士、技师等。</p></li><li><p>按专业领域又可细分为儿科医生、外科医生、心理医生等。</p></li><li><p>口语中更常用doctor,但是正式场合仍使用physician。</p></li></ol><p>所以,physician指经过系统医学训练和考核,获得医生资格并执业的医疗专业人士。是医疗保健领域的核心职业之一。</p><hr><p>procedures 的意思是“程序;步骤”,表示完成某项工作或任务所需遵循的一系列步骤或流程。</p><p>些关键点:</p><ol><li><p>procedure 强调按照规定的顺序和方法来进行。</p></li><li><p>医疗程序(medical procedures)指进行疾病治疗或身体检查的标准步骤。</p></li><li><p>行政程序(administrative procedures)指在政府、公司或组织内部的官方工作流程。</p></li><li><p>程序也可以是规范某项活动的准则或方针。</p></li><li><p>程序的目的是提高工作效率、减少错误。</p></li><li><p>遵守程序意味着按照特定顺序执行每一步。</p></li><li><p>程序可能需要书面文档,以方便培训和规范操作。</p></li><li><p>如果情况失控,也可主动终止程序。</p></li><li><p>相比过程(process),程序更加规范化和固定化</p></li></ol><hr><p>strain 的意思有以下几个:</p><ol><li>拉、绷紧</li></ol><p>例句:Strain the rope tightly. 把绳子用力拉紧。</p><ol><li>扭伤;拉伤</li></ol><p>例句:I strained my back lifting those heavy boxes. 我搬动那些重箱子时扭伤了背。</p><ol><li>过度使用;损伤</li></ol><p>例句:Don’t strain your eyes watching TV in the dark. 别在暗处看电视伤眼睛。</p><ol><li>压力;负荷过重</li></ol><p>例句:The recent difficulties have put a strain on their relationship. 近来的困难给他们的关系造成了压力。</p><ol><li>过滤;过滤掉</li></ol><p>例句:Strain the noodles and run them under cold water.过滤面条并在冷水下冲洗。</p><ol><li>费力;竭力</li></ol><p>例句:She strained to hear what they were saying. 她竭力去听他们在说什么。</p><ol><li>(微生物的)菌株</li></ol><p><em>physicians 执业医师、procedures程序步骤、squeeze积压、挤出、incentivize激励</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161454669.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>are only as good as  ..的好坏取决于..  、precisely精确地· 正是、 metabolism新陈代谢<br>commerical 商业的、贸易的、盈利性质的  、variables变量   、dizzying令人头晕目眩的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161530860.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161541216.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>critical 的意思有以下几个方面:</p><ol><li>批评的;批判的</li></ol><p>例句:She has a very critical attitude toward modern art. 她对现代艺术持非常批判的态度。</p><ol><li>关键的;决定性的</li></ol><p>例句:Proper hydration is critical for athletes. 适当的水化对运动员来说非常关键。</p><ol><li>危急的;危重的</li></ol><p>例句:The patient’s condition was listed as critical after the accident. 事故后,病人的情况被列为危重。</p><ol><li>批评;批评意见</li></ol><p>例句:The film received excellent critical reviews. 这部电影获得了极好的评价。</p><ol><li>关键时刻;危急关头</li></ol><p>例句:We made it through the critical moment.我们挺过了最危急的时刻。</p><ol><li>临界;最高点</li></ol><p>例句:The reactor was close to its critical temperature.反应堆的温度接近临界点。</p><p>综上所述,critical 既可形容事物的重要性,也可表示对事物的批判分析,或描述达到极限的状态</p><hr><p>slash 的常见意思有:</p><ol><li>削减;打折</li></ol><p>例句:The store slashed prices for its end-of-season sale. 商店为季末销售大幅削减了价格。</p><ol><li>砍;割</li></ol><p>例句: He slashed through the vines with his machete. 他用大砍刀砍开藤蔓.</p><ol><li>猛砍;乱砍</li></ol><p>例句: The maniac slashed the victim repeatedly with a knife. 那个疯子用刀猛砍受害者。</p><ol><li>斜线</li></ol><p>例句: Write the date using slashes: mm/dd/yy. 用斜线表示日期:月/日/年。</p><ol><li>(在计算机字段中用于表示)一种选择或替代</li></ol><p>例句: Choose A/B/C. 选择A/B/C。</p><ol><li>(音乐样式)迷幻摇滚</li></ol><p>例句: Guns N’ Roses started as an LA slash metal band. 枪与玫瑰乐队最初是洛杉矶的卷舌摇滚乐队。</p><p>综上所述,slash 的意思与切、砍、削减、选择等相关,可以作为动词或名词使用。</p><hr><p>drilling 有以下几层含义:</p><ol><li><p>钻孔 - Drilling a hole into the wall to hang a picture. 为了挂画在墙上钻孔。</p></li><li><p>练习 - Repeatedly drilling math problems to memorize formulas. 重复训练数学题以记住公式。</p></li><li><p>军事训练 - Soldiers drilling every morning on the parade ground. 士兵每天早晨在操场进行军事训练。</p></li><li><p>疾行 - Drilling through the crowded sidewalk. 穿过拥挤的人行道疾行。</p></li><li><p>严格训斥 - The coach kept drilling the players on minor mistakes. 教练一直严厉指责球员的小错误。</p></li><li><p>开采;钻探 - An oil company is drilling for petroleum in the ocean. 石油公司在海洋钻探石油。</p></li><li><p>牙科钻孔 - The dentist will be drilling several cavities today. 今天牙医要钻几个蛀牙。</p></li></ol><p>所以,drilling 的基本意思是通过钻孔或重复性训练来获得或加强某项技能。</p><hr><p><em>methane甲烷  、 emissions排放、 drilling 钻探、maintained保持维持、dramatically显著的</em>、<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161551101.png" alt="image.png"></p><p><em>A risks B —&gt;A有可能导致B</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162306630.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>rage 的常见意思有:</p><ol><li>激怒;狂怒</li></ol><p>例句:Seeing the mess, he flew into a rage. 看到一团糟,他暴怒起来。</p><ol><li>激烈的情感;狂暴</li></ol><p>例句:a poem full of rage and passion 一首充满激愤与激情的诗歌</p><ol><li>风靡;盛行</li></ol><p>例句:A new dance craze is all the rage right now. 一个新的舞蹈热潮现在正风靡一时。</p><ol><li>激烈的争论或斗争</li></ol><p>例句:a philosophical rage 在哲学上的激烈争论</p><ol><li>精力旺盛;热情</li></ol><p>例句:Quitting smoking has filled me with a rage to live. 戒烟让我热情高涨,对生活充满了激情。</p><ol><li>暴力;激烈</li></ol><p>例句:the rage of war 战争的暴力</p><ol><li>(疾病的)流行</li></ol><p>例句:a flu rage 流感的流行</p><p>综上所述,rage 表示强烈愤怒或热情,也可指某事物的风靡或某情绪的强烈爆发。</p><hr><blockquote><p>!!!</p></blockquote><p><em>strategy战略、策略； uncovered揭露，揭示、confession坦白、忏悔、认罪</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171222257.png" alt="image.png"></p><p><em>protest抗议、抗议活动；sin罪行，罪恶；proactive积极主动地&lt;-反-&gt;passive消极的；<br>reputation名誉，声誉；massive大规模的，大量的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171327987.png" alt="image.png"></p><p><em>approach方法；statement声明</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171329142.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>consolidation 的意思是“巩固,加强”。它的常见含义有:</p><ol><li>巩固,加强已获得的地位或者优势。</li></ol><p>例句:The company is seeking to consolidate its dominant position in the market. 该公司正寻求巩固其在市场的主导地位。</p><ol><li>合并,将多个事物整合在一起。</li></ol><p>例句:There was a wave of consolidation among major banks. 主要银行进行了一波合并潮。</p><ol><li>使更加稳固、坚实。</li></ol><p>例句:The new evidence helped consolidate the argument. 新的证据帮助加强了这个论点。</p><ol><li>统一,整合(权力、资源等)。</li></ol><p>例句:The king consolidated his rule over the empire. 国王统一了他对帝国的统治。</p><ol><li>使(知识等)牢固。</li></ol><p>例句:We need to consolidate what we learned in class today. 我们需要巩固今天课堂上学到的知识。</p><ol><li>合并(财务账目等)。</li></ol><p>例句:All the subsidiaries report to HQ for financial consolidation. 所有子公司汇报给总部进行财务合并。</p><hr><p><em>trade-off 取舍、权衡 ；consolidation合并，加强；instance实例，情况</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171333756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171338448.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171343874.png" alt="image.png"></p><p><em>appropriate恰当的，适当的； collective集体的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171345209.png" alt="image.png"></p><hr><p>quo 的常见意思有:</p><ol><li>status quo</li></ol><p>这个词组表示“现状,原状”。</p><p>例句:We cannot continue with the status quo. We need changes. 我们不能维持现状。我们需要改变。</p><ol><li>pro quo</li></ol><p>这个词组表示“交换,回报”。</p><p>例句:Quid pro quo refers to an exchange of goods or services. Quid pro quo 指商品或服务的交换。</p><hr><p><em>is anything but simple不是容易的；pre-pandemic前疫情的  </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171348681.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>episode 的常见意思有:</p><ol><li>事件,故事的一个章节或阶段</li></ol><p>例句:The latest episode of the drama was very moving. 这部电视剧的最新一集非常动人。</p><ol><li>一段经历,一个阶段</li></ol><p>例句:That was an unfortunate episode in my life. 那是我一生中一段不幸的经历。</p><ol><li>发作,发病</li></ol><p>例句:The patient had a sudden episode of chest pain. 这个病人突然胸痛发作。</p><ol><li>一集电视节目</li></ol><p>例句:I missed the first episode of this TV series. 我错过了这个电视剧的第一集。</p><ol><li>情节中的一个片段</li></ol><p>例句:There are several funny episodes in the movie. 这部电影有几个搞笑的片段。</p><ol><li>事件,事变</li></ol><p>例句:The bombing was just one episode in the long conflict. 这次轰炸只是长期冲突中的一个事件。</p><p>所以,episode 指故事、事件发展中的一个阶段或段落,也可以指电视节目中的一集、或病人的一场发作。</p><hr><p>count 的常见意思有:</p><ol><li>计算;数数</li></ol><p>例句:Let me count the coins in my pocket. 让我数数口袋里的硬币。</p><ol><li>计数;计数值</li></ol><p>例句:What was the final count of votes? 最后的投票计数是多少?</p><ol><li>计数单位;数目</li></ol><p>例句:A vast count of stars are visible in the night sky. 夜空中可见无数的星星。</p><ol><li>重要;有影响力</li></ol><p>例句:Your opinion counts. 你的观点很重要。</p><ol><li>认为;视为</li></ol><p>例句:She counted him as one of her closest friends. 她视他为自己最亲密的朋友之一。</p><ol><li>依靠;信赖</li></ol><p>例句:You can always count on him for help. 对于寻求帮助你总能依靠他。</p><ol><li>控诉;指控</li></ol><p>例句:He was accused on five counts of fraud. 他被控五项诈骗罪。</p><ol><li>回数;节拍</li></ol><p>例句:The dancer kept perfect count throughout the performance. 舞者在整场表演中拍子始终正确。</p><hr><p><em>privileged有特权的；implicitly隐含的，默认的；class阶级；administration行政部门，政府机构；rescue营救，解救，脱困；uninsured没有保险的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171402709.png" alt="image.png"></p><p><em>crisis危机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171411443.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>just as significantly同样重要的是；industry行业； precedent先例</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171425766.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171429332.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>contrast with与…形成对比 ；stark明显的，极端，荒凉;  elementary基础性的；element 元素，成分，要素</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171450834.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171458497.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>systematically 的意思是“有系统地”,是个副词。其含义是:</p><ol><li>按照系统或方法进行</li></ol><p>例句:We need to systematically analyze all the data. 我们需要系统地分析所有数据。</p><ol><li>有条理地,有步骤地</li></ol><p>例句:He systematically went through all the possible solutions. 他有条不紊地检查了所有可能的解决方案。</p><ol><li>有计划地,有组织地</li></ol><p>例句: The manager systematically arranged all the tasks. 经理有组织地安排了所有任务。</p><ol><li>从根本上,彻底地</li></ol><p>例句: We must systematically change how things are done. 我们必须从根本上改变做事的方式。</p><ol><li>不断重复地,习以为常地</li></ol><p>例句: She was systematically abused by her partner. 她不断遭到伴侣的虐待。</p><p>综上,systematically 意思是按照预定的系统、计划或方法进行,做事有条理和组织,而不是碎片化和随意进行。</p><hr><p><em>bias偏见,偏心，倾斜；pernicious有害的，具有负面破坏性的；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171503468.png" alt="image.png"></p><p><em>strikes 击中，罢工，罢课；health care 医疗保健；pension退休金，养老金<br>median中位数，中线，中间值；household家庭，户，住户</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171558168.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p><em>endure忍受；agency机构；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171614940.png" alt="image.png"></p><blockquote><p>!!!</p></blockquote><p>essence 的意思是:</p><ol><li>本质;实质;真谛<br>例句:The essence of his argument is that we need to focus on education. 他论点的真谛是我们需要关注教育。</li><li>精华;精髓;灵魂<br>例句:She has captured the essence of the book in her summary. 她在摘要中抓住了这本书的精髓。</li><li>(植物、化学品等的)香精;香料;香气<br>例句:This perfume contains floral essences. 这种香水含有花香精华。</li></ol><p>essential 的意思是:</p><ol><li>基本的;本质的;必不可少的<br>例句:Water is essential to human life. 水对人类生命至关重要。</li><li>不可或缺的;必需的<br>例句:An engineer needs an essential understanding of math. 工程师需要必不可少的数学知识。</li><li>香精;香精油</li></ol><hr><p><em>race种族；admission 接纳，录取；essential基本的，本质的；recrut招聘，征招 ；surrogates替代品；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307171638065.png" alt="image.png"></p><h1 id="阅读强化"><a href="#阅读强化" class="headerlink" title="阅读强化"></a>阅读强化</h1><h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><p><em><code>词汇体现观点</code></em></p><p><em>词汇体现观点、态度<br>stand in favor of sth 支持某事<br>Unfavorable 不支持<br>Lame 跛脚的<br>Ignore 忽视<br>Ignorant 无知的<br>sustainable 可持续的  sustain持续，连续不断<br>alleviate 缓解<br>aggravate 恶化<br>Lost 失去</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181112122.png" alt="image.png"><br><em>the Federal Court 联邦法院 、annually每年的、 is overturned 被推翻、<br>the supreme court 最高法院、 profit利润</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181117962.png" alt="image.png"></p><hr><p><em><code>如何寻找文章的中心对象？</code></em></p><p><em>题目一定是围绕中心对象展开—&gt;所以，找题目中心对象</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181126215.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181127934.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>rail 铁路、fare票价，车票、nationalizaion 国有化、revenue收入、ever-rising</em><br><em>ever-rising 在句子中的意思是“不断上升的;持续增长的”。它由ever和rising两个词组成。<br>ever 有“永远地”的意思。<br>rising 的现在分词形式,有“上升的;增长的”的意思。<br>将ever和rising组合起来,ever-rising就是一个复合形容词,表示某人或某事“不断上升;持续增长”的状态或趋势。</em><br><em>inflation膨胀、通货膨胀</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181145002.png" alt="image.png"></p><p>*collapse 的常见意思有:</p><ol><li>崩溃,倒塌<br>例句:The old building collapsed after the earthquake.<br>这座老房子在地震后倒塌了。</li><li>衰竭,崩溃<br>例句:The company is in danger of financial collapse.<br>这家公司有财务崩溃的危险。</li><li>折叠,收拢<br>例句:The chair can collapse for easy storage.<br>这把椅子可以折叠起来以便储存。</li><li>体力衰竭<br>例句:The runner collapsed from exhaustion midway through the race.<br>这位运动员在比赛中途由于体力透支而倒下。</li><li>瓦解,分崩离析<br>例句:The alliance between the two countries collapsed.<br>两个国家之间的联盟已瓦解。<br>综上所述,collapse 表示由于各种原因导致的崩溃、倒塌或瓦解的状态。*</li></ol><p><em>commuter 乘务员、compensation补偿，赔偿</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181149134.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>townsfolk 城市里的居民、 imitate模仿、tourism旅游业、Cadtle城堡</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181204822.png" alt="image.png"></p><h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><p><em>discrimination歧视、condemn谴责、insidious隐藏的，潜在的、alphabetism字母表主义、</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181347279.png" alt="image.png"></p><p>overlooked 的意思是“忽视,疏忽”。它是动词 overlook 的过去分词和过去式。<br>下面几个例句可以帮助理解它的意思:</p><ol><li>The teacher overlooked several mistakes in my essay.<br>老师在我的文章中忽视了几处错误。</li><li>Sorry, I overlooked your text message yesterday.<br>不好意思,我昨天忽略了你的短信。</li><li>The security guard overlooked the suspicious person entering the building.<br>安保人员疏忽了那个可疑人物进入大楼。</li><li>Her contributions were often overlooked by her colleagues.<br>她的贡献常常被同事们忽视。</li><li>In his haste, he overlooked a few important details.<br>他匆忙中忽略了几个重要细节。</li><li>The producer apologized for having overlooked the young actor’s talent.<br>制片人为忽视了那位年轻演员的天赋而道歉。<br>综上所述,overlooked 表示注意力不集中导致未注意或忽略某事物、某人的状态或行为,常与动词忽视、疏忽、未注意等意思相对应。</li></ol><p><em>conspicuous 明显的，引人注目的 、prejudice偏见，成见</em></p><p><strong>出现illustrate，is mentioned等等都是举例说明，不是对中心对象的说明 </strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181352977.png" alt="image.png"></p><p><em>subtle微妙的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181357709.png" alt="image.png"></p><p><em>ill-treated虐待</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181401359.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p><em>is comparable to相当于…  、legitimate合法的、正当的、<br>illegal, illegitimate不合法的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181421451.png" alt="image.png"></p><p><em>is quoted to被引用来说明…  、Constitution宪法、interpretation解释，阐释<br>alter 改变，更改 、implement执行、实施、实现、violate违反规则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181426235.png" alt="image.png"></p><blockquote><p>__</p></blockquote><p>diminishing 的意思是“逐渐减少的”,是动词diminish的进行时和过去分词形式。<br>下面几个例句可以帮助理解diminishing的意思:</p><ol><li>The diminishing food supplies posed a threat to the shipwrecked sailors.<br>不断减少的食物供应给那些遇难船员带来了威胁。</li><li>There has been a diminishing number of wildlife in the area due to habitat loss.<br>由于栖息地丧失,该地区的野生动物数量在不断减少。</li><li>His diminishing eyesight made it difficult for him to read.<br>他逐渐衰弱的视力使阅读变得艰难。</li><li>The diminishing sunlight signaled the coming of winter.<br>阳光逐渐减弱,标志着冬季的到来。</li><li>She felt a diminishing desire to socialize with friends.<br>她感到社交的欲望在不断减退。<br>综上所述,diminishing 指 etwas在不断减少或缩小,表示从更多到更少的过程或趋势。与increase, enhance等词义相反。</li></ol><p><em>asset资产财产 、deminish逐渐减少</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181434016.png" alt="image.png"></p><p><em>evade 逃避 、peer同龄人、reform改革、misinterpreted曲解、neglect忽略，忽视 、skepticism怀疑态度、怀疑主义</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181435621.png" alt="image.png"></p><h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><blockquote><p><em>细节题，注意词，细节</em></p></blockquote><p><em>partly 部分地、construction建设，构建、transparancy透明度、公开性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192245188.png" alt="image.png"></p><hr><blockquote><p><em>态度题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192251461.png" alt="image.png"></p><blockquote><p><em>例证题</em></p></blockquote><p><em>Toyota Motor 丰田汽车 、demonstrate展示，证明</em></p><p><em>limbic 的意思是“边缘的,边界的”,来源于解剖学术语,常用来形容脑内负责情绪和记忆的结构区域。<br>limbic system 边缘系统,指大脑内边缘部位的一组核团和神经纤维,控制情感反应和本能行为。<br>limbic cortex 边缘皮层,大脑边缘区域的组织。<br>limbic lobe 边缘小叶,位于大脑半球内侧的一部分,与情绪和记忆相关。<br>limbic brain 边缘脑,主管情感反应和本能的脑区。<br>综上所述,limbic 在解剖学上专门用来指代大脑内与情绪和本能相关的结构,因为这些结构位于大脑的边缘区域。它与理性思考和认知判断相对,更多与情感和直觉相关。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192253419.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192258586.png" alt="image.png"></p><blockquote><p><em>词汇题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211010386.png" alt="image.png"></p><blockquote><p><em>推理题</em></p></blockquote><p><em>当题目中没有给出定位信息的时候，，需要主动定位，70%来自段落首句</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211014882.png" alt="image.png"></p><p><em>search agent 搜索代理程序或者搜索机器人、negotiate谈判、磋商</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211024090.png" alt="image.png"></p><blockquote><p><em>主题题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211032732.png" alt="image.png"></p><h2 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h2><blockquote><p><em>比对</em></p></blockquote><p><em>选项和答案来源比对,先根据题目细节定位到句子，再根据名词一定会重现，动词替换原则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211036300.png" alt="image.png"></p><p><em>关于定位和比对的专项训练—细节题的定位和比对</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211039422.png" alt="image.png"></p><p><em>sustained 的意思是“持续的,不间断的”,是动词sustain的过去式和过去分词。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211043870.png" alt="image.png"></p><p><em>levy ,tax 税、 impose强制施加，征收税、platform站台，月台、apply primarily主要适用于… 、multinational跨国的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211051386.png" alt="image.png"></p><p><em>出现两个名词，可能要考虑两个名词需要用相近的次替换</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211104367.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> english </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>acdemic_gpt添加slack-Claude模型</title>
      <link href="/undefined/6ca9ded9.html"/>
      <url>/undefined/6ca9ded9.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191209443.png" alt="image.png"></p><h1 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h1><hr><p>&gt;</p><ul><li>从GitHub仓库中获取acdemic_gpt</li><li>创建Slack工作区，并添加claude在工作区中</li></ul><h1 id="Slack-Token"><a href="#Slack-Token" class="headerlink" title="Slack Token"></a>Slack Token</h1><hr><p>1.新建一个Slack APP  <a href="https://api.slack.com/apps">传送入口</a></p><p>2.将输入app名称(随意)，并选择自己的workspace<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072326471.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072327289.png" alt="image.png"></p><p>3.创建后点击我们的APP,然后点击左侧栏的<code>OAuth &amp; Permissions</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072329704.png" alt="image.png"></p><p>4.下拉找到 <strong>Scopes</strong>，为我们的 User Token 添加 Scope</p><ul><li><code>channels:history</code></li><li><code>channels:write</code></li><li><code>chat:write</code></li><li><code>im:history</code></li><li><code>im:write</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331212.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072331915.png" alt="image.png"></p><p>5.然后将APP安装到我们的workspace中，安装好之后这里就会显示<code>User OAuth Token</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072335186.png" alt="image.png"></p><h1 id="Claude-Bot-ID"><a href="#Claude-Bot-ID" class="headerlink" title="Claude Bot ID"></a>Claude Bot ID</h1><hr><p>1.进入Slack应用页面，找到我们的 Claude 应用，右击然后选择查看应用详情，复制 Claude 的成员 ID<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072338610.png" alt="image.png"></p><h1 id="配置acdemic-gpt中的config-py"><a href="#配置acdemic-gpt中的config-py" class="headerlink" title="配置acdemic_gpt中的config.py"></a>配置acdemic_gpt中的config.py</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将前面两步获取到的token和ID 分别填入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072340498.png" alt="image.png"></p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><hr><p><code>1.批处理文件一键启动main.py</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">set python_path=&quot;python绝对路径&quot;</span><br><span class="line">set script_path=&quot;main.py文件绝对路径&quot;</span><br><span class="line">%python_path% %script_path%</span><br></pre></td></tr></table></figure><br>最后将文件后缀改为<code>.bat</code></p><p><code>2.promt提示词</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">你是一个专家级ChatGPT提示工程师，在各种主题方面具有专业知识。在我们的互动过程中，你会称我为（yourname)。让我们合作创建最好的ChatGPT响应我提供的提示。</span><br><span class="line">我们将进行如下交互：</span><br><span class="line">1.我会告诉你如何帮助我。</span><br><span class="line">2.根据我的要求，您将建议您应该承担的其他专家角色，除了成为专家级ChatGPT提示工程师之外，以提供最佳响应。然后，您将询问是否应继续执行建议的角色，或修改它们以获得最佳结果。</span><br><span class="line">3.如果我同意，您将采用所有其他专家角色，包括最初的Expert ChatGPT Prompt Engineer角色。</span><br><span class="line">4.如果我不同意，您将询问应删除哪些角色，消除这些角色，并保留剩余的角色，包括专家级ChatGPT Prompt工程师角色，然后再继续。</span><br><span class="line">5.您将确认您的活动专家角色，概述每个角色下的技能，并询问我是否要修改任何角色。</span><br><span class="line">6如果我同意，您将询问要添加或删除哪些角色，我将通知您。重复步骤5，直到我对角色满意为止。</span><br><span class="line">7如果我不同意，请继续下一步。</span><br><span class="line">8.你会问：“我怎样才能帮助[我对步骤1的回答]？</span><br><span class="line">9.我会给出我的答案。</span><br><span class="line">10.你会问我是否想使用任何参考来源来制作完美的提示。</span><br><span class="line">11.如果我同意，你会问我想使用的来源数量。</span><br><span class="line">12.您将单独请求每个来源，在您查看完后确认，并要求下一个。继续，直到您查看了所有源，然后移动到下一步。</span><br><span class="line">13.您将以列表格式请求有关我的原始提示的更多细节，以充分了解我的期望。</span><br><span class="line">14.我会回答你的问题。</span><br><span class="line">15.从这一点开始，您将在所有确认的专家角色下操作，并使用我的原始提示和步骤14中的其他细节创建详细的ChatGPT提示。提出新的提示并征求我的反馈。</span><br><span class="line">16.如果我满意，您将描述每个专家角色的贡献以及他们将如何协作以产生全面的结果。然后，询问是否缺少任何输出或专家。</span><br><span class="line">16.1.如果我同意，我将指出缺少的角色或输出，您将在重复步骤15之前调整角色。</span><br><span class="line">16.2.如果我不同意，您将作为所有已确认的专家角色执行提供的提示，并生成步骤15中概述的输出。继续执行步骤20.</span><br><span class="line">17如果我不满意，你会问具体问题的提示。</span><br><span class="line">18.我将提供补充资料。</span><br><span class="line">19.按照步骤15中的流程生成新提示，并考虑我在步骤18中的反馈。</span><br><span class="line">20.完成回复后，询问我是否需要任何更改。</span><br><span class="line">21.如果我同意，请请求所需的更改，参考您之前的回复，进行所需的调整，并生成新的提示。重复步骤15-20，直到我对提示符满意为止。如果你完全理解你的任务，回答：&quot;我今天能帮你什么，(your name)&quot;</span><br></pre></td></tr></table></figure></p><p><code>3.ppt生成promt</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">帮我制作一篇内容关于这篇文章的PPT，要求如下： </span><br><span class="line">第一、一定要使用中文。 </span><br><span class="line">第二、页面形式有3种，封面、目录、列表。 </span><br><span class="line">第三、目录页要列出内容大纲。 </span><br><span class="line">第四、根据内容大纲，生成对应的PPT列表页，每一页PPT列表页内容使用“=====列表=====”作为开头。 </span><br><span class="line">第五、封面页格式如下： =====封面===== # 主标题 ## 副标题 演讲人：我的名字 </span><br><span class="line">第六、目录页格式如下： =====目录===== # 目录 ## CONTENT 1、内容 2、内容 </span><br><span class="line">第七、列表页格式如下： =====列表===== # 页面主标题 1、要点1 要点描述内容 </span><br><span class="line">第八、列表页里的要点描述内容是对要点的详细描述，10个字以上，50个字以内。 </span><br><span class="line">第九、请用代码块回复你生成的内容。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/undefined/e255a10a.html"/>
      <url>/undefined/e255a10a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191213404.png" alt="image.png"></p><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="认识计算机网络"><a href="#认识计算机网络" class="headerlink" title="认识计算机网络"></a>认识计算机网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip池由因特网管理机构管理</span><br><span class="line">ISP给用户提供网络连接服务，首先会向ip池要一个网段的ip地址，然后分配各用户</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031906978.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031907593.png" alt="image.png"></p><h2 id="计算机网络的组成与分类"><a href="#计算机网络的组成与分类" class="headerlink" title="计算机网络的组成与分类"></a>计算机网络的组成与分类</h2><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><blockquote><p><code>组成成分</code></p><ul><li>硬件</li><li>软件</li><li>协议</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议是规定这些数据如何封装、打包、传输</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032217848.png" alt="image.png"></p><hr><blockquote><p><code>工作方式</code></p><ul><li>边缘部分</li><li>核心部分</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">边缘部分端对端之间的通信：</span><br><span class="line">- 是指进程与进程之间的通信，例如QQ进程发消息，另一端QQ进程接收消息</span><br><span class="line">两个端系统之间的进程通信包括三种方式：</span><br><span class="line">- C/S: </span><br><span class="line">Client(客户)/Server(服务器)--&gt;描述两个端系统之间的进程呈现服务与被</span><br><span class="line">服务的关系; 例如：使用微信发消息--&gt;腾讯服务器--&gt;另一个接收者 ;由于资</span><br><span class="line">源有限同时发消息的人越多(访问服务的人越多)，速度越慢</span><br><span class="line">- B/S</span><br><span class="line">Browser(浏览器)/Server(服务器) --&gt;与C/S方式类似，不同在于C/S方式主</span><br><span class="line">要指下载一些app客户端，在客户端上进行进程通信; 而B/S是直接在浏览器上</span><br><span class="line">与服务端进行通信</span><br><span class="line">- P2P</span><br><span class="line">pear to pear(对等的连接) --&gt; 端系统之间是对等的，互相之间可以即是服</span><br><span class="line">务端又是客户端; 我在下载的同时又能为其他主机提供资源文件 所以P2P环境</span><br><span class="line">当中，下载的主机越多，获取文件速度越快.这与C/S刚好是相反的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032225064.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032239505.png" alt="image.png"></p><hr><blockquote><p>功能组成</p><ul><li>通信子网</li><li>资源子网</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">通信子网: 各种传输介质、通信设备、相应的网络协议组成(把公路铺好，把数据送上路)</span><br><span class="line">- 物理层: 集线器、中继器</span><br><span class="line">- 数据链路层: 交换机、网桥</span><br><span class="line">- 网络层: 路由器</span><br><span class="line">传输层--&gt;起呈上起下作用</span><br><span class="line">资源子网: 实现资源共享的设备和软件的集合(对数据进行封装处理)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032211061.png" alt="image.png"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">计算机网络按区域分类：</span><br><span class="line">- WAN :广域网 --&gt;交换技术 --&gt;通过路由器等中间设备，对数据进行转发存储一</span><br><span class="line">       点点交换出去.</span><br><span class="line">- MAN :城域网</span><br><span class="line">- LAN :局域网 --&gt;广播技术 </span><br><span class="line">- PAN :个人区域网</span><br><span class="line">按使用者分类：</span><br><span class="line">- 公用网: 国有或私有出资建造的大型网络，例如中国电信、联通、移动..</span><br><span class="line">- 专用网: </span><br><span class="line">按交换技术分类：</span><br><span class="line">- 电路交换：</span><br><span class="line">就像打电话,建立连接(开始占用这条资源)--&gt;进行通话(持续占用)--&gt;挂掉电</span><br><span class="line">话(释放链路资源);有以上3个步骤的交换技术就叫做电路交换</span><br><span class="line">- 报文交换：</span><br><span class="line"> 运用存储转发,A想与B通信，首先A发送数据到路由器(路由器先存储数据)，</span><br><span class="line"> 然后再由路由器(选择最快的路径)将数据转发到B;这种交换技术是一段一段</span><br><span class="line"> 的占用链路，不像电路交换持续占用着链路资源</span><br><span class="line">- 分组交换</span><br><span class="line">与报文交换类似，都是采用存储转发</span><br><span class="line">按拓扑结构分：</span><br><span class="line">- 总线型</span><br><span class="line">- 星型</span><br><span class="line">- 环型</span><br><span class="line">- 网状型</span><br><span class="line">按传输技术分：</span><br><span class="line">- 广播式网络：共享公共通信信道--&gt;常采用总线型拓扑结构--&gt;当其中一台计算机</span><br><span class="line">  发出报文分组其他计算机都能收到报文分组</span><br><span class="line">- 点对点网络：使用分组存储转发和路由选择机制 --&gt;发出的信息只有发送目标能收到</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032329031.png" alt="image.png"></p><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">是一种平均来看的标准</span><br><span class="line">注意对于速率：</span><br><span class="line">1M=10^3k=10^6</span><br><span class="line">对于容量：</span><br><span class="line">1M=2^10K=2^20</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032351270.png" alt="image.png"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">带宽是指单位时间内往链路当中“注入”的数据量</span><br><span class="line">比如1us我可以注入3bit数据、也可以注入2bit数据...相当于河的最大宽度</span><br><span class="line">但是数据在链路当中传播的速度始终是不变的--&gt;这就导致相同时间数据到达另一端的量</span><br><span class="line">不同(注意这个量是指同一时刻到达的数据量的不同)--&gt;类比于河越宽，能运送的水越多</span><br><span class="line">--&gt;带宽描述的是一种最大承受能力，并不是实际的承受能力</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306032359509.png" alt="image.png"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际数据发送量，带宽为100MB/s,是指链路最大能承受100的数据量;实际吞吐量30MB/s是指实际来往的数据只有30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041049856.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">带宽是理想状况下数据传送速率——假设一个人理想状态下能每秒吃10个鸡蛋</span><br><span class="line"></span><br><span class="line">吞吐量是某一个时间点通过某个网络的传输速度——在鸡蛋只有5个的情况，实际上每秒只吃5个鸡蛋</span><br><span class="line"></span><br><span class="line">速率在我的理解上更整体——相当于汽车从A到B的平均速度</span><br><span class="line"></span><br><span class="line">- 带宽（理想状况下数据传送速率）</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个人数学有考140分的能力</span><br><span class="line"></span><br><span class="line">- 吞吐量是某一个时间点通过某个网络的传输速度</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">但是在一次月考中由于试卷满分不是150而是100，所以只考了94分</span><br><span class="line"></span><br><span class="line">- 速率</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">一个学期下来，考试数学单科平均分为124分</span><br></pre></td></tr></table></figure><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">发送时延：</span><br><span class="line">- 假如有一串20bit数据，需要一个一个送到信路上，假如带宽=10b/s(往信道注入</span><br><span class="line">10bit信息需要1s),那么发送时延=20/10=2s; </span><br><span class="line">- 注意：实际是达不到带宽那么理想的发送速率，但是做题就以带宽为准</span><br><span class="line">传播时延：</span><br><span class="line">取决于电磁波传播速度和链路长度</span><br><span class="line">排队时延：</span><br><span class="line">一串数据发送到路由器会在路由器口出的缓冲区先排队等待，这段等待处理的时间</span><br><span class="line">被称为排队时延</span><br><span class="line">处理时延：</span><br><span class="line">当数据排队结束被路由器处理转发，需要进行一系列的检错和找出口，这段时间被</span><br><span class="line">称为处理时延</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041118637.png" alt="image.png"></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时延带宽积</span><br><span class="line">描述此时链路当中有多少bit--&gt;也可以称为此链路的容量是多少</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041120590.png" alt="image.png"></p><h3 id="RTT往返时延"><a href="#RTT往返时延" class="headerlink" title="RTT往返时延"></a>RTT往返时延</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RTT：</span><br><span class="line">- 发送第一个bit开始到接收方接收到第一个bit并传回确认信息总共经历的时延</span><br><span class="line">ping [域名]/[ip] --&gt; 检测往返时延</span><br><span class="line">- RTT只关注信道传输时延，不关注发送时延</span><br><span class="line">- 1RTT=2倍的传播时延</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041159393.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041201870.png" alt="image.png"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306041205434.png" alt="image.png"></p><h2 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构-协议-接口-服务"></a>分层结构-协议-接口-服务</h2><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042013894.png" alt="image.png"></p><h3 id="怎么分层？"><a href="#怎么分层？" class="headerlink" title="怎么分层？"></a>怎么分层？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实体：每层要进行处理的数据单元</span><br><span class="line"></span><br><span class="line">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</span><br><span class="line"></span><br><span class="line">服务：</span><br><span class="line"></span><br><span class="line">接口：</span><br><span class="line"></span><br><span class="line">SDU：服务数据单元</span><br><span class="line"></span><br><span class="line">PCI：协议控制信息</span><br><span class="line"></span><br><span class="line">PDU：协议数据单元</span><br><span class="line">上一层的SDU+PCI组装成的PDU,称为下一层的SDU,嵌套包装</span><br><span class="line"></span><br><span class="line">网络体系结构是从功能上描述计算机网络结构。</span><br><span class="line">计算机网络体系结构简称网络体系结构是分层结构。</span><br><span class="line">每层遵循某个/些网络协议以完成本层功能。</span><br><span class="line">计算机网络体系结构是计算机网络的各层及其协议的集合。</span><br><span class="line">第n层在向n+I层提供服务时，此服务不仅包含第n层本身的功能，还包含由下层服务提供的功能。</span><br><span class="line">仅仅在相邻层间有接口，且所提供服务的具体实现细节对上一层完全屏蔽。</span><br><span class="line">体系结构是抽象的，而实现是指能运行的一些软件和硬件。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042018579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042022785.png" alt="image.png"></p><h2 id="计算机网络分层结构"><a href="#计算机网络分层结构" class="headerlink" title="计算机网络分层结构"></a>计算机网络分层结构</h2><hr><h3 id="ISO-OSI参考模型"><a href="#ISO-OSI参考模型" class="headerlink" title="ISO/OSI参考模型"></a>ISO/OSI参考模型</h3><h4 id="ISO-OSI参考模型由来"><a href="#ISO-OSI参考模型由来" class="headerlink" title="ISO/OSI参考模型由来"></a>ISO/OSI参考模型由来</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">计算机网络分层结构：</span><br><span class="line">- 7层OSI参考模型</span><br><span class="line">法定标准</span><br><span class="line">- 4层TCP/IP参考模型</span><br><span class="line">事实标准，因为实际上用这种结构比较多效果比较好，用户体验也很好，所以就为了</span><br><span class="line">事实标准</span><br><span class="line">- 5层体系结构：</span><br><span class="line">这种结构是为了学习计算机网络更方便</span><br><span class="line">为什么要推出OSI参考模型?</span><br><span class="line">起初由于网络分层结构种类多，不统一，无法实现互联互通，于是为了解决这个问题，推</span><br><span class="line">出ISO参考模型，用于支持&quot;异构网络系统&quot;的互联互通</span><br><span class="line">最后OSI为什么失败了？</span><br><span class="line">因为OSI太理想化了，没考虑实际市场应用场景，比如实现起来太复杂、运行效率太低..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042039410.png" alt="image.png"></p><h4 id="ISO-OSI参考模型解释通信过程"><a href="#ISO-OSI参考模型解释通信过程" class="headerlink" title="ISO/OSI参考模型解释通信过程"></a>ISO/OSI参考模型解释通信过程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上四层是端对端加密，中间经过中间系统不会被解析</span><br><span class="line">下三层是点对点加密，中间经过中间系统会分拆包，然后再装包送给下一个系统</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042056217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042103847.png" alt="image.png"></p><h4 id="ISO-OSI各分层结构及其协议"><a href="#ISO-OSI各分层结构及其协议" class="headerlink" title="ISO/OSI各分层结构及其协议"></a>ISO/OSI各分层结构及其协议</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081541320.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">应用层:</span><br><span class="line">- 所有能和用户交互产生网络流量的程序;就是指qq这种需要联网才能使用的应用程序，</span><br><span class="line">但是记事本这种不需要联网的就不属于应用层</span><br><span class="line">- 应用层常见服务：</span><br><span class="line">1.文件传输(FTP)</span><br><span class="line">2.电子邮件(SMTP)</span><br><span class="line">3.万维网(HTTP)</span><br><span class="line">...</span><br><span class="line">表示层: (加密解密、格式转换)</span><br><span class="line">- 用于处理两个通信系统中交换信息的表达方式(语义语法)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.数据格式转换：二进制码--&gt;图片</span><br><span class="line">2.数据加密通信</span><br><span class="line">3.数据压缩和恢复</span><br><span class="line">会话层: (建立会话)</span><br><span class="line">- 向表示层/用户进程建立会话连接，并在连接上有序传输数据，也叫建立同步</span><br><span class="line">  (SYN)</span><br><span class="line">- 主要功能：</span><br><span class="line">1.建立、管理、终止会话</span><br><span class="line">2.使用校验点可是会话在断开后，重新连接时，在校验点处恢复通信(下载</span><br><span class="line">app，网络断开，重新连接上后能继续从断点处下载)</span><br><span class="line"></span><br><span class="line">传输层: (端对端通信,将数据封装成报文)</span><br><span class="line">- 负责两个主机中两个进程之间的通信，即端对端的通信。传输单位是报文段或用</span><br><span class="line">  户数据报</span><br><span class="line">- 主要功能：</span><br><span class="line">1.可靠传输、不可靠传输</span><br><span class="line">- 可靠传输：</span><br><span class="line">传输比较大的文件，分一小段一小段发送，当发完前一段，接收方返</span><br><span class="line">回确认信息后，才会发送下一段内容；如果没有接收到确认信息，那</span><br><span class="line">么会一直发送当前段消息，直到接收到确认信息。</span><br><span class="line">- 不可靠传输：</span><br><span class="line">传输很小的数据包时，比如一段文字，只需要直接丢出去就可以，无</span><br><span class="line">需确认这样可以节约时间</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制</span><br><span class="line">控制发送方发送的速度，如果接收方来不及接收，发送方就会减缓发送速</span><br><span class="line">度</span><br><span class="line">4.复用分用</span><br><span class="line">- 复用：</span><br><span class="line">是指多个进程会同时使用下面运输层的服务，比如qq和微信，同时发</span><br><span class="line">消息，qq的消息和微信的消息会一起混合在一起运输出去</span><br><span class="line">- 分用：</span><br><span class="line">混在在一起的报文，为了区分分别是发送到哪些进程，会用端口号进</span><br><span class="line">行区分，例如请qq的消息端口号是1，接收方端口号1的进程(qq)接</span><br><span class="line">收该条消息；微信端口号2，接收方端口号2的进程(微信)接受该条消</span><br><span class="line">息</span><br><span class="line">5.拥塞控制</span><br><span class="line">       - 传输层协议</span><br><span class="line">       1.TCP</span><br><span class="line">       2.UDP</span><br><span class="line">网络层：(路由选择,将报文分组)</span><br><span class="line">- 主要任务是将&quot;分组&quot;从源端传导目的端,为分组交换网上的不同主机提供通信服</span><br><span class="line">   务，网络层传输单位是&quot;数据报&quot; </span><br><span class="line">- 分组与数据报的关系？</span><br><span class="line">当数据报过长时，就会被切割为一小块的一小块的分组</span><br><span class="line">- 主要功能：</span><br><span class="line">1.路由选择：</span><br><span class="line">选择合适的路由，结合实际情况选出最佳传输路径</span><br><span class="line">2.流量控制：</span><br><span class="line">协调发送端与与接收端的发送速度与传输层类似</span><br><span class="line">3.差错控制：</span><br><span class="line">通信两个结点之间约定一个规则例如奇偶校验之类的，接收方会根据规则</span><br><span class="line">进行对分组纠错，如果能纠错就纠错，不能纠错就扔掉(位错、帧错控制</span><br><span class="line">校验)</span><br><span class="line">4.拥塞控制：是一种全局的调控，与流量控制不同(只是控制收发方的流量速</span><br><span class="line">度)，而拥塞控制，是对所有线路可能产生的拥塞进行控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">数据链路层: </span><br><span class="line">- 主要任务是将自网络层传输过来的&quot;数据报&quot;组装成帧。传输单位是&quot;帧&quot;</span><br><span class="line">- 主要功能：</span><br><span class="line">1.成帧(定义帧的开始和结束)</span><br><span class="line">对于自网络层传来的数据(二进制数据)，定义几种数据是从分别是从哪里</span><br><span class="line">开始，到哪里结束(也就是定义帧的开始和结束)，进而对数据进行封装和</span><br><span class="line">解封装</span><br><span class="line">2.差错控制:位错、帧错控制校验</span><br><span class="line">3.流量控制：发送方速度过快或过慢，可以减慢或加速发送速度</span><br><span class="line">4.控制对信道的访问</span><br><span class="line">物理层:</span><br><span class="line">- 主要任务是在物理媒体上实现比特流的透明传输；透明传输是指任何的比特组合</span><br><span class="line">都可在链路上传输</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042118421.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042117862.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042123612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042209477.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042239380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306042313547.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052053114.png" alt="image.png"></p><h3 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h3><h4 id="TCP-IP参考模型与OSI的区别"><a href="#TCP-IP参考模型与OSI的区别" class="headerlink" title="TCP/IP参考模型与OSI的区别"></a>TCP/IP参考模型与OSI的区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP/IP协议栈：</span><br><span class="line">该协议栈因为TCP IP 协议占大头所以取名为TCP/IP协议栈</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071548418.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OSI参考模型与TCP/IP参考模型相同点与不同点</span><br><span class="line">相同点：</span><br><span class="line">1.都分层</span><br><span class="line">2.基于独立的协议栈的概念</span><br><span class="line">3.可以实现异构网络互连</span><br><span class="line">不同点：</span><br><span class="line">1.OSI定义三点：服务、协议、接口</span><br><span class="line">2.OSI先出现，参考模型先于协议发明，不偏向特定的协议</span><br><span class="line">3.TCP/IP设计之初就考虑到异构网络互通问题，将IP作为重要层次</span><br><span class="line">4.两个参考模型在网络层和传输层的连接方式有区别</span><br><span class="line">- TCP/IP：</span><br><span class="line">- 网络层：无连接</span><br><span class="line">- 传输层：无连接+面向连接</span><br><span class="line">- IOS/OSI：</span><br><span class="line">- 网络层：无连接+面向连接</span><br><span class="line">- 传输层：面向连接</span><br><span class="line">什么是无连接和面向连接？</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071554299.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071558282.png" alt="image.png"></p><h3 id="5层参考模型"><a href="#5层参考模型" class="headerlink" title="5层参考模型"></a>5层参考模型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071609415.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071611581.png" alt="image.png"></p><h2 id="计算机网络结构分层汇总"><a href="#计算机网络结构分层汇总" class="headerlink" title="计算机网络结构分层汇总"></a>计算机网络结构分层汇总</h2><div class="table-container"><table><thead><tr><th style="text-align:center"><nobr><font size="2">OSI七层模型</font></nobr></th><th style="text-align:center"><nobr><font size="2">TCP/IP概念模型</font></nobr></th><th style="text-align:center"><font size="2"> 功能</font></th><th style="text-align:center"><font size="2"><nobr>TCP/IP协议族</nobr></font></th></tr></thead><tbody><tr><td style="text-align:center"><font size="2">应用层 </font><td rowspan="3"><font size="2"><center>应用层</center></font></td></td><td style="text-align:center"><font size="2"><nobr>文件传输、电子邮件、文件服务、虚拟终端</nobr></font></td><td style="text-align:center"><font size="2"><nobr>TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，BGP，DHCP</nobr></font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">表示层</font></td><td style="text-align:center"><font size="2"><nobr>数据格式化、代码转换、数据加密</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">会话层</font></td><td style="text-align:center"><font size="2"><nobr>解除或建立与别的接电的联系</nobr></font></td><td style="text-align:center"><font size="2">没有协议</font></td></tr><tr><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">传输层</font></td><td style="text-align:center"><font size="2">提供端对端接口</font></td><td style="text-align:center"><font size="2">TCP，UDP</font></td></tr><tr><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">网络层</font></td><td style="text-align:center"><font size="2">为数据报选择路由</font></td><td style="text-align:center"><font size="2">IP，ICMP，OSPF，ARP，IGMP</font></td></tr><tr><td style="text-align:center"><font size="2">数据链路层</font><td rowspan="2"><center><font size="2">链路层</font></center></td></td><td style="text-align:center"><font size="2">传输有地址的帧以及错误检测功能</font></td><td style="text-align:center"><font size="2">SLIP，CSLIP，PPP，ARP，RARP，NTU</font></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><font size="2">物理层</font></td><td style="text-align:center"><font size="2">以二进制数据形式在物理媒体上传输数据</font></td><td style="text-align:center"><font size="2">IS02110，IEEE802，IEEE802.2</font></td></tr></tbody></table></div><div style="background-color: #fffacd;padding:20px;"> <mark>什么是协议？</mark><li><font size="2">实体：每层要进行处理的数据单元</font></li><li><font size="2">协议：规定对对等层的实体，进行怎样的操作，这样就知道对一份数据进行怎样包装或拆包</font></li><br><mark>如何判断协议属于哪一层？</mark><br>答：根据封装关系；例如：<font color="#FF0000" size="3">BGP协议是应用层的协议使用UDP封装（使用的传输层的封装和传输服务），所以根据下层为上层提供服务的原则，判断该协议属于哪一层</font></div><div style="background-color: #fffacd;padding:20px;"> <mark>数据报与报文的区别？</mark><br>1.数据报(Datagram)<font size="3"><li> 网络层的数据传输单位,由源地址、目的地址、数据等组成。</li><li> 使用不可靠的网络层服务,以独立的形式传输。</li><li> 每个数据报都独立路由转发,不需要建立连接。</li><li> 使用的数据报协议典型如IP协议。</li><br></font>2. 报文(Message)<font size="3"><li>传输层的数据传输单位,由报头、正文组成。</li><li>使用面向连接的传输层服务,需要建立连接</li><li>对于同一连接的报文,必须按顺序逐一传输</li><li>使用的报文协议典型如TCP协议。</li></font><br><br><mark>为什么传输层UPP协议的数据传输单位也是数据报？</mark><br><font size="3">数据报(Datagram)是网络层的传输单位,但UDP作为一种无连接的传输层协议,其传输特性类似网络层,所以其数据传输单位也采用了数据报的形式。UDP和网络层都使用数据报作为传输单位,但UDP还有一些传输层的特性,如端口号、校验等。所以UDP使用数据报只是因为其无连接的传输特性类似网络层,但UDP仍属于传输层协议。</font></div><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><h3 id="计算机网路概述习题"><a href="#计算机网路概述习题" class="headerlink" title="计算机网路概述习题"></a>计算机网路概述习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.计算机网络无法脱离硬件设施，所以不仅仅是软件模块</span><br><span class="line">C.多个处理器通过内存共享实现的是多机系统，并不是计算机网络</span><br><span class="line">D.不仅是分布式系统，还涉及到资源的共享和信息的传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071614946.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交流是一切活动的前提</span><br><span class="line">所以计算机网络的最基本的功能是数据通信</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071622640.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">工作站和服务器都是高性能的计算机，但是两者侧重点不一样</span><br><span class="line">- 工作站：侧重工作时得高效性 ;主要进行数据运算和图像处理</span><br><span class="line">- 服务器：侧重强调稳定性 ; 主要进行后台服务</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071629192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络可以没有数据库管理系统</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071647734.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络是通过通信设备与线路(硬件设施)连接起来,由功能完善的软件实现资源共享和信息传递--&gt;所以计算机网络的资源主要指：硬件+软件+数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071651057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通信子网就是硬件设施--&gt;实现两个通信进程之间地址的连接</span><br><span class="line">资源子网就是软件--&gt;实现数据的交换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071656125.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071700097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071744046.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072037509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">传播时延2000/2x10^8=10^-5 s </span><br><span class="line">分组大小为100B</span><br><span class="line">带宽=100B/10us=10^7B/s=10MB/s=80Mb/s</span><br><span class="line">(注意B 是字节; b是bit;速率中1M=10^3k=10^6b)</span><br><span class="line">分组大小为512B</span><br><span class="line">带宽=512B/10us=512x10^5B/s=51.2MB/s=409.6Mb/s</span><br><span class="line">注意单位的换算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072048000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">就是传输层的可靠传输和不可靠性传输</span><br><span class="line">1.第一种分段传输，一段一段确认之后，在进行第二段的传输</span><br><span class="line">- 优点：出错后不需要从头开始，只传出错的分组</span><br><span class="line">- 缺点：速度慢，需要分割和拼接</span><br><span class="line">2.第二种一次性传输</span><br><span class="line">- 优点：速度较快，不用分割和拼接分组</span><br><span class="line">- 缺点：出错之后整个文件上传</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072109358.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">电路交换：</span><br><span class="line">建立一次连接，直通目标，无需经过中间的结点，只需考虑起始时的发送时延</span><br><span class="line">发送时延=x/b</span><br><span class="line">传播时延=kd</span><br><span class="line">建立交换电路的时间=s</span><br><span class="line">=&gt;总的交换时延=s+kd+x/b</span><br><span class="line">分组交换：</span><br><span class="line">分组交换经过中间k段电路，经过k个结点(包括起始结点)就需要进行k次发送；</span><br><span class="line">发送时延:</span><br><span class="line">第一个分组到达终点时，紧跟着的分组也到达倒数第二个结点</span><br><span class="line">因此只需考虑第一个分组的全程发送时延+剩下n-1个分组的一段发送时延</span><br><span class="line">=p/b*k + p/b(x/p-1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072135561.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072128988.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1).数据分组可以连续发送--&gt;所以数据就只有发送时延+传播时延+建立握手的时间</span><br><span class="line">    2RTT + 1000KB/1.5Mb/s + 1/2RTT </span><br><span class="line">(2).数据不是连续发送，发送完一个分组需要等待RTT(等待接收方确认传回来)</span><br><span class="line">    只有前999个分组需要等待确认传回，最后一个分组不需要(因为是最后一个分组)</span><br><span class="line">    所以999*(一个分组的发送时延+去的传播时延+确认的发送时延(题中为0)+回的传播时延)</span><br><span class="line">    + (最后一组的发送时延+去的传播时延) + 建立握手时间</span><br><span class="line">    2RTT + 999(1KB/1.5Mb/s + 1/2RTT + 0 + 1/2RTT) + 1KB/1.5Mb/s +1/2RTT</span><br><span class="line">(3).带宽无限大--&gt;发送时间=0 ;一次可以推送20个分组然后等待RTT才可以再发送20个分组</span><br><span class="line">    过程如下手写草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072232042.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072248619.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向字节流：</span><br><span class="line">以字节为单位，只能识别字节，假如A向B发送两个报文(每个报文1024B),B只知道收到了</span><br><span class="line">2048个字节，并不知道从哪个字节开始时第一个报文，从哪到哪是第二个报文</span><br><span class="line">面向报文流：</span><br><span class="line">以报文为单位，B能直到从哪个字节到哪个字节是第一个报文...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072301434.png" alt="image.png"></p><h3 id="计算机网络体系及参考模型习题"><a href="#计算机网络体系及参考模型习题" class="headerlink" title="计算机网络体系及参考模型习题"></a>计算机网络体系及参考模型习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306072311514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081507881.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081512488.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">上层使用下层服务是什么意思？</span><br><span class="line">上层的数据会放到下层,下层会为上层数据添加而额外信息(包括控制信息)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081524982.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因特网的发展：</span><br><span class="line">ARPAnet --&gt; internet --&gt;Internet</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081528643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">协议：</span><br><span class="line">约定相同层次的实体做相同的事</span><br><span class="line">接口：</span><br><span class="line">下层为上层提供的功能调用的入口</span><br><span class="line">服务：</span><br><span class="line">就是下层对上层提供的功能调用，上层使用下层服务</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081534882.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据连路程拥有寻址功能，物理寻址就是找到mac地址</span><br><span class="line">BC.数据链路层也拥有流量控制、差错控制</span><br><span class="line">D.数据链路层没有拥塞控制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081538425.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">每层封装加的信息：</span><br><span class="line">- 传输层: TCP头</span><br><span class="line">- 网络层: IP头</span><br><span class="line">- 数据链路层: MAC头 + FCS尾(数据帧)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081548702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A.数据链路层不仅在分组上增加了源物理地址和目的物理地址，还增加了控制信息</span><br><span class="line">B.网络层将高层协议产生的数据封装成分组，正确</span><br><span class="line">C.传输层将数据封装成数据报，并增加了可靠性和控制信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081559598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">①具有流量控制的有3层: 传输层、网络层、数据链路层</span><br><span class="line">②端到端连接(进程通信)的是: 传输层</span><br><span class="line">③数据分组提供路由选择功能的是: 网络层</span><br><span class="line">⑤为网络层实体提供数据发送和接收功能和过程的是: 数据链路层</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081608525.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081614105.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因特网采用的核心技术是TCP/IP协议</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081617710.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081640015.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">服务访问点SAP：就是上层使用下层服务的接口&quot;钥匙&quot;，只有拿到这把钥匙才能使用服务</span><br><span class="line">应用层SAP:用户界面</span><br><span class="line">传输层SAP:端口号</span><br><span class="line">网络层SAP:IP地址</span><br><span class="line">数据链路层SAP:MAC地址</span><br><span class="line">物理层SAP:网卡接口</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081646625.png" alt="image.png"></p><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222359598.png" alt="image.png"></p><blockquote><p>*物理层接口特性</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306222358559.png" alt="image.png"></p><hr><h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><h3 id="数据通信基础知识1"><a href="#数据通信基础知识1" class="headerlink" title="数据通信基础知识1"></a>数据通信基础知识1</h3><blockquote><p><em>典型的数据通信模型</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230004843.png" alt="image.png"></p><blockquote><p><em>数据通信相关术语</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230007417.png" alt="image.png"></p><blockquote><p><em>设计数据通信系统要考虑的3个问题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230010844.png" alt="image.png"></p><blockquote><p><em>单、半、全三种通信方式</em></p></blockquote><p><em>单工通信：一条单向的信道(一条信道同一时刻要么接收，要么发送)<br>半双工通信：两条单向的信道<br>全双工通信：两条双向的信道(一条信道同一时刻，可以同时发送和接收)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230009020.png" alt="image.png"></p><blockquote><p><em>串行与并行传输方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261729820.png" alt="image.png"></p><blockquote><p><em>同步传输与异步传输通信方式</em></p></blockquote><p><em>同步传输：传输数据是连续传输<br>异步传输：数据间间断断，传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306230018386.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261735457.png" alt="image.png"></p><h3 id="数据通信基础知识2"><a href="#数据通信基础知识2" class="headerlink" title="数据通信基础知识2"></a>数据通信基础知识2</h3><blockquote><p><em>码元</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307261959550.png" alt="image.png"></p><blockquote><p><em>速率、波特</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001158.png" alt="image.png"></p><blockquote><p><em>带宽</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262001622.png" alt="image.png"></p><h3 id="奈氏准则、香农定理"><a href="#奈氏准则、香农定理" class="headerlink" title="奈氏准则、香农定理"></a>奈氏准则、香农定理</h3><blockquote><p><em>奈氏准则</em></p></blockquote><ul><li><em>是在理想低通(无噪声、带宽受到限制)条件下，避免 <strong>码间串扰</strong>  确定的极限的码元的传输速率=2W Baud，所以极限 信息传输速率=2W ×n  （n是码元bit数，就是n进制码元）</em></li><li><em>W 表示带宽，单位Hz</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262100499.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262104722.png" alt="image.png"></p><blockquote><p><em>香农定理</em></p></blockquote><ul><li><em>是在带宽受限，且有噪声的信道中，规定的在该噪声条件下的，不影响码元判断的，极限数据传输速率</em></li><li><em>S/N是信噪比，常常用作10log10(S/N) 来进行转换，从而将单位记作dB,就是定义了一个转换数值的公式 </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262108690.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262114311.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262115670.png" alt="image.png"></p><blockquote><p><em>香农和奈氏</em></p></blockquote><ul><li><em>奈氏准则：关注的是无噪声条件下，不会造成码间串扰的极限 数据传输速率</em></li><li><em>香农定理：关注的是在当前噪声条件下，不会导致数据码元判断失真的 数据极限传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262120589.png" alt="image.png"></li></ul><h3 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h3><h4 id="基带信号与宽带信号"><a href="#基带信号与宽带信号" class="headerlink" title="基带信号与宽带信号"></a><em>基带信号与宽带信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262222235.png" alt="image.png"></p><h4 id="编码与调制-1"><a href="#编码与调制-1" class="headerlink" title="编码与调制"></a><em>编码与调制</em></h4><p><em>将数据 编码 /调制 —&gt;信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262223896.png" alt="image.png"></p><h4 id="数字数据编码为数字信号"><a href="#数字数据编码为数字信号" class="headerlink" title="数字数据编码为数字信号"></a><em>数字数据编码为数字信号</em></h4><blockquote><p><em>非归零编码</em></p></blockquote><p><em>缺点是，需要额外的信道，传输时钟周期信号，告诉多久发一个bit信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271044394.png" alt="image.png"></p><blockquote><p><em>归零编码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262237642.png" alt="image.png"></p><blockquote><p><em>反向不归零编码</em></p></blockquote><ul><li><em>缺点是，对于发送全1的信号，无法判断，有多少个1，因为，高低电平都有可能是1</em></li><li><em>还有就是，缺点在全1，的时候，会出现长条，没有时钟周期，就无法得知发送了，多少个1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307262234072.png" alt="image.png"></li></ul><blockquote><p><em>曼彻斯特编码</em></p></blockquote><ul><li><em>1bit数据，就是1码元，被调制成两段电平，所以数据传输速率只有调制速率的1/2</em></li><li><em>每个码元中间，有一次跳变，可以实现同步，可通过中间跳变反应时钟信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271051270.png" alt="image.png"></li></ul><blockquote><p><em>差分曼彻斯特编码</em></p></blockquote><ul><li><em>每个码元中间都有一次跳变，可以实现同步</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271059163.png" alt="image.png"></li></ul><blockquote><p><em>4B/5B编码</em></p></blockquote><ul><li><em>编码效率80%</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271101120.png" alt="image.png"></li></ul><h4 id="数字数据调制成模拟信号"><a href="#数字数据调制成模拟信号" class="headerlink" title="数字数据调制成模拟信号"></a><em>数字数据调制成模拟信号</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271105446.png" alt="image.png"></p><ul><li><em>采样频率要达到信号最高频率的2倍以上，以保证，可以在每一个最高频的信号峰之内都可以采样到2个信息，得到波峰图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271112992.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271114621.png" alt="image.png"></p><h4 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271138465.png" alt="image.png"></p><blockquote><p><em>1.电路交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271319318.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320037.png" alt="image.png"></p><blockquote><p><em>2.报文交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320009.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271320369.png" alt="image.png"></p><blockquote><p><em>3.分组交换</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321465.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271321976.png" alt="image.png"></p><blockquote><p><em>数据交换方式的选择</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271324239.png" alt="image.png"></p><blockquote><p><em>3.1.分组交换—数据报方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271325439.png" alt="image.png"></p><p><em>无连接服务，就是事先不为分组确定传输路径，传输路径全靠路由选择</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326584.png" alt="image.png"></p><blockquote><p><em>3.2分组交换—虚电路方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271326838.png" alt="image.png"></p><p><em>连接服务，就是事先要确定分组的传输路径，提前建立连接，然后再按照这个路径输送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327331.png" alt="image.png"></p><blockquote><p><em>虚电路与数据报方式的区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271327057.png" alt="image.png"></p><h2 id="传输介质-信道"><a href="#传输介质-信道" class="headerlink" title="传输介质(信道)"></a>传输介质(信道)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271453976.png" alt="image.png"></p><ul><li><em>传输媒体并不是物理层。传输媒体在物理层的下面，因为物理层是体系结构的第一层，因此有时称传输媒体为0层。</em></li><li><em>在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号代表什么意思。但物理层规定了 电 气 特 性，因此能够识别所传送的比特流</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271431578.png" alt="image.png"></li></ul><h3 id="导向性传输介质"><a href="#导向性传输介质" class="headerlink" title="导向性传输介质"></a><em>导向性传输介质</em></h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a><em>双绞线</em></h4><p><em>电流方向相反的铜线，绞合一起，磁感线相互抵消，减少相邻导线的电磁干扰</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271436145.png" alt="image.png"></p><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a><em>同轴电缆</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271440754.png" alt="image.png"></p><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a><em>光纤</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443295.png" alt="image.png"></p><blockquote><p><em>单模光纤和双模光纤</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271447411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271443816.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271448705.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449288.png" alt="image.png"></p><h3 id="非导向性传输介质"><a href="#非导向性传输介质" class="headerlink" title="非导向性传输介质"></a><em>非导向性传输介质</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271449201.png" alt="image.png"></p><h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><blockquote><p><em>中继器</em></p></blockquote><ul><li><em>中继器是对数字信号的再生(整形)</em></li><li><em>中继器是连接两个网段的桥梁，以助于数字信号的再生</em></li><li><em>中继器，只负责将数据发送到另一网段，不管数据中是否有错误</em></li><li><em>中继器两端可以连接相同传输介质，也可以不同传输介质</em></li><li><em>中继器两端网段一定要是统一协议</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271612539.png" alt="image.png"></p><blockquote><p><em>集线器</em></p></blockquote><p><em>集线器，可以连接多台主机，平分带宽，共享数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271616925.png" alt="image.png"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="链路层的功能"><a href="#链路层的功能" class="headerlink" title="链路层的功能"></a>链路层的功能</h2><blockquote><p><em>数据链路层基本概念</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271636246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271637260.png" alt="image.png"></p><blockquote><p><em>功能概述</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639722.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271639736.png" alt="image.png"></p><h3 id="封装成帧-amp-透明传输"><a href="#封装成帧-amp-透明传输" class="headerlink" title="封装成帧&amp;透明传输"></a><em>封装成帧&amp;透明传输</em></h3><blockquote><p><em>封装成帧</em></p></blockquote><p><em>在一段数据添加首部、尾部构成一个帧，接收端就能收到bit流后，能识别帧的开始和结束</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271708120.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271711174.png" alt="image.png"></p><blockquote><p><em>透明传输</em></p></blockquote><p><em>就是传输数据的bit组合不会影响，到帧开始和结束的判定</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271714311.png" alt="image.png"></p><blockquote><p><em>四种组帧的方法</em></p></blockquote><p><strong><em>1.字符计数法</em></strong></p><ul><li><em>帧的开始字符记录的是该帧的字符数(包括自己)</em></li><li><p><em>缺点是，当前面的字符出错，往后的全部会出错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271716399.png" alt="image.png"><br><strong><em>2.字符填充法</em></strong></p></li><li><p><em>传送文本，由于文本字符对应的ASCII码不会出现的bit组合充当帧头，帧尾，中间数据部分不会产生边界判定错误</em></p></li><li><em>如果传送的帧，由二进制程序，或图像等等非ASCII编码文本文件，数据内容有可能出现帧头，帧尾bit组合，导致中间穿插,帧边界判定错误</em></li><li><em>通过对数据部分 字节填充ESC转义字节 ，—&gt;使得特殊字符意义失效，实现干扰的解决</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271720950.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271724181.png" alt="image.png"></p><p><strong><em>3.零比特填充法</em></strong></p><p><em>以01111110 作为帧头和帧尾，发送端先将数据扫描，将所有连续的5个1 后都插入0，这样就不会出现6个1 ，再封装成帧；接收端，再逆过程去掉0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271726553.png" alt="image.png"></p><p><strong><em>4.违规编码法</em></strong></p><p><em>曼彻斯特编码中不会出现的状态(高-高/低-低)来表示帧头，帧尾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271729961.png" alt="image.png"></p><h3 id="差错控制—检错编码"><a href="#差错控制—检错编码" class="headerlink" title="差错控制—检错编码"></a><em>差错控制—检错编码</em></h3><blockquote><p><em>差错从何而来？</em></p></blockquote><ul><li><em>差错来源：随机噪声（线路本身电气特性产生）、冲击噪声（外界短暂原因）</em></li><li><p><em>差错：位错；帧错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271901773.png" alt="image.png"></p></li><li><p><em>链路层编码与物理层编码调制不同：链路层编码是用于<strong>一组比特</strong>，判断传输过程是否出现出错。物理层编码调制针对<strong>单个比特</strong>，解决的是传输过程中 比特同步的问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271903232.png" alt="image.png"></p></li></ul><blockquote><p><em>差错控制—检错编码—奇偶校验码</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271910981.png" alt="image.png"></p><blockquote><p><em>差错控制—检错编码—CRC循环冗余码</em></p></blockquote><p><em>接收结果作 余数为0，就无差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271911773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307271912297.png" alt="image.png"></p><h3 id="差错控制—纠错编码"><a href="#差错控制—纠错编码" class="headerlink" title="差错控制—纠错编码"></a><em>差错控制—纠错编码</em></h3><blockquote><p><em>海明距离</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272215926.png" alt="image.png"></p><blockquote><p><em>海明码纠错步骤</em></p></blockquote><p><strong><em>1.确定校验码位数r</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217701.png" alt="image.png"></p><p><strong><em>2.确定校验码和数据的位置</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272217078.png" alt="image.png"></p><p><strong><em>3.求出校验码的值</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272220510.png" alt="image.png"></p><p><strong><em>4.检错并纠错</em></strong><br><em>方式1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272228839.png" alt="image.png"></p><ul><li><em>先每个校验码对应一个大圆，分别填入器其校验码序号</em></li><li><em>交集部分，填入校验码负责校验的一组序号中重叠的序号数据</em></li><li><em>最中间是三个校验码负责的重叠序号</em></li><li><em>2号校验码负责的没有出错，1,4号出错，所以3，6,7，排除，只剩下5</em></li></ul><p><em>方式2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307272242979.png" alt="image.png"></p><blockquote><p><em>海明码纠错演示</em></p></blockquote><p><strong><em>1．传输的数据：1101</em></strong></p><p><strong><em>2．校验位计算公式：</em></strong></p><p>2^k &gt;= k+n+1,n为数据位在本例中计算的k为3；</p><p>用P1,P2,P3,表示校验位，其中</p><p>P1,的位数2^0,P2,的位数2^1,P3,的位数2^2</p><p>则：</p><div class="table-container"><table><thead><tr><th></th><th>1</th><th>2</th><th>1+2</th><th>4</th><th>1+4</th><th>2+4</th><th>1+2+4</th></tr></thead><tbody><tr><td>位数的二进制</td><td>0001</td><td>0010</td><td>0011</td><td>0100</td><td>0101</td><td>0110</td><td>0111</td></tr><tr><td>位数</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>数据位</td><td></td><td></td><td>1</td><td></td><td>1</td><td>0</td><td>1</td></tr><tr><td>校验位</td><td>P1,</td><td>P2,</td><td></td><td>P3</td><td></td><td></td></tr></tbody></table></div><p><strong><em>3.分组：</em></strong></p><div class="table-container"><table><thead><tr><th>校验位</th><th>位数分组</th></tr></thead><tbody><tr><td>P1,</td><td>1,3,5,7</td></tr><tr><td>P2,</td><td>2,3,6,7</td></tr><tr><td>P3</td><td>4,5,6,7</td></tr></tbody></table></div><p><strong><em>4.计算校验位值(异或运算)</em></strong></p><p>P1^1^1^1=0,得P1=1</p><p>P2^1^0^1=0,得P2=0</p><p>P3^1^0^1=0,得P3=0</p><p>最终传输的数据位：10101<code>0</code>1</p><p><strong><em>5,检验</em></strong><br>     如果接收端收到的是10101<code>1</code>1<br>     还是按照刚才的分组进行计算P1,P2P3每个分组的异或值，为零则无错，为1则有错。<br>     P1组 1^1^1^1=0<br>     P2组 0^1^1^1=1<br>     P3组 0^1^1^1=1</p><h3 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a><em>流量控制与可靠传输机制</em></h3><div style="background-color: #fffacd;padding:20px;"> <font size="3"><mark>可靠传输机制</mark>是指在数据传输过程中,使用各种手段来确保数据能够完整、正确、按序到达目的地的传输机制。<br>主要的可靠传输机制包括:<br>1. 流量控制:发送方和接收方协调传输速率,防止接收缓冲区溢出。<br>2. 错误检测:对传输的数据进行校验,检查是否发生错误。常用奇偶校验、CRC校验等。<br>3. 确认和重传:接收方发回确认帧表示正确接收,发送方如果长时间收不到确认,会重传数据。<br>4. 序列号:对数据包进行编号,确保按序到达。<br>5. 连接管理:建立连接、维护连接状态、终止连接。<br>6. 滑动窗口协议:扩大序列号使用范围,通过窗口控制流量。<br>7. 网络拥塞控制:通过流量控制和拥塞控制技术确保网络稳定运行<br><br>在TCP/IP参考模型的五层网络结构中,主要是<mark>数据链路层</mark>和<mark>传输层</mark>提供可靠的数据传输机制。<br>1. 数据链路层<br>数据链路层通过以下手段提供尽力而为的可靠传输:<li>流量控制:防止接收端缓冲区溢出</li><li>差错检测:检测并纠正传输错误</li><li>确认重传机制:确认帧和重传机制</li><li>链路管理:管理物理链路连接</li><br>2. 传输层<br>传输层中的TCP协议提供面向连接、全双工、可靠的传输服务。主要机制有:<li>序列号和确认机制</li><li>滑动窗口协议</li><li>拥塞控制</li><li>连接管理</li></font></div><h4 id="流量控制与可靠传输的方法"><a href="#流量控制与可靠传输的方法" class="headerlink" title="流量控制与可靠传输的方法"></a><em>流量控制与可靠传输的方法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281155434.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157929.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157464.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281157841.png" alt="image.png"></p><ul><li><em>停止-等待协议  ，发送窗口=1，接收窗口=1</em></li><li><em>后退N帧协议（GBN）发送窗口&gt;1,接收窗口=1</em></li><li><em>选择重传协议（SR）发送窗口&gt;1,接收窗口&gt;1</em></li></ul><h5 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h5><blockquote><p><em>为什么要有停止等待协议？</em></p></blockquote><ul><li><em>为了解决流量控制的问题：互相的停止等待，使得不会传输太多的数据</em></li><li><em>为了解决可靠传输的问题：互相停止等待，接收确认帧，能保证能发现差错，以及处理差错</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281348782.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—无差错情况</em></p></blockquote><ul><li><em>ACK i 是接收方收到第 i 号帧之后，返回给发送方的确认帧</em></li><li><em>每次发送一个数据帧就停止等待，所以只需要1bit来对帧进行编号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352535.png" alt="image.png"></li></ul><blockquote><p><em>停止等待协议—有差错情况</em></p></blockquote><p><strong><em>1.数据帧丢失或检测到帧出错</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281352337.png" alt="image.png"></p><ul><li><em>超时计时器，当没有在设定时间内收到确认帧，发送方就重发一次</em></li><li><em>超时计时器设置的设定时间，要并RTT(往返传播时延)高一点，因为还有发送时延</em></li><li><em>发完一个帧之后，要保留这个帧的副本，用来重发</em></li><li><em>数据帧和确认帧必须编号，以确定确认帧确定的是哪一个数据帧</em></li></ul><p><strong><em>2.ACK丢失</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356757.png" alt="image.png"></p><p><strong><em>3.ACK迟到</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281356868.png" alt="image.png"></p><blockquote><p><em>信道利用率</em></p></blockquote><ul><li><em>信道利用率就是发送方在一个发送周期内，有效的发送数据所需时间(发送时延)，占整个发送周期的比率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281403631.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281404211.png" alt="image.png"></p><blockquote><p><em>梳理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281406220.png" alt="image.png"></p><h5 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h5><h6 id="后退N帧协议GBN"><a href="#后退N帧协议GBN" class="headerlink" title="后退N帧协议GBN"></a><em>后退N帧协议GBN</em></h6><blockquote><p><em>停等协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281646729.png" alt="image.png"></p><blockquote><p><em>后退N帧协议中的滑动窗口</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281541947.png" alt="image.png"></p><blockquote><p><em>GBN发送方要响应的三件事</em></p></blockquote><ul><li><em>窗口已满是指，当前窗口的数据，在没有收到确认帧之前，不能往前移动，此时的状态就是窗口已满</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281539613.png" alt="image.png"></li></ul><blockquote><p><em>GBN接收方要做的事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281651074.png" alt="image.png"></p><blockquote><p><em>运行中的GBN</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281536912.png" alt="image.png"></p><blockquote><p><em>滑动窗口长度</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281559974.png" alt="image.png"></p><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281532640.png" alt="image.png"></p><ul><li><em>1000个窗口，所以发送方同时可以发1000个帧，每个帧1000个字节<br>所以一次右1000x1000x8 bit数据，<strong>受到信道带宽限制，所以发送延时=<br>1000x1000x8b/100Mb/s =80ms</strong></em></li><li><em>只有受到受到1号帧的确认帧，发送框才会开始移动一个，所以，<strong>在没有受到第一个确认帧之前，发送方不会发送新的数据</strong></em></li><li><em>所以计算，受到确认帧的时间=2x50ms + 1000x8b/100Mb/s =100.08ms &gt;80ms ,所以，信道会有20ms没有新数据推入，空闲，有100.08-80ms=20ms无输入，所以<strong>实际平均数据传输率=1000x1000x8b/100.08ms=80Mb/s</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281518658.png" alt="image.png"></li></ul><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281543131.png" alt="image.png"></p><h6 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a><em>选择重传协议SR</em></h6><blockquote><p><em>后退N帧协议的弊端</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281647073.png" alt="image.png"></p><blockquote><p><em>选择重传协议中的滑动窗口</em></p></blockquote><ul><li><em>发送窗口黄色部分是未被确认的帧，绿色部分是发送之后，收的确认帧的帧</em></li><li><em>接收窗口，紫色部分是收到的帧，灰色部分是<strong>希望收到</strong>的帧，发现，接收窗口可以在没有收到希望收到的帧前，接收其他序号的帧，这里不同于GBN协议，GBN协议在没有收到希望收到的帧之前，对其他发送过来的帧会全部丢弃</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281652798.png" alt="image.png"></li></ul><blockquote><p><em>SR 发送方必须响应的三件事</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281659010.png" alt="image.png"></p><blockquote><p><em>SR接收方要做的事</em></p></blockquote><ul><li><em>接收窗口只有当接收到窗口下届的帧，才会将接收窗口往前移动，移动到最小的未接收的帧，并将接收到的这批帧，交付给网络层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705434.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281705718.png" alt="image.png"></p><blockquote><p><em>运行中的SR</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281708817.png" alt="image.png"></p><blockquote><p><em>SR滑动窗口长度</em></p></blockquote><ul><li><em>发送窗口=接收窗口（防止溢出）</em></li><li><em>窗口长度=2^(n-1),n为帧的个数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281711388.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281714834.png" alt="image.png"></p><blockquote><p><em>总结</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281713327.png" alt="image.png"></p><h3 id="信道划分介质访问控制-MAC协议"><a href="#信道划分介质访问控制-MAC协议" class="headerlink" title="信道划分介质访问控制(MAC协议)"></a><em>信道划分介质访问控制(MAC协议)</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942630.png" alt="image.png"></p><ul><li><em>当一个对讲机讲话，其他对讲机就不能够进行讲话，否则会信号冲突</em></li><li><em>广播式链路，如何实现，两对节点之间通信不会互相干扰，就需要介质访问控制来实现</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307281942457.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291141124.png" alt="image.png"></p><h4 id="静态划分信道-信道划分介质访问控制"><a href="#静态划分信道-信道划分介质访问控制" class="headerlink" title="静态划分信道(信道划分介质访问控制)"></a><em>静态划分信道(信道划分介质访问控制)</em></h4><h5 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a><em>频分多路复用FDM</em></h5><ul><li><em>不同用户同一时间占用不同的带宽(频率资源)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282109872.png" alt="image.png"></li></ul><h5 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a><em>时分多路复用TDM</em></h5><ul><li><p><em>缺点是每个用户在每一个帧中占用固定的时隙，导致其他用户空闲时，不传送数据时，时隙被浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282111844.png" alt="image.png"></p></li><li><p><em>改进后的统一时分复用STDM,就解决了上面的问题，铜国集中器，将不同用户的数据，按照进入的先后，排列使得每一个STDM帧都排满</em></p></li><li><em>所以STDM帧的每个用户的时隙，不是固定的，是按照需要动态分配的时隙</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282112256.png" alt="image.png"></li></ul><h5 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a><em>波分多路复用WDM</em></h5><ul><li><em>实际上就是光的频分多路复用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282115560.png" alt="image.png"></li></ul><h5 id="码分多路复用CDM"><a href="#码分多路复用CDM" class="headerlink" title="码分多路复用CDM"></a><em>码分多路复用CDM</em></h5><ul><li><em>不太理解</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282116386.png" alt="image.png"></li></ul><h4 id="动态分配信道-随机访问介质访问控制"><a href="#动态分配信道-随机访问介质访问控制" class="headerlink" title="动态分配信道(随机访问介质访问控制)"></a><em>动态分配信道(随机访问介质访问控制)</em></h4><h5 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a><em>ALOHA协议</em></h5><blockquote><p><em>纯ALOHA协议</em></p></blockquote><ul><li><em>这里帧用T0表示，T0是一个帧从的 发送时间+传播时间 这所有过程，所耗费的时间，所以是在时间坐标上表示帧</em></li><li><em>ALOHA协议想发就发，多个站点，可以在任何时刻，发送数据帧，只是，如果有两个数据帧产生，时间重叠，那么就发生冲突，接收方会检测到差错，不返回确认，如此发送方就会等待一个随机的时刻再次发送数据帧</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282134246.png" alt="image.png"></li></ul><blockquote><p><em>时隙ALOHA协议</em></p></blockquote><ul><li><em>把时间分为若干相同的时间片段，所有用户只允许在<strong>开始时刻</strong>且 <strong>同步</strong>接入网络信道，这样所有用户拥有一个统一的时间划分，都只能在时间片开始时刻发送数据，若发生冲突，则等到下一个时间片开始时刻发送,大大降低了数据冲突问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307282138877.png" alt="image.png"></li></ul><h5 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a><em>CSMA协议</em></h5><p><strong><em>载波监听多路访问协议</em></strong></p><ul><li><em>CS ：载波监听，每一个站发送数据前先检测总线上是否有其他计算机发送数据</em></li><li><em>当信道空闲：发送完整帧(具体发送看CSMA类型)</em></li><li><em>当信道忙：则等待一个随机时间再监听</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290953369.png" alt="image.png"></li></ul><blockquote><p><em>1-坚持CSMA</em></p></blockquote><ul><li><em>空闲直接传输，不等待；忙则一直监听，直到空闲马上传输</em></li><li><em>不是都是空闲的时候再传输吗？为什么会出现冲突？</em></li><li><em>因为，当有两个以上站，同时在等候监听时，由于信息在两台站之间有传播时延，即使是信道上已经存在数据传输，任然检测不出，所以就当做信道空闲，也把数据传输上去，这样就导致数据碰撞，造成冲突</em></li><li><em>优点：只要空闲就发送，媒体利用率最高</em></li><li><em>缺点：冲突概率高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307290956924.png" alt="image.png"></li></ul><blockquote><p><em>非坚持CSMA</em></p></blockquote><ul><li><em>空闲则直接传输，不等待；忙则放弃监听，随机时间后再监听</em></li><li><em>优点：减少了当台站，同时监听到空闲直接发送数据，产生冲突的可能</em></li><li><em>缺点：媒体空闲无法迅速被利用起来，利用率低</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291000848.png" alt="image.png"></li></ul><blockquote><p><em>p-坚持CSMA</em></p></blockquote><ul><li><em>空闲时，概率p直接发送，概率1-p等待下一个时间槽传输。</em></li><li><em>忙则持续监听，直到信道空闲</em></li><li><em>冲突则等待下一个时间槽监听</em></li><li><em>优点：即减少了冲突发生，有能减少空间时间的浪费</em></li><li><em>缺点：冲突后还是会把数据帧发送完，造成浪费</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291004905.png" alt="image.png"></li><li><strong><em>正确使用以上策略可以在一定程度上减少碰撞的发生，但无法彻底解决碰撞问题。</em></strong></li></ul><blockquote><p><em>比对</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291009309.png" alt="image.png"></p><h5 id="CSMA-CD协议"><a href="#CSMA-CD协议" class="headerlink" title="CSMA/CD协议"></a><em>CSMA/CD协议</em></h5><blockquote><p><strong><em>强化CSMA协议，推出CSMA/CD协议</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034112.png" alt="image.png"></p><p><strong><em>载波监听多点接入/碰撞检测协议</em></strong></p><ul><li><em>CSMA/CD适用于半双工网络(也就是<strong>有线以太网</strong>)—就是不能一方发送还没发送完，另一方就发送，这样会造成数据在路上的碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291034904.png" alt="image.png"></li></ul><blockquote><p><em>为什么先听后发会产生冲突</em></p></blockquote><ul><li><em>为什么先听后发还会产生冲突？</em></li><li><em>因为电磁波在总线上有传播时延，B暂时没有检测到A发送过来的数据</em></li><li><em>以A为基准，对于A来说，A检测到发生碰撞的最长时间=2τ</em></li><li><em>所以当发送数据之后过了2τ还没接受到碰撞，说明这次传输，不会产生碰撞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291053463.png" alt="image.png"></li></ul><blockquote><p><em>如何确定碰撞后重传时机</em></p></blockquote><ul><li><em>碰撞之后如何重传，以及重传几次，通过以下方式**</em>截断二进制指数规避法<em>**</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291055125.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291057356.png" alt="image.png"></li></ul><blockquote><p><em>最小帧长</em></p></blockquote><ul><li><em>当检测到碰撞之后，应当立即停止继续发送帧，但是如果检测到碰撞之前就将帧发送完毕，就显得有些尴尬</em></li><li><em>为了避免检测到碰撞之前，就将帧发完，应该设置一个最小的帧长度，保证2τ(最大检测到碰撞时间)之内不会将帧传输完</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103100.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291103689.png" alt="image.png"></p><h5 id="CSMA-CA协议"><a href="#CSMA-CA协议" class="headerlink" title="CSMA/CA协议"></a><em>CSMA/CA协议</em></h5><blockquote><p><em>为什么要有CSMA/CA协议</em></p></blockquote><ul><li><em>无线局域网中无法辺全面的检测碰撞</em></li><li><em>并且当多台站点A,C检测到信道空闲，会同时向终端B发送数据帧，就会导致冲突</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134454.png" alt="image.png"></li></ul><blockquote><p><em>CSMA/CA协议工作原理</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291133228.png" alt="image.png"></p><blockquote><p><em>CSMA/CA与CSMA/CD区别</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291134135.png" alt="image.png"></p><h4 id="动态分配信道-轮询访问介质访问控制"><a href="#动态分配信道-轮询访问介质访问控制" class="headerlink" title="动态分配信道(轮询访问介质访问控制)"></a><em>动态分配信道(轮询访问介质访问控制)</em></h4><ul><li><strong><em>结合了静态划分信道的优点，不会产生冲突；又结合了随机访问协议的优点发送时能独占信道，占全部带宽</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291220580.png" alt="image.png"></li></ul><h5 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a><em>轮询协议</em></h5><ul><li><em>主节点，挨个轮流询问（实际就是以数据帧形式）下面的主机是否要发送数据</em></li><li><em>主节点故障，就无法询问，所有结点就无法传输数据—称为单点故障</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291214203.png" alt="image.png"></li></ul><h5 id="令牌传递协议"><a href="#令牌传递协议" class="headerlink" title="令牌传递协议"></a><em>令牌传递协议</em></h5><ul><li><em>令牌就是特殊格式的MAC协议控制帧，不包含任何信息</em></li><li><em>令牌用于控制信道的使用，确保同一时刻只有一个结点独占信道</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291218760.png" alt="image.png"></li></ul><h2 id="局域网基本概念和体系结构"><a href="#局域网基本概念和体系结构" class="headerlink" title="局域网基本概念和体系结构"></a><em>局域网基本概念和体系结构</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291600023.png" alt="image.png"></p><p><strong><em>决定局域网主要要素</em></strong></p><ul><li><em>网络拓扑</em></li><li><em>传输介质</em></li><li><em>介质访问控制方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291548371.png" alt="image.png"></li></ul><blockquote><p><em>局域网拓扑结构</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291550233.png" alt="image.png"></p><blockquote><p><em>局域网传输介质</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551105.png" alt="image.png"></p><blockquote><p><em>局域网介质访问控制方法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291551614.png" alt="image.png"></p><blockquote><p><em>局域网的分类</em></p></blockquote><p><em>以太网。是目前应用最广泛的局域网，逻辑拓扑是总线型，物理拓扑是星型。使用的是CSMA/CD 协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291554255.png" alt="image.png"></p><blockquote><p><em>IEEE 802标准</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291556090.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291555065.png" alt="image.png"></p><blockquote><p><em>LLC子层和MAC子层</em></p></blockquote><p><em>IEEE 802标准将局域网的数据链路层划分为：逻辑链路层LLC子层，和介质访问控制MAC子层</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291559577.png" alt="image.png"></p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a><em>以太网</em></h3><blockquote><p><em>以太网概述</em></p></blockquote><ul><li><em>以太网有两个标准，DIX Ethernet V2 和IEEE 802.3 ;两种标准的帧格式只有1点点的不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291654999.png" alt="image.png"></li></ul><blockquote><p><em>以太网提供无连接、不可靠服务</em></p></blockquote><ul><li><em>无连接：发送方接受方，之间通信前，不提前确立信道，无握手</em></li><li><em>不可靠：是指，不管接受数据帧是否乱序、差错、丢失</em></li><li><em>无差别接收：是指，在接收数据不会有意外，来什么收什么</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291655881.png" alt="image.png"></li></ul><blockquote><p><em>以太网传输介质与拓扑结构</em></p></blockquote><ul><li><em>现在以太网都是逻辑上总线型，物理上星型</em></li><li><em>传输介质采用双绞线+集线器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291658840.png" alt="image.png"></li></ul><blockquote><p><em>10BASE-T以太网</em></p></blockquote><ul><li><em>BASE 表示传输基带信号，也就是数字信号</em></li><li><em>T表示采用双绞线</em></li><li><em>采用曼彻斯特编码</em></li><li><em>采用CSMA/CD介质访问控制</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291700140.png" alt="image.png"></li></ul><blockquote><p><em>适配器与MAC地址</em></p></blockquote><ul><li><em>通信适配器，实现计算机与外界局域网的连接，也称网络接口板，或网卡NIC</em></li><li><em>现在计算机都嵌入了适配器，就无须单独使用网卡了</em></li><li><em>适配器上装有处理器和存储器(RAM,ROM)，ROM上存储了计算机硬件(网卡)地址MAC地址</em></li><li><em>MAC地址全球唯一，换网卡，MAC地址改变</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291704298.png" alt="image.png"></li></ul><blockquote><p><em>以太网MAC帧—V2格式</em></p></blockquote><ul><li>*为什么有帧开始定界符 ，却没有帧结尾定界符呢？</li><li><em>因为以太网编码采用的是曼彻斯特编码，一个bit内就有一个跳变，当这种形式消失，就说明帧结束，然后只需要往前推4bit就能找到数据位置</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307291717806.png" alt="image.png"></li></ul><blockquote><p><em>高速以太网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292033086.png" alt="image.png"></p><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a><em>无线局域网</em></h3><blockquote><p><em>802.11的MAC帧头格式</em></p></blockquote><ul><li><em>基站AP(也称无线接入点), 是主机通过连接无线网络连入有线网络（以太网）的设备</em></li><li><em>以下的场景：A 想要与B通信，由于距离太远，A要先通过无线网络将数据发送给Ap1,然后Ap1发送给AP2，最后由Ap2将数据发送给B</em></li><li><em>接收端—AP2的MAC地址 ；发送端—AP1的MAC地址；目的地址—B的MAC地址；源地址—A的MAC地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292038208.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292052190.png" alt="image.png"></p><blockquote><p><em>无线局域网的分类</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292053304.png" alt="image.png"></p><p><strong><em>1.有固定基础设施无线局域网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292055469.png" alt="image.png"></p><ul><li><em>一个基本服务集BSS内，的主机可以相互之间直接通过基站发送数据</em></li><li><em>不同基本服务集之间要进行远距离通信，需要借助基站与基站之间的互相通信来实现，称作“漫游”</em></li><li><em>wifi名称—就是服务集标识符</em></li></ul><p><strong><em>2.无固定基础设施无线局域网的自组织网络</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307292101049.png" alt="image.png"></p><h3 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a><em>虚拟局域网VLAN</em></h3><blockquote><p><em>为什么提出虚拟局域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041734284.png" alt="image.png"></p><blockquote><p><em>VLAN基本概念</em></p></blockquote><ul><li><strong><em>就是将局域网内的设备，划分为不同的逻辑工作组，这种域与物理位置无关</em></strong></li><li><em>一个逻辑工作组，就是一个子网，一个广播域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041735592.png" alt="image.png"></li></ul><blockquote><p><em>VLAN实现</em></p></blockquote><ul><li><em>将一个交换机下的局域网，逻辑上划分为两个虚拟的不同的局域网，同时其他交换机下的也可以划分为同样的两个分组，这样相同的分组之间就是一个可以互相通信的虚拟局域网，而不同分组之间就不能互相通信</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041738107.png" alt="image.png"></li><li><em>按照交换机上的端口划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041740977.png" alt="image.png"></p><ul><li><em>按照接入的主机MAC地址划分</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041743116.png" alt="image.png"></p><ul><li><em>假如A要往E发送数据，A主机会先准备一个普通以太网帧，帧送往交换机，交换机会往帧上贴一个标签(标注VLAN1)，发往交换机2，然后交换机2会根据标签，知道这是发往虚拟局域网VLAN1的然后再根据一些其他标志，判断发往E </em></li></ul><blockquote><p><em>VLAN进行数据交换时，帧的格式变化</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041752990.png" alt="image.png"></p><blockquote><p><em>练习</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041753776.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041756089.png" alt="image.png"></p><h2 id="广域网及相关协议"><a href="#广域网及相关协议" class="headerlink" title="广域网及相关协议"></a><em>广域网及相关协议</em></h2><blockquote><p><em>什么是广域网</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041719233.png" alt="image.png"></p><blockquote><p><em>PPP协议</em></p></blockquote><p><strong><em>PPP点对点协议，广域网使用的链路层协议，只支持全双工链路，用于用户使用拨号电话接入因特网</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041721607.png" alt="image.png"></p><blockquote><p><em>PPP协议应该满足的要求/无需满足的要求</em></p></blockquote><ul><li><em>同步线路是逐个bit发送数据，异步线路是逐个字节或字符发送数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726956.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041726276.png" alt="image.png"></p><blockquote><p><em>PPP协议的是哪个组成部分</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727339.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041727950.png" alt="image.png"></p><blockquote><p><em>PPP协议的帧格式</em></p></blockquote><ul><li><em>PPP协议的帧格式，最小单位是字节，所以是面向字节的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308041731402.png" alt="image.png"></li></ul><h2 id="链路层设备"><a href="#链路层设备" class="headerlink" title="链路层设备"></a>链路层设备</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><em>基本概念</em></h3><h4 id="网段"><a href="#网段" class="headerlink" title="网段"></a><em>网段</em></h4><ul><li><em>网段计算机网络中使用同一物理层设备，能够直接通讯的那一部分，同一个网段，会有冲突域，同一时间只能有一台设备占用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042038496.png" alt="image.png"><h4 id="冲突域与广播域"><a href="#冲突域与广播域" class="headerlink" title="冲突域与广播域"></a><em>冲突域与广播域</em></h4></li></ul><p><strong><em>1.冲突域：</em></strong></p><ul><li><em>在以太网  中，如果某个CSMA/CD网络上的两台计算机在同时通信时<strong>会发生冲突</strong>，那么这个CSMA/CD网络就是一个<strong>冲突域</strong>（collision domain)。如果以太网中各个网段以<strong>集线器</strong>连接，因为不能避免冲突，所以它们仍然是一个冲突域</em></li><li><em>冲突域就是连接在<strong>同一导线</strong>上的所有工作站的集合，或者说<strong>是同一物理网段</strong>上所有节点的集合，或以太网上竞争<strong>同一带宽</strong>的节点集合.</em></li><li><em>集线器是一个标准的共享式设备，也就是<strong>同一时刻只有一个端口下联的设备可以发送数据。正常工作时，集线器随机选出某一端口设备并让它独占全部带宽与集线器上联设备（如交换机、路由器等）进行通信</strong>。因此，集线器设备的所有端口即形成了一个冲突域。</em></li><li><em>为了有效避免冲突，局域网中使用<strong>交换机</strong>（Switch）来分割冲突域</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042041995.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042042138.png" alt="image.png"></p><p><strong><em>2.广播域：</em></strong></p><ul><li><em>广播是一种信息的<strong>传播方式</strong>，指网络中的某一设备同时向网络中所有的其它设备发送数据，这个数据所能广播到的范围即为<strong>广播域</strong>(Broadcast Domain)。</em></li></ul><p><strong><em>3.两者区别</em></strong></p><ul><li><em>冲突域是基于物理层</em></li><li><p><em>广播域是基于数据链路层</em></p></li><li><p><em>冲突域：竞争同一带宽的节点的集合</em></p></li><li><em>广播域：接收同样广播消息的节点的集合</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042020764.png" alt="image.png"></li></ul><blockquote><p><em>练习加深了解</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042120355.png" alt="image.png"></p><h3 id="链路层的设备"><a href="#链路层的设备" class="headerlink" title="链路层的设备"></a><em>链路层的设备</em></h3><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a><em>网桥</em></h4><ul><li><em>网桥有左右两个端口，分别分割两个冲突域</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042049108.png" alt="image.png"></p><blockquote><p><em>透明网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045169.png" alt="image.png"></p><blockquote><p><em>源路由网桥</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042045552.png" alt="image.png"></p><blockquote><p><em>网桥的自学习功能</em></p></blockquote><ul><li><em>网桥只有左右两个端口，分别标记位1,2号</em></li><li><em>网桥自学习是指，网桥转发表一开始是空的，当A-&gt;B发送信息时，A会向所有主机发送，当经过第一个网桥时，由于网桥转发表没有对A的记录，所以当数据帧经过该网桥时，就会在转发表记录  A对应1端口位置；同时由于没有对B的记录，无法选择转发，所以只能一股脑转发出去，右边的网桥也经过一样的过程</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042101488.png" alt="image.png"></li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a><em>交换机</em></h4><blockquote><p><em>多接口网桥—交换机</em></p></blockquote><ul><li><em>集线器，也是多接口，集线器，会将每台计算机原有100MB/s带宽，平均为每台只有25MB/s ,同时会有冲突域，一台集线器下的计算机只能同时有一台发送数据，传输速率大大降低</em></li><li><em>交换机，就是一个多接口的网桥，可以隔绝冲突域，一台交换机下的每条信道都能占满带宽(独占媒体带宽)，维持原有的100MB/s,同时一台交换机之内的所有计算机都可以同时传输数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042110168.png" alt="image.png"></li></ul><blockquote><p><em>以太网交换机的两种交换方式</em></p></blockquote><ul><li><em>直通式交换机</em></li><li><em>存储转发式交换机</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042121848.png" alt="image.png"></li></ul><blockquote><p><em>交换机的自学习功能</em></p></blockquote><ul><li><em>与网桥的自学习功能类似，只是多了几个端口</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308042114758.png" alt="image.png"></li></ul><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051043362.png" alt="image.png"></p><p><strong><em>1.网络层功能</em></strong></p><ul><li><em>路由选择分组转发</em></li><li><em>异构网络互联：指的是传输介质、数据编码方式、链路控制协议以及不同的数据单元格式和转发机制的网络，也就是<strong>数据链路层和物理层协议不同</strong>的网络</em></li><li><em>拥塞控制：全局性的概念，是因为整个网络负载过重造成拥塞；而流量控制只是，发送方发送过快导致接收方接收不过来，所以需要流量控制</em></li></ul><p><strong><em>2.拥塞控制方法</em></strong></p><ul><li><em>WAY1开环控制：静态方法</em></li><li><em>WAY2闭环控制：动态方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051053599.png" alt="image.png"><h2 id="SDN基本概念"><a href="#SDN基本概念" class="headerlink" title="SDN基本概念"></a><em>SDN基本概念</em></h2></li></ul><blockquote><p><em>考察概念，主要是选择题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051308929.png" alt="image.png"></p><p><strong><em>1.网络层的关键功能</em></strong></p><ul><li><em>转发：将分组从路由器的输入端口，转发到合适的输出端口【局部的功能】【数据平面的部分】</em></li><li><em>路由：使用路由算法决定分组从发送主机到目标接收主机的路径【全局的功能】【控制平面的部分】</em></li></ul><p><strong><em>2.网络层：数据平面、控制平面</em></strong><br><code>数据平面：</code> </p><ul><li><em>路由器本地动作</em></li><li><em>根据路由表，将分组从输入端口转发到合适的输出端口【路由表和转发表是控制平面的路由选择协议实体算出来的】</em></li></ul><p><code>控制平面：</code></p><ul><li><em>网络范围内的逻辑</em></li><li><em>决定数据报从源到目标主机的端到端路径</em></li><li><em>2个控制平面方法：传统方法、SDN方法(software-define-networking)</em><ul><li><em>传统方法：运行在每一台路由器本地中</em></li><li><em>SDN方法：在远程服务器中实现</em></li></ul></li></ul><p><strong><em>3.控制平面两个方法</em></strong></p><blockquote><p><em>传统方式—每路由控制平面</em></p></blockquote><ul><li><em>传统方式下，每个路由器，即实现了控制平面功能，又实现了数据平面功能</em></li><li><em>每台路由器中的路由选择算法与其他路由器中的路由选择算法相互通信, <strong>计算出路由表和转发表</strong></em></li><li><em>这种方式使得路由器的控制平面与数据平面相互紧紧耦合，带来的问题是，改变路由运行逻辑变得非常困难</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051337186.png" alt="image.png"></li></ul><blockquote><p><em>SDN方式—集中逻辑的控制平面</em></p></blockquote><ul><li><em>将控制平面从路由器物理上剥离开，在远程服务器中集中实现。在远程控制器中计算和分发转发表，以提供给每台路由器</em></li><li><em>计算、转发、远程控制器，是由软件实现，所以是集中式，可编程的</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051345318.png" alt="image.png"></p><p><strong><em>4.SDN方式控制平面的组成</em></strong><br><em>远程控制器中包括：</em></p><ul><li><em>SDN控制器</em></li><li><em>网络控制应用程序</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051351391.png" alt="image.png"></li></ul><p><strong><em>5.SDN控制器的三个层次</em></strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051357037.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051359025.png" alt="image.png"></p><h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a><em>IP数据报</em></h2><h3 id="IP数据报格式"><a href="#IP数据报格式" class="headerlink" title="IP数据报格式"></a><em>IP数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071000263.png" alt="image.png"></p><ul><li><p><em>网络层的传输单位是数据报，，网络层主要用到的协议是IP协议，IP协议的数据报格式如下</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071001404.png" alt="image.png"></p></li><li><p><em>首部长度4bit,从 0011~1111(5~15)，单位是4B，也就是首部长度最小5x4B=20B,最大15x4B=60B</em></p></li><li><em>协议部分，字段值不同，代表不同数据部分协议【注意是数据部分协议，网络层之上的协议】【TCP协议：面向连接服务，字段值6；UDP：不面向连接服务，字段值17】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071013525.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071017094.png" alt="image.png"></p><h3 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a><em>IP数据报分片</em></h3><blockquote><p><em>为什么要分片？</em></p></blockquote><ul><li><em>数据链路层是对IP数据报进行封装成帧，但是帧有最大传输单元MTU，如果IP数据报/分组，大于MTU,怎么办？</em><br><em>所以需要对IP数据报进行<strong>分片</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071038656.png" alt="image.png"></li></ul><blockquote><p><em>数据报分片例子</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034403.png" alt="image.png"></p></blockquote><ul><li><em>最大数据报片&lt;=1420B </em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071034753.png" alt="image.png"></li></ul><h2 id="IPV4地址"><a href="#IPV4地址" class="headerlink" title="IPV4地址"></a><em>IPV4地址</em></h2><ul><li><em>一个路由器会连接很多个主机，一个主机对应路由器一个接口(有线或无线接口)，每个接口都会分配一个唯一的ip地址</em></li><li><em>ip地址都是32bit的标识符，采用点分十进制，每一个字节，用点隔开，并且<br>每个字节的数字都是用十进制表示</em></li><li><em>IP 地址包括两部分：网络 ID（网络地址） + 主机 ID（主机地址）<br>网络 ID 用于不同网络寻址； 主机 ID 用于局域网内通讯</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071522558.png" alt="image.png"></li></ul><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a><em>IP地址的分类</em></h3><p><em>根据 IP 地址(二进制下)前缀数字的不同情况，划分为 A,B,C,D,E 5个类别，如下图  （本文我们主要介绍 A,B,C 三类）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt="image.png"></p><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a><em>A类地址</em></h4><p>*1. 第 1 字节为网络地址，其他 3 字节为主机地址，第 1 个字节第一位固定为0    2. 网络号范围： 1.0.0.0 - 126.0.0.0<br>3.包含私有地址和保留地址</p><pre><code>1. 私有网络号：10 （局域网中使用的网络地址）（网段1个）2. 保留地址：127.X.X.X</code></pre><p>4.主机数量：千万台*</p><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a><em>B类地址</em></h4><p>*1.第 1.2 字节为网络地址，其他为主机地址，第 1 个字节前两位固定为 10<br>2.网络号范围：128.0.0.0 - 191.255.0.0<br>3.包含私有地址和保留地址</p><pre><code>- 私有网络号：172.16—172.31 （网段16个）- 保留地址：169.254.X.X （IP 地址为自动获取，且无可用 DHCP 服务时，分                   配该地址）- 广播地址：191.255.255.255</code></pre><p>4.主机数量：最大 65534 台*</p><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a><em>C类地址</em></h4><p>*1. 第 1.2.3 字节为网络地址，第 4 字节为主机地址，第 1 个字节前三位固定110<br>2.网络号范围：192.0.0.0—223.255.255.0<br>3.包含私有地址和保留地址</p><pre><code>- 私有网络号 ：192.168.0~192.168.255 网段共255个</code></pre><p>4.主机数量：最大 254 台*</p><p><code>*网段个数，代表某类ip地址网络号有几种分法*</code></p><h4 id="特殊用途ip地址"><a href="#特殊用途ip地址" class="headerlink" title="特殊用途ip地址"></a><em>特殊用途ip地址</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630383.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131622431.png" alt="image.png"></p><ul><li><em>A类可用的网络号：1~126</em></li><li><em>B类可用的网络号：128.1~191.255</em></li><li><em>C类可用的网络号：192.0.1~223.255.255</em></li><li><em>主机号要减去全0，全1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071630367.png" alt="image.png"></li></ul><h4 id="私有ip"><a href="#私有ip" class="headerlink" title="私有ip"></a>私有ip</h4><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="图片alt"> </p><h2 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a><em>NAT网络地址转换</em></h2><blockquote><p><em>内网ip,不能直接与外网通信</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071705939.png" alt="image.png"></p><blockquote><p><em>NAT转换</em></p></blockquote><ul><li><em>需要通过NAT转换，将内网ip（专用网/私有ip地址）以及端口号，通过路由器 按照NAT转换表 转换为路由器的公网ip地址和端口号，才能与外部通信</em></li><li><em>NAT路由器一般只有1个公网ip，所以内网的主机公用一个公网ip</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071707488.png" alt="image.png"></li></ul><blockquote><p><em>什么时候需要NAT转发？什么时候不需要？</em></p></blockquote><ul><li><em>当申请的网络号是公网网络号，那么其下的ip都是公网ip，就不需要再对其NAT转换</em></li><li><em>当使用的都是专用网络，内网网络号，那么其下的都是私有ip，也就需要保证，路由器拥有至少一个公网ip，通过NAT转换与外部通信</em></li></ul><h2 id="子网划分与子网掩码"><a href="#子网划分与子网掩码" class="headerlink" title="子网划分与子网掩码"></a><em>子网划分与子网掩码</em></h2><blockquote><p><em>什么是子网？</em></p></blockquote><p><strong><em>子网或子网络是大型网络内的较小网络。子网划分使网络路由更加高效。</em></strong></p><blockquote><p><em>为什么要划分子网？</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">详细概述：</span><br><span class="line">首先，先明白网络广播的基本概念，本网段向本网络的所有节点发送数据包，所有节点都会收到，但往往只有一个节点是需要这个数据包的，因此广播的过程会很浪费的占用一部分网络资源。因此划分子网的一个最为重要意义就在于减少网络广播所带来的负面影响，提高性能的整体性能。因为广播数据包只能在同一网段中传输，网络规模小了，网络中用户数少了，当然所占用的资源也就少了。</span><br><span class="line"></span><br><span class="line">其次，这节省了IP地址的资源。这看似于前面介绍的连接主机数减少相矛盾，其实这要看具体的情况来定。对本省规模较大网络（200个用户以上），划分子网后，可用的IP地址数减少了。但如果是那些小型的企业网络来哦说，划分子网后又可以节省大量的IP地址资源。比如现在学校有四个机房，每个机房25台电脑，如果直接分配四个C类地址字段，每个机房一个。虽然这样做理论上没有错，但实际上你一共浪费了（254-25）*4=916个IP地址（全0全1不取,故256-2=254）。如果公用网络都这样分配IP地址，那么IP地址资源早就枯竭了。</span><br><span class="line"></span><br><span class="line">另外，不同的子网之间是不能直接通信的，需要借助路由器或网关。而且网络规模小了是相对较安全的，比如财政部门。而且较小的网络也比较容易部署特定的安全政策，而网络规模大了这些政策可能会影响到其他普通用户的工作。还有一个优点就是便于维护，当某个网点要查找故障的时候，网络规模小了，更容易查找到错误网络。</span><br><span class="line"></span><br><span class="line">需要注意的一点就是，划分子网也是有一些弊端的，一方面就是：可连接的主机数减少，这对于网络规模小的网点没有影响，但如果网络规模大，他们就必须划分为多个子网，如果它们需要进行频繁的通信的话就需要总是借助路由器或网关，会影响工作效率。另一方面就是：各个相对对立的网点，主机号0和1是不能取的，需要留给网络地址和广播地址。因此每多一个子网，就必须浪费两个IP地址（当然，这问题不大。）。</span><br><span class="line">总结：划分子网并不适用于所有网络，对于各部门间工作相对独立的企业或行业来说，划分子网还是可取的。而对于那些IP资源本来就不是很够，各部门间的联系又非常紧密的则最好不划分子网。</span><br></pre></td></tr></table></figure><blockquote><p><em>什么是子网掩码？</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071832869.png" alt="image.png"></p><blockquote><p><em>子网划分</em></p><ul><li><em>采用B类ip地址，该申请的网络号为145.13</em></li><li><em>由于</em></li><li><em>内部再划分子网，其中一个子网网络地址为145.13.3</em></li><li><em>这个子网里有多台主机，(子网网络地址+主机号)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071821362.png" alt="image.png"></li></ul></blockquote><ul><li><em>子网的划分实际上就是将<code>二级ip地址</code>,将原本主机号，借用若干位，作为子网号—&gt;<code>三级ip地址</code></em></li><li><em>在两级IP地址两个字段的基础上新增一个<code>子网号字段</code></em></li><li><em>划分子网纯属是一个单位内部的事情，单位对外仍然表现为没有划分子网的网络。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eg.  对外表现ip为141.14.72.24【这是一个B类ip地址，网络地址为141.14.0.0,后面是主机号】</span><br><span class="line"></span><br><span class="line">假如子网掩码是：</span><br><span class="line">255.255.192.0</span><br><span class="line">11111111 11111111 11000000 00000000</span><br><span class="line">可以看出，该子网是借用了2bit作为子网号，后面14bit才是主机号 </span><br><span class="line"></span><br><span class="line">141.14.72.24</span><br><span class="line">10001101 00001110 01001000 00011000</span><br><span class="line">与子网掩码相与，得到的子网网络地址就是：</span><br><span class="line">141.14.64.0</span><br><span class="line">10001101 00001110 01000000 00000000</span><br><span class="line">主机号是子网号后面14bit：</span><br><span class="line">2072</span><br><span class="line">001000 00011000</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071834346.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071846600.png" alt="image.png"></li></ul><blockquote><p><em>习题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308072115836.png" alt="image.png"></p><h2 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h2><p>CIDR（Classless Inter-Domain Routing）无分类域间路由选择</p><p>划分子网在一定程度上缓解了因特网发展中遇到的困难，但其仅仅是对分类编址方式的改进，A、B、C类IP网络号都为8的倍数，其划分不够精细，存在很大程度的浪费，基于此，无分类编址方式CIDR应运而生。</p><h3 id="分类编址的问题"><a href="#分类编址的问题" class="headerlink" title="分类编址的问题"></a>分类编址的问题</h3><p>1992年因特网面临三个必须尽早解决的问题</p><ol><li>B类地址在1992年分配了近一半，眼看很快就将全部分配完毕</li><li>因特网主干网上的路由表中的项目数急剧增长（由几千个增长至几万个）</li><li>整个IPV4的地址空间最终将全部耗尽，在2011年2越3日，IANA宣布IPV4地址已经耗尽了</li></ol><p>IETF研究采用无分类编址的方法来解决前两个问题，其认为第三个问题属于更加长远的问题，因此专门成立IPV6工作组负责研究新版本IP协议的问题</p><h3 id="CIDR最主要的两个特点"><a href="#CIDR最主要的两个特点" class="headerlink" title="CIDR最主要的两个特点"></a>CIDR最主要的两个特点</h3><ul><li><strong>CIDR消除了传统的A类、B类和C类地址及划分子网的概念</strong>，因此可以更加有效地分配IPv4的地址空间，并且在新的IPv6使用前容许因特网的规模继续增长</li></ul><blockquote><p>CIDR把32位的IP地址划分为两个部分，前面的部分是网络前缀，用来指明网络，后面的部分则用来指明主机，其与分类编址最大的不同，便是网络前缀不局限于8的倍数。因此CIDR使IP地址从三级编址（使用子网掩码）又回到两级地址，但这已经是无分类的两级编址。CIDR在IP地址后面加上斜线“/”，然后写上网络前缀所占的位数。<br>IP地址 :: = {&lt;网络前缀&gt;，&lt;主机号&gt;}</p></blockquote><ul><li><strong>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块”</strong>。我们只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（最小地址）和终止地址（最大地址），以及地址块中的地址数。</li></ul><blockquote><p>例如，已知IP地址为128.14.35.7/20是某CIDR地址块中的一个地址，现在把它写成二进制形式，其中前20位是网络前缀，而后面的12位是主机号：<br>128.14.35.7/20 = <strong>10000000 00001110 0010</strong>0011 00000111<br>这个地址块的最小地址为：<strong>10000000 00001110 0010</strong>0000 00000000<br>这个地址块的最大地址为：<strong>10000000 00001110 0010</strong>1111 11111111</p></blockquote><h3 id="CIDR的地址掩码"><a href="#CIDR的地址掩码" class="headerlink" title="CIDR的地址掩码"></a>CIDR的地址掩码</h3><p>为了更方便地进行路由选择，CIDR使用32位的地址掩码（address mask）。地址掩码由一串1和一串0组成，而1的个数就是网络前缀的长度。虽然CIDR不使用子网了，但由于目前一些网络还使用子网划分和子网掩码，因此CIDR使用的地址掩码也可继续称为子网掩码</p><blockquote><p>例如，/20地址块的地址掩码是：11111111 11111111 11110000 00000000（20个连续的1）。斜线记法中，斜线后面的数字就是地址掩码中1的个数</p></blockquote><h3 id="CIDR不划分子网的理解"><a href="#CIDR不划分子网的理解" class="headerlink" title="CIDR不划分子网的理解"></a>CIDR不划分子网的理解</h3><p>另外，“CIDR不使用子网”，是指<strong>CIDR中并没有在32位地址中指明若干位作为子网字段。但分配到一个CIDR地址块的单位</strong>仍然可以在本单位内根据需要划分出一些子网。<strong>这些子网也都只有一个网络前缀和一个主机地址号，但子网的网络前缀比整个单位的网络前缀要长一些</strong></p><blockquote><p>例如，某单位分配到地址块/20，就可以继续划分为8个子网（即需要从主机号中借用3位来划分子网）。这时，每一个子网的网络前缀就变成23位（原来的20位加上主机号借来的3位），比该单位的网络前缀多了3位</p></blockquote><h3 id="路由聚合的概念"><a href="#路由聚合的概念" class="headerlink" title="路由聚合的概念"></a>路由聚合的概念</h3><p>由于一个CIDR地址块有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称为路由聚合（Route aggregation）,它使得路由表中的一个项目可以表示原来传统分类网络地址的很多个路由。路由聚合也称为构成<strong>超网（supernettig）</strong></p><blockquote><p>如果没有采用CIDR，则在1994年和1995年，因特网一个路由器就回超过7万个项目，而使用了CIDR以后，在1996年一个路由表的项目数菜只有3万多个。路由聚合有利于减少路由器之间的路由选择信息交换，提高整个网络性能</p></blockquote><p><img src="https://s1.ax1x.com/2018/11/19/FpQmUx.jpg#shadow" alt=""></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><h4 id="最长前缀匹配的概念"><a href="#最长前缀匹配的概念" class="headerlink" title="最长前缀匹配的概念"></a>最长前缀匹配的概念</h4><p>在使用CIDR时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要做相应的改变。这时，每个项目由<br><strong>“网络前缀”  和  下一跳地址</strong>组成。但是在<strong>查找路由表时可能得到不止一个匹配结果</strong>。这样就带来一个问题：我们应当从这些匹配的结果中选择哪一条路由呢？</p><p>正确的答案是：<strong>应当从匹配结果中选择具有最长网络前缀的路由</strong>。这叫作最长前缀匹配（longest-prefix matching）,这时因为网络前缀越长，其地址块就越小（因为主机位数越少），因而路由就越具体。最长前缀匹配又称为<strong>最佳匹配或最长匹配</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">eg.路由器接收到一个分组R0,它的目的ip地址是132.19.237.5</span><br><span class="line">路由器路由表包含5个目的网络号分别是</span><br><span class="line">132.0.0.0/8   </span><br><span class="line">【前8位是网络前缀，地址掩码11111111 000000000 00000000 00000000】 </span><br><span class="line">132.0.0.0/11</span><br><span class="line">【前11位是网络前缀，地址掩码11111111 11100000 00000000 00000000】</span><br><span class="line">132.19.232.0/22</span><br><span class="line">【前22位是网络前缀，地址掩码11111111 11111111 11111100 00000000】</span><br><span class="line">0.0.0.0/0</span><br><span class="line">【这是默认路由，所有目的网络都不匹配的时候走这里】</span><br><span class="line"></span><br><span class="line">目的ip地址是132.19.237.5</span><br><span class="line">10000100 00010011 11101001 00000101</span><br><span class="line">与上述子网掩码与运算后，匹配的网络地址是</span><br><span class="line">132.0.0.0/8  和 132.0.0.0/11</span><br><span class="line">但是按照最长路由前缀匹配，应该选择走132.0.0.0/11这个网络</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308081951285.png" alt="image.png"></p><h4 id="依据地址位置划分地址快"><a href="#依据地址位置划分地址快" class="headerlink" title="依据地址位置划分地址快"></a>依据地址位置划分地址快</h4><p>如果IP地址的分配从一开始就采用CIDR，那么我们可以按网络所在的地理位置来分配地址块，这样就可以大大减少路由表中的项目数</p><blockquote><p>例如，可以将世界划分为四大地区，每一个地区分配一个CIDR地址块：<br>地址块194/7(194.0.0.0至195.255.255.255)分配给欧洲<br>地址块198/7(198.0.0.0至199.255.255.255)分配给北美洲<br>地址块200/7(200.0.0.0至201.255.255.255)分配给中美洲和南美洲<br>地址块202/7(202.0.0.0至203.255.255.255)分配给亚洲和太平洋地区</p></blockquote><p>上面一个地址块包含约3200万个地址($2^{32}-7$)。这种分配方法使得IP地址与地理位置关联，它的好处是可以大大压缩路由表中的项目数。例如从中国发往北美的数据报（不管它是地址块198/7中的哪一个地址）都先送到美国的一个路由器，因此在路由表中使用一个项目就行了。<br>  但是，在使用CIDR之前，因特网的地址管理机构并没有按照地理位置来分配IP，现在要把已分配的IP地址回收再重新分配是十分困难的事情，因为这牵涉很多正在工作的主机必须改变其IP地址。<strong>所以基于地址位置划分地址块仅仅停留在想法</strong></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><p><mark>网络层协议</mark></p><h3 id="ARP协议的作用"><a href="#ARP协议的作用" class="headerlink" title="ARP协议的作用"></a>ARP协议的作用</h3><p>完成主机或路由器IP地址到MAC地址的映射，解决下一跳走哪的问题</p><blockquote><p><strong>*由于实际网络链路中，传送数据帧时，必须使用MAC地址</strong>，<br>例如：在一个局域网内，所有设备使用同一套链路，主机A想要向同一个网段下的主机B,在数据链路上发送数据帧，肯定需要在帧头加上源MAC地址和目的MAC地址，但是如果主机A不知道主机B的目的MAC地址怎么办？这就需要先检查<strong>ARP高速缓存</strong>，检查是否有主机B的IP地址与MAC地址的映射，如果有，则直接将主机B的MAC地址封装上数据帧，放到链路上传输；如果没有，那么就需要使用ARP协议，主机A向局域网内所有设备广播ARP请求的分组，<strong>同一局域网内所有主机收到该请求</strong>，当主机B收到这个请求分组，发现目的IP就是自己的IP地址，就会向主机A 单播返回一个 带有IP和MAC地址的分组，A得到B的响应，立刻将主机B的ip和MAC地址的映射项写入ARP缓存（<strong>10-20min更新一次</strong>），然后主机A就能向帧头加上目的MAC地址放到链路上传送了</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082116250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308082127346.png" alt="image.png"></p><h2 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h2><p><mark>应用层协议</mark></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt="image.png"></p><h3 id="主机如何获取ip地址？"><a href="#主机如何获取ip地址？" class="headerlink" title="主机如何获取ip地址？"></a><strong><em>主机如何获取ip地址？</em></strong></h3><ul><li><em>动态分配</em></li><li><em>静态分配</em></li></ul><h3 id="什么是动态分配DHCP协议？"><a href="#什么是动态分配DHCP协议？" class="headerlink" title="什么是动态分配DHCP协议？"></a><strong><em>什么是动态分配DHCP协议？</em></strong></h3><p><strong><em>DHCP协议是应用层协议，使用UDP传送</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091011931.png" alt="image.png"></p><h2 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h2><p><mark>网络层协议</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091013671.png" alt=""></p><h3 id="什么是ICMP"><a href="#什么是ICMP" class="headerlink" title="什么是ICMP?"></a><em>什么是ICMP?</em></h3><p>ICMP，全称是 Internet Control Message Protocol，即互联网控制报文协议，所谓控制，就是通过下发指令来感知和控制网络环境，所以它一定是配合一个无法感知网络环境的协议来工作的，这个协议就是 IP(包括 IPv4 和 IPv6)。</p><p>所以，ICMP 通常被认为是 IP 协议的一部分，它封装在 IP 层中，使用 IP 协议进行传输。因此，严格来说，<strong><em>ICMP 既不是一个网络层协议，也不是一个传输层协议，而是介于两者之间的一个协议。但是一般认为属于网络层协议</em></strong></p><p>它的主要功能是传输网络诊断信息，信息主要包括两类：</p><ul><li>一类是 查询类报文 ：主要用于信息的查询和采集，比如采集传输路径上的每个路由器都是谁，本次传输的报文是否达到目的地等等。</li><li>另一类是 差错诊断类报文 ：主要用于诊断网络故障，比如传输报文被丢弃的原因是什么等等。</li></ul><h3 id="为什么需要ICMP？"><a href="#为什么需要ICMP？" class="headerlink" title="为什么需要ICMP？"></a><em>为什么需要ICMP？</em></h3><p>我们都知道，<strong><em>IP 协议是一个不可靠协议</em></strong>，如果 IP 包在传输过程中出现错误，比如 checksum 对不上，拥塞，超时等等，那么 IP 包是会直接被丢弃的，之后也不会有进一步的努力来修正。</p><p>这是 IP 协议的一个设计准则决定的，也就是 best effort，尽力而为，这样的好处是让 IP 协议尽量保持简单的形态，只负责有效率的数据传输，而更多的质量控制交给高层的协议去处理(比如 TCP)。</p><p>但高层能提供质量控制的协议毕竟在少数，所以就需要在下层有协议来辅助 IP 完成必要的网络质量管理。ICMP 协议自然就被提出来了。</p><p>通过 ICMP 协议，当 IP 包发生错误的时候，上层发送 IP 包的主机或路由器并不知道下层发生了错误，这个时候，下层的主机或路由器就可以通过发送 ICMP 包，将错误信息汇报给上层，从而让上层的主机或路由器进行调整。</p><p>不过需要注意的是，<strong><em>ICMP 仅仅只能提供某些特定类型的错误信息汇报，并不能帮助 IP 协议成为可靠的协议</em></strong>。它能做的事还是有限，但用于基本的网络质量管理是足够了。</p><h3 id="ICMP应用场景"><a href="#ICMP应用场景" class="headerlink" title="ICMP应用场景"></a><em>ICMP应用场景</em></h3><h4 id="错误报告"><a href="#错误报告" class="headerlink" title="错误报告"></a><strong>错误报告</strong></h4><p>ICMP 错误消息报告网络错误，例如目的地不可达、超时或分段问题。这些消息对于具有无连接通信模型的用户数据报协议 (UDP) 尤其重要。</p><p>UDP 不提供可靠、有序的数据包传输。发送 UDP 数据包时，数据包可能会丢失，也可能在传送时出现校验和错误等故障。如果发生这种情况，接收方会将 ICMP 错误报告消息发回给发送方，以通知该问题。</p><h4 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a><strong>诊断</strong></h4><p>您可以使用 ICMP 进行网络诊断。它最常用于 <strong><em>ping 和 traceroute</em></strong> 命令。</p><ul><li><p><strong><em>ping 命令通过向目标设备发送 ICMP 回显请求数据包来测试网络设备的可访问性</em></strong>。如果设备可以访问，则会返回 ICMP 回显回复。它可以可靠地检查网络延迟并确保设备可用。</p></li><li><p><strong><em>traceroute 命令跟踪数据包从源到目的地所采用的路径</em></strong>。为此，该命令将回显请求和回显回复消息发送到预定目的地。</p></li></ul><blockquote><p>例如：回显请求包含一个生存时间 (TTL) 值，数据包每通过一个路由器，该值就会减 1。当数据包到达 TTL 为零的路由器时，路由器会向源端发送一条 ICMP 消息。该消息包含有关数据包所采用路由的信息。Traceroute 会显示数据包的确切路径，可以为您提供网络性能详情。</p></blockquote><h3 id="ICMP报文格式长啥样？"><a href="#ICMP报文格式长啥样？" class="headerlink" title="ICMP报文格式长啥样？"></a><em>ICMP报文格式长啥样？</em></h3><ul><li><em>【注意区分，报文是数据部分，报文在网络层封装成IP数据报】</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091035923.png" alt="image.png"></p><p>如下图所示，ICMP 报文是被封装在 IP 数据报中传输的。</p><p>IP 报头中的 Protocol 字段为 1 即表示该报文携带的是 ICMP 报文。(此处只是为了说明问题，因此 IP 报头是简化了的)</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091057587.png" alt="image.png"></p><p>进一步看，ICMP 报头为 4 个字节：</p><ul><li>类型 type：占 1 个字节，表示较大范围类型分类的 ICMP 报文</li><li>代码 code：占 1 个字节，表示较小范围类型分类的 ICMP 报文(type的细分)</li><li>校验和 checksum：占 2 个字节，ICMP checksum 的计算方法类似于 IP checksum，但是不同的是 IP 只校验头部，ICMP 校验头部+数据部分</li></ul><p>后面紧接的 ICMP 数据部分，根据前面的类型和代码字段的不同，具有不同的内容。</p><h3 id="ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】"><a href="#ICMP报文分为-【ICMP差错报文】和【ICMP询问报文】" class="headerlink" title="ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】"></a><em>ICMP报文分为 【ICMP差错报文】和【ICMP询问报文】</em></h3><h4 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a><em>ICMP差错报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091033395.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091104579.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091105405.png" alt="image.png"></p><h4 id="ICMP询问报文"><a href="#ICMP询问报文" class="headerlink" title="ICMP询问报文"></a><em>ICMP询问报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091106410.png" alt="image.png"></p><h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><h3 id="为什么需要IPV6？"><a href="#为什么需要IPV6？" class="headerlink" title="为什么需要IPV6？"></a><em>为什么需要IPV6？</em></h3><p><em>IPv4地址采用32比特标识，理论上能够提供的地址数量是43亿（由于地址分配的原因，实际可使用的数量不到43亿）。另外，IPv4地址的分配也很不均衡：美国占全球地址空间的一半左右，而欧洲则相对匮乏；亚太地区则更加匮乏。与此同时，移动IP和宽带技术的发展需要更多的IP地址。目前IPv4地址已经消耗殆尽。针对IPv4的地址短缺问题，也曾先后出现过几种解决方案。比较有代表性的是无类别域间路由CIDR（Classless Inter-Domain Routing）和网络地址转换NAT（Network Address Translator）。但是CIDR和NAT都有各自的弊端和不能解决的问题，由此推动了IPv6的发展。</em></p><p><strong><em>IPv6地址采用128比特标识。128位的地址结构使IPv6理论上可以拥有（43亿×43亿×43亿×43亿）个地址。近乎无限的地址空间是IPv6的最大优势。</em></strong></p><h3 id="IPV6地址表示方法"><a href="#IPV6地址表示方法" class="headerlink" title="IPV6地址表示方法"></a><em>IPV6地址表示方法</em></h3><ol><li><p><em>IPv6地址总长度为128比特，通常分为8组，每组为4个十六进制数的形式，每组十六进制数间用冒号分隔。例如：FC00:0000:130F:0000:0000:09C0:876A:130B，这是IPv6地址的首选格式。</em></p></li><li><p><em>为了书写方便，IPv6还提供了<strong>压缩格式</strong>，以上述IPv6地址为例，具体压缩规则为：</em></p><ul><li><em>每组中的前导“0”都可以省略，所以上述地址可写为：FC00:0:130F:0:0:9C0:876A:130B</em></li><li><em>地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替，所以上述地址又可以进一步简写为：FC00:0:130F::9C0:876A:130B。</em></li><li><em>需要注意的是，<strong>在一个IPv6地址中只能使用一次双冒号“::”</strong>，否则当计算机将压缩后的地址恢复成128位时，无法确定每个“::”代表0的个数</em></li></ul></li></ol><h3 id="IPv6数据报格式"><a href="#IPv6数据报格式" class="headerlink" title="IPv6数据报格式"></a><em>IPv6数据报格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091306357.png" alt="image.png"></p><h3 id="IPV6与IPV4对比"><a href="#IPV6与IPV4对比" class="headerlink" title="IPV6与IPV4对比"></a><em>IPV6与IPV4对比</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091307625.png" alt="image.png"></p><h3 id="IPV4向IPV6过渡"><a href="#IPV4向IPV6过渡" class="headerlink" title="IPV4向IPV6过渡"></a><em>IPV4向IPV6过渡</em></h3><ul><li><strong>*双栈技术</strong>：主机或路由器同时装有IPV4 和 IPV6两个协议栈，因此，主机既能和IPV4通信，也能和IPv6网络通信。*</li></ul><blockquote><p>IPv6和IPv4是功能相近的网络层协议，两者都基于相同的物理平台，而且加载于其上的传输层协议TCP和UDP又没有任何区别。如果一台主机同时支持IPv6和IPv4两种协议，那么该主机既能与支持IPv4协议的主机通信，又能与支持IPv6协议的主机通信，这就是双协议栈技术的工作机理。</p></blockquote><ul><li><strong>*隧道技术</strong>：在IPV6分组进入IPV4网络时，将IPV6分组封装成IPV4分组；当封装成IPV4分组离开IPV4网络时，再装数据部分（IPV6部分）转发给目的节点。*</li></ul><blockquote><p>利用隧道技术可以通过现有的运行IPv4协议的Internet骨干网络（即隧道）将局部的IPv6网络连接起来，因而是IPv4向IPv6过渡的初期最易于采用的技术。路由器将IPv6的数据分组封装入IPv4，IPv4分组的源地址和目的地址分别是隧道入口和出口的IPv4地址。在隧道的出口处，再将IPv6分组取出转发给目的站点。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091308688.png" alt="image.png"></p><h2 id="路由算法与路由选择协议概述"><a href="#路由算法与路由选择协议概述" class="headerlink" title="路由算法与路由选择协议概述"></a><em>路由算法与路由选择协议概述</em></h2><blockquote><p><em>路由算法</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062114988.png" alt="image.png"></p><blockquote><p><em>路由算法分类</em></p></blockquote><ul><li><em>静态路由算法（非自适应路由算法）：管理员手动配置路由信息</em></li><li><em>动态路由算法（自适应路由算法）：路由器彼此交换信息，自行优化路由表</em><ul><li><em>全局性算法：链路状态路由算法OSPF</em><br>  <em>所有路由器掌握完整的网络拓扑和链路费用</em></li><li><em>分散性算法：距离向量路由算法RIP</em><br>  <em>路由器只掌握物理相连的邻居及链路费用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062115290.png" alt="image.png"></li></ul></li></ul><blockquote><p><em>分层次的路由选择协议</em></p></blockquote><ul><li><strong>*路由选择协议需要分层次</strong><br>1.因为因特网规模大 2.因为许多单位不想让外界知道自己的路由选择协议<em></em>所以就分为多个自治系统AS，并且将不同自治系统可以使用不同协议<em></em>一个AS内使用的RIP、OSPF协议；AS与AS之间使用的BGP协议*</li><li><strong>*自治系统AS</strong>：<br>是单一的技术管理下的一组路由器（这些路由器使用一种AS内部的路由选择协议）；互联网是一个由网络组成的网络。它由成千上万个被称为“自治系统”（autonomous system，AS）的更小网络组成。这些网络中的每一个实际上就是由单一组织运行的一个大型路由器池。如果我们继续将 BGP 比作互联网的邮政服务，那么自治系统就相当于各邮政分局。一个城镇可能有数百个邮箱，但邮箱中的所有邮件都必须先经过本地邮政分局，然后再运送到另一个目的地。自治系统中的内部路由器就好比邮箱。它们将出站流量路由到自治系统，然后使用 BGP 路由将这些流量传输到其目的地。*</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062122986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062126920.png" alt="image.png"></p><h3 id="RIP协议及距离向量算法"><a href="#RIP协议及距离向量算法" class="headerlink" title="RIP协议及距离向量算法"></a><em>RIP协议及距离向量算法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835341.png" alt="image.png"></p><h4 id="RIP协议报文格式"><a href="#RIP协议报文格式" class="headerlink" title="RIP协议报文格式"></a><em>RIP协议报文格式</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议，使用UDP传输数据</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091945467.png" alt="image.png"></p><h4 id="什么是RIP协议？"><a href="#什么是RIP协议？" class="headerlink" title="什么是RIP协议？"></a><em>什么是RIP协议？</em></h4><blockquote><p><em>注意：RIP协议属于<strong>应用层协议</strong>，是一种<strong>分布式的基于距离向量的路由选择协议</strong>适用于与比较小的网络</em></p></blockquote><p><em>RIP协议要求网络中每一个路由器都维护从它自己到其他每一个目的网络的唯一最佳距离记录（即一组距离）。</em><br><em>距离：通常为“跳数”，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此<strong>距离为16表示网络不可达。</strong></em></p><p><em>路由表有三项：目的网络、距离、下一条路由器</em></p><ul><li><strong>*目的网络</strong>：通过该路由器能够到达的网络*</li><li><strong>*距离</strong>：该路由器到达目的网络的最佳距离（跳数）*</li><li><strong>*下一跳路由器</strong>：如果要走这样的最佳距离，需要走过的下一跳路由器<em></em>【直接交付，是指目的网络和该路由器直接相连的】*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091606961.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091718131.png" alt="image.png"></p><h4 id="RIP协议的特点"><a href="#RIP协议的特点" class="headerlink" title="RIP协议的特点"></a><em>RIP协议的特点</em></h4><ol><li><em>仅和<strong>相邻路由器</strong>交换信息。</em></li><li><em>交换的信息是当前本路由器所知道的全部信息，即<strong>自己的路由表。</strong></em></li><li><em>按固定的时间间隔交换路由信息，例如，<strong>每隔 30 秒</strong>。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息（当链路有变化，就不等30s了，比如某个网段不存在了，会立刻告诉。）</em></li></ol><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a><em>距离向量算法</em></h4><p><em>在RIP协议相邻路由器互相交换路由表之后，如何处理，才能得到到达某一个网络的最短距离？这就是距离向量算法所解决的问题</em></p><ol><li><em>修改相邻路由器发来的RIP报文中 <strong>所有表项。</strong><br> 对地址为X的相邻路由器发来的RIP报文，修改此报文中的所有项目：把“下一跳”字段中的地址改为X，并把所有的“距离” 字段 +1。</em></li><li><em>对修改后的RIP报文中的每一个项目，进行以下步骤：</em><br> <em>（1）R1路由表中若没有Net3，则把该项目填入R1路由表</em><br> <em>（2）R1路由表中若有Net3，则查看下一跳路由器地址：</em><ul><li><em>若下一跳是X，则用收到的项目替换源路由表中的项目；</em></li><li><em>若下一跳不是X， 原来距离比从X走的距离远则更新，否则不作处理。</em></li></ul></li><li><em>若180s还没收到相邻路由器X的更新路由表，则把X记为不可达的路由器，即把距离设置为16。</em></li><li><em>返回</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091734766.png" alt="image.png"></li></ol><blockquote><p><em>距离向量算法例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091737534.png" alt="image.png"></p><p><strong><em>解析：</em></strong><br><em>来自B的向量为（5，0，8，12，6，2）；<br>其数字分别对应路由器C通过B 到达(A，B，C，D，E，F) 路由器的距离，<br>由于还有C到B的延迟6,所以每个分量还需要+6；其他的同理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091738922.png" alt="image.png"></p><h4 id="好消息穿的快，坏消息传的慢"><a href="#好消息穿的快，坏消息传的慢" class="headerlink" title="好消息穿的快，坏消息传的慢"></a><em>好消息穿的快，坏消息传的慢</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091835185.png" alt="image.png"></p><h3 id="OSPF协议及链路状态算法"><a href="#OSPF协议及链路状态算法" class="headerlink" title="OSPF协议及链路状态算法"></a><em>OSPF协议及链路状态算法</em></h3><h4 id="OSPF分组格式"><a href="#OSPF分组格式" class="headerlink" title="OSPF分组格式"></a><em>OSPF分组格式</em></h4><blockquote><p><em>注意：OSPF协议是<strong>网络层协议，使用IP数据报传输数据</strong>OSPF协议是不使用UDP数据报传送，而是直接使用IP数据报传送，因此OSPF是被划分到属于网络层协议-这一点考研党要以考纲为标准）<em>**</em></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091941328.png" alt="image.png"></p><h4 id="为什么会有OSPF协议？"><a href="#为什么会有OSPF协议？" class="headerlink" title="为什么会有OSPF协议？"></a><em>为什么会有OSPF协议？</em></h4><p><em>开放式最短路径优先OSPF（Open Shortest Path First）协议是IETF定义的一种<strong>基于链路状态的内部网关路由协议</strong>。</em></p><p><em>为什么会出现OSPF？:因为<strong>RIP是一种基于距离矢量算法的路由协议</strong>，存在着</em></p><ul><li><strong>收敛慢；</strong></li><li><strong>易产生路由环路；</strong></li><li><strong>可扩展性差，最大只能支持15跳。</strong></li></ul><p><em>OSPF的出现很好地解决了上述3个问题</em></p><h4 id="OSPF协议的特点"><a href="#OSPF协议的特点" class="headerlink" title="OSPF协议的特点"></a><em>OSPF协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091934529.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935354.png" alt="image.png"></p><h4 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a><em>链路状态路由算法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091935933.png" alt="image.png"></p><h3 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a><em>BGP协议</em></h3><h4 id="BGP协议报文格式"><a href="#BGP协议报文格式" class="headerlink" title="BGP协议报文格式"></a><em>BGP协议报文格式</em></h4><blockquote><p><em>注意：BGP协议是<strong>应用层协议，使用TCP传送</strong></em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308091948118.png" alt="image.png"></p><h4 id="什么是BGP协议？"><a href="#什么是BGP协议？" class="headerlink" title="什么是BGP协议？"></a><em>什么是BGP协议？</em></h4><p><em>边界网关协议 (BGP) 就是互联网的邮政服务。当有人把一封信投进邮筒时，邮政服务就会处理这封邮件，并选择一条快速、高效的路线将这封信投递给收件人。同样地，当有人通过互联网提交数据时，BGP 负责寻找数据能传播的所有可用路径，并选择最佳的路由，这通常意味着在自治系统之间跳跃。</em></p><h4 id="BGP协议的特点"><a href="#BGP协议的特点" class="headerlink" title="BGP协议的特点"></a><em>BGP协议的特点</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092009810.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092010645.png" alt="image.png"></p><h4 id="BGP协议交换信息过程"><a href="#BGP协议交换信息过程" class="headerlink" title="BGP协议交换信息过程"></a><em>BGP协议交换信息过程</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011121.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092011023.png" alt="image.png"></p><h4 id="BGP协议四种报文"><a href="#BGP协议四种报文" class="headerlink" title="BGP协议四种报文"></a><em>BGP协议四种报文</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092012373.png" alt="image.png"></p><h3 id="三种路由协议的比较"><a href="#三种路由协议的比较" class="headerlink" title="三种路由协议的比较"></a><em>三种路由协议的比较</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308092013263.png" alt="image.png"></p><h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a><em>IP组播</em></h2><h3 id="IP网络的3种数据传输方式"><a href="#IP网络的3种数据传输方式" class="headerlink" title="IP网络的3种数据传输方式"></a><em>IP网络的3种数据传输方式</em></h3><p><em>IPv4协议定义了三种IP数据包的传输方式：单播（unicast）、广播（broadcast）和组播（multicast）。通过对三种包传播方式比较式介绍，可以看到组播方式的优越性。</em><br><em>组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用。它是实现高效局域网组播的重要标识。</em></p><p><strong><em>1.单播方式</em></strong><br><em>单播（Unicast）是在一台源IP主机和一台目的IP主机之间进行。网络上绝大部分的数据都是以单播的形式传输的，例如电子邮件收发、网上银行都是采用单播实现的。</em></p><ul><li><em>一份单播报文，使用一个单播地址作为目的地址。Source向每个接收者发送一份独立的单播报文。如果网络中存在N个接收者，则Source需要发送N份单播报文</em></li><li><em>网络为每份单播报文执行独立的数据转发，形成一条独立的数据传送通路。N份单播报文形成N条相互独立的传输路径</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单播缺点：</span><br><span class="line">1.重复流量过多（每有一个用户就要发送一份同样的数据） </span><br><span class="line">2.消耗设备和链路带宽资源（假如有一百个用户，就要发送一百份数据） </span><br><span class="line">3.难以保证传输支质量（用户数量过大时，会造成发送端和链路上的网络设备因为流量过大以及负载过高而网络瘫痪或死机）</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122114438.png" alt="image.png"></li></ul><p><strong><em>2.广播方式</em></strong><br><em>广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式，是一种点对多点传输方式。</em></p><ul><li><em>一份广播报文，使用一个广播地址作为目的地址。Source向本网段对应的广播地址发送且仅发送一份报文。</em></li><li><em>不管是否有需求，保证报文被网段中的所有用户主机接收。</em><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">广播缺点：</span><br><span class="line">1.地域范围限制（广播报文被限制在一个共享网段中） </span><br><span class="line">2.安全性无法保障（在该网段中所有主机都接收的到广播报文，不管是否想要接收） </span><br><span class="line">3.有偿性无法保障（计费困难）</span><br></pre></td></tr></table></figure></li></ul><p><strong><em>3.组播方式</em></strong><br><em>组播（Multicast）是在一台源IP主机和多台（一组）IP主机之间进行，中间的交换机和路由器根据接收者的需要，有选择性地对数据进行复制和转发</em></p><ul><li><p><em>组播在点对多点的应用上，结合了单播和广播的优势。组播方式下，单一的信息流沿组播分发树被同时发送给一组用户，相同的组播数据流在每一条链路上最多仅有一份。</em></p></li><li><p><em>相比单播，由于被传递的信息在距信息源尽可能远的网络节点才开始被复制和分发，所以用户的增加不会导致信息源负载的加重以及网络资源消耗的显著增加。</em></p></li><li><p><em>相比广播，由于被传递的信息只会发送给需要该信息的接收者，所以不会造成网络资源的浪费，并能提高信息传输的安全性。另外，广播只能在同一网段中进行，而组播可以实现跨网段的传输。</em></p></li></ul><h3 id="组播IP"><a href="#组播IP" class="headerlink" title="组播IP"></a><em>组播IP</em></h3><p><em>组播不可能以某一个主机的IP作为自己的目的IP，但是以太网报文在封装时必须要填入目的IP</em></p><p><em>怎么办？</em></p><p><em>回想一下，组播IP不能以某个主机的IP作为自己的目的IP，换句话说，组播IP不需要考虑主机标识，哪个类型的IP地址没有主机标识，<strong>D类</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308071545601.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122208049.png" alt="image.png"></p><h3 id="组播MAC"><a href="#组播MAC" class="headerlink" title="组播MAC"></a><em>组播MAC</em></h3><p><em>同样地，组播报文在数据链路层需要填充目的MAC地址，如何填充正确的MAC地址呢？</em></p><p><em>单播报文在填入目的MAC时，会通过ARP协议根据目的IP询问目的主机的MAC地址，而组播由于目的IP并不是某个主机的IP，所有无法用ARP协议询问目的MAC。既然ARP寻址方式行不通，组播MAC地址有自己的转换方式</em></p><blockquote><p>*组播MAC地址主要用于一对多的本地网络组播服务,会在路由器、交换机、服务器、IP设备等上使用, 比如：</p><ul><li><em>服务器/工作站 - 在进行组播通信时,服务器和工作站会作为发送端或接收端使用组播MAC地址。比如视频会议软件。</em></li><li><em>游戏主机 - 一些网络游戏主机和服务也可能使用组播MAC地址</em></li></ul></blockquote><p><em>这些实现组播的设备的MAC地址，被称为组播MAC地址，它与平时我们上网网卡的单播MAC地址不同，有以下区别</em></p><blockquote><p><strong>*MAC地址的唯一性只是在单播MAC地址而言</strong>。单播MAC地址用于唯一标识一台网络设备,确实要求全球唯一。但是组播MAC地址用于支持一对多的组播通信,其地址格式规定了前24位是固定值,后24位可以配置。组播MAC地址之所以可以在多台设备上取相同的值,*</p></blockquote><ol><li>组播MAC地址只需要在局域网内的设备上唯一即可,不需要全球唯一。</li><li>组播通信需要将报文复制给多个接收端,所以不能使用唯一的MAC地址。</li><li>通过配置组播MAC的后24位,可以生成多个相同的组播MAC地址。</li><li>不同网络接口可以配置相同的组播MAC地址,以接收同一多播流。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122144515.png" alt="image.png"></li></ol><h3 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a><em>IGMP协议</em></h3><p><em>互联网组管理协议 (IGMP) 是允许多个设备共享一个 IP 地址以便它们可以接收相同数据的协议。IGMP 是一个网络层协议，用于在使用互联网协议版本 4 (IPv4) 的网络上设置多播。具体来说，IGMP 允许设备加入一个多播组。</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122211412.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122214062.png" alt="image.png"></p><h3 id="组播路由选择协议"><a href="#组播路由选择协议" class="headerlink" title="组播路由选择协议"></a><em>组播路由选择协议</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122216955.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308122217429.png" alt="image.png"></p><h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a><em>移动IP</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131124271.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131125560.png" alt="image.png"></p><h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a><em>网络层设备</em></h2><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a><em>路由器</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144391.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144007.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144035.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131144550.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131145981.png" alt="image.png"></p><h2 id="多层次协议汇总"><a href="#多层次协议汇总" class="headerlink" title="多层次协议汇总"></a><em>多层次协议汇总</em></h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131528802.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a><em>习题</em></h2><h3 id="网络层的功能-1"><a href="#网络层的功能-1" class="headerlink" title="网络层的功能"></a><em>网络层的功能</em></h3><blockquote><p><em>网络层数据报传输是否可靠，取决于协议；如果使用有连接，有确认的协议那就是可靠传输</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131150887.png" alt="image.png"></p><p><em>异构网络互联：中异构网络是指，数据链路层和物理层均不同的网络</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131157448.png" alt="image.png"></p><p><em>网络拥塞是指通信子网中负载增加，随着负载增加，越来越多分组由于等待，过长会被丢弃，所以导致虽然负载增加，但是吞吐率下降</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131159040.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131416251.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131418246.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131420473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131422480.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131424547.png" alt="image.png"></p><p><em>中间路由器和源主机都不知道IP分组到达目的主机需要经过的完整路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131426158.png" alt="image.png"></p><p><em>各层常用协议</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131455900.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131458020.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131501758.png" alt="image.png"></p></blockquote><h3 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a><em>路由算法</em></h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131506707.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131513947.png" alt="image.png"></p><p><em>OSPF协议采用Dijstra最短路径算法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131516568.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131523233.png" alt="image.png"></p></blockquote><h3 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a><em>IPV4</em></h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131535270.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131613278.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131616022.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131621255.png" alt="image.png"></p><p><em>127开头的表示环回地址，不分配给主机；<br>主机号全0，全1也不分配<br>主机号全0，表示本网络；全1表示所有主机</em><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131625892.png" alt="image.png"></p></blockquote><ul><li><em>在所有主机都是使用公网IP时，就<strong>不需要考虑NAT转换</strong>，主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和C目的IP地址；MAC帧额外信息部分，封装A源MAC地址和路由器的MAC地址。</li><li>接着由路由器向C发送：IP数据爆首部，封装路由器自己IP(源IP)，和C的IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(y源MAC)，和C的MAC地址(目的MAC)。</li></ol></li><li><em>当主机使用的内网IP时，多台主机共享路由器的一个公网IP，<strong>需要考虑NAT转换</strong>，(假设A是外网主机，BC是内网主机)主机A通过中间路由器向主机C发送数据</em><ol><li>A向路由器发送：IP数据报首部，封装A源IP地址和路由器的IP地址【因为C的局域网IP不能通信】；MAC帧额外信息部分，封装A源MAC地址和路由器MAC地址(目的)</li><li>路由器向C发送：IP数据报首部，封装路由器自己的IP地址(源IP)，和C的内网IP(目的IP)；MAC帧额外信息部分，封装路由器自己的MAC地址(源MAC)，和C的MAC地址(目的MAC)<br>&gt;<blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131638477.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131643347.png" alt="image.png"></p></blockquote></li></ol></li></ul><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131702214.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308131728805.png" alt="image.png"></p><p><em>IPV4首部，比较重要的几个字段：首部长度，单位4B；总长度，单位1B<br>片偏移，单位8B；</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142150490.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308142153044.png" alt="image.png"></p><p><em>IP分组自能在目的主机中重组</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161537864.png" alt="image.png"></p><p><em>路由聚合，构成超网</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161619359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308161643795.png" alt="image.png"></p><p><em>内部网络ip地址范围</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161717209.png" alt="image.png"></p><p><em>NAT转换表，只有当源ip地址和源端口都对应，才能转换为公网地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308161736068.png" alt="image.png"></p></blockquote><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301059261.png" alt="image.png"></p><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a><em>传输层概述</em></h2><h3 id="什么是传输层？"><a href="#什么是传输层？" class="headerlink" title="什么是传输层？"></a><em>什么是传输层？</em></h3><p>传输层是只有主机才有的层次。<br><strong>传输层的功能</strong>：</p><ol><li>传输层提供进程与进程之间的逻辑通信</li><li>复用和分用</li><li>传输层对收到的报文进行差错检测</li><li>传输层的两种协议<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301103467.png" alt="图片alt"> </p></li></ol><h3 id="传输层的两个协议TCP-amp-UDP"><a href="#传输层的两个协议TCP-amp-UDP" class="headerlink" title="传输层的两个协议TCP&amp;UDP"></a><em>传输层的两个协议TCP&amp;UDP</em></h3><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301105552.png" alt="图片alt"> </p><h3 id="传输层的寻址与端口"><a href="#传输层的寻址与端口" class="headerlink" title="传输层的寻址与端口"></a><em>传输层的寻址与端口</em></h3><p>复用：应用层所有的应用进程都可以通过传输层再传输到网络层。<br>分用：传输层从网络层收到数据后交付指明的应用进程</p><p><mark>端口</mark>：又称为逻辑端口/软件端口，用于标识主机中的应用进程，是传输层的SAP, 与交换机路由器的物理端口不同，是一种虚拟的逻辑端口。</p><p>端口号只有本地意义，在因特网中不同计算机的相同端口是没有联系的。<br>端口号长度为16bit,能表示65536个不同的端口号。</p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301113972.png" alt="图片alt"> </p><div style="background-color: #fffacd;padding:20px;"> 熟知端口号一般是固定的，以下是一些重要的熟知端口号<p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301116873.png" alt="图片alt"></p>在网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程。<center><mark>套接字Socket = (主机IP地址，端口号)</mark></center></div><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><em>UDP协议</em></h2><h3 id="用户数据报协议UDP特点"><a href="#用户数据报协议UDP特点" class="headerlink" title="用户数据报协议UDP特点"></a><em>用户数据报协议UDP特点</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154002.png" alt="image.png"></p><h3 id="UDP数据报首部格式"><a href="#UDP数据报首部格式" class="headerlink" title="UDP数据报首部格式"></a><em>UDP数据报首部格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301154585.png" alt="image.png"></p><h3 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a><em>UDP校验</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301155099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301156204.png" alt="image.png"></p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><em>TCP协议</em></h2><h3 id="TCP协议特点"><a href="#TCP协议特点" class="headerlink" title="TCP协议特点"></a><em>TCP协议特点</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301511230.png" alt="image.png"></p><blockquote><p><em>TCP是面向字节流的，会对数据的每一个字节按序编号，一个字节占用一个序号，再由多个连续字节组成一个传输单位报文</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301539150.png" alt="image.png"></p></blockquote><h3 id="TCP报文段首部格式"><a href="#TCP报文段首部格式" class="headerlink" title="TCP报文段首部格式"></a><em>TCP报文段首部格式</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538164.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538754.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301538099.png" alt="image.png"></p><h2 id="TCP的连接管理"><a href="#TCP的连接管理" class="headerlink" title="TCP的连接管理"></a><em>TCP的连接管理</em></h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>TCP是面向连接的协议，TCP把连接作为最基本的抽象。每一条TCP连接唯一地被通信两端的两个端点所确定。那么，TCP连接的端点是什么呢？TCP连接的端点又叫套接字（socket），根据TCP协议的规定，端口号拼接到IP地址即构成了套接字，即.</p><div style="background-color: #fffacd;padding:20px;"> 套接字 socket = （IP地址：端口号） </div><p>这样一来，TCP连接可以以下式子表示</p><div style="background-color: #fffacd;padding:20px;"> TCP连接 ::= {socket1, socket2} = {（IP1: port1）,（IP2: port2）}</div><p>在面向连接通信中，连接的建立和释放是必不可少的过程。TCP连接的建立采用客户服务器方式，主动发起连接建立的应用进程叫做客户，而被动等待连接的应用进程叫做服务器。  本文主要讲述TCP是如何管理连接的建立和连接的释放的</p><h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><p><mark>图1.三次握手建立TCP连接</mark></p><p><p align="center"> <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301730864.png" alt="图1"> </p><br>图1画出了TCP连接建立的过程。假定图中左端是客户A，右端是服务器B，一开始时，两端都处于CLOSED（关闭）状态。图中的方框分别是端点所处的状态。</p><ol><li>服务器进程准备好接受外来的连接，这通常是通过调用<code>socket</code>，<code>bind</code>，<code>listen</code>这三个函数来完成，我们称之为被动打开（passive open）。然后服务器进程就处于LISTEN状态，等待客户的连接请求，如有，则作出响应。</li><li><p>客户通过调用<code>connect</code>发起主动打开（active open），向服务器发出连接请求报文段，请求中的首部的同步位SYN = 1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能携带数据，则要消耗一个序号。这时，TCP客户进入SYN-SEND（同步已发送）状态。</p><div style="background-color: #fffacd;padding:20px;"> TCP规定，序号（seq）用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。</div></li><li><p>服务器收到客户端连接请求后，必须确认（ACK）客户的SYN报文段。在确认报文段中，把SYN和ACK位都置为1，确认号为ack = x + 1，同时也为自己选择一个初始序号seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时，TCP服务器进入SYN-RCVD（同步收到）状态。</p><div style="background-color: #fffacd;padding:20px;"> TCP规定，若确认号ack = N，则表明：到序号 N - 1为止的所有数据都已正确收到。</div></li><li><p>客户在收到服务器的确认后，还要向服务器进程给出确认。确认报文段的ACK置1，SYN=0，确认号ack = y + 1，而自己的序号seq = x + 1。TCP规定，这个报文段可以携带数据，也可以不携带数据，如果不携带数据，下一个数据报文段的序号仍是seq = x + 1。这时，TCP连接已经建立，客户进入ESTABLISHED（已建立连接）状态。</p></li><li>服务器收到客户的确认后，也进入estab-listen状态。</li></ol><h4 id="为什么需要三次握手"><a href="#为什么需要三次握手" class="headerlink" title="为什么需要三次握手"></a>为什么需要三次握手</h4><p>为什么客户在收到服务器的确认后，还要向服务器发送一次确认呢？这主要是为了防止已失效的连接请求报文段突然又传送到了服务器，因而发生错误。</p><p>考虑一种情况，客户发出连接请求后，但因连接请求报文丢失而未收到确认。于是客户再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。客户共发送了两个连接请求报文段，其中第一个丢失，第二个到达了服务器。没有“已失效的连接请求报文段”。<br>现假定一种异常情况。即客户发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达服务器。本来这是一个早已失效的报文段，但服务器收到此失效的连接请求后，就误认为是客户又一次发出一次新的连接请求。于是就向客户发出确认报文段，同意建立连接。假定不采用三次握手，那么只要服务器发出确认，新的连接就建立了。</p><p>由于现在客户端并没有发出建立连接的请求，因此不会理睬服务器的确认，也不会向服务器发送数据。但服务器却以为新的连接已经建立了，并一直等待客户发送数据。服务器的许多资源就这样白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如刚才的情况下，客户不会向服务器的确认发出确认，由于服务器收不到确认，就知道客户并没有要求建立连接。</p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><p>TCP建立一个连接需要三个报文段，释放一个连接却需要四个报文段。<br>因此释放连接的过程也称之为四次握手。</p><p><mark>图2.TCP释放连接的过程</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308301753176.png" alt="image.png"><br>数据传输结束后，通信的双方可以释放连接。数据传输结束后的客户A和服务器B都处于ESTABLISHED状态，然后进入释放连接的过程</p><ol><li>A的应用进程先发出释放连接报文段，并停止发送数据，主动关闭TCP连接。A把连接释放报文段首部终止位FIN置1，其序号为seq = u。这时A进入FIN-WAIT-1（终止等待1）状态。</li><li>B收到连接释放报文段后即发出确认确认号为ack = u + 1，而自己的序号为seq = v。然后B就进入CLOSE-WAIT（关闭等待）状态。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于半关闭状态，即A已经没有数据要发送了，但B若发送数据，A仍接收。</li><li>A收到来自B的确认后，就进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。</li><li>若B已经没有要向A发送的数据，其应用进程就通知TCP释放 连接。这时B发出的连接释放报文段FIN = 1，还必须重复上次已发送过的确认号ack = u + 1。假定B的序号为w（在半关闭期间B可能又发送了一些数据）。这时B就进入了LAST-ACK（最后确认）状态，等待A的确认。</li><li>A收到了的连接释放报文段后，必须对此发出确认。其确认号为ack = w + 1，而自己的序号为seq = u + 1。然后进入到TIME-WAIT（时间等待）状态。请注意，现在TCP连接还没有释放掉。必须经过时间等待计时器（TIME-WAIT timer）设置的时间 2MSL后，A才进入到CLOSED状态。时间MSL叫做最长报文段寿命（Maximum Segment Lifetime）。</li><li>B只要收到A发出的确认，就进入CLOSED状态。我们注意到，B结束TCP连接的时间要比A早一些。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字扩展与多模块存储器区别</title>
      <link href="/undefined/a9bcdbf2.html"/>
      <url>/undefined/a9bcdbf2.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012237688.jpg" alt="星空 女孩子 好看 唯美 动漫高清壁纸_彼岸壁纸.jpg"></p><p><code>从功能来看:</code><br>字扩展是对存储芯片内部来说的。字扩展只能扩展容量，<strong>对单个存储器进行扩容</strong>，属于一个存储器的一部分，也就是说拥有同一个读写周期。其实是一个比存储器更小的概念，在使用高位交叉编址的时候是不用考虑存储器内部里面有几个芯片，是怎么连接的。</p><p>多模块存储器,说的是存储器，可独立运行，扩充容量的同时，在每个存储模块独立交叉编址的情况下，能提高吞吐率。</p><p><code>从作用来看</code><br>字扩展是为了解决单片存储芯容量有限，将多个存储芯片连接组成一个存储器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012227321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012228058.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">答案是选A。</span><br><span class="line">字位拓展是对于一个存储器而言的，也就是对应着多模块存储中的一个模块（所以多模块存储器又叫做多体并行存储器，这个体就是存储体的意思</span><br><span class="line"></span><br><span class="line">4Kx4的存储芯片通过位扩展--&gt;16K的存储芯片</span><br><span class="line">单块存储芯片容量4K--&gt;地址数=2^12--&gt;也就需要12根低地址线作为地址线接入A15~A4</span><br><span class="line">那么也就是需要16/4=4块存储芯片组合位扩展--&gt;需要2根高位地址线作为片选线A3~A2</span><br><span class="line">--&gt;所以答案A</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哪些方法可以判断一个有向图是否有环</title>
      <link href="/undefined/d30215e4.html"/>
      <url>/undefined/d30215e4.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242342184.jpg" alt="房间 少女 蓝色眼睛 夏天的裙子 室内绿色植物 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><hr><p><code>关键路径能否判断有向图是否有环存在争议</code><br>关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错—&gt;至于通过报错判断是否有环是否可以利用还存在争议</p><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><hr><p><code>深度优先遍历如何判断有向环是否有环？</code><br>基于深度优先遍历，如果只是用来遍历每个结点而不重复，那么会给每个遍历过的结点标记为1，弹栈后标记依旧存在，于是这遍历过的结点会影响其他深度的继续前进。导致不会有重复的出现。</p><p>但是如果通过深度优先遍历来判断有向图是否有环的话，就要在标记1的基础上，给每次弹栈之后的顶点去掉标记(类比为真正意义上的弹栈)。至于为什么要这样做?</p><p>因为首先要搞清楚对于有向图环究竟是什么？就是对一条路径上探索到最深处而不出现首位相连的情况。因此只需满足该次递归直到结束，过程之中不会出现重复顶点即可，如果不清除标记，那么被访问过的顶点如果同时出现在其他深度的递归里面，那么该深度的前进就会碰到所谓”重复的顶点”，但是其实并没有在该条递归中重复出现(并没有环)，那么就无法判断是否有环了。</p><p>下面是一个有向图无环图。从深度优先1—&gt;2—&gt;4,弹栈回到1—&gt;3—&gt;4.<br>在各自的栈内都没有重复元素，说明无环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242226749.png" alt="image.png"></p><p>下面是一个有向环图，深度优先从1—&gt;2—&gt;3—&gt;1,发现重复元素，说明有环存在<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242232058.png" alt="image.png"></p><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><hr><p><code>广度优先遍历无法判断是否有环存在</code><br>为什么广度优先遍历不能判断有向图是否有环存在呢？</p><p>因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</p><p>举下面的例子，每次入栈前都对顶点做了标记，发现，广度遍历对于无环图，也判断为遇到了重复顶点，因此广度优先遍历无法区分有向图的有环情况<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242242396.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模4补码与模2补码</title>
      <link href="/undefined/f711f08b.html"/>
      <url>/undefined/f711f08b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231353117.jpg" alt="女孩男孩 海边风景 时光飞逝动漫壁纸_彼岸壁纸.jpg"></p><p><code>模4补码</code>和<code>模2补码</code>都是把负小数变为正数从而规避负号问题（将负号转为数值）的一种方法。</p><p><strong>*以负小数-0.1101为例</strong></p><p><code>将其原码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不使用模操作，只是将符号位设置为1</span><br><span class="line">[x]原 = 1.1101</span><br></pre></td></tr></table></figure></p><p><code>将其模2补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用模2操作，以2为模，相减求其补码。相当于每次加2，都等于加0</span><br><span class="line">[x]补 = 2 - 0.1101 = 10 - 0.1101 = 1.0011</span><br></pre></td></tr></table></figure></p><p><code>将其模4补码表示时</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模4补码也称变形补码</span><br><span class="line">使用模4操作，以4为模，相减求其补码。相当于每次加4，都等于加0</span><br><span class="line">[x]补 = 4 - 0.1101 = 100 - 0.1101 = 11.0011 </span><br></pre></td></tr></table></figure></p><p>模2补码和模4补码所加的数都是加在符号位上，并不会影响绝对值的大小，所以在进行补码乘法时，通常不会代入符号位进行相乘</p><p>基于模4补码与模2补码的特点<br>模2补码—单符号位<br>模4补码—双符号位</p><p><code>通过符号位判断溢出</code></p><ul><li>一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</li><li>双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</li><li>一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</li></ul><p><code>双符号位溢出情况</code></p><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补码、模与运算</title>
      <link href="/undefined/b988fae0.html"/>
      <url>/undefined/b988fae0.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221829953.jpg" alt="晚上 树 女孩 ɡ 唯美 电脑壁纸_彼岸壁纸.jpg"></p><h3 id="引入补码的原因"><a href="#引入补码的原因" class="headerlink" title="引入补码的原因"></a><code>引入补码的原因</code></h3><hr><p><strong>1.原码的符号位无法参与运算</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如原码 3位数值位，1为符号位</span></span><br><span class="line">[x]原 = <span class="number">1</span> <span class="number">011</span> = <span class="number">-3</span>；</span><br><span class="line">[y]原 = <span class="number">0</span> <span class="number">101</span> = +<span class="number">5</span>；</span><br><span class="line">[x]原+[y]原 = <span class="number">1</span> <span class="number">011</span> + <span class="number">0</span> <span class="number">101</span> = <span class="number">0000</span> =<span class="number">0</span> ；<span class="comment">//值不为5-3=-2</span></span><br></pre></td></tr></table></figure><br><strong>2.将减法变加法</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有负数才有补码</span></span><br><span class="line"><span class="comment">//原因是为了将减法变成加法，用到了取模运算，减去一个数，相当于加上这个数(负数)补码</span></span><br><span class="line"><span class="comment">//例如0-1</span></span><br><span class="line"><span class="number">000</span> - <span class="number">001</span> <span class="comment">//等价于0往前走1格 --&gt;到了-1</span></span><br><span class="line"><span class="number">000</span> + <span class="number">111</span> <span class="comment">//等价于0往后走7格 --&gt;到了-1，因为有个取模运算</span></span><br><span class="line"><span class="comment">//上面这个例子就揭示了补码的意义</span></span><br><span class="line"><span class="comment">//注意只有负数才需要补码，正数不需要，因为机器可以处理正数相加</span></span><br><span class="line"><span class="comment">//这里正数相加也需要取模</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230905588.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305230910775.png" alt="image.png"></p><h3 id="补码的“补”的含义"><a href="#补码的“补”的含义" class="headerlink" title="补码的“补”的含义"></a><code>补码的“补”的含义</code></h3><hr><p>其中<code>模</code>M=10000,所以对于1111来说他的补码就是<code>10000 - 1111 =0001</code>；<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222247351.png" alt="image.png"></p><h3 id="补码加减运算"><a href="#补码加减运算" class="headerlink" title="补码加减运算"></a><code>补码加减运算</code></h3><hr><p>补码相加相减应该并不陌生。但是由于bit限制，存储的位数不够，补码相加或相减得到的数字超过最大或最小值时，就会发生<strong>符号位进位</strong>—&gt;也就是<strong>溢出</strong>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221634678.png" alt="image.png"></p><p>这个时候就需要通过<strong>取模运算</strong>，即有点像循环数组，超过最大模，则回到开始位置<br>所以要想补码计算正确，前提是，两数相加或相减不能超过模的绝对值，不然取模就不准确。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221955806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221757259.png" alt="image.png"></p><h2 id="补码取模"><a href="#补码取模" class="headerlink" title="补码取模"></a><code>补码取模</code></h2><ul><li>定点小数</li><li>定点整数</li></ul><p>补码取模，对于这个具体模的选取，有下面这样的规律。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221657830.png" alt="image.png"></p><p><code>当参加运算的数是定点小数时，模M=2</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700634.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221700274.png" alt="image.png"></p><p><code>当参加运算的数是定点整数时</code><br>模M=2^(n+1),n+1表示n位数值位，1位符号位;n+1代表总共存储位<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">1100</span> <span class="number">0000</span> </span><br><span class="line">[y]补 = <span class="number">1110</span> <span class="number">0000</span></span><br><span class="line"></span><br><span class="line">[x]补 + [y]补 = <span class="number">1100</span> <span class="number">0000</span>+<span class="number">1110</span> <span class="number">0000</span> = <span class="number">1</span> <span class="number">0010</span> <span class="number">0000</span> --&gt;然后再取模<span class="number">2</span>^<span class="number">8</span> --&gt; <span class="number">0010</span> <span class="number">0000</span> (使得数值又落在范围之内)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">再举个小一点的例子</span><br><span class="line">[x]补 = <span class="number">110</span> --&gt; <span class="number">-2</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">110</span> + <span class="number">111</span> = <span class="number">1</span> <span class="number">101</span> --&gt;取模<span class="number">2</span>^<span class="number">3</span> --&gt; <span class="number">101</span> (数值又落回在范围内，恰好表示<span class="number">-3</span>)</span><br><span class="line"></span><br><span class="line">[x]补 = <span class="number">011</span> --&gt; <span class="number">3</span></span><br><span class="line">[y]补 = <span class="number">010</span> --&gt; <span class="number">2</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">011</span> + <span class="number">010</span> =<span class="number">101</span> --&gt; <span class="number">-3</span></span><br><span class="line"></span><br><span class="line">计算正确的前提是参与运算的数字不能大于模。若是大于模，模也需要变大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221814424.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[x]补 = <span class="number">100</span> --&gt; <span class="number">-4</span></span><br><span class="line">[y]补 = <span class="number">111</span> --&gt; <span class="number">-1</span></span><br><span class="line">[x]补 + [y]补 = <span class="number">100</span> + <span class="number">111</span> =<span class="number">1</span> <span class="number">011</span> --&gt; 取模 --&gt; <span class="number">011</span> --&gt;<span class="number">-3</span> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221818894.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>补码的移位</title>
      <link href="/undefined/fe859f5c.html"/>
      <url>/undefined/fe859f5c.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212338262.jpg" alt=""></p><p><code>对补码左移运算</code><br>书里介绍的是补码左移符号位不变，仅仅数值位左移，低位补0.其实这是不准确的说法。这是建立在补码左移数值不溢出的情况。以8bit存举例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1110</span>  补码 <span class="number">-2</span> </span><br><span class="line"><span class="number">1111</span> <span class="number">1100</span>  左移之后 补码<span class="number">-4</span>   </span><br><span class="line"></span><br><span class="line">这是左移没有溢出的情况，发现不溢出的前提下，符号位没有变化</span><br></pre></td></tr></table></figure><br>但是如果负数补码左移，发生了数值溢出，也就是。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span>  补码 <span class="number">-65</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1110</span>  左移 补码 <span class="number">-2</span></span><br><span class="line"></span><br><span class="line">由于<span class="number">8b</span>it小负数<span class="number">-128</span>，<span class="number">-65</span>x2=<span class="number">-130</span>&lt;<span class="number">-128</span>,发生溢出</span><br><span class="line">如果按照符号位不变的规则，仅仅移动数值位，发现并没有左移x2</span><br></pre></td></tr></table></figure><br>以另一种方式左移，也就是将符号位一起参与左移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1011</span> <span class="number">1111</span> 补码 <span class="number">-65</span></span><br><span class="line"><span class="number">10111</span> <span class="number">1110</span> 左移 补码 <span class="number">-130</span></span><br><span class="line">向高位补齐一位存储位，发现就符合左移x2的规则</span><br></pre></td></tr></table></figure><br>因此，实际上机器上处理补码的左移，是连同符号位和数值位一起左移。<br>只是在补码没有溢出的情况下，数值最高位会始终为1，左移补上符号位后，表面上看起来符号位没有发生变化，实际上符号位向高位左移了。<br><strong>所以补码左移连同符号位一起左移，不溢出的情况正负性不改变，溢出的话正负性变化</strong></p><p><code>补码右移</code></p><ul><li>正数补码：高位补0，低位舍去</li><li>负数补码：高位补1，低位舍去</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两者本质上都是符号位参与了移位，只是，右移只会使数值减小，不会发生溢出</span><br><span class="line"></span><br><span class="line">- 对于补码右移:本质上符号位跟着右移，而符号位空了出来，然后根据之前正负性再重新给符号位补上符号，所以表现为以上正负数高位分别补0,补1的规律</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1011</span> <span class="number">1111</span></span><br><span class="line">右移</span><br><span class="line">_011 <span class="number">1111</span></span><br><span class="line">补上符号位</span><br><span class="line"><span class="number">1011</span> <span class="number">1111</span> ---&gt;表现为符号位不动</span><br><span class="line"></span><br><span class="line">正数同理</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/undefined/8d4b7ae1.html"/>
      <url>/undefined/8d4b7ae1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181119031.jpg" alt="白色长头发 黑色衣服 个性超酷女生 ai绘画 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305121847899.png" alt="image.png"></p><h2 id="计算机硬件基本组成"><a href="#计算机硬件基本组成" class="headerlink" title="计算机硬件基本组成"></a>计算机硬件基本组成</h2><h3 id="冯诺依曼机"><a href="#冯诺依曼机" class="headerlink" title="冯诺依曼机"></a>冯诺依曼机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.计算机由五大部件组成</span><br><span class="line">2.指令和数据以同等地位存于存储器，可按地址寻访</span><br><span class="line">3.指令和数据用二进制表示</span><br><span class="line">4.指令由操作码和地址码组成</span><br><span class="line">5.存储程序(将指令以代码形式事先输入计算机主存中，然后按程序规定顺序执行)</span><br><span class="line">6.以运算器为中心</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082011725.png" alt="image.png"></p><h3 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.由于以运算器为中心存取效率低，改为了以存储器为中心</span><br><span class="line">2.CPU=运算器+控制器</span><br><span class="line">3.CPU+主存储器=主机(注意这里的主机与平时说的主机有区别,不包含硬盘、风扇）</span><br><span class="line">4.辅存，就是硬盘归于I/O设备，App存储在辅存，只有运行时，才会将代码读取到主存运行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082012220.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082013350.png" alt="image.png"></p><h3 id="CPU结构"><a href="#CPU结构" class="headerlink" title="CPU结构"></a>CPU结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1971年之后，Intel发明微处理器后，将MAR MDR集成到CPU里</span><br><span class="line">在那之后CPU=运算器+控制器(包括了MAR+MDR)</span><br></pre></td></tr></table></figure><h2 id="各个硬件工作原理"><a href="#各个硬件工作原理" class="headerlink" title="各个硬件工作原理"></a>各个硬件工作原理</h2><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR:存储器地址寄存器，用于存放所要访问的主存单元的地址。与存储器空间有关。</span><br><span class="line">MDR:存储器数据寄存器，用于存放向主存写入的或从主存中读出的信息。与存储字长相等。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082025891.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存储体</span><br><span class="line">1byte字节=8bit比特</span><br><span class="line">1B=1 byte</span><br><span class="line">1b=1 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082110830.png" alt="image.png"></p><h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">乘积高位:两个16位数相乘，结果可能会有32位，那左半部分的16位就是乘积高位，存储到ACC中，右半部分的16位就是乘积低位，存储到MQ中。</span><br><span class="line"></span><br><span class="line">ACC - X = 差</span><br><span class="line">被减数-减数=差；</span><br><span class="line"></span><br><span class="line">ALU：隔在ACC 与 x之间，存储逻辑运算单元</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082219286.png" alt="image.png"></p><h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IR：指令寄存器(从主存储器取出的指令存在这里)</span><br><span class="line">PC：程序计数器，存放下一条指令地址(0,1,2，...)</span><br><span class="line">CU:控制单元，分析指令，给出控制信号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082223627.png" alt="image.png"></p><h3 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082227267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.pc=0指向第一条指令的[主存地址]0，并将0地址放入MAR</span><br><span class="line">2.同时 控制器 通过控制总线 告诉主存储器进行读操作</span><br><span class="line">3.主存储器根据MAR里的地址0取存储体里面的 指令内容(操作码+地址码000001 000000101)放  </span><br><span class="line">  到MDR</span><br><span class="line">4.然后控制器从MDR取走指令(地址码+操作码)，存在IR中</span><br><span class="line">5.IR将指令的[操作码]送给CU分析，是[取数]操作;IR将[地址码]送到MAR，导致MAR=0000000101=5</span><br><span class="line">6.主存储器根据MAR=5,将对应数据放到MDR=0000000000010=2</span><br><span class="line">7.在控制单元指挥，MDR中数据放到ACC中，ACC=2</span><br><span class="line"></span><br><span class="line">基本流程</span><br><span class="line">由pc地址，获取指令--&gt;IR存放并拆分指令--&gt;CU分析操作码指令;获取地址码数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305082231550.png" alt="Uploading file...dva2d"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305090954868.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305091113638.png" alt="image.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常把MAR、MDR也集成在CPU里面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101016612.png" alt="image.png"></p><h2 id="计算机系统层次结构"><a href="#计算机系统层次结构" class="headerlink" title="计算机系统层次结构"></a>计算机系统层次结构</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101024404.png" alt="image.png"></p><h2 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编译程序</span><br><span class="line">1.分别经过编译器(翻译为汇编)，汇编器(翻译为二进制)</span><br><span class="line">2.一次性全部翻译，无许再次翻译(下次执行可以执行编译好的文件)</span><br><span class="line">解释程序</span><br><span class="line">1.只经过编译器(直接翻译为二进制)</span><br><span class="line">2.翻译一句，立即执行，接着翻译下一句，且不保存(下次执行还需编译)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101027138.png" alt="image.png"></p><h2 id="程序转换过程"><a href="#程序转换过程" class="headerlink" title="程序转换过程"></a>程序转换过程</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">预处理--&gt;编译--&gt;汇编--&gt;链接</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122248015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249809.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个模块都有一个相对地址(以自己为参照物)，链接为可执行文件.exe后装入的是磁盘当中，并且获得一个虚拟的内存地址(因为磁盘不是内存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122249316.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入--&gt;执行时装入</span><br><span class="line">是将磁盘中的可执行文件在需要运行用到的时候才装入内存，这里有个地址转换，虚拟地址变成真实的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122252113.png" alt="image.png"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1~8</button></li><li class="tab"><button type="button" data-href="#test1-2">9</button></li><li class="tab"><button type="button" data-href="#test1-3">10</button></li><li class="tab"><button type="button" data-href="#test1-4">11</button></li><li class="tab"><button type="button" data-href="#test1-5">12</button></li><li class="tab"><button type="button" data-href="#test1-6">13</button></li><li class="tab"><button type="button" data-href="#test1-7">14</button></li><li class="tab"><button type="button" data-href="#test1-8">15</button></li><li class="tab"><button type="button" data-href="#test1-9">16</button></li><li class="tab"><button type="button" data-href="#test1-10">17</button></li><li class="tab"><button type="button" data-href="#test1-11">18</button></li><li class="tab"><button type="button" data-href="#test1-12">19</button></li><li class="tab"><button type="button" data-href="#test1-13">20</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1.完整的计算机系统应包括(D)</span><br><span class="line">A.运算器、存储器、控制器   外部设备和主机</span><br><span class="line">C. 主机和应用程序    D. 配套的硬件设备和软件系统</span><br><span class="line"></span><br><span class="line">解析：A是计算机主机的组成部分，而B、C只涉及计算机系统的部分内容，都不完整。</span><br><span class="line"></span><br><span class="line">2.冯·诺依曼机的基本工作方式是（A）。</span><br><span class="line">A.控制流驱动方式</span><br><span class="line">B.多指令多数据流方式</span><br><span class="line">C.微程序控制方式</span><br><span class="line">D.数据流驱动方式</span><br><span class="line"></span><br><span class="line">解析：数据驱动方式分为：控制流驱动、数据流驱动</span><br><span class="line">控制流驱动：指令--&gt;数据 (计算机先取出指令，指令告诉我们需要什么数据，然后操作)</span><br><span class="line">数据流驱动：数据--&gt;指令 (首先直到想要什么数据，然后取出指令，对数据进行操作)</span><br><span class="line"></span><br><span class="line">3.下列（B）是冯诺依曼机工作方式的基本特点。</span><br><span class="line">A.多指令流单数据流</span><br><span class="line">B.按地址访问并顺序执行指令</span><br><span class="line">C.堆栈操作</span><br><span class="line">D.存储器按内容选择地址</span><br><span class="line"></span><br><span class="line">解析：A冯诺依曼机是单指令但数据流  BD其他机器也有 C即存储程序特点</span><br><span class="line"></span><br><span class="line">4.以下说法错误的是（D）。</span><br><span class="line">A.硬盘是外部设备</span><br><span class="line">B.软件的功能与硬件的功能在逻辑上是等效的</span><br><span class="line">C.硬件实现的功能一般比软件实现具有更高的执行速度</span><br><span class="line">D.软件的功能不能用硬件取代</span><br><span class="line"></span><br><span class="line">解析：C硬件执行速度比软件快，比如C语言需要编译在执行，而硬件可以直接执行，速度更快</span><br><span class="line">D软件的功能都能有硬件取代</span><br><span class="line"></span><br><span class="line">5.存放欲执行指令的寄存器是（D）。</span><br><span class="line">A.MAR</span><br><span class="line">B.PC</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">6.在CPU中，跟踪下一条要执行的指令的地址的寄存器是（A）。</span><br><span class="line">A.PC</span><br><span class="line">B.MAR</span><br><span class="line">C.MDR</span><br><span class="line">D.IR</span><br><span class="line"></span><br><span class="line">7.CPU不包括（C）。</span><br><span class="line">A.地址寄存器</span><br><span class="line">B.指令寄存器(IR)</span><br><span class="line">C.地址译码器</span><br><span class="line">D.通用寄存器</span><br><span class="line"></span><br><span class="line">解析：地址译码器是存储体里面的用于识别地址的部分，不属于CPU里</span><br><span class="line"></span><br><span class="line">8.在运算器中，不包含（D），</span><br><span class="line">A.状态寄存器</span><br><span class="line">B.数据总线</span><br><span class="line">C.ALU</span><br><span class="line">D.地址寄存器</span><br><span class="line"></span><br><span class="line">解析：D选项MAR集成在CPU中控制器里，不在运算器中</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">越靠近CPU存取速度越快。</span><br><span class="line">Cache是高速缓冲存储器，使得主存中部分数据存储在Cache中避免每次都从主存中找，提高存取速度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122138723.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A数据通路是数据在部件之间的传送路径</span><br><span class="line">C程序运行时如果存储在硬盘当中，那么读取数据的速度就会非常慢，所以不会在硬盘当中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122143557.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">软件分为系统软件和应用软件。</span><br><span class="line">- 系统软件：直接和底层交互，保证计算机正确高效运行的基础软件(操作系统、数据库管理系统、语言处理系统..)</span><br><span class="line">- 应用软件：为了解决某个应用领域问题特意编写的软件(Pr、youtub、数据库系统..)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122148503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 编译程序：例如编译器，将高级语言编译为汇编</span><br><span class="line">- 连接程序：例如程序中引用别人的库函数需要连接程序</span><br><span class="line">- 两者都输系统软件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122149189.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122157766.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122200685.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122205755.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相邻存储器，既可以按内容寻址，也可以按地址寻址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122208926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122222345.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">翻译程序有三种：</span><br><span class="line">- 汇编程序：汇编语言--&gt;机器语言</span><br><span class="line">- 编译程序：高级语言--&gt;机器语言(部分高级语言会先编译为汇编语言，在汇编为机器语言)</span><br><span class="line">- 解释程序：高级语言--&gt;机器语言</span><br><span class="line"></span><br><span class="line">链接程序只负责逻辑块顺序的调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122229446.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为指令和数据都用二进制表示，所以计算机如何区分指令和数据呢？</span><br><span class="line">- 根据指令周期，根据指令和数据确定指令周期，在这个周期里取的的一定是指令或数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122236217.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-12"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122242300.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-13"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305122257268.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="计算器的性能指标"><a href="#计算器的性能指标" class="headerlink" title="计算器的性能指标"></a>计算器的性能指标</h2><h3 id="存储器性能指标"><a href="#存储器性能指标" class="headerlink" title="存储器性能指标"></a>存储器性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR：32位(能存储32个二进制位)--&gt;2^32个地址</span><br><span class="line">MDR：8位(存储字长=每个存储单元大小)</span><br><span class="line"></span><br><span class="line">1个MAR 对应 1个MDR--&gt;容量(总字长)2^32*8 bit =4GB</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101041517.png" alt="image.png"></p><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU主频：1s内脉冲信号的次数，单位Hz,10Hz表示每秒10个脉冲信号</span><br><span class="line">CPU时钟周期=主频周期=节拍：1个脉冲信号所需时间 = 1/CPU主频</span><br><span class="line">CPI：执行1个指令所需时钟周期数</span><br><span class="line"></span><br><span class="line">CPU执行时间：程序执行时间=（CPI*指令条数)/主频</span><br><span class="line"></span><br><span class="line">IPS：每秒执行多少指令=主频/CPI</span><br><span class="line"></span><br><span class="line">FLOPS:每秒可以进行多少次浮点操作</span><br><span class="line"></span><br><span class="line">通常会给IPS、FLOPS加数量单位K M G T (注意：与内存大小表示数量级不一样)</span><br><span class="line">描述存储容量、文件大小时：K=2^10,M=2^20,G=2^30,T=2^40</span><br><span class="line">描述频率、速率时：K=10^3,M=10^6,G=10^9,T=10^12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101054549.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101113160.png" alt="image.png"></p><h3 id="系统整体性能指标"><a href="#系统整体性能指标" class="headerlink" title="系统整体性能指标"></a>系统整体性能指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基准程序(跑分软件)：是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同的其它计算机程能进行比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101124844.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101122590.png" alt="image.png"></p><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU CPI MIPS MFLOPS概念理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130930318.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">提升CPU性能主要途径是采用并行技术，是CPU空闲部分运作起来</span><br><span class="line"></span><br><span class="line">计算机结构主要分两种结构</span><br><span class="line">- 冯诺依曼结构：存储程序</span><br><span class="line">- 哈佛结构：程序数据分开存储</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130943319.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 寄存器的基本单元是D触发器</span><br><span class="line">- D是输入、CP是控制信号、Q是输出</span><br><span class="line">- 只有当CP信号为1时，才能接受保存D输入信号(0/1)；</span><br><span class="line"></span><br><span class="line">- 计算机数据处理时，一次存取、加工和传送的数据bit位数长度，称为“字”</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305130952586.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 存储字长</span><br><span class="line">- 指令字长</span><br><span class="line">- 机器字长：计算机一次能直接处理的二进制位长度</span><br><span class="line">- 数据字长：计算机数据总线(数据传输线)，一次能并行传送信息的位数，与MDR没有直接关联，加 入MDR存储字长是16bit,数据字长4bit,那么数据总线需要分4次传输。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131005683.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32/64位微机，指的是，机器字长32/64,也就是一次性直接处理二进制数据位数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131021918.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">科学计算的计算机，涉及到很多浮点运算，所以，MFLOPS是衡量参数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131025498.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">透明的概念是指不可见</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131036759.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU周期，也称为机器周期，因为CPU执行速度很快，但是从主存中存取数据很慢，所以以从内存中读取一条指令的最短时间来定义机器周期</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131058578.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPI 一条指令所需要的时钟周期个数</span><br><span class="line">提高时钟频率，程序执行变快,也就是一条指令所需时间变短，但是由于周期也变短，所以周期个数还是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131102562.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><h3 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">八进制  0,1,2,3,4,5,6,7</span><br><span class="line">十进制  0,1,2,3,4,5,6,7,8,9</span><br><span class="line">十六进制  0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101436044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任意进制--&gt;十进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101441427.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">二进制一&gt;八进制</span><br><span class="line">3位一组，每组转换成对应的八进制符号</span><br><span class="line"></span><br><span class="line">二进制一&gt;十六进制</span><br><span class="line">4位一组，每组转换成对应的十六进制符号</span><br><span class="line"></span><br><span class="line">八进制一&gt;二进制</span><br><span class="line">每位八进制对应的3位二进制</span><br><span class="line"></span><br><span class="line">十六进制一&gt;二进制</span><br><span class="line">每位十六进制对应的4位二进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101447378.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制--&gt;二进制</span><br><span class="line">整数部分 /2 </span><br><span class="line">小数部分 x2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101452817.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101507643.png" alt="image.png"></p><h3 id="进制常见书写方式"><a href="#进制常见书写方式" class="headerlink" title="进制常见书写方式"></a>进制常见书写方式</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305101450476.png" alt="image.png"></p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCD码是二进制编码的十进制数的表示方式</span><br><span class="line">分为：8421码、8421余3码、2421码</span><br></pre></td></tr></table></figure><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8421码</span><br><span class="line">- 四个二进制位表示十进制数的基本数字1~9(有6个冗余)</span><br><span class="line">- 8、4、2、1分别对应每一位的权值 </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>0111</th><th>1000</th><th>1001</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">但是当数字&gt;9时，虽然四个二进制位能表示，但是比如13--&gt;1101，但是却不在映射表里,1101没有意义</span><br><span class="line"></span><br><span class="line">所以+6校正，1101+0110=19=10011=&gt;0001 0011 后半部分3,前半部分可以看做10，虽然在二进制位上是19,但是这样表示13更加有规律</span><br></pre></td></tr></table></figure><h3 id="余3码"><a href="#余3码" class="headerlink" title="余3码"></a>余3码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">余3码：8421码+(0011) </span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0011</th><th>0100</th><th>0101</th><th>0110</th><th>01111</th><th>1000</th><th>1001</th><th>1010</th><th>1011</th><th>1100</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="2421码"><a href="#2421码" class="headerlink" title="2421码"></a>2421码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2421码</span><br><span class="line">- 改变权值定义，四位二进制位权值改为2、4、2、1 例如：1101--&gt;1x2 + 1x4 + 0x2 + 1x1 </span><br><span class="line">- 为了避免歧义(例如5表示可以是0101 ,也可以是1011)，规定5以上的数字首位为1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>0000</th><th>0001</th><th>0010</th><th>0011</th><th>0100</th><th>1011</th><th>1100</th><th>1101</th><th>1110</th><th>1111</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr></tbody></table></div><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102252444.png" alt="image.png"></p><h2 id="无符号整数的表示和运算"><a href="#无符号整数的表示和运算" class="headerlink" title="无符号整数的表示和运算"></a>无符号整数的表示和运算</h2><hr><h3 id="无符号数表示"><a href="#无符号数表示" class="headerlink" title="无符号数表示"></a>无符号数表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.无符号数，寄存器bit限制，超出寄存器大小，强行硬塞，数据丢失</span><br><span class="line">2.对于无符号数，表示的都是非负整数，无原码、补码、反码一说</span><br><span class="line">3.n bit 无符号数表示范围0~2^n -1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102300100.png" alt="image.png"></p><h3 id="无符号数的运算"><a href="#无符号数的运算" class="headerlink" title="无符号数的运算"></a>无符号数的运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加法运算：从低位到高位按位相加</span><br><span class="line">减法运算：计算机只能加法运算--&gt;2-5=-3；对5取反+1，再与2相加</span><br></pre></td></tr></table></figure><h2 id="带符号整数的表示和运算"><a href="#带符号整数的表示和运算" class="headerlink" title="带符号整数的表示和运算"></a>带符号整数的表示和运算</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.原码、补码、反码都是对一个带符号数的不同表示方式</span><br><span class="line">2.n+1个bit位，最高位0/1表示正负；剩余n-1bit表示数值真值；</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原码表示"><a href="#原码表示" class="headerlink" title="原码表示"></a>原码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.对于真值0分为[+0]:0000 0000  ; [-0]:1000 0000</span><br><span class="line">2.缺点是符号位不能参与运算，导致原码无法进行+-之间加减运算</span><br><span class="line">3.带符号数的原码表示范围：-(2^n - 1)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102332263.png" alt="Uploading file...ogu40"></p><h3 id="补码表示"><a href="#补码表示" class="headerlink" title="补码表示"></a>补码表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 正数 原码--&gt;补码：不变（正数，原码、反码、补码一致）</span><br><span class="line">- 负数 原码--&gt;补码：符号位不变，数值位取反(先转反码)；然后+1(转补码)</span><br><span class="line">- 负数 补码--&gt;原码：符号位不变，取反+1</span><br><span class="line">- n+1个bit补码表示范围：-(2^n)~2^n - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305102353746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手算，负数 原码转补码：从右往左找到第一个1，这个1左边的所有“数值位“按位取反&quot;</span><br><span class="line">- 逆向转换方法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110006401.png" alt="image.png"></p><h3 id="补码加法运算"><a href="#补码加法运算" class="headerlink" title="补码加法运算"></a>补码加法运算</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码符号位也能参与运算</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110837267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-19+(-19)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110839169.png" alt="image.png"></p><h3 id="补码减法运算"><a href="#补码减法运算" class="headerlink" title="补码减法运算"></a>补码减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将减法变加法</span><br><span class="line">A-B --&gt; [A]补-[B]补 --&gt; [A]补 + [-B]补</span><br><span class="line"></span><br><span class="line">[B]补 &lt;--&gt; [-B]补 将全部位按位取反，再+1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110848785.png" alt="image.png"></p><h3 id="各种码性质总结"><a href="#各种码性质总结" class="headerlink" title="各种码性质总结"></a>各种码性质总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">为什么补码0只有0000 0000 一种表示方式？为什么1000 0000不表示-0，而表示-128？</span><br><span class="line">1.因为，</span><br><span class="line">[+0]原=0000 0000 --&gt;[0]补=0000 0000 </span><br><span class="line">而</span><br><span class="line">[-0]原=1000 0000 --&gt;[-0]补=1111 1111 + 1 =0000 0000</span><br><span class="line">所以[+0]原,[-0]原 对应补码都是0000 0000，那么 [0]补 只有一种表示方式</span><br><span class="line"></span><br><span class="line">2.因为补码是一种取模的运算</span><br><span class="line">...如下图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211806007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305110908583.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">bit数</th><th style="text-align:center">3bit</th><th style="text-align:center">4bit</th><th style="text-align:center">8bit</th></tr></thead><tbody><tr><td style="text-align:center">二进制补码最小值</td><td style="text-align:center">100</td><td style="text-align:center">1000</td><td style="text-align:center">1000 0000</td></tr><tr><td style="text-align:center">对应真值</td><td style="text-align:center">-4</td><td style="text-align:center">-8</td><td style="text-align:center">-128</td></tr></tbody></table></div><h3 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 移码：补码的基础上将符号位取反。注意：移码只能用于表示整数</span><br><span class="line">- 如果机器字长n+1bit，那么移码表示范围-(2^n - 1)~2^n -1,与补码表示范围相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111350911.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111342134.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111355197.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111402641.png" alt="image.png"></p><h2 id="定点小数"><a href="#定点小数" class="headerlink" title="定点小数"></a>定点小数</h2><hr><h3 id="定点小数概念"><a href="#定点小数概念" class="headerlink" title="定点小数概念"></a>定点小数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定点整数(带符号整数)</span><br><span class="line">- 小数点默认位置在最后面</span><br><span class="line">- 能由原、反、补、移码表示</span><br><span class="line">定点小数</span><br><span class="line">- 小数点默认在符号位之前一位</span><br><span class="line">- 能由原、反、补码表示</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111403221.png" alt="image.png"></p><h3 id="定点小数表示范围"><a href="#定点小数表示范围" class="headerlink" title="定点小数表示范围"></a>定点小数表示范围</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111413977.png" alt="image.png"></p><h3 id="定点小数扩展"><a href="#定点小数扩展" class="headerlink" title="定点小数扩展"></a>定点小数扩展</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定点小数扩展，是往小数点后面扩展bit位</span><br><span class="line">定点整数是往小数点前扩展bit位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111419042.png" alt="image.png"></p><h3 id="定点小数加减法运算"><a href="#定点小数加减法运算" class="headerlink" title="定点小数加减法运算"></a>定点小数加减法运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">处理逻辑与定点整数处理方法相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111425594.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111428306.png" alt="image.png"></p><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.BCD码四位一组，表示一个十进制数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131536385.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 16进制表示符号：0x --&gt; 前标 ； H --&gt;尾标</span><br><span class="line">- 16进制表示，为了区分16进制和二进制，例如 11无法区分是16进制的11 还是二进制的3</span><br><span class="line">- 10进制标识符号：D --&gt; 尾标 </span><br><span class="line">- 2进制标识符号：B --&gt; 尾标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131540652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">精度低的无法表示精度高的单位，所以存在有的十进制小数转换为二进制的时候</span><br><span class="line">例如： 10进制：0.3 --&gt;二进制位数会无限循环下去，无法完全表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131604025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">移码是将补码的符号位取反</span><br><span class="line">由于补码对0只有一种表示</span><br><span class="line">所以移码也只有一种表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131609746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码对0有两种表示，所以能表示的数就少一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131616588.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制能表示2^N个数</span><br><span class="line">十进制能表示10^N个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131628462.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解题目意思</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131637220.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现，规律，当数字为2的n次方时，对应二进制补码就是1000...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131648836.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x为0或正数都满足条件</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131702569.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二进制转为16进制，将二进制位4个一组，最后加H标注16进制</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131707032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码、补码、反码、移码判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131726740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131728858.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码表示范围-128~127</span><br><span class="line">移码0000 0000 --&gt;补码1000 0000 (128),--&gt;[-x]=128，超出补码范围，所以--&gt;移码也表示不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131732736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主存地址都是正数，所以用无符号数表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131737071.png" alt="image.png"></p><h2 id="运算方法与运算电路"><a href="#运算方法与运算电路" class="headerlink" title="运算方法与运算电路"></a>运算方法与运算电路</h2><hr><h3 id="最基本逻辑运算"><a href="#最基本逻辑运算" class="headerlink" title="最基本逻辑运算"></a>最基本逻辑运算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">与、或、非</span><br><span class="line">其中 与 或 是双目运算符(3个数参与运算)；非 是单目运算符(只有一个数参与运算)</span><br><span class="line"></span><br><span class="line">与：相当于数学中的乘法运算</span><br><span class="line">或：相当于加法运算</span><br><span class="line"></span><br><span class="line">两者符合分配率、结合律</span><br><span class="line"></span><br><span class="line">利用这一点可以将实际中的电路问题--&gt;用数学表达式描述出来--&gt;化简表达式--&gt;化简电路</span><br><span class="line"></span><br><span class="line">逻辑表达式，实际上就是对电路的数学描述，对表达式的简化，就是对电路的简化，省钱</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141754713.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111452785.png" alt="image.png"></p><h3 id="复合逻辑"><a href="#复合逻辑" class="headerlink" title="复合逻辑"></a>复合逻辑</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与非： 先与后非</span><br><span class="line">或非： 先或后非</span><br><span class="line">异或：两边不同输出1，两边相同输出0</span><br><span class="line">同或：两边不同输出0，两边相同输出1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305111507023.png" alt="image.png"></p><h3 id="电路的加法器设计"><a href="#电路的加法器设计" class="headerlink" title="电路的加法器设计"></a>电路的加法器设计</h3><hr><h4 id="一位全加器FA"><a href="#一位全加器FA" class="headerlink" title="一位全加器FA"></a>一位全加器FA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Si:本位的和，当Ai Bi Ci-1 其中只有1个1时，Si才会为1</span><br><span class="line">2.Ci:本位的进向下一位的进位，当Ai Bi Ci-1存在两个1时才为1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141835311.png" alt="image.png"></p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.串行加法器：只含有一个全加器，外加一个进位触发器(用于存储进位信号，参与下一次运算)</span><br><span class="line">2.由于串行加法器的特点，只能一位一位的进行运算，运算效率较低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141839155.png" alt="image.png"></p><h4 id="串行进位的并行加法器"><a href="#串行进位的并行加法器" class="headerlink" title="串行进位的并行加法器"></a>串行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.并行加法器：将n个全加器串接起来，就尅进行两个n位数的相加</span><br><span class="line">2.但是，这种只有当低位运算完进位之后，才能进行下一位的运算，这中间进位数据的传输比较慢，影响效率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141844080.png" alt="image.png"></p><h4 id="并行进位的并行加法器"><a href="#并行进位的并行加法器" class="headerlink" title="并行进位的并行加法器"></a>并行进位的并行加法器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.并进进位的并行加法器</span><br><span class="line">- 首先将每一位对应的Ai Bi 存入一位全加器中</span><br><span class="line">- 再同时运算Ai Bi得到Gi Pi,然后低位将Gi Pi 传给所有高位</span><br><span class="line">- 这样所有位就同时拥有了所有需要的数据</span><br><span class="line">- 然后再同时进行加法运算，得到结果</span><br><span class="line"></span><br><span class="line">优点：非常快，几乎进位都是同时产生的</span><br><span class="line">缺点：位数越高的电路设计越复杂(逻辑表达式很长--&gt;电路就复杂)</span><br><span class="line"></span><br><span class="line">所以最多套到C4,也就是最多将4个FA 并行串联</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141908629.png" alt="image.png"></p><h4 id="补码加减运算器"><a href="#补码加减运算器" class="headerlink" title="补码加减运算器"></a>补码加减运算器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- Sub:加减法控制信号；0--&gt;加法 1--&gt;减法</span><br><span class="line">- 多路选择器接收Sub控制信号，0(加法)，补码直接传入；1(减法)，补码全部按位取反，输入</span><br><span class="line">- 同时Cin接收Sub信号，0(+0) ，1(+1,实现取反+1)</span><br><span class="line"></span><br><span class="line">同样也能实现有符号数的+ - 运算；加法直接按位相加，减法取反+1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142056585.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142136732.png" alt="image.png"></p><h4 id="标志位的生成"><a href="#标志位的生成" class="headerlink" title="标志位的生成"></a>标志位的生成</h4><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142220933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142159184.png" alt="image.png"></p><h5 id="OF-Overflow-Flag"><a href="#OF-Overflow-Flag" class="headerlink" title="OF:Overflow Flag"></a>OF:Overflow Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- OF判断有符号数是否发生溢出，OF=1，溢出</span><br><span class="line">- OF=最高位进位⊕次高位进位</span><br><span class="line">1011 + 1001 = 1 0100 --&gt; 只有符号位进位 溢出</span><br><span class="line">0100 + 0100 =   1000 --&gt; 只有次高位进位 溢出</span><br><span class="line">1111 + 1100 = 1 1011 --&gt; 符号位和次高位都进位，不溢出</span><br><span class="line">- OF对无符号位加减法无意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142216317.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142203384.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进位都是1的情况，任然1⊕1=0，没有溢出，如下</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142157255.jpg" alt="IMG20230514215554.jpg"></p><h5 id="SF-Sign-Flag"><a href="#SF-Sign-Flag" class="headerlink" title="SF: Sign Flag"></a>SF: Sign Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- SF符号标志位，SF=最高位本位和，SF=0表示正数，SF=1表示负数；</span><br><span class="line">- 起始很好理解，当补码运算完得到的结果，依然是补码--&gt;原码（转换过程符号位不变，所以补码正负就是原码正负）</span><br><span class="line">- 同样只对有符号数有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142217411.png" alt="image.png"></p><h5 id="ZF-Zero-Flag"><a href="#ZF-Zero-Flag" class="headerlink" title="ZF: Zero Flag"></a>ZF: Zero Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ZF标志运算结果是否为0，ZF=1说明结果为0</span><br><span class="line">- 对有符号数和无符号数都有意义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142221513.png" alt="image.png"></p><h5 id="CF-Carry-Flag"><a href="#CF-Carry-Flag" class="headerlink" title="CF: Carry Flag"></a>CF: Carry Flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 进位/借位标志位，表示无符号数的加减法是否发生了进位或借位</span><br><span class="line">- CF判断无符号数是否溢出,CF=1时说明无符号数发生溢出</span><br><span class="line">- CF=最高位产生的进位⊕Sub</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142226856.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142231563.png" alt="image.png"></p><h3 id="定点数的移位运算"><a href="#定点数的移位运算" class="headerlink" title="定点数的移位运算"></a>定点数的移位运算</h3><hr><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><h5 id="原码的移位"><a href="#原码的移位" class="headerlink" title="原码的移位"></a>原码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原码的移位--符号位保持不变，仅对数值位移位</span><br><span class="line">右移高位补0，低位舍弃；若舍弃位=0，则相当于÷2；若舍弃位=1，则精度丢失</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142255621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左移低位补0，高位舍弃，若舍去位=0，则相当于x2;若舍弃的位=1，则出现严重误差</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142259507.png" alt="image.png"></p><h5 id="反码的移位"><a href="#反码的移位" class="headerlink" title="反码的移位"></a>反码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">反码移位</span><br><span class="line">- 正数反码=原码，所以移位与原码一致</span><br><span class="line">- 负数反码 右移高位补1，低位舍去；左移低位补1，高位舍去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142314217.png" alt="image.png"></p><h5 id="补码的移位"><a href="#补码的移位" class="headerlink" title="补码的移位"></a>补码的移位</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">补码移位</span><br><span class="line">- 正数补码=原码，所以移位与原码一致</span><br><span class="line">- 负数补码 右移高位补1，低位舍去；左移低位补0，高位舍去(想象成转为原码移位，有一个取反+1的操作)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142308220.png" alt="image.png"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑移位看做是无符号数的算数移位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305142324825.png" alt="image.png"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不带进位位：左移时将最高位同时送往最低位和CF符号标志位</span><br><span class="line">带进位为：左移将最高位送往CF,同时将CF原来的数送往最低位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182147315.png" alt="image.png"></p><h3 id="定点数的乘除运算"><a href="#定点数的乘除运算" class="headerlink" title="定点数的乘除运算"></a>定点数的乘除运算</h3><h4 id="原码乘法运算"><a href="#原码乘法运算" class="headerlink" title="原码乘法运算"></a>原码乘法运算</h4><hr><h5 id="手算乘法-二进制"><a href="#手算乘法-二进制" class="headerlink" title="手算乘法(二进制)"></a>手算乘法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.乘法要错位相加，原因是位权不同</span><br><span class="line">2.二进制乘法与十进制乘法基本一致</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182156868.png" alt="image.png"></p><h5 id="原码的一位乘法"><a href="#原码的一位乘法" class="headerlink" title="原码的一位乘法"></a>原码的一位乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.X存放被乘数；MQ存放乘数</span><br><span class="line">2.ACC开始前置为0</span><br><span class="line">3.MQ每一次将最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">4.例如开始时，ACC=00000+1*01101=01101</span><br><span class="line">5.接着MQ右移一位，ACC也右移一位补在MQ高位；此时ACC=00110 ;MQ=10101</span><br><span class="line">6.重复MQ最低位 与X相乘，得到的数与ACC相加</span><br><span class="line">7.ACC=00110 + 1*01101=10011 </span><br><span class="line">8.循环上述过程，直至MQ乘数的符号位位于最低位</span><br><span class="line">9.这样巧妙地实现了错位相加，也解释了为什么ACC存储乘积高位，MQ存储乘积低位</span><br><span class="line">10.最后修改乘积的符号位 xs⊕ys=1⊕0=1,为负数</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">- 乘数和被乘数的最高位为符号位，都设为0,也就是只有数值位参与运算，最后才通过异或逻辑运  </span><br><span class="line">  算，改变ACC中乘积符号位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182210010.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182222001.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">手算模拟</span><br><span class="line">1.乘法过程中均为逻辑右移</span><br><span class="line">2.部分积和被乘数要取双符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182248501.png" alt="image.png"></p><h4 id="补码乘法运算"><a href="#补码乘法运算" class="headerlink" title="补码乘法运算"></a>补码乘法运算</h4><h5 id="补码的一位booth乘法"><a href="#补码的一位booth乘法" class="headerlink" title="补码的一位booth乘法"></a>补码的一位booth乘法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.为什么要采用双符号位补码运算？</span><br><span class="line">- 因为所有寄存器都统一使用n+2位,n个真值位，2个符号位</span><br><span class="line">- 这里双符号位是ACC和X寄存器中使用；MQ是单符号位，最后一位对多一个辅助位(初始为0)</span><br><span class="line"></span><br><span class="line">2.根据 [辅助位-MQ最低位] 确定加什么</span><br><span class="line">- 辅助位-MQ中最低位=1时，(ACC)+[x]补</span><br><span class="line">- 辅助位-MQ中最低位=0时，（ACC+0</span><br><span class="line">- 辅助位-MQ中最低位=-1时，(ACC)+[-x]补</span><br><span class="line"></span><br><span class="line">3.最后当MQ符号位处于最低位时，还要多一次加法运算(辅助位-符号位)</span><br><span class="line"></span><br><span class="line">4.MQ符号位之前的n位，补位在ACC最终值后面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182323608.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305182319721.png" alt="image.png"></p><h4 id="乘法总结"><a href="#乘法总结" class="headerlink" title="乘法总结"></a>乘法总结</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.部分积和被乘数都采用双符号位</span><br><span class="line">2.原码一位乘法累加n次(n为数值位)；补码booth乘法累加n+1次(辅助位一直与前一位判断直到符号位，所以多一次累加)</span><br><span class="line">3.位移次数都是n次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt=""></p><h4 id="原码的除法运算"><a href="#原码的除法运算" class="headerlink" title="原码的除法运算"></a>原码的除法运算</h4><h5 id="手算除法-二进制"><a href="#手算除法-二进制" class="headerlink" title="手算除法(二进制)"></a>手算除法(二进制)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">由于每一位的商只能是0或1</span><br><span class="line">所以当除数&gt;剩余部分，上0；反之上1</span><br><span class="line">由于这里展示的机器字长最多5位，确定五位商就停止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201016899.png" alt="image.png"></p><h5 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.ACC 存储被除数或余数的真值(符号位=0)；X中存储除数真值|y|;                     MQ中存储商 (默认初始都为0)。</span><br><span class="line">2.MQ最低位作为上商位，先默认上商1</span><br><span class="line">3.(ACC)+[-|y|]补 &lt; 0 说明相减结果小于0，上商应该为0;(ACC)+|y| --》恢复余数</span><br><span class="line">4.得到余数，余数末尾补0</span><br><span class="line">5.ACC 和MQ统一逻辑左移一位；</span><br><span class="line">6.MQ继续上商1，看余数是否&lt;0;..逻辑左移..MQ上商...</span><br><span class="line">7.最后符号位单独异或处理</span><br><span class="line">8.ACC中存储的最终的余数实际=(ACC)x2^-n --&gt;(n是数值位数，小数点左移n位)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035336.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201038613.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201035783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201036756.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><h5 id="加减交替法-不恢复余数"><a href="#加减交替法-不恢复余数" class="headerlink" title="加减交替法(不恢复余数)"></a>加减交替法(不恢复余数)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">每次上商位1得到余数为负时，都需要加回除数的补码，这样效率低。</span><br><span class="line">有没有当余数为负时，更加高效的算法呢？</span><br><span class="line"></span><br><span class="line">=&gt;加减交替法</span><br><span class="line"> </span><br><span class="line">1.假设上商1，得到余数负数a,恢复余数加回除数补码b,即a+b</span><br><span class="line">2.然后余数(ACC)左移一位(相当于x2),即2(a+b)</span><br><span class="line">3.继续上商1，2(a+b)-b=2a+b;</span><br><span class="line"></span><br><span class="line">1.假设上商1，得到余数正数a,无需回复余数</span><br><span class="line">2.然后余数(ACC)左移一位，即2a</span><br><span class="line">3.然后上商1，2a-b </span><br><span class="line"></span><br><span class="line">==&gt;发现当余数为负数时，MQ商先改为0，[恢复余数(a+b)，再左移1位2(a+b)]，下一轮商1，减去除数==&gt;2a+b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line">==&gt;发现当余数为正数时，MQ商1不变，[无需恢复余数，将余数a左移一位(2a)],下一轮商1，减去除数==&gt;2a-b</span><br><span class="line">直接就得到了下一轮新余数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201242501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 若余数为负则可直接商0,让余数左移1位再加上除数得到下一个新余数</span><br><span class="line">- 若余数为正则商1，让余数左移1位再减去余数</span><br><span class="line"></span><br><span class="line">- 最后一步如果余数是负数，那么无需再跳步，直接恢复余数--&gt; +[|y|补]得到正确余数</span><br><span class="line">- 最后正确余数的正负性=商的正负性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201237524.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 前面的加减法进行n+1次</span><br><span class="line">- 每次加减确定一位商，左移n次，因为最后一位商确定后不需要左移</span><br><span class="line">- 最后如果余数是负数，还要再进行一次恢复余数的加法</span><br><span class="line">- 所以加减法总次数可能是n+1,也可能是n+2次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201245837.png" alt="image.png"></p><h4 id="补码的除法运算"><a href="#补码的除法运算" class="headerlink" title="补码的除法运算"></a>补码的除法运算</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201405373.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201406368.png" alt="image.png"></p><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU 运算逻辑单元 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211111916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串行进位的并行加法器，影响速度的关键主要是进位延迟，因为只有当低位运算结束产生进位信息之后高位才开始运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211122175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进位生成信号g,由本位两位数相加生成的进位</span><br><span class="line">进位传递信号P,由于上一位的进位传递生成的进位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211132098.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALU算数逻辑单元，包括算数运算。逻辑运算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211145021.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参考补码的移位</span><br><span class="line">注意</span><br><span class="line">正数补码与原码移位相同；</span><br><span class="line">负数时，左移低位补0(因为转换为原码时，有个取反+1操作)；右移高位补1就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211157256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不带进位位的循环位移</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211204568.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">易错</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211450757.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单符号位判断溢出，是判断与输入的符号位是否相同</span><br><span class="line">双符号位判断溢出，是判断两个符号位是否相同</span><br><span class="line">两者都是异或判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211507346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个二进制位来表示符号位，其余位与补码相同，【例如模2补码的-3为1101,模2用1位，这里是最高位表示符号位，剩下3位是3的补码，同样模4补码表示-3为11_101,模4用两位表示符号位，这里是最高两位11，其余3位为3的补码】总的说来就是符号位左边那一位表示正确的符号(_**这就说明了选择题里面存储模4补码只需要一个符号位是正确的，因为任意一个正确的数值，模4补码的符号位两个都是一样的，只需存储一个就行了)，0为正，1为负；右边那一位如果和左边的相同，如 &quot;00”表示正且无溢出，&quot;11&quot;表示负且无溢出。如果右边那一位与左边那一位不一样，则表示有溢出。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211537444.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 一位符号位判断溢出：参与操作的两个符号数相同，但计算结果与原操作数不同，则溢出了</span><br><span class="line">- 双符号位判断溢出：两个符号位存储相同的符号数，当计算之后结果两个符号位不同，说明溢出</span><br><span class="line">- 一位符号位+进位情况：符号位进位与最高位数值位产生的进位相同时无溢出，否则溢出</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>s1s2符号位</th><th>表示情况</th></tr></thead><tbody><tr><td>s1s2=00</td><td>表示结果为正，无溢出</td></tr><tr><td>s1s2=01</td><td>表示结果正溢出</td></tr><tr><td>s1s2=11</td><td>表示结果为负，无溢出</td></tr><tr><td>s1s2=10</td><td>表示结果负溢出</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211547635.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211553302.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211555833.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原码一位乘与补码booth乘法运算总结</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211612186.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终乘积，2n+1位，n次移位，n个原本数值位数，1符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211629251.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">补码左移不出现错误，前提是最高位不保存信息</span><br><span class="line">负数时，1表示无信息：正数时，0表示无信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211703620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1字节=1byte =8 bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211710642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OF溢出标志--&gt;什么时候会溢出？</span><br><span class="line">- 正数加负数永远不可能会溢出</span><br><span class="line">- 溢出只可能是正数+正数=负数(过大);负数+负数=正数(过小)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211720950.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">动手练习</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211758167.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 该计算机存储方式采用小端存储--&gt;从左到右,地址从低到高--&gt;低位数据存储在低位地址</span><br><span class="line">- 该计算机采用按边界对齐存储，一个字是32bit=4byte(字节) ，保证边界对齐即可如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211843283.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小端存储、对齐存储方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212132173.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CF 借位标志：判断数值最高位有没有向更高位借位，表现为补码就是数值最高位有没有产生进位</span><br><span class="line"></span><br><span class="line">只有当更小的数-更大的数的时候，才会发生借位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212156620.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ - ^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212218720.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;O&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305212223536.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">补码原码移位的本质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221628714.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/fe859f5c.html">补码的移位 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305221901254.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/b988fae0.html">补码、模与运算 | 风起之时 (fqzs.netlify.app)</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题求A+B补码</span><br><span class="line">方式1.将A、B转换成对应补码，然后将两个补码相加，然后取模(2^(n+1))</span><br><span class="line">方式2.手算将两个数运算结果算出来，-9-5=-14;接着-14转换为补码，然后取模</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222136591.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变形补码也称模4补码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305222236202.png" alt="image.png"><br><a href="https://fqzs.netlify.app/undefined/f711f08b.html">模4补码与模2补码 | 风起之时 (fqzs.netlify.app)</a></p><h3 id="C语言中强制类型转换"><a href="#C语言中强制类型转换" class="headerlink" title="C语言中强制类型转换"></a>C语言中强制类型转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意C语言中定点整数是用补码存储的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无符号数转变为有符号数</span></span><br><span class="line"><span class="comment">//不改变数据内容，改变解释方式</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;                      <span class="comment">//1110 1111 0001 1111 --&gt; -4321</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> y =(<span class="type">unsigned</span> <span class="type">short</span>)x;<span class="comment">//1110 1111 0001 1111 --&gt; 61215</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.长整数转变为短整数</span></span><br><span class="line"><span class="comment">//高位截断低位保留</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">165537</span>,b=<span class="number">-34991</span>;             <span class="comment">//a: 0x000286a1</span></span><br><span class="line"><span class="type">short</span> c=(<span class="type">short</span>)a, d=(<span class="type">short</span>)b       <span class="comment">//c:     0x86a1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.短整数转变为长整数</span></span><br><span class="line"><span class="comment">//符号位扩展</span></span><br><span class="line"><span class="type">short</span> x=<span class="number">-4321</span>;             <span class="comment">//x: 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">int</span> m=x;                   <span class="comment">//m: 1111 1111 1111 1111 1111 1110 1111 0001 1111</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> n=(<span class="type">unsigned</span> <span class="type">short</span>)x;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> p =n;                          </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201423386.png" alt="image.png"></p><h3 id="数据的存储和排列"><a href="#数据的存储和排列" class="headerlink" title="数据的存储和排列"></a>数据的存储和排列</h3><h4 id="大小端存储"><a href="#大小端存储" class="headerlink" title="大小端存储"></a>大小端存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">大端存储：低位地址存储高位字节，高位地址存储低位字节 --&gt;符合阅读习惯</span><br><span class="line">小端存储：低位地址存储低位字节，高位地址存储高位字节 --&gt;便于机器处理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201439101.png" alt="image.png"></p><h4 id="边界对齐存储"><a href="#边界对齐存储" class="headerlink" title="边界对齐存储"></a>边界对齐存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现代计算机通常按字节编址--&gt;也就是一个字节需要一个地址存放</span><br><span class="line"></span><br><span class="line">寻找地址方式有多种</span><br><span class="line">- 按字节寻址,无需序号转换，第几号字节就是对应第几号地址</span><br><span class="line">- 按半字寻址,一个半字=2字节，需要序号转换，第几个半字转换为第几个字节--&gt;序号x2</span><br><span class="line">- 按字寻址，一个字=4字节，序号转换，第几个字转换为第几个字节--&gt;序号x4</span><br><span class="line"></span><br><span class="line">边界对齐方式--&gt;访问同一个字/半字长度的数据--&gt;只需要一次--&gt;当这个字剩余空间无法存储一个完整数据时，就会浪费剩余空间，存储在下一个字里面(空间换时间)</span><br><span class="line"></span><br><span class="line">边界不对齐--&gt;访问同一个字/半字长度的数据时--&gt;有可能分开存储在不同的字里面，需要两次读取，然后拼接--》没有空间浪费(时间换空间)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201451614.png" alt="image.png"></p><h3 id="浮点数的表示与运算"><a href="#浮点数的表示与运算" class="headerlink" title="浮点数的表示与运算"></a>浮点数的表示与运算</h3><h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">阶码:例如2^8,阶码=8</span><br><span class="line">尾数：常用原码或补码表示的定点小数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201527561.png" alt="image.png"></p><h4 id="浮点数位数的规格化"><a href="#浮点数位数的规格化" class="headerlink" title="浮点数位数的规格化"></a>浮点数位数的规格化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浮点数，尾数数值部分，最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202236948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双符号位，当溢出发生时，可以挽救，更高位的符号位是正确符号位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202205855.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原码表示的尾数进行规格化过后(最高位数值位必须有效=1)</span><br><span class="line">正数：最大值0.111...1;最小值0.10...0; --&gt;表示范围1/2&lt;=M&lt;=1-2^n</span><br><span class="line">负数：最大值1.100...0;最小值1.11...1; --&gt;表示范围-(1-2^n)&lt;=M&lt;=-1/2</span><br><span class="line">补码表示的尾数进行规格化后(最高位数值位必须有效，正数最高位=1，负数最高位=0)</span><br><span class="line">正数：与原码一致(因为正数补码=原码)</span><br><span class="line">负数：最大值1.01...1;最小值1.00...0 --&gt;表示范围-1&lt;=M&lt;=-(1/2 + 2^-n) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202244388.png" alt="image.png"></p><h4 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h4><h5 id="移码定义"><a href="#移码定义" class="headerlink" title="移码定义"></a>移码定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">移码=真值+偏置值(这里单纯看做无符号数进行加减)</span><br><span class="line">对于8bit数</span><br><span class="line">令偏置值=128，则移码恰好=补码符号位取反</span><br><span class="line">令偏置值=127，则移码就是另一种对应关系了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"></p><h5 id="IEEE-754规格化"><a href="#IEEE-754规格化" class="headerlink" title="IEEE 754规格化"></a>IEEE 754规格化</h5><hr><blockquote><p>本结重点</p><ul><li>IEEE 754标准</li><li>十进制转换成二进制浮点数`</li><li>二进制浮点数转换成十进制`</li><li>IEEE 754规格化表示的浮点数范围</li><li><code>要表示的数绝对值要更小怎么办？</code></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准</span><br><span class="line">1.尾数部分原码表示；阶码部分用移码表示；</span><br><span class="line">2.位数部分的数符放在最左端(阶码前面)</span><br><span class="line">3.尾数部分默认最高位有一个1，如下，真实的尾数部分要加个1--&gt; 1.M</span><br><span class="line">4.阶码真值=移码-偏移量；如下 E-127</span><br><span class="line">5.阶码全1，全0作特殊用途，不参与表示范围</span><br><span class="line">6.这里规定移码的偏置值=2^(n-1)-1</span><br><span class="line">7.移码1111 1111 表示-128 ；移码0000 0000 表示-127</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305202329313.png" alt="image.png"></p><p><code>十进制转换成二进制浮点数</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305210946320.png" alt="image.png"></p><p><code>二进制浮点数转换成十进制</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211008947.png" alt="image.png"></p><p><code>IEEE 754规格化表示的浮点数范围</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？</span><br><span class="line">- 最小绝对值；尾数全为0(因为尾数部分默认隐藏了一个1)，阶码真值最小-126,对应移码表示0000 0001，此时整体真值(1.0)x2^-126</span><br><span class="line">- 最大绝对值：尾数全为1，阶码真值最大127，对应移码表示1111 1110，此时整体的真值为(1.11...11)x2^127</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211019218.png" alt="image.png"></p><p><code>要表示的数绝对值要更小怎么办？</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">周知，阶码全为0 表示的是-127，但是阶码规定全0用作其他用途</span><br><span class="line"></span><br><span class="line">- 当阶码全0，固定视作阶码=-126，且尾数隐藏最高位是0(也就是说非规格化了，这样最高位是0，也就能表示更小的绝对值)</span><br><span class="line">- 当阶码全0，尾数M全0时，表示真值+-0</span><br><span class="line"></span><br><span class="line">- 当阶码全1，尾数M全0时，表示正负无穷，具体正负看符号位</span><br><span class="line">- 当阶码全1，尾数M不全为0时，表示非数值&quot;NaN(Not a Number)&quot;(如0/0，∞-∞这样的非法运算)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305211046415.png" alt="image.png"></p><h4 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h4><blockquote><p>运算步骤</p><ul><li><code>对阶</code>: 小阶向大阶靠齐</li><li>尾数求和 ：对阶之后位数相加</li><li>规格化：使得形式为 x . mmm</li><li>舍入 : 由于存储字长有限，规定只能保留x为有效尾数</li><li>判溢出<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305280019397.png" alt="Uploading file...laoi3"></li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对阶、位数加减、规格化、判溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281217040.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">舍入</span><br><span class="line">1.&quot;0&quot;舍&quot;1&quot;入法</span><br><span class="line">采用双符号位，当对符号位产生进位时，低位的符号位产生变化，此时对整体进行算数右移，同时阶码+1，由于右移，最低位会舍去--&gt;此时规定&quot;0&quot;舍&quot;1&quot;入，--&gt;当最低位0直接舍去，当最低位为1,往高位进一位1，也就是移位后末尾+1。这种方法可能</span><br><span class="line"></span><br><span class="line">2.恒置&quot;1&quot;法</span><br><span class="line">尾数右移时，无论丢掉最低位时“1”还是&quot;0&quot;都是右移后的尾数末尾恒置&quot;1&quot;,这种方法同样有使尾数变大变小的两种可能</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281226346.png" alt="image.png"></p><h4 id="浮点数强制类型转换"><a href="#浮点数强制类型转换" class="headerlink" title="浮点数强制类型转换"></a>浮点数强制类型转换</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">float : 1符号位 + 8阶码 + 23位尾数(最高位隐含一个1,实际有效24位) </span><br><span class="line">double尾数：1符号位 + 11位阶码 + 52位尾数(隐含一个1，实际有效53位)</span><br><span class="line"></span><br><span class="line">32位：</span><br><span class="line">char--&gt;short--&gt;int--&gt;long--&gt;double</span><br><span class="line">float--&gt;double   这些转换不会出现精度丢失</span><br><span class="line"></span><br><span class="line">int:表示整数，范围-2^31~ 2^31-1 ,,有效位数32位</span><br><span class="line">float：表示整数及小数，范围...如下</span><br><span class="line">因为float尾数只有23位(实际24位有效)&lt;int 31位 ，但是由于float有阶码,float可以表示范围更大的数字，所以int转float不会溢出，最多只是由于位数限制丢失部分精度</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281303360.png" alt="image.png"></p><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">运算过程中自动会从低字节转换为高字节类型--&gt;防止数据溢出</span><br><span class="line">虽然long与dobuble都是8字节，但是double能表示的范围更大，所以转换为long</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022102868.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">阶码代表数的范围大小范围；尾数代表着精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022105535.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">基数--&gt;小数点每移动一位，数值扩大或缩小的倍数</span><br><span class="line">所以基数越大，在尾数数量相同的情况下，表示的范围越宽，但是由于跨度大精度也低</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022118721.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">之后规格化之后阶码超出所表示范围，才会发生溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022123969.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">double浮点数阶码：</span><br><span class="line"></span><br><span class="line">移码=真值+偏置值(单纯看做无符号数进行加减)</span><br><span class="line"></span><br><span class="line">阶码11bit --&gt;阶码是用移码表示--&gt;要求真值最大--&gt;移码最大(单纯看做无符号数)</span><br><span class="line">真值=移码的二进制数-偏置值(1023)=1111 1111 110 - 1023 = 2046 - 1023=1023</span><br><span class="line">为什么移码不能是 1111 1111 111？这样不是更大吗？</span><br><span class="line">因为移码全1用于表示无穷或者&quot;NaN(Not a Number)&quot;.所以移码二进制数最大是</span><br><span class="line">除了最低位为0，其他位全1</span><br><span class="line"></span><br><span class="line">double浮点数尾数：</span><br><span class="line">尾数有52为也就是 .111...1(前面隐藏了一个1实际为53位--&gt;1.111...1= 2-2^-52 )</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022248536.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022308311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IEEE 754标准要非常熟悉</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022321441.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 00.. 0000 </span><br><span class="line">分别当做移码、原码、补码 、单精度浮点数</span><br><span class="line">求大小排序？</span><br><span class="line">分析：最高位为1，其中只有移码表示的是正数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022330175.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.并不能增加数据表示范围，数据表示范围主要有阶码决定</span><br><span class="line">B.无论有没有规格化，浮点运算都需要对阶，所以并没有方便浮点运算</span><br><span class="line">C.数据溢出是因为阶码超过表示范围</span><br><span class="line">D.规格化可以使有效值尽可能往前靠，尽可能增加能表示的有效位数--&gt;提高精度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022334896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">浮点数的溢出：</span><br><span class="line">上溢--&gt;是指二进制绝对值超出机器能够表示范围，这里带上正负号就分为正上溢/负上溢</span><br><span class="line">例如:机器只有8bit,能表示最大机器数 1111 1111，但是计算结果是 1 1111 1111就叫</span><br><span class="line">上溢</span><br><span class="line">下溢--&gt;是指二进制绝对值小于机器能够表示范围，这里带上正负号就分为正下溢/负下溢</span><br><span class="line">例如：机器只有8bit,如果要表示 0.000 0000 1 由于只有8bit 只能表示到0.000 0000</span><br><span class="line">所以下溢统一表示成0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306022346384.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031644256.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意这里尾数是采用补码形式</span><br><span class="line">采用的不是IEEE 754标准 ，所以尾数小数点前的那位数代表符号位</span><br><span class="line">根据下面表格，要使得最高位必须是有效值(因为存储bit有限，所以尽可能将后面的有效数字记录下来，这样就尽量减少精度丢失)</span><br><span class="line">基数为2 --&gt; 阶码变化1能一次移动一位小数点，故最高的一位为有效数即最大精度</span><br><span class="line">基数为4 --&gt; 阶码变化1能一次移动两位小数点，故最高两位其中一位有效即最大精度</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031152816.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">舍入只当尾数右移时发生</span><br><span class="line">1.右规时发生</span><br><span class="line">2.对阶相加时发生</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031202320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">阶码(2bit符号位+3bit数值位); 尾数(2bit符号位+5bit数值位)</span><br><span class="line"></span><br><span class="line">X</span><br><span class="line">7 -&gt; 00 111</span><br><span class="line">29 -&gt; 00 11101 -&gt;右移5位-&gt; 00.11101</span><br><span class="line">Y </span><br><span class="line">5 -&gt; 00 101 -&gt;对阶+2-&gt; 00 111</span><br><span class="line">5 -&gt; 00 00101 -&gt;右移3位-&gt; 00.10100 -&gt; 再右移2位-&gt;00.00101</span><br><span class="line">X+Y</span><br><span class="line">尾数相加-&gt; 00.11101 + 00.00101=01.00010-&gt;溢出-&gt;右规-&gt;00.10001 </span><br><span class="line">阶码+1-&gt;01 000-&gt;阶码溢出-&gt;最终结果溢出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031212327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">II. 1.5678E3 = 1567.8 有小数转化为int小数部分会丢掉损失精度</span><br><span class="line">IV. d+f对阶 , f小数点右移97位，尾数只有23位，右移97位数据完全舍去只有0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031231235.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031238006.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C800 0000H 转换为二进制 1100 1000 0000 0000 0000 0000 0000 0000 </span><br><span class="line">当表示为int型时，int是补码表示 ，因此转换为原码--&gt; 1011 1000 0000 0000 0000 ...</span><br><span class="line">当表示为float时，符号位1；阶码 10010000 ；尾数 000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031619213.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如何判断某些小数能否被IEEE 754浮点数表示？</span><br><span class="line">1.将小数转化为分数</span><br><span class="line">2.看分母是否是2^k,如果是，分母就能被约掉，从而能精确表示</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031625124.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-0.4375 </span><br><span class="line">x2 --&gt; -0.875</span><br><span class="line">x2--&gt; -1.75</span><br><span class="line">符号位1，阶码值2，尾数值1.75</span><br><span class="line">--&gt; 阶码=2-127=-125--&gt;0111 1101 </span><br><span class="line">--&gt; 尾数=.1100 ...000(1隐藏了)</span><br><span class="line">最终1 0111 1101 1100 ...000</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031630044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意这里是转换成普通浮点数类型，不是IEEE 754标准</span><br><span class="line">所以尾数最高位是符号位(没有隐藏1)，小数点后一位开始才是数值位最高位</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031653349.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">两个规格化浮点数进行加减</span><br><span class="line">- 尾数溢出时，采用双符号位的第二个符号位的值发生变化，此时就能判断需要进行一次</span><br><span class="line">右规</span><br><span class="line">- 尾数最高位数值位不是有效位时，需要进行左规，具体左规几次，看中间空着几位无效</span><br><span class="line">位</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031657690.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大大大题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306031720160.png" alt="image.png"></p><h1 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h1><h2 id="存储器系统基本概念"><a href="#存储器系统基本概念" class="headerlink" title="存储器系统基本概念"></a>存储器系统基本概念</h2><h3 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 越靠近CPU的读取速度越快，造价越高，容量越小</span><br><span class="line">- Cache——主存.解决了主存与CPU速度不匹配的问题</span><br><span class="line">- 主存——辅存，实现虚拟存储系统，解决了主存容量不够的问题(app存储在辅存，运行时不   断将需要运行的部分代码搬入主存中)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281502936.png" alt="image.png"></p><h3 id="各层存储器的速度与价格"><a href="#各层存储器的速度与价格" class="headerlink" title="各层存储器的速度与价格"></a>各层存储器的速度与价格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">固态硬盘比机械硬盘读写到内存的速度快很多，所以固态硬盘的电脑开机速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281516218.png" alt="image.png"></p><h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按层次分类"><a href="#按层次分类" class="headerlink" title="按层次分类"></a>按层次分类</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">能被CPU直接读取：Cache 主存(内存)</span><br><span class="line">不能被CPU直接读取：辅存、外存</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281524893.png" alt="Uploading file...m8hu5"></p><h4 id="按存储介质分类"><a href="#按存储介质分类" class="headerlink" title="按存储介质分类"></a>按存储介质分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">半导体存储器：主存、Cache</span><br><span class="line">磁性材料存储器：磁盘、磁带</span><br><span class="line">光存储器：光盘...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281529290.png" alt="image.png"></p><h4 id="按存取方式分类"><a href="#按存取方式分类" class="headerlink" title="按存取方式分类"></a>按存取方式分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- RAM(Random Access Memory) ：随机存取存储器，读写任何一个存储单元所需时间相同，随机访问</span><br><span class="line">- SAM(Sequential Access Memory)：顺序存取存储器，读写一个存储单元时间取决于存储单元物理位置。例如磁带，想要读取后面的内容必须，等待磁带滚动到后面</span><br><span class="line">- DAM(Direct Access Memory)：既有随机存取又有顺序存取特性。例如留声机，唱片。可以随机放置唱针，决定其读取位置，又需要顺序播放</span><br><span class="line">- CAM(Content Addressed Memory)：相联存储器，按照内容访问的存储器，上面的3种都是按照地址访问的存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281534267.png" alt="image.png"></p><h4 id="按照信息可更改性分类"><a href="#按照信息可更改性分类" class="headerlink" title="按照信息可更改性分类"></a>按照信息可更改性分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- R/WM(Read/Write Memory)：即可读，也可写。如；磁盘、内存、Cache</span><br><span class="line">- ROM(Read Only Memory): 只能读，不能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281601025.png" alt="image.png"></p><h4 id="按照信息的可保存性"><a href="#按照信息的可保存性" class="headerlink" title="按照信息的可保存性"></a>按照信息的可保存性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">易失性存储器：断电后信息消失，(主存、Cache)</span><br><span class="line">非易失性存储器：断电后信息仍然保留--</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281610963.png" alt="image.png"></p><h3 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281617226.png" alt="image.png"></p><h2 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h2><h3 id="基本的半导体元件及原理"><a href="#基本的半导体元件及原理" class="headerlink" title="基本的半导体元件及原理"></a>基本的半导体元件及原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">存储元由MOS管、电容组成</span><br><span class="line">- MOS管：像是一种电控开关，只有当电压达到阈值x后，才会导电(半导体)</span><br><span class="line"></span><br><span class="line">- 电容：达到一定电压差时，两端电荷移动(给电容充电)；根据电容是否保存了电荷来 </span><br><span class="line">        存储0、1信息</span><br><span class="line">- 如何知道保存的是0 or 1?</span><br><span class="line">通过给MOS管一个阈值电压，使MOS管接通，然后，电容放点，如果保存了电荷，那</span><br><span class="line">么在导线另一头能电测到电流说明信号&quot;1&quot;.无电流则信号&quot;0&quot;</span><br><span class="line"></span><br><span class="line">如图，由8给存储元组成一排，构成一个存储单元(存储字)，同一根红色导线连接8个存储元的MOS管，这样只要给红色导线一个阈值电压，在绿色导线处读取电流信号，就能同时得知8个bit信息。</span><br><span class="line">--&gt;这也是为什么一次读取最多的bit位数被称为存储字，因为一个存储字,MOS管接通了同一根导线。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">存储元：存储一个bit的0、1信息</span><br><span class="line">存储单元：一整行的存储元。也称存储字</span><br><span class="line">存储体：所有的存储单元，构成存储体</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281629015.png" alt="image.png"></p><h3 id="存储器芯片的基本原理"><a href="#存储器芯片的基本原理" class="headerlink" title="存储器芯片的基本原理"></a>存储器芯片的基本原理</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">地址线：输送地址信号到MAR,每根地址线，输送1bit信号</span><br><span class="line">MAR：存储了地址信息(0/1信号)</span><br><span class="line">译码器：将地址信息转化为电信号，传递给字选线</span><br><span class="line">字选线：连接了某一整个字的所有MOS管，字选线接通电压，存储单元内的信号被释放</span><br><span class="line">MDR:存储 存储字给出 的 01信号</span><br><span class="line">数据总线：和CPU连接，总线宽度=存储字长</span><br><span class="line">CPU根据数据总线取的MDR 里的数据</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281654789.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">另外除了上述构造外，还需要控制器来对芯片内部电路工作进行控制</span><br><span class="line">- MAR 中存储的地址的电信号，电信号是不稳定的，控制器控制其只有在稳定之后，才会通过译码 </span><br><span class="line">  器进行翻译.</span><br><span class="line">- MDR 中存储了数据的电信号，同时控制器，控制待其稳定之后，才会通过数据总线送入CPU</span><br><span class="line"></span><br><span class="line">另外，控制器对外提供3种线路：</span><br><span class="line">- 片选线(CS/CE):头上划线表示该信号低电平有效。控制该芯片是否被启用</span><br><span class="line">- 读控制线(OE)：头上划线表示该信号低电平有效。控制此次操作是读数据操作</span><br><span class="line">- 写控制线(WE)：头上划线表示该信号低电平有效。控制此次操作是写数据操作</span><br><span class="line"></span><br><span class="line">此外读写控制线另外一种设计方法:</span><br><span class="line">- 将读写控制线合二为一：低电平写，高电平度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281713066.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">金属引脚：每根外接线都对应一个金属引脚</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281733503.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n位地址--&gt;地址占nbit--&gt;需要n条地址线</span><br><span class="line">n位地址意味着2^n种地址，总容量=2^n x 存储字长</span><br><span class="line">1K=2^10 ,1M=2^20 ,1G=2^30</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281737266.png" alt="image.png"></p><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281755263.png" alt=""></p><h2 id="DRAM-和-SRAM存储芯片"><a href="#DRAM-和-SRAM存储芯片" class="headerlink" title="DRAM 和 SRAM存储芯片"></a>DRAM 和 SRAM存储芯片</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DRAM(Dynamic Random Access Memory):动态RAM ，使用栅极电极 存储信息</span><br><span class="line">SRAM(Static Random Access Memort):静态RAM ，使用双稳态触发器存储信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281810749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容：1个MOS管接通后，通过一个电容放不放电，判断1/0</span><br><span class="line"></span><br><span class="line">- 双稳态触发器：含有6个MOS管，通过A、B 两点的高低电平判断1/0; A电平由左线读取，B电平由右线读取。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281826751.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 栅极电容</span><br><span class="line">读取是破坏性读取(读取完后放电)，读出后应要有重写操作——&gt;&quot;再生&quot;，读写速度慢</span><br><span class="line"></span><br><span class="line">- 双稳态触发器</span><br><span class="line">读取是非破坏，无需重写，读写速度更快</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281848035.png" alt="image.png"></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型特点</th><th style="text-align:center">SRAM</th><th style="text-align:center">DRAM</th></tr></thead><tbody><tr><td style="text-align:center">存储信息</td><td style="text-align:center">触发器</td><td style="text-align:center">电容</td></tr><tr><td style="text-align:center">破坏性读出</td><td style="text-align:center">非</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">读出后是否需要重写</td><td style="text-align:center">不用</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">运行速度</td><td style="text-align:center">快</td><td style="text-align:center">慢</td></tr><tr><td style="text-align:center">集成度</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">发热量</td><td style="text-align:center">大</td><td style="text-align:center">小</td></tr><tr><td style="text-align:center">存储成本</td><td style="text-align:center">高</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">易失/非易失存储器？</td><td style="text-align:center">易失(断电后消失)</td><td style="text-align:center">易失(断电后消失)</td></tr><tr><td style="text-align:center">需要刷新？</td><td style="text-align:center">不需要</td><td style="text-align:center">需要</td></tr><tr><td style="text-align:center">送行列地址</td><td style="text-align:center">同时送</td><td style="text-align:center">分两次送</td></tr><tr><td style="text-align:center">常用作</td><td style="text-align:center">Cache</td><td style="text-align:center">主存</td></tr></tbody></table></div><h3 id="DRAM的刷新"><a href="#DRAM的刷新" class="headerlink" title="DRAM的刷新"></a>DRAM的刷新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">由于DRAM是电容存储电信号，但是电容中的电荷会随着时间的流逝很快消失</span><br><span class="line">==&gt;所以需要给电容中的电荷进行刷新。</span><br><span class="line"></span><br><span class="line">- 多久刷新一次？  </span><br><span class="line"> - 刷新周期为2ms</span><br><span class="line">- 每次刷新多少个存储单元？ </span><br><span class="line"> - 以行为单位，每次刷新一行存储单元。</span><br><span class="line"> - 为什么一行有多个存储单元呢?</span><br><span class="line">- 为什么一行有多个存储单元？</span><br><span class="line"> - 因为假如一行只有一个存储单元，那么假如MAR有20bit,意味着2^20种地址，那</span><br><span class="line"> 就需要2^20条字选线，明显不太可能--&gt;所以将多个存储单元放在一行--&gt;行2^10</span><br><span class="line"> 条字选线，列2^10条字选线，通过矩阵行列方式，大大减少了字选线的根数.</span><br><span class="line">- 如何刷新？</span><br><span class="line">- 有硬件支持，读出一行的信息后重新写入，占用1个读写(存取)周期</span><br><span class="line">- 在什么时候刷新？</span><br><span class="line">    - 因为2ms=2000us,而一个读写周期才0.5us,2ms内能完成4000个读写周期</span><br><span class="line">      加入DRAM内部排列成128字x128字，那么因为一次刷新1行，总共128行，2ms内</span><br><span class="line">      全部刷新也只需要128个读写周期，2ms内足够所有行都刷新好多次了。</span><br><span class="line">    - 刷新分为以下几种策略:</span><br><span class="line">- 分散刷新：每次读写完都刷新一行，读0.5us,刷新0.5us,--&gt;使得存取周期</span><br><span class="line">变为1us</span><br><span class="line">- 集中刷新: 2ms内集中安排一段时间专门用来刷新--&gt;系统的存取周期还是</span><br><span class="line">  0.5us</span><br><span class="line">- 异步刷新: 2ms/128=15.6us,也就是每隔15.6us刷新一行</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305281911916.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291643813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291648554.png" alt="image.png"></p><h3 id="DRAM地址线复用技术"><a href="#DRAM地址线复用技术" class="headerlink" title="DRAM地址线复用技术"></a>DRAM地址线复用技术</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 送行列地址同时送是什么意思？</span><br><span class="line">- 也就是行地址(蓝色),和列地址(红色)，同时分别传输给行地址译码器和列地址译</span><br><span class="line">码器</span><br><span class="line">- 但是，如果地址bit位数很大，不如32位(16bit行地址+16bit列地址)，所需地址线就需要32条，如何才能实现地址线复用？</span><br><span class="line">- 很简单，设置两个地址缓冲器，用于暂时存放行地址和列地址</span><br><span class="line">- 然后只需要n/2条地址线，先将行地址送入行地址缓冲器，然后将列地址的送入列</span><br><span class="line">  地缓</span><br><span class="line">- 最后，行列地址缓冲器，同时将行列地址分别送给行列地址译码器</span><br><span class="line">- 所以DRAM送行列地址不是同时的，而是分为两次</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291715226.png" alt="image.png"></p><h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的分类"><a href="#ROM的分类" class="headerlink" title="ROM的分类"></a>ROM的分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">RAM用作主存、Cache--易失性存储器</span><br><span class="line">ROM只读存储器--非易失性存储器</span><br><span class="line"></span><br><span class="line">ROM:</span><br><span class="line">- MROM</span><br><span class="line">- PROM</span><br><span class="line">- EPROM</span><br><span class="line">- 闪存(Flash Memory)</span><br><span class="line">U盘、SD卡</span><br><span class="line">- 每个存储元只需要存储单个MOS管，位密度比RAM高</span><br><span class="line">- 闪存需要先擦除再写入，所以写的速度比读要慢</span><br><span class="line">- SSD(Solid State Drives)</span><br><span class="line">固态硬盘</span><br><span class="line">- 由控制单元+Flash芯片构成，与闪存区别在控制单元不一样</span><br><span class="line">- 手机辅存也使用Flash芯片，但相比SSD使用的Flash芯片要集成度更高，功</span><br><span class="line">耗低价格更高</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291735194.png" alt="image.png"></p><h3 id="BIOS芯片"><a href="#BIOS芯片" class="headerlink" title="BIOS芯片"></a>BIOS芯片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- BIOS芯片也是ROM存储芯片</span><br><span class="line">- 常说的主板就是主存，但是事实上主板上的BIOS芯片也是主存的一部分</span><br><span class="line">- 逻辑上主存=RAM+BIOS,两者的存储区域是统一编址的</span><br><span class="line">- 统一编址：主存RAM和BIOS统一编址是指，计算机的内存和BIOS芯片的地址空间是连续的，即内存和BIOS芯片的地址空间是统一编址的。这样做的好处是，可以让BIOS直接访问内存，从而加快计算机的启动速度</span><br><span class="line">- </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291745955.png" alt="image.png"></p><h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><h3 id="单块存储芯片与CPU的连接"><a href="#单块存储芯片与CPU的连接" class="headerlink" title="单块存储芯片与CPU的连接"></a>单块存储芯片与CPU的连接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单块存储芯片与CPU连接</span><br><span class="line">数据总线=存储字长</span><br><span class="line">但是如果数据总线&gt;存储字长？要如何扩展?--&gt;位扩展</span><br><span class="line">地址总线根数n--&gt;有2^n个数据地址</span><br><span class="line">但是如果要扩存字数怎么办? --&gt;字扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011440864.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAR MDR实际上是集成在CPU 里</span><br><span class="line">MDR实际上是通过数据总线将数据往返于CPU与主存</span><br><span class="line">MAR实际上是通过地址总线将地址从CPU--&gt;主存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011448514.png" alt="image.png"></p><h3 id="位扩展—增加存储字长"><a href="#位扩展—增加存储字长" class="headerlink" title="位扩展—增加存储字长"></a>位扩展—增加存储字长</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">8k存储单元=8^10=2^13</span><br><span class="line">每块芯片都有2^13个地址可以用来存储字，对应接入的地址总线也就有13根</span><br><span class="line">假如单块存储芯片的存储字长只有1bit--&gt;但是数据总线有8根(8bit宽)--&gt;接入一块新的芯片</span><br><span class="line">1.地址总线与前一块存储芯片一一对应(相当于地址线串联)</span><br><span class="line">2.对两块存储芯片的片选芯片CS都输入相同的电平信号，表示同时启用或弃用</span><br><span class="line">3.前一块的存储芯片的数据总线接入D0,后一块接入D1</span><br><span class="line">4.对两块存储芯片WE读写控制芯片d都输入相同的电平信号--&gt;同时读或写</span><br><span class="line"> --&gt;这样就实现了两块1bit存储字长的存储芯片当做一块2bit存储字长的存储芯片使用</span><br><span class="line"> --&gt;实现了1bit存储字长扩展为2bit</span><br><span class="line"> --&gt;重复接入8块芯片扩展为8bit与CPU数据总线宽度匹配</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011920923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011927602.png" alt="image.png"></p><h3 id="字扩展—增加存储字数"><a href="#字扩展—增加存储字数" class="headerlink" title="字扩展—增加存储字数"></a>字扩展—增加存储字数</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">上述位扩展只是扩展了字的位数由1bit--&gt;8bit,但是数据容量(字的数量)还是8k,那么要如何扩展存储的字的个数呢？--&gt;字扩展</span><br><span class="line">1.如下图，单块存储芯片的字长已经满足了数据总线的宽度，利用率达到了最大</span><br><span class="line">2.但是存储的字的数量只有8k=2^13个字；要想扩展字的总数量，可以再加一块8k的存储</span><br><span class="line">芯片</span><br><span class="line">3.前13条地址总线串联这接入两块芯片的对应地址线接口</span><br><span class="line">4.A13~A15条空余的地址总线，其中A13、A14分别接入两块存储芯片的CS片选芯片</span><br><span class="line">5.一次只让1块芯片工作，这样就相当于实现了存储容量的扩展</span><br><span class="line">扩展之后为了只让1块芯片运行，不让数据信号产生冲突</span><br><span class="line">1.A13接入第一块存储芯片的CS,信号为1时，工作</span><br><span class="line">2.A14接入第二块存储芯片的CS,信号为1时，工作</span><br><span class="line">3.当A13为1，A14就为0，为了避免两块芯片同时工作导致数据冲突</span><br><span class="line">--&gt;那么对于第一块芯片来说地址信号就 是01x xxxx xxxx xxxx</span><br><span class="line">--&gt;对于第二块芯片来说地址信号就是 10x xxxx xxxx xxxx</span><br><span class="line">==&gt;这种方法导致地址信号 00x xxxx xxxx xxxx和11x xxxx xxxx xxxx用不了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011959763.png" alt="image.png"></p><h4 id="片选法"><a href="#片选法" class="headerlink" title="片选法"></a>片选法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">有没有办法解决某些地址信号处于禁用状态的办法呢？</span><br><span class="line">1.上述方式是将CPU多余的地址线接入CS--&gt;没块存储芯片接入1根</span><br><span class="line">2.换用另一种方式--&gt;将一根地址线分为两条接入两个存储芯片的CS</span><br><span class="line">3.对其中一个分路上设置一个非门,这样同样的信号分别到两块芯片就会变为不同的状态</span><br><span class="line">    实现一个开一个关</span><br><span class="line">    4.这样的第一块芯片的有效地址就变为1x xxxx xxxx xxxx到0x xxxx xxxx xxxx地址充</span><br><span class="line">     分得到利用</span><br><span class="line">    5.并且一根地址线可以接入两块存储芯片</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012008057.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这样的方法叫做译码器片选法：</span><br><span class="line">上述译码器为1-2译码器(接入1条地址线--&gt;产生2个片选信号)</span><br><span class="line">假如有n条片选线，经过1-2译码器后就能产生2^n个片选信号</span><br><span class="line">3-8译码器(接入3条地址线--&gt;产生2^3=8个片选信号)</span><br><span class="line">例如下方：</span><br><span class="line">3条片选线信号为0 0 0 ;经过译码器1 0 0 0 0 0 0 0 </span><br><span class="line">3条片选线信号为0 0 1; 经过译码器0 1 0 0 0 0 0 0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012026895.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">换用2-4译码器</span><br><span class="line">片选线信号</span><br><span class="line">00 --&gt;接入第一块芯片</span><br><span class="line">    01 --&gt;接入第二块</span><br><span class="line">    10 --&gt;接入第三块</span><br><span class="line">    11 --&gt;接入第四块     </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012035469.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012045088.png" alt="image.png"></p><h3 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012042360.png" alt="image.png"></p><h3 id="补充：译码器"><a href="#补充：译码器" class="headerlink" title="补充：译码器"></a>补充：译码器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">左边高电平有效</span><br><span class="line">右边低电平有效--&gt;片选信号端有个小圆圈，说明是取反，也就是低电平有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012051911.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除此之外，CPU还有一个比较重要的输出端MREQ(主存储器请求的信号)</span><br><span class="line">1.当CPU想要访问主存的时候，就会发出MREQ信号(接线端有个圆圈，说明是低电平信号)</span><br><span class="line">2.当CPU 没有发出请求信号时，G2B端(使能端)输出的就是1--&gt;取反0--&gt;取反1，也就是</span><br><span class="line">说片选信号都为1，所有的芯片都不工作(低电平有效的)</span><br><span class="line">CPU 实际工作过程：</span><br><span class="line">1.先是CPU通过地址线送出地址信号(包括低位地址信号+高位片选信号)</span><br><span class="line">2.送出地址信息后，电信号还不稳定因此还要等待一段时间带他稳定</span><br><span class="line">3.稳定之后再发出主存请求信号MREQ，低电平0，让某一个选通线变为有效</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012052110.png" alt="image.png"></p><h2 id="双端口RAM和多模块存储器"><a href="#双端口RAM和多模块存储器" class="headerlink" title="双端口RAM和多模块存储器"></a>双端口RAM和多模块存储器</h2><hr><h3 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">存取周期是指：</span><br><span class="line">存取时间+恢复时间</span><br><span class="line">存取完不能立马存取下一个，需要等待恢复</span><br><span class="line">所以存取周期是可以连续读/写的最短时间间隔</span><br><span class="line">DRAM存取周期较长：</span><br><span class="line">存取时间r,恢复时间3r 周期T=4r</span><br><span class="line"></span><br><span class="line">既然有恢复时间，那多核CPU要访问存，怎么办？--&gt;双端口RAM</span><br><span class="line"></span><br><span class="line">主存的恢复时间跟不上CPU的访问速度怎么办？ --&gt;多模块存储器解决</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012140350.png" alt="image.png"></p><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">采用双端口RAM 实现多CPU同时访问内存条--&gt;需要更复杂线路</span><br><span class="line">两个端口同时对同一主存操作有一下4种情况：</span><br><span class="line">1.两个端口同时对不同的地址单元存取数据--&gt;ok</span><br><span class="line">2.两个端口同时对同一地址单元读出数据 --&gt;ok</span><br><span class="line">3.两个端口同时对同一地址单元写入数据 --&gt;no</span><br><span class="line">4.两个端口同时对同一地址单元，一个写入数据，另一个读出数据--&gt;no</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012155771.png" alt="image.png"></p><h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">多模块存储器解决存取周期恢复时间跟不上CPU访问速度问题</span><br><span class="line">多提存储器理解为多根内存条，编码方式分为：</span><br><span class="line">- 高位交叉编址：</span><br><span class="line"></span><br><span class="line">- 低位交叉编址(实现连续访问)：</span><br><span class="line">当连续访问连续地址的时候--&gt;采用低位交叉编址--&gt;实现每个地址都分布于不同</span><br><span class="line">的模块--&gt;直接避免了访问完一个内存条之后处于的恢复时间</span><br><span class="line">--&gt;采用低位交叉编址的多体存储器连续存储n个存储字--&gt;耗时T+(n-1)r</span><br><span class="line">(另外提一下，T=r(存取时间)+3r(恢复时间))</span><br><span class="line">用下图理解</span><br><span class="line"></span><br><span class="line">- 连续访问的现实意义：</span><br><span class="line">例如程序中的数组等都是需要用连续的内存空间存储，采用低位地址交叉编址，</span><br><span class="line">极大提高访问速度</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012211905.png" alt="image.png"></p><h3 id="多体并行存储器应该去几个体？"><a href="#多体并行存储器应该去几个体？" class="headerlink" title="多体并行存储器应该去几个体？"></a>多体并行存储器应该去几个体？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">设多路并行的存储体数量为m</span><br><span class="line">- m&lt;T/r ,--&gt;导致存取数据时，会需要等待时间r</span><br><span class="line">- m&gt;T/r ,--&gt;导致数据时，有闲置的时间r没被利用</span><br><span class="line">- m=T/r ,--&gt;最优，不会有等待时间，也不会有时间闲置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306012250325.png" alt="image.png"></p><h3 id="实际生活中应用"><a href="#实际生活中应用" class="headerlink" title="实际生活中应用"></a>实际生活中应用</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">平时所说的双通道是什么？</span><br><span class="line">- 就是内存条实现了 低位交叉编址的多体存储器</span><br><span class="line">这是两条计算机内存条的卡槽</span><br><span class="line">- 分为黄色和绿色两种卡槽</span><br><span class="line">那要如何插入内存条实现低位交叉编址呢？</span><br><span class="line">- 实现低位交叉编址：假如有两条内存条--&gt;插入颜色一样的卡槽内(双通道，提升速度)</span><br><span class="line">- 实现高位交叉编址：假如有两条内存条--&gt;分别插入颜色不一样的卡槽内(单纯的扩容)</span><br><span class="line">假如有一条16G内存与两条8G内存，该如何选？</span><br><span class="line">选择两条8G内存分别插入颜色相同的卡槽--&gt;形成双通道--&gt;访存速度比单条16G的更快</span><br><span class="line">为什么买内存条要买相同主频和相同容量的两根组成双通道？</span><br><span class="line">- 相同主频是因为，假如一块高一块低。其中高的一块会主动降频，使得主频一致，这样</span><br><span class="line">性能浪费</span><br><span class="line">- 相同容量是因为，两条相同容量的内存组成双通道性能提升，如果是不同容量的内存，</span><br><span class="line">系统会按照容量小的那一条进行组建。 比如4G内存和8G内存，8G会分出4G和单条4G内</span><br><span class="line">存组成双通道，8G中剩余的4G则仍然是单通道。假如打游戏的时候有数据存储在了剩余的</span><br><span class="line">4G单通道内存中，访存速度就变慢--&gt;导致游戏一卡一卡</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021227140.png" alt="image.png"></p><h2 id="外存储器-辅存"><a href="#外存储器-辅存" class="headerlink" title="外存储器(辅存)"></a>外存储器(辅存)</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><hr><h4 id="磁盘最底层工作原理"><a href="#磁盘最底层工作原理" class="headerlink" title="磁盘最底层工作原理"></a>磁盘最底层工作原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">计算机的外存也称为辅存存储器，目前主要使用磁表面存储器。</span><br><span class="line"></span><br><span class="line">磁表面存储 ，如下图，把磁性草料薄薄地涂抹在金属或塑料表面上作为载磁体存储信息。</span><br><span class="line"></span><br><span class="line">例如磁带的工作原理：</span><br><span class="line">1.磁带上方有一个磁头，磁头是由一根铁芯和两组线圈构成</span><br><span class="line">2.当写入数据时，根据数据01信号区分接通电流的方向写线圈通电流，根据电磁铁原理，</span><br><span class="line">使得电磁铁不断改变N S 方向--&gt;从而下面划过的磁带因磁场作用带上不同N S 极，这样</span><br><span class="line">就写上了数据</span><br><span class="line">3.当读数据时，磁带划过铁芯，由于磁带上带有N S极，使得铁芯切割次感应线产生电流</span><br><span class="line">根据划过的N S磁感应线方向的不同，产生的感应电流方向不同，在根据从读线圈传出的</span><br><span class="line">电流信号对应01信号，从而读出0\1两种不通的二进制状态</span><br><span class="line">注意：</span><br><span class="line">1.磁表面存储器每次只能1bit的读写数据</span><br><span class="line">2.读写不能同时进行</span><br><span class="line">优点：</span><br><span class="line">1.存储容量大，位价格第</span><br><span class="line">2.记录介质可以被重复使用</span><br><span class="line">3.记录信息可以长期保存不丢失</span><br><span class="line">4.非破坏性读出，读出时不需要再生(刷新)</span><br><span class="line">缺点：</span><br><span class="line">1.存取速度慢</span><br><span class="line">2.机械结构复杂</span><br><span class="line">3.对工作环境要求高(容易受到外部磁场的影响)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021406971.png" alt="image.png"></p><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">磁盘设备的组成：</span><br><span class="line">- 存储区域：</span><br><span class="line">一块磁盘含有多层的记录面(磁盘是分层的)，每个记录面划分为若干磁道(一圈一圈)</span><br><span class="line">，而每条磁道又分为若干扇区,扇区(也称块)是磁盘读写的最小单位。</span><br><span class="line">- 一些名词：</span><br><span class="line">1.磁头数:</span><br><span class="line">就是记录面数，表示硬盘有多少个磁头，磁头用于读写盘上信息，1个记</span><br><span class="line">    录面对应1个磁头</span><br><span class="line">2.柱面数：</span><br><span class="line">因为磁盘有多层，每层的记录面磁道互相之间形成一圈圈的柱面，柱面数反应了</span><br><span class="line">磁道数</span><br><span class="line">3.扇区数：</span><br><span class="line">将以个盘划分为多块扇形区域，这样就将每条磁道也化为了多段</span><br><span class="line">- 硬盘存储器：</span><br><span class="line">由磁盘驱动器+磁盘控制器+盘片组成</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021430553.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021439849.png" alt="image.png"></p><h4 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.磁盘容量</span><br><span class="line">一个磁盘所能存储的字节总数，分为：</span><br><span class="line">- 非格式化容量：</span><br><span class="line">磁记录表面可以利用的磁单位总数</span><br><span class="line">- 格式化容量：</span><br><span class="line">留下来某些扇区作为备用扇区，以防止某些扇区损坏，平时不作为磁记录</span><br><span class="line">2.记录密度</span><br><span class="line">- 道密度</span><br><span class="line">半径1cm所含磁道的数量</span><br><span class="line">- 位密度</span><br><span class="line">在一条磁道上单位长度上能记录的二进制代码位数</span><br><span class="line">(注意每条磁道的记录位数一样的，所以，越靠近圆心的磁道为密度越大)</span><br><span class="line">- 面密度</span><br><span class="line">单位面积记录的二进制代码位数</span><br><span class="line">3.平均存取时间</span><br><span class="line">=寻道时间+旋转时间+传输时间</span><br><span class="line">一般做题时，寻道时间会给，旋转时间选转半圈时间(根据转速自己算),传输时间根据转</span><br><span class="line">速算出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021501493.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021503207.png" alt="image.png"></p><h4 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">确定某一个扇区号，需要给该扇区编一个唯一的地址</span><br><span class="line">驱动器号+柱面号+盘面号+扇区号--&gt;依次锁定位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021510383.png" alt="image.png"></p><h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于单个磁盘只能串行的访问信息，速度很慢--&gt;为了解决这个问题，提出磁盘阵列RAID(磁盘冗余阵列) ，将多个独立的物理磁盘组成一个独立的逻辑磁盘，数据可以在多个物理盘上分割交叉存储，并行的访问</span><br><span class="line"></span><br><span class="line">RAID</span><br><span class="line">- RAID0:</span><br><span class="line">无冗余无校验的磁盘阵列</span><br><span class="line">- 直接将数据分割存储在多块盘上的不不同扇区，做到并行访问。</span><br><span class="line">- 无校验：</span><br><span class="line">是指当一块磁盘扇区损坏，由于没有备份数据就永远丢失；</span><br><span class="line">同时如果扇区没有完全损坏，数据发生跳变，由于没有信息对比，无法校验</span><br><span class="line"></span><br><span class="line">- RAID1：</span><br><span class="line">镜像磁盘阵列(有冗余)</span><br><span class="line">- 粗暴的存两份数据在两块盘上，既能并行访问，又能备份。同时其中当某一块</span><br><span class="line">  发生跳变，磁盘数据也能与另一块进行对比校验</span><br><span class="line">- 有冗余：浪费一半空间镜像数据</span><br><span class="line">- RAID3：</span><br><span class="line">采用纠错的海明码的磁盘阵列</span><br><span class="line">- 相比与镜像磁盘阵列，这种方法存储4bit信息，只需再存储3bit海明校验码就</span><br><span class="line">  能做到4bit数据的校验--&gt;4:3 相比与镜像的1：1更节省空间</span><br><span class="line"></span><br><span class="line">像百度云网盘，为了保证磁盘用户数据的准却不丢失，常采用磁盘冗余阵列的方式提升存储的安全可靠性以及传输率</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021516060.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021532104.png" alt="image.png"></p><h3 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021548206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021551451.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021552722.png" alt="image.png"></p><h2 id="Cache-缓存"><a href="#Cache-缓存" class="headerlink" title="Cache(缓存)"></a>Cache(缓存)</h2><h3 id="Cache的基本原理概念"><a href="#Cache的基本原理概念" class="headerlink" title="Cache的基本原理概念"></a>Cache的基本原理概念</h3><h4 id="Cache概念"><a href="#Cache概念" class="headerlink" title="Cache概念"></a>Cache概念</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">由于CPU访问速度过快，主存跟不上，所以引入更高速的存储单元--&gt;Cache</span><br><span class="line"></span><br><span class="line">Cache工作原理：</span><br><span class="line">当微信程序运行时--&gt;将微信相关的程序代码及相关数据送到主存当中--&gt;但是CPU速度太</span><br><span class="line">快主存存取数据速度跟不上--&gt;引入Cache--&gt;例如使用视频聊天功能--&gt;将视频聊天的代码</span><br><span class="line">复制到Cache中，这样速度矛盾就得到缓和</span><br><span class="line">Cache体积：</span><br><span class="line">Cache是有SRAM实现，SRAM速度快，成本高，但是集成度低</span><br><span class="line">--&gt;Cache一般被集成在CPU中所以限制了其大小</span><br><span class="line">--&gt;又由于集成度低，导致容量小往往只有几M到十几M之间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021640411.png" alt="image.png"></p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">局部性原理：</span><br><span class="line">- 空间局部性：</span><br><span class="line">将来也要访问的数据在当前访问数据的周围附近</span><br><span class="line">(例如数组元素，数据都是相邻的)</span><br><span class="line">- 时间局部性：</span><br><span class="line">将来要访问的数据是当前时间访问的数据</span><br><span class="line">(例如for循环，i可能重复使用)</span><br><span class="line"></span><br><span class="line">二维数组实际是一行一行存储的：</span><br><span class="line">a[0][1] 与a[0][2]相邻存储，展开为列</span><br><span class="line">但是</span><br><span class="line">a[1][0] 与a[2][0]之间相隔了多个元素，地址不连续</span><br><span class="line">下面两段代码：</span><br><span class="line">A--&gt;是按照连续的存储空间依次遍历数组--&gt;局部性较好--&gt;容易被Cache命中--&gt;快</span><br><span class="line">B--&gt;按照数组一列一列的遍历--&gt;元素地址不连续--&gt;间隔着访问跨度大--&gt;局部性较差--&gt;</span><br><span class="line">  --&gt;从Cache中找到元素的概率小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021652853.png" alt="image.png"></p><h4 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命中率H</span><br><span class="line">CPU想要访问的信息已经在Cache中的比率</span><br><span class="line">Cache-主存系统的平均访问时间：</span><br><span class="line">1.CPU同时访问Cache和主存</span><br><span class="line">平均访问时间 Htc+(1-H)tm</span><br><span class="line">2.CPU先访问Cache再访问主存</span><br><span class="line">平均访问时间 Htc+(1-H)(tc+tm)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021701798.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021706706.png" alt="image.png"></p><h4 id="Cache-主存分块访问"><a href="#Cache-主存分块访问" class="headerlink" title="Cache-主存分块访问"></a>Cache-主存分块访问</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于局部性原理，Cache会把目前访问数据“周围”部分数据放到Cache,但是如何界定“周围”是多大呢？</span><br><span class="line">将主存分块，例如没1kB为一块，主存与Cache之间就一&quot;块&quot;为单位数据交换</span><br><span class="line">例如主存4MB=2^22B，每1KB分为1块--&gt;2^22/2^10=2^12=4096块</span><br><span class="line">这样就先对块号编址前共2^12块，那么前12bit对应块号；每块1KB=2^10，那么后</span><br><span class="line">10bit对应块内位置</span><br><span class="line">主存中块又被称作：</span><br><span class="line">页/页面/页框</span><br><span class="line">Cache中块又被称作：</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306021716362.png" alt="image.png"></p><h3 id="cache和主存的映射方式"><a href="#cache和主存的映射方式" class="headerlink" title="cache和主存的映射方式"></a>cache和主存的映射方式</h3><p><em>思考一个问题？如何确定将主存中的数据搬到Cache中后，数据在Cache中的存放位置？这就需要一个具体的映射方式来确定，一个主存地址中的数据在Cache中的存储位置</em></p><p><strong>*地址映射</strong>：地址映射是一种规则，它指明了把主存地址空间映射到Cache地址空间所用的规则，即把存放在主存中的程序按照某种规则装入Cache。，由Cache的块数比主存块数少得多，因此需要加入主存字块标记和字块内地址*</p><p><strong>*地址变换</strong>：地址变换是一个过程，它是指CPU在访存时，将主存地址按映射规则换算成Cache地址的过程。*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">映射方式主要有以下三种</span><br><span class="line">1.全相联映射：</span><br><span class="line">- 主存块可以放在Cache的任何位置</span><br><span class="line">- 那如这样的话要怎么区分Cache块号数据对应主存数据的块号呢？</span><br><span class="line">1.加一个标记，初始都为0，用于标记Cache块内的数据对应主存的块号</span><br><span class="line">2.另外还要加一个有效位，用于表示对应的标记是否有效(因为标记初始</span><br><span class="line">都为0)如果不加有效位，那么主存0号为的数据无法确定是哪一个。</span><br><span class="line">2.直接映射</span><br><span class="line">3.组相联系映射</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061546623.png" alt="image.png"></p><h4 id="全相联映射-随意放"><a href="#全相联映射-随意放" class="headerlink" title="全相联映射(随意放)"></a>全相联映射(随意放)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1..因为Cache行也就是Cache块，一个Cache块有64B--&gt;主存一个块也是64B</span><br><span class="line">2..所以主存块有256MB/64B=2^22个，也就是块号从0~2^22-1 --&gt;需要22个bit位</span><br><span class="line">表示块号 </span><br><span class="line">3..主存块每块内存储64B，(由于1B编一个地址)每块内地址64个--&gt;2^6--&gt;需要</span><br><span class="line">6bit位表示--&gt;地址前22bit表示块号，后6bit表示块内地址</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.将主存地址的前22位对比Cache中所有块的标记</span><br><span class="line">2.若标记匹配且有效位为1，则Cache命中，访问块内地址为001110的单元</span><br><span class="line">3.若未命中或有效位=0，则正常访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221529841.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一快的副本。</em></li><li><em>字块内地址：由于Cachei块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061558454.png" alt="image.png"></p><h4 id="直接映射-只能放在固定位置"><a href="#直接映射-只能放在固定位置" class="headerlink" title="直接映射(只能放在固定位置)"></a>直接映射(只能放在固定位置)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设某个计算机的主存地址空间大小256MB,按字节编址，其数据Cache有8个Cache行，行长64B</span><br><span class="line">1.通过上面的分析已经知道主存有2^22个块，块内有2^6字</span><br><span class="line">2.直接映射：</span><br><span class="line">主存块在Cache中的位置=主存块号%Cache总块数</span><br><span class="line">3.这样做取余运算，主存的块放到Cache中就只有唯一的一个固定存放位置</span><br><span class="line">4.同样我们需要对Cache块中的数据标记它在主存中对应的块号</span><br><span class="line">能不能对标记进行一些优化呢？</span><br><span class="line">- 因为主存块号对8取余运算，所以块号的后3bit位就对应表示Cache中的块号</span><br><span class="line">  那么就不需要对主存块号的全部22bit进行标记，只需标记前19bit</span><br><span class="line">那CPU访问主存地址是如何进行呢？</span><br><span class="line">访问1....1101 001110</span><br><span class="line">1.首先根据主存块号的后3位确定Cache行(块)</span><br><span class="line">2.再比对主存块号的前19位是否与Cache中的标记匹配</span><br><span class="line">3.若标记匹配且有效位=1,则命中，访问块内地址</span><br><span class="line">    4.若没命中直接访问主存</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221530376.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中哪一块的副本。</em></li><li><em>Cache:字块地址：指明存放在Cache中的哪个Cache块。</em></li><li><em>字块内地址：由于Cache块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061633344.png" alt="image.png"></p><h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与直接映射类似</span><br><span class="line">只不过对分组数取余</span><br><span class="line">会将主存块放到Cache对应分组里面的任何一块</span><br><span class="line">其他类似</span><br></pre></td></tr></table></figure><blockquote><p><em>主存地址结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221531760.png" alt="image.png"></p></blockquote><ul><li><em>主存字块标记：指明当前Cache是主存中那一块的副本。</em></li><li><em>组地址：指明存放在Cache中的哪个Cache块的组。</em></li><li><em>字块内地址：由于Cche块和主存块都是由若干字节组成的，当需要访问某一个字时，需要找到该字在指定的Cache块中的地址。</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061702445.png" alt="image.png"></li></ul><h3 id="Cache替换算法"><a href="#Cache替换算法" class="headerlink" title="Cache替换算法"></a>Cache替换算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">什么时候需要使用Cache替换？</span><br><span class="line">全相联映射、组相连映射</span><br><span class="line">为什么直接映射不需要考虑替换算法？</span><br><span class="line">因为直接映射，主存块在Cache中的块的位置是通过取余得到的--&gt;位置是固定的--&gt;</span><br><span class="line">所以无需考虑放在其他空位上的情况，只需要替换固定的位置上的，所以只要对应块号上</span><br><span class="line">已经有数据直接替换就可以了</span><br><span class="line">Cache替换算法：</span><br><span class="line">1.随机替换算法RAND</span><br><span class="line">2.先进先出算法FIFO</span><br><span class="line">3.近期最少使用LRU</span><br><span class="line">4.最近不经常使用LFU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081713896.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">随机替换算法RAND:</span><br><span class="line">- 只有Cache装满之后才进行替换算法</span><br><span class="line">- 满了之后随机选择一个块进行替换，毫无规律</span><br><span class="line">- 完全没考虑局部性原理，命中率很低，实际效果很不稳定</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081737148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">先进先出算法FIFO:</span><br><span class="line">- 类似队列，先放入的最先被替换(时间先后)</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 没有考虑局部性原理，因为最先被调入的块，不意味着就用不到，也有可能频繁用到</span><br><span class="line">- 有可能出现抖动现象，就是刚被换出的块，再此被访问放入，频繁的换入换出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081742465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最近最少使用算法LRU：</span><br><span class="line">- 当Cache满时，从当前访问的块开始，往前找n个块，看最近访问最少的将其替换</span><br><span class="line">- 具体实现：设置一个计数器(对应每个块)记录多久没被访问</span><br><span class="line"> 1.命中时，所命中的块的计数器清零，比其低的计数器加1，其余不变</span><br><span class="line"> 2.未命中且还有空闲块时，新装入得块的计数器置为0，其余非空闲块全加1</span><br><span class="line"> 3.未命中且无空闲行时，计数器的最大块的信息块被替换，新装入的块计数器置为0</span><br><span class="line">   其余全加1</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该算法遵循了局部性原理，近期被访问的主存块，在不就的将来也会被访问到</span><br><span class="line">  淘汰最久没被访问到的块是最合理的，Cache效率高</span><br><span class="line">- 但是如果频繁访问到的主存块数量比Cache数量多，也会发生抖动现象，例如访问块号</span><br><span class="line">  &#123;1,2,3,4,5...1,2,3,4,5&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081831963.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最近不经常使用算法LFU:</span><br><span class="line">- 为每一个Cache块增加一个计数器，用于记录每个Cache块被访问过几次，当Cache块满</span><br><span class="line">  了之后替换计数器最小的</span><br><span class="line">算法性能怎么样？</span><br><span class="line">- 该替换算法没有遵循局部性原理，因为经常被访问的主存块未来不一定会用到</span><br><span class="line">  例如：微信视频聊天，因为视频聊天会需要很频繁的访问与聊天有关的块，访问次数会</span><br><span class="line">  瞬间达到很大，之后不使用视频聊天功能，由于访问次数已经很大，当中的块就很难被</span><br><span class="line">  替换了</span><br><span class="line">- 实际运行效率不如LRU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081846769.png" alt="image.png"></p><h3 id="Cache写策略"><a href="#Cache写策略" class="headerlink" title="Cache写策略"></a>Cache写策略</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">假如CPU修改了Cache块中的数据副本，要如何确保主存中的数据也保持一致的修改？</span><br><span class="line">--&gt;Cache写策略要探讨的问题</span><br><span class="line">写策略根据Cache是否命中来讨论：</span><br><span class="line"> - 写命中</span><br><span class="line"> - 写不命中</span><br></pre></td></tr></table></figure><h4 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h4><hr><h5 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.写回法：</span><br><span class="line">- 当CPU对Cache写命中时，，只修改Cache中的内容，而不立即写入主存，只</span><br><span class="line">有当此块被换出时，才写回主存</span><br></pre></td></tr></table></figure><ul><li><em>有效位：1bit 用于判断该数据是否有效</em></li><li><em>脏位：1bit 用于标记Cache中数据是否被修改过</em></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306081925565.png" alt="image.png"></p><h5 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.全写法：</span><br><span class="line">当CPU对Cache写命中时，必须同时把数据写入Cache和主存</span><br><span class="line">--&gt;这样写不会很慢吗？(因为主存是DRAM，地址分两次送)</span><br><span class="line">- 为了解决CPU写变慢的问题，推出了写缓冲(writer buffer)</span><br><span class="line">--&gt;什么是写缓冲？</span><br><span class="line">- 写缓冲是SRAM芯片(与Cache相同)，所以将数据写入Cache的时候，同时</span><br><span class="line"> 写入写缓冲，当CPU干其他事时候，写缓冲就就将数据同步到主存里面</span><br><span class="line">--&gt;效果怎么样？</span><br><span class="line">- 当写入操作不频繁的时候--&gt;效果很好</span><br><span class="line">- 当写入操作很频繁的时候--&gt;由于写缓冲容量有限，会导致缓缓从饱和CPU进入阻塞状态</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082235849.png" alt="image.png"></p><h4 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h4><hr><h5 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3.写分配法：</span><br><span class="line">当CPU写不命中的时候，会先把主存中的块调入Cache中，在Cache块中修改</span><br><span class="line">修改完之后，只有当Cache块被替换之后才会将数据同步到主存中</span><br><span class="line"> --&gt;写分配法常常搭配写回法使用(配合着完成写命中和写不命中的情况)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082244804.png" alt="image.png"></p><h5 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4.非写分配法：</span><br><span class="line">当CPU对Cache写不命中的时候只写入主存，不调入Cache</span><br><span class="line">--&gt;常常搭配全写法使用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082249652.png" alt="image.png"></p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现代计算机常采用多级Cache:</span><br><span class="line">离CPU越近速度需要越快</span><br><span class="line">--&gt;所以Cache-Cache之间通常采用全写法+非写分配法 ,实现数据同步</span><br><span class="line">   Cache-主存之间通常采用写回法+写分配法，实现数据同步</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082301873.png" alt="image.png"></p><h2 id="页式存储器"><a href="#页式存储器" class="headerlink" title="页式存储器"></a>页式存储器</h2><h3 id="逻辑地址-虚拟地址"><a href="#逻辑地址-虚拟地址" class="headerlink" title="逻辑地址(虚拟地址)"></a>逻辑地址(虚拟地址)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">地址：</span><br><span class="line">- 逻辑地址(虚地址)：</span><br><span class="line">什么是虚拟地址？</span><br><span class="line">因为主存的容量有限，所以只能将需要运行的程序代码和数据放入主存块</span><br><span class="line">中，因此为了匹配主存块的大小,操作系统将程序也划分为&quot;页/块&quot;(与主</span><br><span class="line">存块大小相等)因此就出现了虚拟地址</span><br><span class="line">虚拟地址有哪些部分？</span><br><span class="line">虚拟地址包括 逻辑页号+页内地址 --&gt;都是外存中的地址</span><br><span class="line"></span><br><span class="line">- 物理地址(实地址)</span><br><span class="line">- 物理地址就是程序放入内存中实际的地址；</span><br><span class="line">- 其中块内地址与虚拟地址的页内地址对应</span><br><span class="line">- 主存块号却不是与虚拟地址的逻辑页号对应，所以出现了一个映射表，存储</span><br><span class="line">块号与页号的映射关系</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306082318668.png" alt="image.png"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">页表：</span><br><span class="line">- 为了将虚拟地址与主存中实际存放的地址互相映射，于是出现了页表</span><br><span class="line">- 页表是存储在主存当中，所以CPU想要进行一次地址转换的时候就要先进行一次访</span><br><span class="line">  存</span><br><span class="line">- 页表是一行一行的，每一行称为一个&quot;页表项&quot;</span><br><span class="line"></span><br><span class="line">CPU取变量x到ACC寄存器的机器指令：操作码+地址码(虚拟地址)</span><br><span class="line">- 000001(操作码) 00(逻辑页号)1000000011(块内地址)</span><br><span class="line">- 查页表 00&lt;-&gt;10 转换地址 000001(操作码) 10(物理块号)1000000011(块内地址)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091738584.png" alt="image.png"></p><h3 id="地址转换过程"><a href="#地址转换过程" class="headerlink" title="地址转换过程"></a>地址转换过程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CPU要将虚拟地址转换为物理地址</span><br><span class="line">1.先进行一次访问，因为页表存储在主存当中，那如何知道应该访问哪一个地址呢？</span><br><span class="line">&gt;首先访问页表基地址寄存器(存储了页表的起始地址)</span><br><span class="line">&gt;然后根据逻辑地址页号从基地址往后找到目标&quot;页表项&quot;(因为页号地址是按页号顺</span><br><span class="line"> 序编址)</span><br><span class="line">&gt;接着将查得到 主存块号与块内地址拼接成 -&gt; 物理地址</span><br><span class="line">&gt;然后CPU按照物理地址 先访问Cache后访问主存的原则寻找数据</span><br><span class="line">2.如果是需要频繁访问的数据，每次访问都要先进行一次访存查页表，那会很慢，怎么办？</span><br><span class="line">&gt;新增一个页表项的高速寄存器(快表TLB)，用于存放有需要频繁访问的数据的页表项</span><br><span class="line">3.地址转换过程增加-快表TLB</span><br><span class="line">&gt;快表是SRAM所以访问速度比主存块很多，查询速度很快</span><br><span class="line">&gt;快表示一种&quot;相联存储器&quot;根据内容寻址</span><br><span class="line">&gt;CPU进行数据访问(地址转换)要先获得物理地址,会先访问快表，如果没有才访问内存</span><br><span class="line">&gt;快表容量有限很容易被存满，存满之后也需要进行替换</span><br><span class="line">&gt;快表TLB ,相当于主存与外存之间的&quot;Cache&quot;用于存放外存中页表的副本</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091759660.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091815584.png" alt="image.png"></p><h2 id="全篇总结"><a href="#全篇总结" class="headerlink" title="全篇总结"></a>全篇总结</h2><blockquote><p>指令上的地址都是逻辑地址，经过查找页表/快表得到主存块号，拼接成物理地址，然后根据物理地址从Cache中寻找数据(根据Cache与主存的不同映射关系，结合物理地址寻找到对应的Cache块)，如果没找到就进入主存寻找。这就是完整的寻址过程</p></blockquote><h2 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h2><h3 id="存储器的基本概述习题"><a href="#存储器的基本概述习题" class="headerlink" title="存储器的基本概述习题"></a>存储器的基本概述习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">磁盘是直接存取存储器DAM</span><br><span class="line">DAM不像随机存储器能直接找到数据，需要先确定柱面，然后确定盘面，最后确定扇区</span><br><span class="line">DAM也不想顺序存储必须从头到尾依次访问</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052058664.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052109433.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">相联存储器是内容指定方式和地址指定方式相结合进行寻址的存储器</span><br><span class="line">分为以下四种寄存器：</span><br><span class="line">1.检索寄存器CR：</span><br><span class="line">存储要检索的存储字</span><br><span class="line">2.屏蔽字寄存器MR：</span><br><span class="line">只有MR置为1时，才对对应该列的数据进行检索判断是否符合CR里的要求</span><br><span class="line">3.符合寄存器RR：</span><br><span class="line">将检索到符合要求的那一行数据信息置为1，不符合置为0</span><br><span class="line">4.字选择寄存器WSR：</span><br><span class="line">提前限定检索的目标(范围)，将需要检索的置为1，即使RR中是符合要求的也不进行</span><br><span class="line">检索</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052116306.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据传输率=数据传输量/耗时</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052125794.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052130732.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均访问时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052134149.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052144938.png" alt="image.png"></p><h3 id="主存储器习题"><a href="#主存储器习题" class="headerlink" title="主存储器习题"></a>主存储器习题</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">读写控制线可以是1根或2根</span><br><span class="line">注意当是DRAM时存在地址线复用的情况，到时候需要注意</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052151135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不存在死区的只有分散刷新，实际上是将刷新时间整合进存取周期里面</span><br><span class="line">对于其他刷新方式都存在独立的死区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052158108.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RAM 就是易失性存储器</span><br><span class="line">ROM 就是非易失性存储器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052211466.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DRAM采用地址线复用技术，地址线只需要原来的一半，通过行列地址确定确定要取的那个存储字</span><br><span class="line">--&gt; 地址线5根+行列选通线2根+读写控制线2根+数据线8根 =17根</span><br><span class="line">--&gt; 为什么不需要片选线？</span><br><span class="line">因为行列选通线起到了片选线的作用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052215875.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.采用高速DRAM</span><br><span class="line">2.采用双端口RAM</span><br><span class="line">3.采用多体并行存储结构</span><br><span class="line">4.刷新存储器到显示控制器的内保部总线宽度加倍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052237594.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 单体4字宽度是什么意思？</span><br><span class="line">是指把存储器的字长扩大为原来的4倍，实现的是一个单体4字结构的存储器，每次可同时</span><br><span class="line">读出4个字的内容这样做的好处是有利于提高存储器每个字的平均读写速度，但其灵活性</span><br><span class="line">不如多体单字结构的存储器，还会多用到集合缓冲寄存器</span><br><span class="line">- 单体多字存储器就是位扩展吗？</span><br><span class="line">不完全是。位扩展是指用多个存储器器件对字长进行扩充，比如用2个16K×4位芯片组成</span><br><span class="line">16K×8位的存储器而把存储器改为单体4字宽度是指用一个存储器器件对字长进行扩充，比</span><br><span class="line">如用一个16K×4位芯片组成4K×16位的存储器两者的区别在于是否需要多个存储器器件和片</span><br><span class="line">选信号。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052250465.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">体冲突就是指访问完一个存储器，存储周期还没结束就再次访问造成访问不了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052311096.png" alt="image.png"></p><h3 id="主存储器与CPU的连接习题"><a href="#主存储器与CPU的连接习题" class="headerlink" title="主存储器与CPU的连接习题"></a>主存储器与CPU的连接习题</h3><hr><p>1.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052318692.png" alt="image.png"></p><p>2.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306052329357.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以4个字节为编址单位就是，一个地址存储4个字节</span><br><span class="line">要构造32KB的存储体，首先判断需要多少容量 32KB/4B=8K，不需要字扩展</span><br><span class="line">又因为一个地址存储4B=32bit，到哪存储芯片只有8bit,需要位扩展</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061332828.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以是4块256x16bit芯片全部字扩展为为1024</span><br><span class="line">也可以是4块512x8bit,其中两两箱位扩展为两块521x16bit ,再字扩展为1024x16bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061354808.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAR地址寄存器：用来存放当前CPU访问的内存单元地址，或存储CPU要写入内存的单元地址</span><br><span class="line">MDR数据寄存器：用来存放CPU从内存中读出的信息或写入内存的信息</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061402115.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061413069.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">芯片是64x64是指64行x64列，给出芯片规格，才能直到刷新总共需要多少次，一次刷新一行</span><br><span class="line">总共需要刷新64次，2ms内异步刷新，只要保证2ms内恰好刷新完就可以那么刷新周期就是2ms/64</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061417643.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">256Kx1bit位扩展为256kx32bit</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061422425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061429484.png" alt="image.png"></p><h3 id="外部存储器习题"><a href="#外部存储器习题" class="headerlink" title="外部存储器习题"></a>外部存储器习题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061431596.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061438195.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.固态硬盘随机读写性高于磁盘,所以固态硬盘常常作系统盘，磁盘用作仓库盘</span><br><span class="line">C.随机写比较慢，因为固态硬盘需要将已有的数据进行擦除，之后才能写</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061441560.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的存取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061445647.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">寻道时间8ms</span><br><span class="line">延迟时间--&gt;转到该磁道对应扇区，取转半圈时间--&gt;4.17ms</span><br><span class="line">传输时间--&gt;有时题目会给读取数据量KB,然后会给传输速度MB/s;有时直接通过转速和扇区占</span><br><span class="line">          比来计算读取时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061451659.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">磁盘的最小读写单元是一个扇区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061456065.png" alt="image.png"></p><h3 id="高速缓冲存储器-Cache-习题"><a href="#高速缓冲存储器-Cache-习题" class="headerlink" title="高速缓冲存储器(Cache)习题"></a>高速缓冲存储器(Cache)习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221203457.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221209136.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221219813.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221351133.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221353099.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221455353.png" alt="image.png"></p><p>*128KB/16B = 8K(块)=2^13(块)，组相连映射，每组8块，所以2^13/8=2^10(组)，—&gt;10bit表示Cache内组号</p><p>主存地址1234567H —&gt;说明主存地址共4x7=28位，28-10-4=14(主存字块标记位数)*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221542461.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221604202.png" alt="image.png"></p><p><em>逻辑地址与物理地址区别就是页号不同</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221642813.png" alt="image.png"></p><p><em>Cache容量计算：数据部分+控制部分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221650066.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222021823.png" alt="image.png"></p><p><em>没有告诉主存地址位数,只知道地址号数<br>通过逻辑右移·取余数得到低位部分数<br>就可得如组号是多少了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221659922.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221710825.png" alt="image.png"></p><p><em>Cache一次缺失，就需要将一个主存块替换进Cache里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221701004.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307221705615.png" alt="image.png"></p><p><em>1.做这题第一眼，忽略了写命中也要算进去<br>2.这里k=1000刚好是4的倍数，，因为一个块16B,可以存4个数组元素，所以替换到Cache中的数组都可以访问到不会遗漏，所以可以根据每8次缺失1次算<br>3.当k=10,时，只能访问到a[9],剩余替换到Cache块中的a[10],a[11]不会访问到，所以要按实际情况计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222004782.png" alt="image.png"></p><p>*时间局部性：一条指令一旦被执行，在不久的将来可能会再次执行<br>典型代表：循环指令</p><p>空间局部性：一旦一个存储单元被访问，那么它附近的存储单元也很快被访问典型代表：数组，顺序指令*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222013840.png" alt="image.png"></p><p><em>比较器的作用：用于判断需要取的数据是否在Cache中已存在<br>1.由于一次存取只能存取一个数据，故一次存取先根据主存地址中的Cache组号，确定数据所在Cache组（一组8个Cache块）<br>2.在根据主存地址标志位tag(用于确定对应的主存块号)，通过比较器将目的tag位，与该组中所有Cache块中存储的数据的tag位进行比对，如果匹配成功，说明Cache命中<br>3.所以比较器是用在确定组号之后，比较组内所有块的tag位，所以组内有8块，就需要8个比较器，tag位有20位，比较器位数就需要20位</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222036946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222048277.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222054958.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222059557.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222116123.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222121516.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222132157.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154250.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222154018.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222153389.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222208624.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217240.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222219607.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307222217728.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231216744.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231307226.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231314918.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231319447.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231321170.png" alt="image.png"><br><em>本题要点</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231323044.png" alt="image.png"></p><p><em>(1)(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231339697.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231340569.png" alt="image.png"><br><em>(4)</em><br>*修改页面，是指改完主存中的内容后，再将主存中修改的内容写到辅存(外存)</p><p>Cache直写，是一并将修改写入Cache和主存，就是全写法，通过写缓冲实现*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231343247.png" alt="image.png"></p><p><em>LRU标记位需要3bit,用于标记各个块被访问的先后顺序，由于每个分组内只有8个块，先后顺序无非1~8，所以3bit位标记先后顺序即可</em><br><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231353841.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406025.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307231406198.png" alt="image.png"></p></blockquote><h3 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h3><p><mark>大纲已删</mark></p><h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><hr><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一条指令包括：</span><br><span class="line">OP操作码</span><br><span class="line">A地址码 </span><br><span class="line">一条指令根据包含地址码数目不同分为零地址指令、一地址指令、二地址指令...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091933733.png" alt="image.png"></p><h3 id="指令-按包含地址数分类"><a href="#指令-按包含地址数分类" class="headerlink" title="指令-按包含地址数分类"></a>指令-按包含地址数分类</h3><h4 id="零级地址指令"><a href="#零级地址指令" class="headerlink" title="零级地址指令"></a>零级地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">零地址指令：</span><br><span class="line">1.不需要操作数，比如空操作、停机、关中断等</span><br><span class="line">2.堆栈计算机，两个隐含在栈顶和次栈顶，当扫描到操作符时，自动弹出两个操作数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091940071.png" alt="image.png"></p><h4 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一地址指令:</span><br><span class="line">1.只需要1个操作数，如自加1，自减1，取反、求补码等</span><br><span class="line">指令含义：OP(A1)-&gt;A1 ,完成该条指令需3次访存，取指令-&gt;读A1-&gt;将A1写回主存</span><br><span class="line">2.需要两个操作数,但是其中一个操作数隐含在某个寄存器中(不需要访存)</span><br><span class="line">指令含义：(ACC)OP(A1)-&gt;ACC,完成该条指令需要2次访存，取指令-&gt;读A1 </span><br><span class="line">(写回ACC,ACC不属于主存，不需要访存)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306091945146.png" alt="image.png"></p><h4 id="二地址、三地址指令"><a href="#二地址、三地址指令" class="headerlink" title="二地址、三地址指令"></a>二地址、三地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">二地址指令：</span><br><span class="line">涉及两个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A1</span><br><span class="line">完成该一条指令需要访存4次，取指-&gt;读A1-&gt;读A2-&gt;写A1</span><br><span class="line">三地址指令：</span><br><span class="line">涉及三个操作数</span><br><span class="line">(A1)OP(A2)-&gt;A3</span><br><span class="line">完成该条指令需要访存4次，取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">都是需要两个操作数，访存都是四次，区别是结果是写回原操作数地址还是另外的地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092151489.png" alt="image.png"></p><h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">四地址指令：</span><br><span class="line">涉及四个操作数</span><br><span class="line">(A1)OP(A2)-&gt;(A3) 完成该条指令需要4次访存</span><br><span class="line">取指令-&gt;读A1-&gt;读A2-&gt;写A3</span><br><span class="line">与三地址指令差不多，为什么说是四地址指令呢？</span><br><span class="line">因为正常情况取指令结束后PC+1，指向下一条指令</span><br><span class="line">四地址指令后，是将PC的值修改为下一条指令A4的地址(这样实现PC摆脱单调的顺序执行)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092153291.png" alt="image.png"></p><h3 id="指令-按指令长度分类"><a href="#指令-按指令长度分类" class="headerlink" title="指令-按指令长度分类"></a>指令-按指令长度分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令字长：</span><br><span class="line">就是一条指令的总长度</span><br><span class="line">机器字长：</span><br><span class="line">对CPU而言，一次整数运算所能处理的二进制数的位数，和ALU直接相关</span><br><span class="line">存储字长：</span><br><span class="line">一个存储单元中的二进制代码位数(通常与MDR位数相同)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092229935.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按操作码长度分类：</span><br><span class="line">定长操作码</span><br><span class="line">可变长操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092235120.png" alt="image.png"></p><h3 id="指令-按操作类型分类"><a href="#指令-按操作类型分类" class="headerlink" title="指令-按操作类型分类"></a>指令-按操作类型分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">按操作类型分类：</span><br><span class="line">1.数据传送类:</span><br><span class="line">- 数据传送：进行主存与Cache之间的数据传递</span><br><span class="line">2.运算类：</span><br><span class="line">- 算数逻辑操作</span><br><span class="line">- 移位操作</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">3.程序控制类：</span><br><span class="line">- 转移操作：</span><br><span class="line">本质就是改变PC指向的指令，像是if else条件判断，来跳转执行代码</span><br><span class="line">4.输入输出类(I/O)：</span><br><span class="line">- 输入输出操作：</span><br><span class="line">进行CPU和I/O设备之间的数据传递</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092238548.png" alt="image.png"></p><h2 id="扩展操作码的指令格式"><a href="#扩展操作码的指令格式" class="headerlink" title="扩展操作码的指令格式"></a>扩展操作码的指令格式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当指令是定长时，由于位数限制</span><br><span class="line">正常情况下：0001(操作码) 1000 0000(地址码)</span><br><span class="line">--&gt;由于操作码只有4位，最多有2^4=16种操作码</span><br><span class="line">有没有办法扩展操作码数量？</span><br><span class="line">在指令定长的情况下，采用操作码变长</span><br><span class="line">--&gt;4位地址码时：是三地址指令，0000~1110  共15条操作指令</span><br><span class="line">--&gt;8位地址码时，是二地址指令，1111 0000~1111 1110 共15条指令</span><br><span class="line">--&gt;12位地址码时,是一地址指令，....15条指令</span><br><span class="line">--&gt;16位操作码时，是零地址指令，....16条指令</span><br><span class="line">注意，</span><br><span class="line">操作码低字节全1 ，1111表示扩展一字节操作码</span><br><span class="line">意味着操作码扩展后只有最低字节是变化的，高字节都是全1</span><br><span class="line">但当零地址操作码，由于无法再扩展，所以低字节1111也能表示一种操作码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306092257767.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">另一种扩展方式：</span><br><span class="line">根据实际情况设计扩展方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092330955.png" alt="image.png"></p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令字寻址"><a href="#定长指令字寻址" class="headerlink" title="定长指令字寻址"></a>定长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">程序计数器PC --&gt;始终指向下一条要指向的指令</span><br><span class="line">当系统采用定长指令结构&amp;&amp;指令字长=存储字长=16bit=2B&amp;&amp;主存按字编址</span><br><span class="line">=&gt;那么指令地址刚好是相差1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092335480.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按字节编址，两条指令的地址相差2</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092353568.png" alt="image.png"></p><h4 id="变长指令字寻址"><a href="#变长指令字寻址" class="headerlink" title="变长指令字寻址"></a>变长指令字寻址</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指令的字长不确定，需要先读入一个字，根据操作码判断这条指令的字节数n</span><br><span class="line">然后修改PC的值 (PC)+n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306092357251.png" alt="image.png"></p><h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JMP 7 --&gt;跳跃到7的指令 --&gt;跳跃寻址--&gt;直接改变PC的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306100001074.png" alt="image.png"></p><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><hr><p>指令分为操作码和地址码，根据地址码寻找指令或者操作数有很多种方式。根据地址码找指令的叫做指令寻址，被寻找的指令为吓一跳欲执行的指令。根据地址码找操作数的叫数据寻址。今天着重讲一下数据寻址的几种方式。寻址方式对于对于编译原理很重要</p><h3 id="寻址特征"><a href="#寻址特征" class="headerlink" title="寻址特征"></a>寻址特征</h3><hr><p>指令有10种寻数据寻址方式，那机器拿到一条指令后如何知道用什么寻址方式呢？<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101129895.png" alt="image.png"></p><p>我们在地址前面加入4个01数代表不同的寻址方式，我们称为<code>寻址特征</code>。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101130888.png" alt="image.png"><br>对于多地址指令，需要在每个地址前加一个寻址特征，分别代表他是什么寻址方式</p><h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636280.png" alt="image.png"></p><p>指令的地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636944.png" alt="image.png"></p><p>访存次数<br>取指令访存一次<br>取操作数访存两次<br>一共三次。<br>我们上述都是找的地址的地址，称为一次间接寻址，还有多次间接寻址。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101636795.png" alt="image.png"></p><p>如两次寻址，原理类似，就是嵌套次数不同。<br>这样增加了访存次数。为什么要有间接寻址呢？<br>1.扩大寻址范围，如果地址A的位数小于有效地址EA的位数，所以EA可以扩大寻址范围，可以找到更多的数。<br>2.如果一个操作数的地址会发生变换，间接寻址不需要修改指令。<br>多级间接寻址相比一级间接寻址有利于程序的多级调用，这里不再讲述。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101056688.png" alt="image.png"></p><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">指令中直接给操作数所在寄存器编号--&gt;无需访存，访问寄存器</span><br><span class="line">只需访存1次：取指令</span><br><span class="line"></span><br><span class="line">优点：指令执行阶段不访问主存，只访问寄存器，指令字短(寄存器集成在CPU中不可能很多)</span><br><span class="line"> 执行速度快</span><br><span class="line">缺点：寄存器昂贵，寄存器数量有限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101106740.png" alt="image.png"></p><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><hr><p>类比于间接寻址，寄存器间接寻址指令的地址是一个寄存器的地址，此寄存器存放的是操作数所在主存单元的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101116277.png" alt="image.png"></p><p>取指令访存一次，取操作数访问一次，总共访存2次，比间接寻址速度更快</p><h3 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h3><hr><p>没有给出具体地址，而是指令中隐含操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101145542.png" alt="image.png"><br>如图，指令中只给出其中一个操作数的地址，另外一个操作数隐含在寄存器ACC中<br>这样有利于缩短指令字长。</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101150946.png" alt="image.png"><br>立即寻址的地址不是操作数的地址，而是操作数本身，又称为立即数<br>操作特征是“#”，就代表使用的是立即寻址，后面跟的就是立即数<br>取指令访存一次，这总共访存一次。</p><h3 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h3><hr><ul><li>EA：effective  address</li><li>BR:   base address register</li><li>IX:    index register</li><li>PC:<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101200160.png" alt="image.png"></li></ul><p>偏移寻址都是在一个地址基础上，通偏移量的方式来寻址。<br>偏移寻址分为：基址寻址、变址寻址、相对寻址。<br>区别在于偏移的地址起点的不同。</p><h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><hr><p>以程序的起始存放地址作为“起点”。将CPU中基址寄存器(BR)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(BR)+A。其中BR可为专用基址寄存器，也可用通用寄存器作为基址寄存器。</p><p><strong>采用专用寄存器BR作为基地址寄存器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101202827.png" alt="image.png"></p><p>将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A(偏移量),<br>形成操作数的有效地址，EA=(BR)+A</p><p><strong>采用通用寄存器作为基地址寄存器。</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101209582.png" alt="image.png"></p><p>在指令中需要用R0指明基地址存放在哪个寄存器种<br>具体R0需要占几个bit需要看通用寄存器总数判断</p><p><strong>注意:</strong><br>存放基地址的存储器无论似乎BR还是其他通用寄存器，<br>程序员都无法对其进行修改，全部由操作系统控制</p><h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><hr><p>程序员自己决定从哪开始作为“起点”。将CPU中变址寄存器(IX)的内容加上指令格式中的<strong>形式地址A</strong>,而形成操作数的有效地址，即EA=(IX)+A。其中IX可为专用变址寄存器，也可用通用寄存器作为变址寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101243055.png" alt="image.png"><br>与基址寄存器的区别在于，IX是面向用户的，用户可以对IX的地址进行操作修改<br>等效于IX作为偏移量，形式地址A不变作为基地址</p><p><strong>用于循环操作</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249065.png" alt="image.png"></p><p>如果对一个循环程序进行基地址寻址，需要i个ACC加法指令，指令多效率低<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101249789.png" alt="image.png"></p><p>对循环程序进行变址寻址，使用常数条指令即可完成</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101242731.png" alt="image.png"></p><h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><hr><p>相对寻址以PC 程序计数器所指的地址作为”起点”,把程序计数器PC的内容加上指令格式中的形式地址A而形成有效地址即 EA=(PC)+A，其中A是相对于PC所指的地址的偏移量，可正可负补码表示。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101633201.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如for循环指令需要挪动原有的位置，那么他的指令在主存中的位置也会改变</span><br><span class="line">循环指令的最后一条指令是跳转指令，跳转回起始指令继续循环。</span><br><span class="line"></span><br><span class="line">由于之前改变了指令的整体位置,假如跳转指令跳转的地址是基址寻址，那么会跳转到错误的内存，于是需要相对寻址</span><br><span class="line">相对于PC指向的指令位置+偏移量:</span><br><span class="line">例如PC 先指向M+3,取出指令后，PC+1=M+4，同时之前取出的指令采用相对寻址使得</span><br><span class="line">PC-4 = M+4-4=M,再次回到了整个函数指令的起始处</span><br><span class="line">优点：</span><br><span class="line">使得这段代码始终在程序内浮动不需要更改指令跳转的地址</span><br><span class="line">相对寻址广泛运用于转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101712907.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">硬件如何实现数的&quot;比较&quot;？</span><br><span class="line">- cmp指令</span><br><span class="line">cmp a,b ，实际上a-b</span><br><span class="line">- 相减结果信息保存在PSW程序状态字寄存器中</span><br><span class="line">- 根据PSW得某几个标志位进行条件判断，决定是否转移</span><br><span class="line">PSW中标志位：</span><br><span class="line">- CF:进位/借位标志位，最高位有进位/借位时CF=1</span><br><span class="line">- ZF:零标志位，运算结果为0，ZF=1，否则ZF=0</span><br><span class="line">- SF:符号标志SF,运算结果为负SF=1,否则SF=0</span><br><span class="line">- OF:溢出标志，结果溢出OF=1,否则OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101745619.png" alt="image.png"></p><h3 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">堆栈寻址：</span><br><span class="line">硬堆栈：</span><br><span class="line">堆栈寄存器：存放操作数</span><br><span class="line">SP堆栈指针寄存器：存放栈顶元素的指针(地址)</span><br><span class="line">速度快，不访存</span><br><span class="line">软堆栈：</span><br><span class="line">操作数存放在主存里</span><br><span class="line">SP堆栈指针寄存器</span><br><span class="line">速度比较慢，访存1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306101802059.png" alt="image.png"></p><h2 id="程序的机器级代码表示"><a href="#程序的机器级代码表示" class="headerlink" title="程序的机器级代码表示"></a>程序的机器级代码表示</h2><hr><h3 id="汇编语言的考试要求"><a href="#汇编语言的考试要求" class="headerlink" title="汇编语言的考试要求"></a>汇编语言的考试要求</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111601729.png" alt="image.png"></p><h3 id="X86汇编语言基础"><a href="#X86汇编语言基础" class="headerlink" title="X86汇编语言基础"></a>X86汇编语言基础</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是X86?</span><br><span class="line">1978年Intel公司生产了一块CPU芯片代号8086，</span><br><span class="line">之后就出现了80286、80386等一系列86结尾的型号的CPU，都兼容之前的CPU，能够将程序</span><br><span class="line">移植到新的CPU执行。因此X86汇编语言指令，是指能够被这一系列CPU处理的汇编语言指</span><br><span class="line">令</span><br></pre></td></tr></table></figure><hr><h4 id="以mov指令为例"><a href="#以mov指令为例" class="headerlink" title="以mov指令为例"></a>以mov指令为例</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111617341.png" alt="image.png"><br>s-&gt;source-&gt;源操作数<br>d-&gt;destination-&gt;目标操作数<br><code>mov d , s</code>-&gt;将源操作数s复制到目的操作数d所指的位置</p><p>mov指令常用格式有一下几种<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111619250.png" alt="image.png"><br>其中当指明的是内存地址的时候，通过dword ptr(双字)、word ptr(单字)、byte ptr(字节)<br>来指明需要读写的长度</p><hr><h4 id="X86CPU有哪些寄存器"><a href="#X86CPU有哪些寄存器" class="headerlink" title="X86CPU有哪些寄存器"></a>X86CPU有哪些寄存器</h4><ul><li>X 结尾：通用寄存器</li><li>I 结尾 ：变址寄存器</li><li>P结尾：堆栈寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111633315.png" alt="image.png"></li></ul><ul><li>寄存器都以E开头，E-&gt;Extenden=32bit，</li><li>对于通用寄存器而言如果指向使用低位的16bit，那么可将E 去掉</li><li>变地址寄存器和堆栈寄存器都不能去掉E ,只能固定使用32bit</li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111638172.png" alt="image.png"></p><hr><h4 id="源、目的-操作数书写格式"><a href="#源、目的-操作数书写格式" class="headerlink" title="源、目的 操作数书写格式"></a>源、目的 操作数书写格式</h4><ul><li>[寄存器] 是指寄存器里所存的地址所指向的数据，相当于寄存器间接寻址</li><li>[地址/寄存器] 前没有指明读学长度时，默认32bit</li><li>[af996-12 h]-&gt;最后h表示16进制，这样写是指地址af886往前偏移12位地址所指数据</li><li>[abx +8]-&gt;是指该寄存器内地址往后+8的主存地址所指向的数据<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111642835.png" alt="image.png"></li></ul><hr><h4 id="常见的算数运算指令"><a href="#常见的算数运算指令" class="headerlink" title="常见的算数运算指令"></a>常见的算数运算指令</h4><ul><li>乘法 mul d,s -&gt; 表示无符号数d * s,乘积存入d</li><li>乘法 imul d,s -&gt; 表示有符号数d * s,乘积存入d</li><li>除法 div s -&gt;无符号数除法，被除数会提前存放在edx:eax中<br>  -&gt;edx:eax表示两个寄存器拼接将被除数从原来的32bit扩展为64bit ;<br>  -&gt;商存入eax,余数存入edx中</li><li>除法 idiv s -&gt;有符号数除法，被除数会提前存放在edx:eax中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111737632.png" alt="image.png"></li></ul><hr><h4 id="常见的逻辑运算指令"><a href="#常见的逻辑运算指令" class="headerlink" title="常见的逻辑运算指令"></a>常见的逻辑运算指令</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111750543.png" alt="image.png"></p><hr><h4 id="s、d操作数"><a href="#s、d操作数" class="headerlink" title="s、d操作数"></a>s、d操作数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.对于X86系统，指令后面的两个操作数不允许两个都来自主存&lt;mem&gt;</span><br><span class="line">2.并且，目的操作数d 不能是常数&lt;con&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172215148.png" alt="image.png"></p><hr><h4 id="AT-amp-T格式指令与Intel格式指令区别"><a href="#AT-amp-T格式指令与Intel格式指令区别" class="headerlink" title="AT&amp;T格式指令与Intel格式指令区别"></a>AT&amp;T格式指令与Intel格式指令区别</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111800835.png" alt="image.png"></p><ul><li>基址+变址 <em> 比例因子+偏移量<br>用于结构体数组内信息的寻址<br>基地址-&gt;寻找数组起始地址<br>变址 </em> 比例因子-&gt;寻找目标元素在数组内的位置<br>偏移量-&gt;寻找目标信息在该元素内的具体位置<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111806568.png" alt="Uploading file...npg0j"></li></ul><h3 id="选择语句的机器级表示"><a href="#选择语句的机器级表示" class="headerlink" title="选择语句的机器级表示"></a>选择语句的机器级表示</h3><hr><h4 id="jmp指令与cmp指令"><a href="#jmp指令与cmp指令" class="headerlink" title="jmp指令与cmp指令"></a>jmp指令与cmp指令</h4><p><strong>1.程序中选择分支结构</strong></p><ul><li>程序计数器PC又被称为IP寄存器<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112305940.png" alt="image.png"></li></ul><hr><p><strong>2.无条件跳转指令—Jmp</strong></p><p>执行该条指令PC会无条件跳转到某个主存地址，执行那个地址的指令</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317121.png" alt="image.png"></p><p>无条件跳转指令格式 -&gt; jmp &lt;地址&gt; </p><ul><li>jmp 128 -&gt;跳转到地址128</li><li>jmp eax -&gt; 地址来自于寄存器</li><li>jmp [999] -&gt;地址来自于主存地址999中存的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112317178.png" alt="image.png"></li></ul><hr><p><strong>3.jmp跳转标记位格式</strong></p><pre><code>因为写程序的时候，例如if-else分支语句的时候，通过条件判断决定跳转执行那一条程序语句，这样就有一个问题，如果都采用上面的三种jmp跳转指令--需要先知道需要跳转的程序的主存地址(jmp 116)，这样写死了地址，很不灵活，一旦程序的主存地址一改变，原有的jmp指令就会跳转错误位置，所以就可以通过对需要跳转的语句做标记NEXT ,通过jmp NEXT 的跳转方式实现跳转</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112330386.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112332972.png" alt="image.png"></p><hr><p><strong>4.条件转移指令-jxxx</strong></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112334438.png" alt="image.png"></p><p>通常使用条件跳转指令前，需要使用cmp指令。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336192.png" alt="image.png"></p><p>所以cmp指令经常和条件跳转指令搭配使用。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112336184.png" alt="image.png"></p><hr><p><strong>5.cmp指令的底层原理</strong></p><p>本质上就是对a,b两个操作数镜像减法运算a-b,并生成了OF、ZF、CF、SF四个标志位信息<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112339041.png" alt="image.png"></p><p>ALU 每进行一次运算的标志位都会自动存入<br>PSW程序状态字寄存器中(Intel称它为“标志寄存器FR”)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112341179.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340031.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112340390.png" alt="image.png"></p><p>jxxx指令，就是根据cmp指令得到的标志位，来判断是否= &lt;  &gt; ！=<br>进而决定进行跳转<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306112345836.png" alt="image.png"></p><hr><h4 id="条件转移指令jmp实现循环"><a href="#条件转移指令jmp实现循环" class="headerlink" title="条件转移指令jmp实现循环"></a>条件转移指令jmp实现循环</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142216499.png" alt="image.png"></p><hr><h4 id="loop指令实现循环"><a href="#loop指令实现循环" class="headerlink" title="loop指令实现循环"></a>loop指令实现循环</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 指令：</span><br><span class="line">- 格式loop Looltop  // ecx-- ,若ecx!=0,跳转到Looptop</span><br><span class="line">- 只能用ecx作为循环计数器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142229529.png" alt="image.png"></p><hr><h3 id="函数调用的机器级表示"><a href="#函数调用的机器级表示" class="headerlink" title="函数调用的机器级表示"></a>函数调用的机器级表示</h3><h4 id="call、leave、ret指令"><a href="#call、leave、ret指令" class="headerlink" title="call、leave、ret指令"></a>call、leave、ret指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">call、leave、ret指令实现函数调用：</span><br><span class="line">call 指令 作用：</span><br><span class="line">1.将IP旧址压栈保存(保存在当前函数的栈帧顶部)</span><br><span class="line">2.设置新的IP值，无条件转移到被调用函数的第一条指令</span><br><span class="line">leave 指令 作用：</span><br><span class="line">1.将现在的函数的栈帧撤销，相当于将该函数弹栈</span><br><span class="line">ret 指令 作用：</span><br><span class="line">1.弹栈后，从函数的栈帧顶部找到IP旧值，将其出栈并恢复IP原有的值指向回原来位</span><br><span class="line">置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306142240959.png" alt="image.png"></p><hr><h4 id="如何访问栈帧里的数据？"><a href="#如何访问栈帧里的数据？" class="headerlink" title="如何访问栈帧里的数据？"></a>如何访问栈帧里的数据？</h4><h5 id="访问栈帧数据Push和Pop指令"><a href="#访问栈帧数据Push和Pop指令" class="headerlink" title="访问栈帧数据Push和Pop指令"></a>访问栈帧数据Push和Pop指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ebp和esp：</span><br><span class="line">ebp指向当前栈帧的底部，esp指向当前栈帧的顶部，两者标记了当前栈帧的一个范围</span><br><span class="line">ebp、esp存的是地址不是数据值，ebp和esp只是一个指针</span><br><span class="line"></span><br><span class="line">Push、Pop指令实现入栈出栈操作操作，X86默认以4字节为单位：</span><br><span class="line">格式:</span><br><span class="line">Push ?  //先让esp-4，在将数据压入</span><br><span class="line">Push eax   #将寄存器eax的值压栈</span><br><span class="line">Push 985   #将立即数985压入栈中</span><br><span class="line">Push [ebp+8] #将主存地址[ebp+8]的数据压栈</span><br><span class="line">(所谓压栈是指将esp里保存的地址，所指向的数据的值修改,然后esp-4)</span><br><span class="line">Pop ?  //栈顶元素出栈并写入&lt;寄存器/主存地址&gt;，在esp+4</span><br><span class="line">Pop eax   # 将栈顶元素出栈，写入寄存器eax</span><br><span class="line">Pop [ebp+8] # 将栈顶元素出栈，并写入主存地址[ebp+8]</span><br><span class="line">(所谓出栈是指,将esp保存的地址所指向的值写入?,然后esp+4)</span><br><span class="line">问题： </span><br><span class="line">这样访问栈帧数据不灵活，因为每次Push都只能往esp+4的位置Push(压入数据)</span><br><span class="line">每次Pop也只能一次弹出一个栈顶元素，并写入一个栈顶栈顶元素</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151025134.png" alt="image.png"></p><hr><h5 id="访问栈帧数据mov指令"><a href="#访问栈帧数据mov指令" class="headerlink" title="访问栈帧数据mov指令"></a>访问栈帧数据mov指令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以直接对esp进行加减运算：</span><br><span class="line">可以使用减法/加法，即sub/add修改栈顶指针esp的值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151046206.png" alt="image.png"></p><hr><h4 id="如何切换栈帧？"><a href="#如何切换栈帧？" class="headerlink" title="如何切换栈帧？"></a>如何切换栈帧？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.先执行call指令：</span><br><span class="line">1.将当前IP(取出call之后自动指向下一条)值，相当于 Push IP</span><br><span class="line">2.将IP设置为被调用函数的第一条指令地址, 相当于jmp add</span><br><span class="line"></span><br><span class="line">2.进入目标函数后：&lt;保存上一个函数的栈帧，并设置当前函数栈帧&gt;</span><br><span class="line">1.Push ebp --&gt;将前一个函数的栈底地址保存入栈(先esp+4,然后将ebp值压入)</span><br><span class="line">2.mov ebp esp --&gt; 将esp的地址值复制给ebp,使ebp指向另一个函数的栈底地址</span><br><span class="line"> ==&gt; 1+2等价于enter指令</span><br><span class="line"> </span><br><span class="line">3.一系列逻辑处理</span><br><span class="line"></span><br><span class="line">4.恢复上一层函数的栈帧：</span><br><span class="line">1.mov esp ebp --&gt; 让esp指向当前函数栈底</span><br><span class="line">2.Pop ebp --&gt; 将栈顶元素出栈，并写入ebp(ebp重新指回上一个函数基底)</span><br><span class="line"> ==&gt; 等价于leave指令</span><br><span class="line">5.ret指令：</span><br><span class="line">从栈顶找到返回的地址(原来基础上继续执行)，出栈并将值写到IP寄存器中，使其继续执</span><br><span class="line">行</span><br></pre></td></tr></table></figure><p><code>调用函数</code></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151109099.png" alt="image.png"></p><p><code>函数返回</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151130458.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151214922.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151105535.png" alt="image.png"></p><hr><h4 id="如何传递参数和返回值？"><a href="#如何传递参数和返回值？" class="headerlink" title="如何传递参数和返回值？"></a>如何传递参数和返回值？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">栈帧最底部(基址)一定是上一层栈帧的基址</span><br><span class="line"></span><br><span class="line">栈帧的最顶部，一定是IP的返回地址(当前栈帧除外)</span><br><span class="line"></span><br><span class="line">栈帧结构，分为以下几块区域，每块区域内同时越靠前定义的就越靠近栈顶:</span><br><span class="line">1.局部变量区域</span><br><span class="line"></span><br><span class="line">2.未使用区域</span><br><span class="line">为什么会有未使用区域？</span><br><span class="line">因为gcc编译器会将每个栈帧大小设置为16B的整数倍(当前函数栈帧除外)</span><br><span class="line">当局部变量和调用参数没有填满栈帧时，就会空出未使用的部分</span><br><span class="line">3.调用参数区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172225143.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172137430.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">传递参数，返回值</span><br><span class="line">传低参数：在call指令前，将调用参数写入栈帧顶部区域</span><br><span class="line">接收返回值：在执行ret指令前将函数返回值写入eax寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172234781.png" alt="image.png"></p><hr><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CISC: Complex Instruction Set Computer(复杂指令集)</span><br><span class="line">- 通过一条指令完成复杂的基本功能，所以，它的指令往往是变长的</span><br><span class="line">- 变长，这也决定了它的指令执行效率低，因为需要花时间判断该指令的长度</span><br><span class="line">- 像是前面提到的乘法指令 000100 0000000110 只通过乘法指令就可以进行访存，所以</span><br><span class="line">  CISC指令对指令的访存权限没有限制</span><br><span class="line">- 由于随着CISC指令变得越来越复杂，很难用一个专门的电路硬件来实现，所以&quot;存储程</span><br><span class="line">  序&quot;，就是事先将几条组合指令存储在某个地方，比如要实现矩阵的乘法--&gt;可以通过</span><br><span class="line">  矩阵的加法、减法;整数加法、减法、乘法，5个比较通用的电路之间配合使用来实现复</span><br><span class="line">  杂的矩阵乘法</span><br><span class="line">RISC: Reduced Instruction Set Computer(精简指令集)</span><br><span class="line">- 一条指令只完成一个基本动作，一条指令一个电路</span><br><span class="line">- 由于电路设计简单功耗更低，所以主要用于移动设备:手机、平板等</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172336854.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CSIC:</span><br><span class="line">1.寄存器数量少，因为可以访存的指令没有限制，可以直接从主存中存取，不会过多的占</span><br><span class="line">  用寄存器的数量</span><br><span class="line">2.难以用优化编译生成高效的目标代码程序，因为，CISC本身就是一个复杂体，又胖又无</span><br><span class="line"> 法切割重组，决定了其效率的上限很低</span><br><span class="line"></span><br><span class="line">RISC:</span><br><span class="line">1.寄存器数量多，因为，可以访存的指令只有Load/Stroe，所以进行计算等操作的时候，</span><br><span class="line">  只能通过寄存器来存放数据，最后再通过Load/Stroe指令来进行写入或删除</span><br><span class="line">2.指令精简，可以很大程度上重组功能，生成更高效的代码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306172340404.png" alt="image.png"></p><h1 id="中央处理器CPU"><a href="#中央处理器CPU" class="headerlink" title="中央处理器CPU"></a>中央处理器CPU</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041138990.png" alt="image.png"></p><h2 id="CPU的功能和基本结构"><a href="#CPU的功能和基本结构" class="headerlink" title="CPU的功能和基本结构"></a>CPU的功能和基本结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a><em>CPU的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032012738.png" alt="image.png"></p><h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a><em>运算器和控制器的功能</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032026718.png" alt="image.png"></p><h3 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a><em>运算器的基本结构</em></h3><h4 id="专用数据通路方式"><a href="#专用数据通路方式" class="headerlink" title="专用数据通路方式"></a>专用数据通路方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每个寄存器与ALU之间都有专门的单独的数据通路--&gt;称为专用数据通路</span><br><span class="line">下图所示，所有寄存器与ALU都直接相连，但是我们不需要同时有这么多寄存器同时输入数据</span><br><span class="line">以下有两种解决办法:1.多路选择器;2.</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032116421.png" alt="image.png"></p><blockquote><p><em>多路选择器</em></p></blockquote><p><em>使用多路选择器根据控制信号选择一路输出</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032113430.png" alt="image.png"></p><blockquote><p><em>三态门</em></p></blockquote><p>计算机里面<strong>1 0</strong> 分别表示 <strong>是  非</strong> 两种逻辑，但是还不够，因此引入了一种新的状态——<strong>高阻态</strong>(相当于电阻无穷大，断路状态)。</p><p>三态：高电平、低电平、高阻态。</p><p>三态门主要与总线连接，因为总线在同一时间内只能对一个设备有效。<br>通常在数据总线上连接有<strong>多个器件</strong>。同一时刻只能有一个设备选通，用于数据传输；其他设备处于高阻态(断开)。<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032142905.png" alt="image.png"></p><p>EN使能信号：<br>    EN是<strong>0信号</strong>表示数据从A-&gt;B ;<strong>1信号</strong>表示数据从B-&gt;A；当EN使能信号无效时(没有产生信号)处于高阻态</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032148055.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032150494.png" alt="image.png"></p><h4 id="CPU内部单总线方式"><a href="#CPU内部单总线方式" class="headerlink" title="CPU内部单总线方式"></a>CPU内部单总线方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将所有寄存器的输入端和输出端都连接到一条公用的通路上(CPU内部总线)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032203518.png" alt="image.png"></p><p><strong>引入暂存寄存器</strong><br><em>从这开始内部总线就只能同时有一个输入信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032207030.png" alt="image.png"></p><p><strong>为了避免输入信号还没稳定的时候就发出输出信号，在ALU后面再引入一个暂存寄存器+一个三态门</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当输入信号稳定前，期间产生的输出信号被存放在暂存器中(此时三态门没有导通);</span><br><span class="line">当输入信号稳定之后，(三态门接通)最终产生的输出信号才传输到CPU内部总线</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032209466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032216449.png" alt="image.png"></p><h3 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307032229276.png" alt="image.png"></p><h3 id="CPU的基本结构"><a href="#CPU的基本结构" class="headerlink" title="CPU的基本结构"></a>CPU的基本结构</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041129708.png" alt="image.png"></p><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041136632.png" alt="image.png"></p><hr><h2 id="指令的执行过程"><a href="#指令的执行过程" class="headerlink" title="指令的执行过程"></a>指令的执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p><strong>CPU从主存中每取出并执行一条指令所需的全部时间</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041154511.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041200018.png" alt="image.png"></p><h3 id="数据流-微操作-有效信号"><a href="#数据流-微操作-有效信号" class="headerlink" title="数据流(微操作+有效信号)"></a>数据流(微操作+有效信号)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041429770.png" alt="image.png"><br><strong>注意书写数据流的时候需要写出——&gt; 微操作 + 有效控制信号</strong></p><hr><blockquote><p><em>指令周期的数据流向-取指周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041216231.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-间址周期</em></p></blockquote><p><strong>Ad(MDR) -&gt; MAR</strong> 中Ad 表示的是将MDR数据(取得的指令)中的<code>地址码部分</code>放入MAR中<br><strong>Ad(IR) -&gt; MAR</strong> 中Ad表示的也是将IR数据(取得的指令)中的<code>地址码部分</code>放到MAR中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041238584.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-执行周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041412833.png" alt="image.png"></p><blockquote><p><em>指令周期的数据流向-中断周期</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041428150.png" alt="image.png"></p><h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041435747.png" alt="image.png"></p><h3 id="回顾-1"><a href="#回顾-1" class="headerlink" title="回顾"></a>回顾</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041434691.png" alt="image.png"></p><h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><h3 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据通路的基本结构有:</span><br><span class="line">1.CPU内部单总线方式</span><br><span class="line">所有CPU部件连接一根内部总线，同时只能一组部件数据交换(一个发出，一个接收)</span><br><span class="line">2.CPU内部多总线方式</span><br><span class="line">为了解决同时只能有一组部件进行数据交换，所以提出CPU内部多总线，所有部件与这些</span><br><span class="line">多根总线都有连接，同时可以支持n组部件数据交换(n是总线根数)</span><br><span class="line">3.专用数据通路方式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041936960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307041935158.png" alt="image.png"></p><h3 id="数据通路-CPU内部单总线方式"><a href="#数据通路-CPU内部单总线方式" class="headerlink" title="数据通路-CPU内部单总线方式"></a>数据通路-CPU内部单总线方式</h3><blockquote><p><em>完成一次加法运算，完整的数据通路(单总线方式)</em></p></blockquote><p>由于这是单总线方式，一次只能有一组部件传输数据(例如 (ACC)-&gt;Bus-&gt;ALU  实现ACC和ALU之间的 <strong>被加数</strong>传输，<strong>加数</strong>只能先通过MDR-&gt;Bus-&gt;Y 存放在暂存寄存器中)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042005863.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>取指周期过程<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042040431.png" alt="image.png"></p><p>间址周期过程(省略微操作)：<br>    1.R0out  ,MARin 控制信号有效 -&gt;R0内间接地址传送到MAR<br>    2.MemR ,MARout ,MDRinE 控制信号有效 -&gt; 根据间接地址得到的直接地址EA存入MDR<br>    3.MDRout ,MARin 控制信号有效 -&gt;EA传给MAR<br>    4.MARout ,MemR ,MDRinE 控制信号有效 -&gt; 根据EA找到的操作数()存入MDR<br>    5.MDRout ,Yin 控制信号有效 -&gt; 将目的操作数((R0))放入暂存寄存器Y中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137539.png" alt="image.png"></p><p>执行周期过程(省略微操作):<br>    1.R1out , ALUin ,CU向ALU发送加法操作信号, 控制信号有效 -&gt;将源操作数送入ALU运算(Y寄存器同时会将之前暂存的目的操作数通过专用数据通路送往ALU)<br>    2.Zout ,MDRin 控制信号有效 -&gt; 将计算结果送入MDR寄存器<br>    3.MemW ,MDRoutE ,MARout -&gt; MDR将计算结果送到主存，MAR目的操作数地址传给主存，主存根据MAR中已经存在的目的操作数的有效地址，将结果写回到目的操作数的地址<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042137717.png" alt="image.png"></p><h3 id="数据通路-专用数据通路方式"><a href="#数据通路-专用数据通路方式" class="headerlink" title="数据通路-专用数据通路方式"></a>数据通路-专用数据通路方式</h3><blockquote><p><em>专用数据通路-取指周期</em></p></blockquote><p>取指周期数据流向:<br>    <em>1</em>. (PC)-&gt;MAR                 C0有效<br>    <em>2</em>. (MAR) -&gt;主存             C1有效<br>    <em>3</em>. 1-&gt;R                          控制单元向主存发送读命令<br>    <em>4</em>.  M(MAR) -&gt; MDR      C2有效<br>    <em>5.</em>  (MAR) -&gt; IR              C3有效<br>    <em>6.</em>  (PC)+1-&gt;PC<br>    <em>7.</em>  Op(IR) -&gt;CU             C4有效【Op是操作码，Ad是地址码；将操作码传给CU分析】<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307042219807.png" alt="image.png"></p><h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><h3 id="硬布线控制器（组合逻辑控制器）"><a href="#硬布线控制器（组合逻辑控制器）" class="headerlink" title="硬布线控制器（组合逻辑控制器）"></a>硬布线控制器（组合逻辑控制器）</h3><h4 id="什么是硬布线控制器？"><a href="#什么是硬布线控制器？" class="headerlink" title="什么是硬布线控制器？"></a><em>什么是硬布线控制器？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070922995.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070924177.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070930551.png" alt="image.png"></p><h4 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a><em>硬布线控制器的设计</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070934082.png" alt="image.png"></p><blockquote><p><em>1.分析每个阶段的微操作序列</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070935646.png" alt="image.png"></p><p><em>2.选择CPU的控制方式</em><br><strong>这里采用同步控制方式(定长机器周期)—&gt;一个周期安排3个节拍</strong></p><p><em>3.安排微操作时序</em></p><p><strong>取指周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070943155.png" alt="image.png"><br><strong>间址周期</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070946256.png" alt="image.png"><br><strong>执行周期</strong><br><em>访存指令STA 、ADD 、LDA<br>非访存指令<br>转移指令</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070945614.png" alt="image.png"></p><p><em>4.电路设计</em><br><strong>a.列出操作时间表</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951515.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070952398.png" alt="image.png"><br><strong>b.写出微操作命令的最简表达式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070948343.png" alt="image.png"><br><strong>c.画出逻辑图</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307070951629.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062351469.png" alt="image.png"></p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><h4 id="什么是微程序控制器？"><a href="#什么是微程序控制器？" class="headerlink" title="什么是微程序控制器？"></a>什么是微程序控制器？</h4><blockquote><p><em>为了方便修改和扩展，提出了微程序控制器</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071919688.png" alt="image.png"></p><ul><li>微命令是控制部件向执行部件发出的控制信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CPU内的控制器包含:CU IR PC</span><br><span class="line">CU控制单元用于实现微指令的执行</span><br><span class="line">1.由于CM内存储了多种指令 的 微程序,所以“微地址形成部件”需要根据IR内具体</span><br><span class="line">的指令的操作码，判断该指令对应CM内哪个微程序，以获得其&quot;起始微地址&quot;</span><br><span class="line">  (改正一下表述:所谓微程序既可以说是一条完整指令，包括取指周期、间址周</span><br><span class="line">  期、执行周期、中断周期的所有微指令的总和;也可以说单独的某个周期的微程</span><br><span class="line">  序，例如:取指周期微程序，这里“微地址形成部件，的作用是在根据IR中的操作</span><br><span class="line">  码特征，分析执行周期的微程序的微指令首地址，而不是取指周期微指令首地址</span><br><span class="line">  因为取指周期是通用的它的地址可以由执行周期中最末尾的微指令的下地址指</span><br><span class="line">  明，而执行周期的微指令不是通用的，所以需要单独通过“微地址形成部件”，来</span><br><span class="line">  获得首地址)</span><br><span class="line">2.再根据&quot;顺序逻辑&quot; 中&quot;标志&quot;信息判断下一步要执行微指令的存放地址(一般标志</span><br><span class="line">信息是根据指令地址码(IR中的地址码)的特征，判断是否要进行间址周期，无需间</span><br><span class="line">接寻址就跳过间址周期微指令;如果要间接寻址,那么按照“CMDR中的下地址”顺序执</span><br><span class="line">行下去)</span><br><span class="line">3.CMAR接收来自经过顺序逻辑处理后的“起始微地址”</span><br><span class="line">4.CMAR 将地址(微指令地址)送入地址译码器，找到地址对应的微指令在CM中的位</span><br><span class="line">置</span><br><span class="line">5.CM(控制存储器)根据位置取出该条微指令(操作控制+下地址) ,送到CMDR</span><br><span class="line">6.CMDR将微指令的操作控制信息 传至CPU内部和系统总线的控制信号</span><br><span class="line">7.CMDR 将下一条(相邻的)微指令地址传给顺序逻辑(顺序逻辑会根据之前获得的标</span><br><span class="line">志+CLK信息，如果当前执行到了间址周期微指令，会根据标志信息，判断是否跳过)</span><br><span class="line">8.重复这一循环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071924474.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071950460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个微程序包括一条指令的所有周期的微指令，所以一条指令的取指周期微程序+执行周期微程序，其实是一个微程序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307071958856.png" alt="image.png"></p><h4 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092240574.png" alt="image.png"></p><h5 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h5><blockquote><p><em>水平型微指令、垂直型微指令、混合型微指令</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092245360.png" alt="image.png"></p><h5 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h5><blockquote><p><em>编码方式</em></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">微指令编码主要方式分为3种</span><br><span class="line">直接编码: </span><br><span class="line">n个微命令-&gt;需要分别对应n个bit信号位</span><br><span class="line">字段直接编码: </span><br><span class="line">采用译码器，将控制字段分段,比如3bit为1段,能产生2^3种不同信号,</span><br><span class="line">这样就能用更少bit存储控制信号。</span><br><span class="line">这样实现，相同字段内的控制信息无法并行进行--&gt;所以互斥信号放在同一字段</span><br><span class="line">字段间接编码:</span><br><span class="line">译码器上加一层译码器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101035576.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101037705.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101047396.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><em>互斥的放在同一段内，控制字段，需要表示的状态数，需要预留一个全0,表示无操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101046382.png" alt="image.png"></p><h5 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h5><blockquote><p><em>方式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101050533.png" alt="image.png"></p><blockquote><p><em>例题</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101053029.png" alt="image.png"></p><h5 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h5><blockquote><p><em>微程序控制单元的设计</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141414952.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141419465.png" alt="image.png"></p><p><em>微程序设计的分类</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141420731.png" alt="image.png"></p><p><em>硬布线与微程序的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421167.png" alt="image.png"></p><p><em>微程序控制器回顾</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141421854.png" alt="image.png"></p></blockquote><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141625402.png" alt="image.png"></p><h3 id="指令流水线基本概念性能指标"><a href="#指令流水线基本概念性能指标" class="headerlink" title="指令流水线基本概念性能指标"></a>指令流水线基本概念性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141515119.png" alt="image.png"></p><h4 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a><em>指令流水的定义</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141632815.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141501856.png" alt="image.png"></p></blockquote><h4 id="流水线表示方法"><a href="#流水线表示方法" class="headerlink" title="流水线表示方法"></a><em>流水线表示方法</em></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141500715.png" alt="image.png"></p></blockquote><h4 id="流水线的性能指标-—吞吐率、加速比、效率"><a href="#流水线的性能指标-—吞吐率、加速比、效率" class="headerlink" title="流水线的性能指标 —吞吐率、加速比、效率"></a><em>流水线的性能指标</em> —<strong>吞吐率、加速比、效率</strong></h4><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513986.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513423.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307141513840.png" alt="image.png"></p></blockquote><h3 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h3><h4 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">完成一条指令，常分为五个阶段:</span><br><span class="line">IF(取指阶段)、ID(译码段)、EX(执行段)、M(访存)、WB(写回)</span><br><span class="line"></span><br><span class="line">由于每个功能段需要消耗时间不一致，为了统一方便指令流水线，以最长耗时为准这里就设为100ns</span><br><span class="line"></span><br><span class="line">同时就需要在每个功能段后面加一个缓冲寄存器--&gt;锁存器</span><br><span class="line">目的是为了保证执行更快的阶段，将数据存放，处于缓冲等待的状态，以维持统一</span><br><span class="line"></span><br><span class="line">Instruction Cache(指令Cache)--也就是Cache中存放指令的区域</span><br><span class="line">取指一般都是在指令Cache中取指</span><br><span class="line"></span><br><span class="line">Data Cache(数据Cache)--也就是Cache数据区域</span><br><span class="line">M访存，当Cache命中的情况下，直接访问数据Cache</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142119460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">考试中常见的指令有五类(RSIC精简指令集)</span><br><span class="line">运算类指令、LOAD指令、STORE指令、条件转移指令、无条件转移指令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142127965.png" alt="image.png"></p><h4 id="各类指令的执行过程"><a href="#各类指令的执行过程" class="headerlink" title="各类指令的执行过程"></a>各类指令的执行过程</h4><h5 id="运算类指令执行过程"><a href="#运算类指令执行过程" class="headerlink" title="运算类指令执行过程"></a>运算类指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142135940.png" alt="image.png"></p><h5 id="LOAD指令执行过程"><a href="#LOAD指令执行过程" class="headerlink" title="LOAD指令执行过程"></a>LOAD指令执行过程</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD--取数指令，RSIC指令集中唯二可以访存的指令,作用是从主存取数到寄存器中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142144944.png" alt="image.png"></p><h5 id="STORE指令执行过程"><a href="#STORE指令执行过程" class="headerlink" title="STORE指令执行过程"></a>STORE指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142150614.png" alt="image.png"></p><h5 id="条件转移指令执行过程"><a href="#条件转移指令执行过程" class="headerlink" title="条件转移指令执行过程"></a>条件转移指令执行过程</h5><p><strong>WrPC逻辑上既不属于M段，也不属于WB段，只是因为WrPC所需要的功能部件与这5个阶段的功能部件是“相互独立的”，所以可以看做一个独立的阶段，可以自由安排</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142157041.png" alt="image.png"></p><h5 id="无条件转移指令执行过程"><a href="#无条件转移指令执行过程" class="headerlink" title="无条件转移指令执行过程"></a>无条件转移指令执行过程</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142205108.png" alt="image.png"></p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142207049.png" alt="image.png"></p><h3 id="指令流水线的影响因素"><a href="#指令流水线的影响因素" class="headerlink" title="指令流水线的影响因素"></a>指令流水线的影响因素</h3><h4 id="结构相关"><a href="#结构相关" class="headerlink" title="结构相关"></a>结构相关</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142243130.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142245235.png" alt="image.png"></p><h4 id="数据相关"><a href="#数据相关" class="headerlink" title="数据相关"></a>数据相关</h4><p><em>这里三地址指令的顺序搞错了，顺序应该是OP R1 R2 R3  —&gt; (R1)OP(R2)—&gt;R3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142254264.png" alt="image.png"></p><blockquote><p><em>硬件阻塞</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142257185.png" alt="image.png"><br><em>NOP空操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142256095.png" alt="image.png"><br><em>数据旁路技术</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307142308675.png" alt="image.png"></p></blockquote><h4 id="控制相关"><a href="#控制相关" class="headerlink" title="控制相关"></a>控制相关</h4><p><em>由于指令会提前预取，如果到时候需要进行条件转移，那么之前预取的指令就不会执行，浪费导致阻塞</em><br><em>解决办法就是尽早的判别是否需要跳转</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151112357.png" alt="image.png"></p><h3 id="指令流水线分类"><a href="#指令流水线分类" class="headerlink" title="指令流水线分类"></a>指令流水线分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151115488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151120957.png" alt="image.png"></p><h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><h4 id="超标量技术"><a href="#超标量技术" class="headerlink" title="超标量技术"></a>超标量技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151125637.png" alt="image.png"></p><h4 id="超流水技术"><a href="#超流水技术" class="headerlink" title="超流水技术"></a>超流水技术</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127336.png" alt="image.png"></p><h4 id="超长指令字"><a href="#超长指令字" class="headerlink" title="超长指令字"></a>超长指令字</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151127292.png" alt="image.png"></p><h2 id="多处理器基本概念"><a href="#多处理器基本概念" class="headerlink" title="多处理器基本概念"></a>多处理器基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151153767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151258121.png" alt="new.png"></p><blockquote><p><em>SISD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453525.png" alt="image.png"></p><p><em>SIMD</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151453930.png" alt="image.png"></p><p><em>MIMD</em></p><p><strong>共享存储多处理器</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454475.png" alt="image.png"><br><strong>多计算机系统</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151454095.png" alt="image.png"></p><p><em>向量处理器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151455393.png" alt="image.png"></p></blockquote><h2 id="硬件多线程的基本概念"><a href="#硬件多线程的基本概念" class="headerlink" title="硬件多线程的基本概念"></a>硬件多线程的基本概念</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504162.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504522.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151504655.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151505623.png" alt="image.png"></p><h2 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h2><h3 id="CPU的功能与结构习题"><a href="#CPU的功能与结构习题" class="headerlink" title="CPU的功能与结构习题"></a>CPU的功能与结构习题</h3><blockquote><p><em>PSW属于运算器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161825605.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161834865.png" alt="image.png"></p><p><em>指令寄存器就是IR</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161835516.png" alt="image.png"></p><p><em><mark>操作系统位数是指操作系统可寻址的位数</mark></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161844725.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161846997.png" alt="image.png"></p><p><em>CPU中寄存器分为用户可见，和不可见</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161847536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161853622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161854165.png" alt="image.png"></p><p><em>存储字长—假如内存按照字节寻址，则内存中一个地址对应1byte,存储字长就是1byte</em><br><em>机器字长—CPU一次性能处理的数据的最大位数，往往等于运算器中寄存器的位数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307161856909.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162105859.png" alt="image.png"></p><p><em>地址译码器属于主存，是将地址信号翻译成存储器的选通信号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162111498.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162129014.png" alt="image.png"></p><p><em>如果指令字按字边界对齐，那么可以按一个机器字(这里是32bit=4B)，占一个地址。所以，本来按字节编址需要32位，那么按字编址，就只需30位</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162132028.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162201928.png" alt="image.png"></p></blockquote><h3 id="指令执行过程习题"><a href="#指令执行过程习题" class="headerlink" title="指令执行过程习题"></a>指令执行过程习题</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162204207.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162208016.png" alt="image.png"></p><p><em>需要存取的指令地址信息，追根究底来自于PC</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307162215113.png" alt="image.png"></p><p><em>机器周期—取决于访存时间—&gt;存取周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172057737.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172103654.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172106455.png" alt="image.png"></p><p><em>1.取指操作是控制器固有的功能，不需要操作码控制</em><br><em>2.指令有长有短，当指令过长占两个存储字长时，就需要两次访存</em><br><em>3.中断周期，是在当前指令执行完之后才出现</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172110895.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172113362.png" alt="image.png"></p><p><em>冯诺依曼计算机—&gt;同时存储指令和数据，并且统一编址</em><br><em>那吗如何区分取得的二进制串是数据还是指令呢？</em><br><em>1.首先先规定一个指令入口地址，这个地址存放的必定是指令</em><br><em>2.从入口地址取指令，然后根据指令周期的阶段，当进行到执行周期，取的<br>一定是数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172122269.png" alt="image.png"></p><p><em>开中断是指 允许中断</em><br><em>取完空操作指令，PC照样会+1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172154839.png" alt="image.png"></p><p><em>中断周期的前一个周期—&gt;执行周期</em><br><em>中断周期的后一个周期—&gt;下一条指令的取指周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172159620.png" alt="image.png"></p></blockquote><h3 id="数据通路的功能和基本概念习题"><a href="#数据通路的功能和基本概念习题" class="headerlink" title="数据通路的功能和基本概念习题"></a>数据通路的功能和基本概念习题</h3><blockquote><p><em>数据通路是指数据不同功能部件之间传送的路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172205638.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172227023.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307172232124.png" alt="image.png"></p><p><em>CPU内部单总线结构—由于只有一条数据总线，所以切换时钟周期T(节拍时)<br>就需要先释放上一个时钟周期里面微操作所占用的数据通路，才能开始下一个微操作</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181557135.png" alt="image.png"></p><p><em>举例：一整个完整管道系统(管道+阀门) ，就是一个数据通路(电路+部件)<br>水管就是电路，阀门就是部件(不能存储，是时序逻辑元件)</em><br><em>部件 分为 组合逻辑元件(不能存储，也称操作元件) 和 时序逻辑元件(能存储，也称状态元件)</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181603679.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181612657.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181621484.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181630451.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181631386.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181716181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181719840.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307181720622.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182056692.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182057675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182058005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182102014.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182117697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182112370.png" alt="image.png"></p><p><em>1.该指令，是变址寻址, X是变址寄存器XR ,D是形式地址，所以有效地址是(X)+D,那么，得到有效地址只有1个，也就意味着操作数只有一个，所以是隐含了一个操作数在ACC里面</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182129217.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182147615.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182151182.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307182158118.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191121774.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191123723.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191124619.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191128718.png" alt="image.png"></p><p><em>答题要爽快</em><br><em>1.题中M(MAR)-&gt;MDR ,外部总线数据输入到MDR控制信号MDRinE ,图中没有给出，可以不写<br>2.IR，FR(状态字寄存器)都与CU输入端相连<br>3.rd,目的寄存器，rs，源寄存器<br>4.题中声明了数据送到MDR需要5个时钟周期</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146369.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191146756.png" alt="image.png"></p></blockquote><h3 id="控制器的功能和工作原理-1"><a href="#控制器的功能和工作原理-1" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191433576.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191444240.png" alt="image.png"></p><p><em>1.缩短微指令长度，自然可以减少从CM中取指的次数，加快速度</em><br><em>2.增大控制存储器CM容量，会增加对CPU占用率，所以应该是减少CM容量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191447484.png" alt="image.png"></p><p><em>1.控制存储器CM是用的ROM芯片，只读存储器，非易失性存储器，里面的微指令是出厂就设定好的</em><br><em>2.主存是用的DRAM芯片，易失性存储器，关机数据就清空</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191454136.png" alt="image.png"></p><p><em>访存延迟比电路延迟大很多</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191502908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191504073.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191550336.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191556007.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191627070.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191628996.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191633814.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191636725.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191923360.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191928517.png" alt="image.png"></p><p><em>对于汇编语言程序员可见的寄存器，即是在汇编语言中能出现的寄存器</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191930184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191936535.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191952494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307191958740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192104787.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192107103.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192115047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192116029.png" alt="image.png"></p></blockquote><h3 id="异常和中断机制"><a href="#异常和中断机制" class="headerlink" title="异常和中断机制"></a>异常和中断机制</h3><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192120189.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307192123119.png" alt="image.png"></p></blockquote><h3 id="指令流水线习题"><a href="#指令流水线习题" class="headerlink" title="指令流水线习题"></a>指令流水线习题</h3><blockquote><p><em>流水CPU—时间并行技术<br>RSIC采用的一定是流水CPU，部分CSIC也采用流水CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202134527.png" alt="image.png"></p><p><em>超标量流水线—空间换时间，配置多个相同功能部件，同时处理相同任务</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202140283.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307202147772.png" alt="image.png"></p><p><em>m段流水线稳定时，是指，第一条指令完全从头到尾执行完，之后，每隔一个时钟周期，都会有一条指令执行结束，这样的状态就是稳定状态<br>稳定状态平均下来，一个时钟周期，完成一条任务,CPU吞吐能力(单位时间内流水线完成的任务数量)=1条/T ; 等效于m个并行部件CPU吞吐能力</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211139928.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211150637.png" alt="image.png"><br><em>度为4，表示处理机能并行处理4条指令(超标量流水技术)，那么处理20条指令，相当于普通流水线处理20/4=5条指令，过程与上面一致</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211153372.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211200981.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211444035.png" alt="image.png"></p><p><em>1.加入空操作，可以解决所有类型的指令流水线影响因素(结构、数据、控制)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211450269.png" alt="image.png"></p><p><em>数据相关流水线冲突有:<br>RAW(写后读冲突)：在前一条指令还没有写回数据，后面就开始读取该数据<br>WAR(读后写冲突)：在前一条指令对数据还没有开始读，后一条指令就开始写<br>WAW(写后写冲突)：后续指令比前面的指令先进行写数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211512534.png" alt="image.png"></p><p><em>要实现流水线必须将每个功能段时间取为一样长,且按照最长的功能段为标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211513312.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211529027.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211532867.png" alt="image.png"></p><p><em>动态调度技术，就是将能够并行执行，不会造成数据冲突的指令安排调度在同一个周期内完成</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211540142.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211603920.png" alt="image.png"></p><p><em>流水段寄存器延时—指令功能段与段(部件与部件)之间需要通过将之前的数据放到寄存器里，传递给后面的功能段(部件)，这里存在一些时间延迟，所以考虑CPU时钟周期，不仅要以最长时间为标准，还需要加上寄存器延时</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211606983.png" alt="image.png"></p><p><em>1.单周期CPU—指令周期不细化分为取指、间址、执行、等等周期，理想状态1个时钟周期就可执行一条指令<br>2.多周期CPU—指令周期细分为取指、间址、执行、中断等多个机器周期，每个机器周期都需要多个时钟周期<br>3.基本流水线—理想状态下，稳定后，隔1个时钟周期就能完成一条指令<br>4.超标量流水线—理想状态下，稳定后，隔一个时钟周期，能完成多条指令，CPI&lt;1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211617413.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211635734.png" alt="image.png"></p><p><em>画出流水线时空图、非流水线时空图、指令周期流程图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211700005.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211644593.png" alt="image.png"></p><p><em>画出流水线功能段结构图、指令执行过程流水线的时空图</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211658332.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211659606.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211942581.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211944729.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211948548.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307211951115.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212046439.png" alt="image.png"></p><p><em>（1）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212115428.png" alt="image.png"><br><em>（2）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212123922.png" alt="image.png"><br><em>(3)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212120953.png" alt="image.png"><br><em>(4)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212127310.png" alt="image.png"></p><p><em>(1)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212150355.png" alt="image.png"><br><em>(2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159175.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212159029.png" alt="image.png"><br><em>（3）</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307212206954.png" alt="image.png"></p></blockquote><h1 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151633335.png" alt="image.png"></p><h2 id="总线的概念与分类"><a href="#总线的概念与分类" class="headerlink" title="总线的概念与分类"></a>总线的概念与分类</h2><h3 id="总线的定义"><a href="#总线的定义" class="headerlink" title="总线的定义"></a>总线的定义</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151634177.png" alt="image.png"></p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151641836.png" alt="image.png"></p><h4 id="按数据传输格式"><a href="#按数据传输格式" class="headerlink" title="按数据传输格式"></a>按数据传输格式</h4><p><em>并行总线由与传输速率过快，容易产生电磁干扰，所以，并行总线不一定比串行总线传输速度快</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151644599.png" alt="image.png"></p><h4 id="按总线功能"><a href="#按总线功能" class="headerlink" title="按总线功能"></a>按总线功能</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151646654.png" alt="image.png"></p><blockquote><p><em>重点介绍系统总线- 单总线结构</em></p><p><em>1.单总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151655545.png" alt="image.png"><br><em>2.双总线结构</em><br><em>【突发传输+通道】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151701271.png" alt="image.png"><br><em>3.三总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151821115.png" alt="image.png"><br><em>4.四总线结构</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151822640.png" alt="image.png"></p></blockquote><h4 id="按时序控制方式"><a href="#按时序控制方式" class="headerlink" title="按时序控制方式"></a>按时序控制方式</h4><blockquote><p><em>略</em></p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151648934.png" alt="image.png"></p><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><p>&gt;<br><em>1.总线的传输周期（总线周期）<br>2.总线时钟周期<br>3.总线的工作频率<br>4.总线的时钟频率<br>5.总线宽度<br>6.总线带宽<br>7.总线复用<br>8.信号线数</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151833607.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834590.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151834082.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151838059.png" alt="image.png"><br><em>地址/数据总线复用，使得使用较少的线传输更多信息，但是这样，数据地址就只能交替进行输送，不能同时进行，会降低数据传输速率</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307151844178.png" alt="image.png"></p><h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><h2 id="习题-7"><a href="#习题-7" class="headerlink" title="习题"></a>习题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121248608.png" alt="image.png"></p><p><em>1.总线同一时刻只能有一个设备发送数据，但可以有越多台设备接收数据</em><br><em>2.总线同一时刻只能有一个主设备控制总线传输操作，主设备可以要求从设备发送数据，也可以自己发送数据给从设备，这个控制权在主设备手中</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121332574.png" alt="image.png"></p><p><em>1.系统总线有多种总线结构，其中单总线结构(不止只有一条总线，包含数据、地址、控制总线)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121341960.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121347353.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121349253.png" alt="image.png"></p><p><em>1.一次间接寻址获得的数据是操作数的有效地址</em><br><em>2.其实这个有效地址还是经过数据总线传送给CPU的</em><br><em>3.地址总线只能是单向的从CPU到主存，不能从主存到CPU</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121350811.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121359492.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121426426.png" alt="image.png"></p><p><em>1.CPU从主存获得的数据都是从数据总线送过来的；对于CPU识别从主存取的数据是<strong>地址</strong>还是<strong>操作数</strong>，是通过当前处于指令周期的那个阶段来判断，具体通过控制单元，识别状态触发器的二进制位信息</em><br><em>2.主存则通过，送过来的数据是通过数据总线还是地址总线，来确定是数据还是地址</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121431767.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121427891.png" alt="image.png"></p><p><em>总线带宽，计算练习</em><br><em>注意区分：时钟频率与总线频率的区别</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121434319.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121439770.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121442220.png" alt="image.png"></p><p><em>分辨率：代表一个图中总共有多少<strong>单元</strong>构成</em><br><em>颜色：每个单元内有多少种颜色</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121436770.png" alt="image.png"></p><p><em>总线标准</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121445379.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121624261.png" alt="image.png"></p><p><em>突发传输方式：是指，往主存送入一个块的首地址，那么就可以连续的读写后面后面一连串地址的数据</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121628976.png" alt="image.png"></p><p><em>USB又称通用串行总线，只能单个bit传输数据，但是传输路很高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121631356.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121634840.png" alt="image.png"></p><p><em>同步通信方式，同步时钟信号，必须要同一设备给出，以保证统一<br>同步通信方式，要求时钟信号保持一致，但是如果有的设备离的比较远，时钟信号传输中会有延迟，所有会导致时钟信号不统一，所以同步通信方式只适合设备距离较近的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121644500.png" alt="image.png"></p><p><em>1.并行总线速度过快会有干扰，串行则不会，所以串行并不一定比并行慢<br>2.突发传输：送入一个首地址，能连续读或写一连串数据<br>普通传输：送入一个地址，读或写一个数据；<br>由于传输地址信息需要占用总线，读取数据也需要占用总线，所以突发传输提高了总线利用率，更少的用来传输地址信息</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121650695.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121651874.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121703663.png" alt="image.png"></p><p><em>三通道总线，可以三个通道互相独立工作，那就要x3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121705356.png" alt="image.png"></p><p><em>总线一般被设计来传输固定大小的一块数据，这块数据被称为字(word),一个字包含的字节数(即字的大小)是各种计算机系统里面的基本参数，而且这个参数在不同的系统里通常是不同的。 大多数的现代计算机系统里面，<strong>一个字要么是4个字节（32位），要么是8个字节（64位）</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121713698.png" alt="image.png"></p><p><em>70%数据用于读，30%数据用于写；由于读的速度慢，写的速度快，所以读的时间&gt;70%总时间，写的时间&lt;30%总时间；故应该按照数据量去算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308121718898.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Telegram</title>
      <link href="/undefined/fd45428c.html"/>
      <url>/undefined/fd45428c.html</url>
      
        <content type="html"><![CDATA[<h1 id="常用bot"><a href="#常用bot" class="headerlink" title="常用bot"></a>常用bot</h1><p><code>@SMS24.me</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供虚拟手机号，接收短信</span><br></pre></td></tr></table></figure></p><p><code>@Vision Bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图像识别，识别文字</span><br></pre></td></tr></table></figure></p><p><code>@WhatAnimeBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传图片，根据图片寻找动漫片段</span><br></pre></td></tr></table></figure></p><p><code>@lang_translat_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">翻译机器人</span><br></pre></td></tr></table></figure></p><p><code>@hao1234bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索</span><br></pre></td></tr></table></figure></p><p><code>@filetobot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将文件上传到无限空间，并生成链接</span><br></pre></td></tr></table></figure></p><p><code>@GmailBot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">编辑接收谷歌邮件</span><br></pre></td></tr></table></figure></p><p><code>@newfileconverterbot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件格式转换，支持各种文件</span><br></pre></td></tr></table></figure></p><p><code>@TempMail_org_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提供10min临时邮箱</span><br></pre></td></tr></table></figure></p><p><code>@sendme_bot</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配合浏览器安装SendMe Telegram插件，可以直接将网页内容发送到电报，用于资源记录收集</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python安装</title>
      <link href="/undefined/ae5c380e.html"/>
      <url>/undefined/ae5c380e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181118970.jpg" alt="绘梨衣壁纸_彼岸壁纸.jpg"></p><h1 id="配置python"><a href="#配置python" class="headerlink" title="配置python"></a>配置python</h1><hr><ul><li><code>下载好python环境，将文件夹配置到环境变量当中</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355861.png" alt="image.png"></li></ul><ul><li><code>CMD输入python查看版本信息，若显示说明配置成功</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355755.png" alt="image.png"></li></ul><ul><li><code>若不显示，打开CMD窗口，where python查看python安装位置 path查看环境变量配置</code></li><li><code>不显示，而是打开微软商店，需要将变量中的python移到Microsoft上方,或者删除Microsoft环境变量</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355535.png" alt="image.png"></li></ul><h1 id="添加pip"><a href="#添加pip" class="headerlink" title="添加pip"></a>添加pip</h1><hr><p><strong>pip</strong>是一个以Python计算机程序语言写成的软件包管理系统，他可以安装和管理软件包</p><ul><li>将图中<code>\python311\Script</code>配置到环境变量当中<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302355943.png" alt="image.png"></li></ul><ul><li><code>查看配置是否成功</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip -V</span><br></pre></td></tr></table></figure></li></ul><h1 id="最便捷方式"><a href="#最便捷方式" class="headerlink" title="最便捷方式"></a>最便捷方式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装python后，install前勾选pip to path</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD命令</title>
      <link href="/undefined/3e5cd712.html"/>
      <url>/undefined/3e5cd712.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108345.jpg" alt="可爱女学生 蓝色眼睛 咖啡 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="调出远程桌面控制"><a href="#调出远程桌面控制" class="headerlink" title="调出远程桌面控制"></a>调出远程桌面控制</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mstsc</span><br></pre></td></tr></table></figure><p><code>输入ip地址</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352256.png" alt="image.png"></p><h1 id="查看连接过的wifi密码"><a href="#查看连接过的wifi密码" class="headerlink" title="查看连接过的wifi密码"></a>查看连接过的wifi密码</h1><hr><p><code>1.查看历史所有wifi</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profiles</span><br></pre></td></tr></table></figure></p><p><code>2.查看指定wifi的密码</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh wlan show profile name=&quot;wifi名&quot; key=clear</span><br></pre></td></tr></table></figure></p><h1 id="查询本机当前ip地址"><a href="#查询本机当前ip地址" class="headerlink" title="查询本机当前ip地址"></a>查询本机当前ip地址</h1><hr><ul><li><code>查看当前局域网ip和其他信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353460.png" alt="image.png"></li></ul><ul><li><code>查看更详细信息</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353598.png" alt="image.png"></li></ul><ul><li><code>查看当前外网地址</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L ip.tool.lu</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353405.png" alt="image.png"></li></ul><h1 id="ping检测ip地址或服务器网络情况"><a href="#ping检测ip地址或服务器网络情况" class="headerlink" title="ping检测ip地址或服务器网络情况"></a>ping检测ip地址或服务器网络情况</h1><hr><ul><li><code>短暂监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名)</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353128.png" alt="image.png"></li></ul><ul><li><code>持续监测</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping (+要检测的ip地址/绑定了ip的域名) -t</span><br></pre></td></tr></table></figure></li></ul><h1 id="调出资源监测器"><a href="#调出资源监测器" class="headerlink" title="调出资源监测器"></a>调出资源监测器</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perfmon.msc</span><br></pre></td></tr></table></figure><p><code>监测磁盘、网络、CPUz占用率</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302353676.png" alt="image.png"></p><h1 id="查看电脑当前所有用户"><a href="#查看电脑当前所有用户" class="headerlink" title="查看电脑当前所有用户"></a>查看电脑当前所有用户</h1><hr><p><code>查看用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354885.png" alt="image.png"></p><p><code>删除用户名</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user 名字 /del</span><br></pre></td></tr></table></figure></p><h1 id="修复丢失或损坏的系统文件"><a href="#修复丢失或损坏的系统文件" class="headerlink" title="修复丢失或损坏的系统文件"></a>修复丢失或损坏的系统文件</h1><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">工具可以允许用户扫描所有受保护的系统文件，并且检查系统文件的完整性，然后恢复Windows损坏的系统文件</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfc /scannow</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cmd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(三)</title>
      <link href="/undefined/1db5c403.html"/>
      <url>/undefined/1db5c403.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107238.jpg" alt="北极光 冬天 ѩ 树 人 狗 房子 灯光 动漫 绘画 风景壁纸_彼岸壁纸.jpg"></p><h1 id="数据的机器级表示"><a href="#数据的机器级表示" class="headerlink" title="数据的机器级表示"></a>数据的机器级表示</h1><h2 id="补码解析"><a href="#补码解析" class="headerlink" title="补码解析"></a>补码解析</h2><hr><ul><li><code>补码</code>：计算机只能加法运算<code>2+(-5)</code>,所以需要补码，补码大小是<code>原码取反+1</code></li><li><p><code>原码</code>：补码取反+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0101     //5的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5    fffffffb </span><br></pre></td></tr></table></figure><p><code>由于X8架构采用的是小端存储</code>：低字节在前(低地址)，高字节在后(高地址) —&gt; <code>fbffffff</code></p></li><li><p><code>补码原码相加</code>：对应位置相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 0000 0000 0010     //2的原码</span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1011     //补码 -5 </span><br><span class="line"></span><br><span class="line">1111 1111 1111 1111 1111 1111 1111 1101     //补码 -3 =2+(-5)  --&gt;依次相加</span><br></pre></td></tr></table></figure></li><li><p>对于有符号数，最高位为1，就是负数</p></li></ul><h2 id="整型不同类型"><a href="#整型不同类型" class="headerlink" title="整型不同类型"></a>整型不同类型</h2><div class="table-container"><table><thead><tr><th style="text-align:left">整型类型</th><th style="text-align:center">符号</th><th style="text-align:center">字节</th><th style="text-align:center">整型数范围</th></tr></thead><tbody><tr><td style="text-align:left">基本整型</td><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">-2^31~(2^31-1)</td></tr><tr><td style="text-align:left">短整型</td><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">-2^15~(2^15-1)</td></tr><tr><td style="text-align:left">长整型</td><td style="text-align:center">long</td><td style="text-align:center">(32位)4;(64位)8</td><td style="text-align:center">-2^31~(2^31-1)或-2^63~(-2^63-1)</td></tr><tr><td style="text-align:left">无符号整型</td><td style="text-align:center">unsigned int</td><td style="text-align:center">4</td><td style="text-align:center">0~2^32-1</td></tr><tr><td style="text-align:left">无符号短整型</td><td style="text-align:center">unsigned short</td><td style="text-align:center">2</td><td style="text-align:center">0~2^16-1</td></tr><tr><td style="text-align:left">无符号长整型</td><td style="text-align:center">unsigned long</td><td style="text-align:center">(32位)4;(62位)8</td><td style="text-align:center">0~(2^32-1)或0~(-2^64-1)</td></tr></tbody></table></div><ul><li><code>有符号数</code>：最高位只表示正负，不代表大小</li><li><code>无符号数</code>：最高位代表大小，不表示正负</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">short最小数字：</span><br><span class="line">1000 0000 0000 0000  //补码 -32768 </span><br><span class="line">1000 0000 0000 0000  //原码  32768</span><br></pre></td></tr></table></figure><h2 id="溢出解析"><a href="#溢出解析" class="headerlink" title="溢出解析"></a>溢出解析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数值溢出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">short</span> a = <span class="number">32767</span>;   <span class="comment">//01111 1111 1111 1111     32767</span></span><br><span class="line">a = a+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);  <span class="comment">//10000 0000 0000 0000    -32768 </span></span><br><span class="line"><span class="comment">//解决办法是用更大的空间存储</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=a+<span class="number">1</span>;   </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304111919441.png" alt="image.png"></p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><h3 id="浮点数IEE754标准解析"><a href="#浮点数IEE754标准解析" class="headerlink" title="浮点数IEE754标准解析"></a>浮点数IEE754标准解析</h3><hr><div class="table-container"><table><thead><tr><th style="text-align:center">浮点类型</th><th style="text-align:center">字节</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>格式</th><th>SEEEEEEE</th><th>EMMMMMMM</th><th>MMMMMMMM</th><th>MMMMMMMM</th></tr></thead><tbody><tr><td>二进制</td><td>01000000</td><td>10010000</td><td>00000000</td><td>00000000</td></tr><tr><td>十六进制</td><td>40</td><td>90</td><td>00</td><td>00</td></tr></tbody></table></div><ul><li><code>S</code>：符号位1表示正，0表示负</li><li><code>E</code>：指数部分，(指数部分的值规定只能是1到254，不能是全0，全1)，指数部分运算前都要减去127(这是EEE-754的规定)，因为还要表示负指数。这里的<code>10000001</code>转换为十进制数为129,129-127=2，即实际指数部分为2.<code>表示小数部分小数点往后移两位</code></li><li><code>M</code>：小数部分 <code>0010000 00000000 00000000</code> 左边默认省略了一个1，应该是<code>1.0010000 00000000 00000000(二进制数)</code></li></ul><blockquote><p>分析上面浮点数<br>S=0，表示正数<br>E=2^0+2^7-127=129-127=2,表示小数点向后移动两位<br>M=<code>0010000 00000000</code> ，前面默认有个1，<code>1.0010000 00000000 00000000</code><br>因为E，M小数点向后移动两位，<code>100.10000 00000000 00000000</code> =2^2 + 2^-1 =4.5</p></blockquote><h3 id="浮点数精度丢失"><a href="#浮点数精度丢失" class="headerlink" title="浮点数精度丢失"></a>浮点数精度丢失</h3><hr><ul><li>浮点型变量分为单精度（float）型、双精度（double）型</li><li>float的数值范围：<code>2^-126~2^127</code>(因为指数部分值1~254，再减去127，得到的-126~127，也就是二进制位数小数点后126位，到小数点前127位)</li><li>float的精度：<code>6~7位</code></li><li>double数值范围：<code>2^-1022~2^1023</code></li><li>double的精度：<code>15~16位</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们赋给a的值为1.23456789e10,加20后，应该得到的值为1.234567892e10,</span><br><span class="line">但b输出结果却是b=12345678848.000000,变得更小了。我们将这种现象称为精度丢失，因</span><br><span class="line">为float型数据能够表示的有效数字为7位，最多只保证1.234567e10的正确性，要使结果正确，</span><br><span class="line">就需要把a和b均改为double型，因为double可以表示的精度为15~16位。</span><br></pre></td></tr></table></figure><code>int 溢出 可以考虑改用double存储</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git远程仓库</title>
      <link href="/undefined/3f8bae1e.html"/>
      <url>/undefined/3f8bae1e.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181109558.jpg" alt="Uploading file...0i2ar"></p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>当安装Git后首先要做的事情是设置用户名称和emailt地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><p>设置用户信息</p><ul><li><code>git config --global user.name &quot;itcast&quot;</code></li><li><code>git config --global user.email &quot;hello@iteast.cn&quot;</code></li></ul><p>查看用户信息</p><ul><li><code>git config --global user.name</code></li><li><code>git config --global user.email</code></li></ul><h1 id="获取本地仓库及其基础操作指令"><a href="#获取本地仓库及其基础操作指令" class="headerlink" title="获取本地仓库及其基础操作指令"></a>获取本地仓库及其基础操作指令</h1><ul><li>初始化仓库文件夹：<code>git init</code></li><li><code>git status</code>：查看的修改的状态（暂存区、工作区）</li><li><code>git add 单个文件名|通配符.</code>：工作区-&gt;暂存区</li><li><code>git commit -m &#39;注释内容&#39;</code>：暂存区-&gt;本地仓库的当前分支</li><li><code>git-log</code>：查看提交日志</li><li><code>git reset --hard commitID</code>：版本回退；commitID 可以使用 git-log 或 git log 指令查看</li><li><code>git push -f -u origin master</code>：把修改推送至远程</li><li><code>git branch</code>：查看本地分支</li><li><code>git branch 分支名</code>：创建本地分支</li><li><code>git checkout 分支名</code>：切换本地分支</li><li><code>git merge 分支名称</code>：一个分支上的提交合并到另一个分支上</li><li><code>git branch -d 分支名</code>：删除分支，不能删除当前分支<h1 id="配置SSH公钥"><a href="#配置SSH公钥" class="headerlink" title="配置SSH公钥"></a>配置SSH公钥</h1></li></ul><hr><ul><li>生成SSH公钥：<code>ssh-keygen -t rsa</code>   不断回车; 如果公钥已经存在，则自动覆盖</li><li>获取公钥：<code>cat ~/.ssh/id_rsa.pub</code></li><li>公钥获取后，将其添加到github仓库设置中，以获取推送权限</li><li>验证是否配置成功: <code>ssh-T:git@github.com</code></li></ul><h1 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h1><hr><ul><li>命令：<code>git remote add &lt;远端名称&gt; &lt;仓库路径&gt;</code><ul><li>远端名称，默认是origin，取决于远端服务器设置</li><li>仓库路径，从远端服务器获取此URL<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354039.png" alt="image.png"></li></ul></li></ul><h1 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h1><hr><ul><li>命令：<code>git remote</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354389.png" alt="image.png"></li></ul><h1 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h1><hr><ul><li>命令：<code>git push [-f] [--set-upstream] [远端名称 [本地分支名][:远端分支名] ]</code></li><li>当前分支已经和远端分支关联，则可以省略分支名和远端名<code>git push</code></li><li><code>--set-upstream</code> 推送到远端的同时并且建立起和远端分支的关联关系。<br><code>git push --set-upstream origin master</code></li></ul><h1 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h1><hr><ul><li>命令: <code>git clone &lt;仓库路径&gt; [本地目录]</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354898.png" alt="image.png"></li></ul><h1 id="从远程仓库抓取和拉取"><a href="#从远程仓库抓取和拉取" class="headerlink" title="从远程仓库抓取和拉取"></a>从远程仓库抓取和拉取</h1><ul><li>抓取 命令：<code>git fetch [remote name] [branch name]</code> </li><li>抓取指令就是将仓库里的更新都抓取到本地，不会进行合并</li><li><p>如果不指定远端名称和分支名，则抓取所有分支。</p></li><li><p>拉取 命令：<code>git pull [remote name] [branch name]</code></p></li><li>拉取指令就是将远端仓库的修改拉到本地并自动进行合并，等同于fetch+merge</li><li>如果不指定远端名称和分支名，则抓取所有并更新当前分支。</li></ul><h1 id="其他基础命令"><a href="#其他基础命令" class="headerlink" title="其他基础命令"></a>其他基础命令</h1><h2 id="查看当前仓库大小"><a href="#查看当前仓库大小" class="headerlink" title="查看当前仓库大小"></a>查看当前仓库大小</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git count-objects -vH</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302354114.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白鲸vpn无限白嫖</title>
      <link href="/undefined/e47230b0.html"/>
      <url>/undefined/e47230b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="pc端"><a href="#pc端" class="headerlink" title="pc端"></a>pc端</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181102465.jpg" alt="232826-1622906906220f.jpg"></p><h2 id="官网下载地址"><a href="#官网下载地址" class="headerlink" title="官网下载地址"></a>官网下载地址</h2><p><a href="https://www.bjchuhai.com/?mid=3020">https://www.bjchuhai.com/?mid=3020</a></p><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><ul><li>随便填写一个邮箱，密码随意，没有二次验证</li><li>邀请码可以填写安卓手机端的账户邀请码，可以延长30天试用时间，并加速5%<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351374.png" alt="image.png"></li></ul><h2 id="重复注册"><a href="#重复注册" class="headerlink" title="重复注册"></a>重复注册</h2><ul><li>注册之后重新注册一个账号<br>一般情况提示账户密码错误<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302351877.png" alt="image.png"></li></ul><ul><li><p>找到<code>‪C:\ProgramData\Whale</code> 路径下的文件，并将所有文件删除<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302352313.png" alt="image.png"></p></li><li><p>再次注册即可</p></li></ul><h1 id="手机端-安卓"><a href="#手机端-安卓" class="headerlink" title="手机端(安卓)"></a>手机端(安卓)</h1><h2 id="手机注册"><a href="#手机注册" class="headerlink" title="手机注册"></a>手机注册</h2><p>与pc注册步骤一致</p><h2 id="重复注册-1"><a href="#重复注册-1" class="headerlink" title="重复注册"></a>重复注册</h2><p>手机最多注册两个账号，且无法像pc端进行重复注册操作<br>有两个方法：</p><ul><li>安装安卓模拟器(推荐voms pro)：通过手机模拟器，注册账号，并改变模拟器虚拟机的设备信息，实现重复注册，再通过填写邀请码延长时间</li><li>利用电脑端重复注册时，填写手机账号的邀请码，延长手机账号使用时间</li><li>注意,pc端，手机端 账号<code>是通用的^-^</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> VPN 白嫖 备用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(一)</title>
      <link href="/undefined/cc777f4a.html"/>
      <url>/undefined/cc777f4a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181108759.jpg" alt="大海 棕榈树 海滩沙滩 帆船 岛 插图风景 动漫壁纸_彼岸壁纸.jpg"></p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><div class="table-container"><table><thead><tr><th>类型</th><th>字节数</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td></tr><tr><td>float</td><td>4字节</td><td>形式-&gt;0.123 或 1.23e-1</td></tr><tr><td>double</td><td>8字节</td><td>双精度浮点型</td></tr><tr><td>char</td><td>1字节</td><td>与int类型可通用，printf(“%c\n”,c+32);—&gt;a</td></tr><tr><td>字符串</td><td>字符数+1</td><td>字符串结尾\0字符不显示，用于判断字符串结束，因此+1</td></tr></tbody></table></div><p><code>一个字节byte = 8 bit</code><br>-&gt; 1 byte = 0000 0000 </p><p><code>补充</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">32位(byte)</th><th style="text-align:center">64位(byte)</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">4</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">long long</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td><td style="text-align:center">8</td></tr></tbody></table></div><h1 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h1><div class="note blue [icon] modern"><p>printf函数的具体代码格式</p></div><div class="table-container"><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">格式</th></tr></thead><tbody><tr><td style="text-align:center">%c</td><td style="text-align:center">字符</td></tr><tr><td style="text-align:center">%d</td><td style="text-align:center">带符号整数,-左对齐，不带右对齐(printf函数默认靠右对齐)</td></tr><tr><td style="text-align:center">%x</td><td style="text-align:center">无符号十六进制数，用小写字母</td></tr><tr><td style="text-align:center">%X</td><td style="text-align:center">无符号十六进制数，用大写字母</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">浮点数；%5.2f显示5位数字，并带有2位小数的浮点数</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">一串字符，%10s代表占用10个字符位置</td></tr><tr><td style="text-align:center">%u</td><td style="text-align:center">无符号整数</td></tr><tr><td style="text-align:center">%p</td><td style="text-align:center">一个指针</td></tr></tbody></table></div><h1 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h1><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><div class="table-container"><table><thead><tr><th style="text-align:left">数组初始化</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">（1）在定义数组时对数组元素赋初值。</td><td style="text-align:left">int a[10]={0,1,2,3,4,5,6,7,8,9};不能写成int a[10];a[10]={0,1,2,3,4,5,6,7,8,9}</td></tr><tr><td style="text-align:left">（2）可以只给一部分元素赋值</td><td style="text-align:left">int a[10]={0,1,2,3,4};</td></tr><tr><td style="text-align:left">（3）使一个数组中全部元素的值为 0，那么可以写为</td><td style="text-align:left">int a[10]={0,0,0,0,0,0,0,0,0,0};或int a[10]={0};</td></tr><tr><td style="text-align:left">（4）在对全部数组元素赋初值时，数据的个数，可以不指定数组的长度</td><td style="text-align:left">int a[]={1,2,3,4,5};</td></tr></tbody></table></div><ul><li>数组名a存的是数组的起始地址，数组名传递到子函数后，形参接收到的是数组起始地址</li><li>指针在64为计算机上是8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> k=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[k]; --&gt;<span class="comment">//有的编译器支持，但是有的编译器不支持，尽量还是不要这样使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//另外不能直接给指针赋值一个数组</span></span><br><span class="line"><span class="type">int</span> *data;</span><br><span class="line">data=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; --&gt; 错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *data</span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">data=arr         --&gt; 正确</span><br><span class="line"></span><br><span class="line"><span class="comment">//另外，数组名是一个常量指针，它指向数组第一个元素，无法被修改</span></span><br><span class="line"><span class="comment">//如果要修改，需要定义一个指针变量</span></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">arr++;  --&gt;错误</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *data=arr;</span><br><span class="line">data++; --&gt;正确</span><br></pre></td></tr></table></figure></li></ul><h1 id="调试debug"><a href="#调试debug" class="headerlink" title="调试debug"></a>调试debug</h1><p><code>进入子函数</code></p><ul><li>按向下箭头进入子函数</li><li>按拐弯箭头越过子函数，只在当前函数一步一步走下去<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091733716.png" alt="image.png"></li></ul><p><code>查看变量内存视图</code></p><ul><li>点击内存视图</li><li>输入&amp;i，i为要查看内存视图的变量<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102154125.png" alt="image.png"></li></ul><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul><li>指针在64位计算机上站8个字节<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* 在变量定义中的意思</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>; </span><br><span class="line"><span class="type">int</span>* pa = &amp;a; <span class="comment">//这里的*声明定义的p是指针,指向的是a的内存地址</span></span><br><span class="line"><span class="type">int</span> ** p = &amp;pa; <span class="comment">//二级指针，** 声明该指针是 指针的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 在变量赋值运算中的意思</span></span><br><span class="line">*pa == <span class="number">1</span>; <span class="comment">//这里*是取值得意思 pa的值</span></span><br><span class="line">*p == pa;</span><br><span class="line">**p == *pa == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针进行+运算</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061516769.png" alt="image.png"></li></ul><h1 id="struct结构体"><a href="#struct结构体" class="headerlink" title="struct结构体"></a>struct结构体</h1><h2 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h2><hr><ul><li><p>方式1</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，每次结构体声明都要<code>struct student s；</code>指针声明<code>struct student *p*;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名&#123;</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方式2</p><div class="note pink [icon] [style] flat"><p>这种方式定义的结构体，结构体声明方式直接<code>stu s；</code>结构体指针<code>pstu p;</code></p></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span><span class="comment">//下面起了别名stu后student可以省略不写</span></span><br><span class="line">[成员列表]</span><br><span class="line">&#125;stu,*pstu; <span class="comment">//stu结构体别名；*pstu结构体指针别名</span></span><br></pre></td></tr></table></figure></li><li><p>结构体数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> val;</span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明单独结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">x</span>;</span></span><br><span class="line"><span class="comment">//声明结构体数组</span></span><br><span class="line">Stack st; <span class="comment">//最大容量MaxSize,无需手动分配空间，默认MaxSize</span></span><br><span class="line"><span class="comment">//声明结构体二维数组</span></span><br><span class="line">Stack b[<span class="number">10</span>]; <span class="comment">//声明一个名为b的结构体数组的数组，包含10个结构体数组</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="typedef的使用"><a href="#typedef的使用" class="headerlink" title="typedef的使用"></a>typedef的使用</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Element;<span class="comment">//重命名int类型  Element i;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> *p;<span class="comment">//重命名指针类型      p k;</span></span><br><span class="line">trpedef <span class="class"><span class="keyword">struct</span> <span class="title">student</span> <span class="title">stu</span>;</span><span class="comment">//如上，重命名结构体类型 stu s;</span></span><br></pre></td></tr></table></figure><h1 id="循环体循环判断"><a href="#循环体循环判断" class="headerlink" title="循环体循环判断"></a>循环体循环判断</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(a&lt;i);找到第i个结点</span><br><span class="line">while(a&lt;=i);找到第i+1个结点</span><br><span class="line">同理&gt;;&gt;=</span><br></pre></td></tr></table></figure><h1 id="二的次方"><a href="#二的次方" class="headerlink" title="二的次方"></a>二的次方</h1><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th><th>13</th><th>14</th><th>15</th><th>16</th></tr></thead><tbody><tr><td>2</td><td>4</td><td>8</td><td>16</td><td>32</td><td>64</td><td>128</td><td>256</td><td>512</td><td>1024</td><td>2048</td><td>4096</td><td>8192</td><td>16384</td><td>32768</td><td>65536</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown语法</title>
      <link href="/undefined/f134a8e5.html"/>
      <url>/undefined/f134a8e5.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181116370.jpg" alt="唯美 梦幻 鲸鱼 女孩 Сè 日落 大海 动漫 高清 壁纸_彼岸壁纸.jpg"></p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><hr><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h2 id="表格写法"><a href="#表格写法" class="headerlink" title="表格写法"></a>表格写法</h2><blockquote><p>要添加表，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列。您可以选择在表的任一端添加管道。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax | Description |</span><br><span class="line">| --- | ----------- |</span><br><span class="line">| Header | Title |</span><br><span class="line">| Paragraph | Text |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">Syntax</th><th style="text-align:center">Description</th><th style="text-align:right">Test Text</th></tr></thead><tbody><tr><td style="text-align:left">Header</td><td style="text-align:center">Title</td><td style="text-align:right">Here’s this</td></tr><tr><td style="text-align:left">Paragraph</td><td style="text-align:center">Text</td><td style="text-align:right">And more</td></tr></tbody></table></div><h1 id="分栏显示"><a href="#分栏显示" class="headerlink" title="分栏显示"></a>分栏显示</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab 栏目1--&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目2--&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 栏目3--&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">栏目1</button></li><li class="tab"><button type="button" data-href="#test1-2">栏目2</button></li><li class="tab"><button type="button" data-href="#test1-3">栏目3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p>这里是1</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p>这里是2</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="大量内容隐藏"><a href="#大量内容隐藏" class="headerlink" title="大量内容隐藏"></a>大量内容隐藏</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;  </span><br><span class="line">&lt;summary&gt;点击打开&lt;/summary&gt;  </span><br><span class="line">隐藏的内容  </span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><details>  <summary>显示的文字</summary>  隐藏的内容  </details><h1 id="16进制颜色码"><a href="#16进制颜色码" class="headerlink" title="16进制颜色码"></a>16进制颜色码</h1><ul><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- 红色 - #FF0000</span><br><span class="line">- 橙色 - #FFA500</span><br><span class="line">- 黄色 - #FFFF00</span><br><span class="line">- 绿色 - #00FF00</span><br><span class="line">- 青色 - #00FFFF</span><br><span class="line">- 蓝色 - #0000FF</span><br><span class="line">- 紫色 - #800080</span><br><span class="line">- 粉色 - #FFC0CB</span><br><span class="line">- 白色 - #FFFFFF</span><br><span class="line">- 黑色 - #000000</span><br><span class="line">- 银色 - #C0C0C0</span><br><span class="line">- 灰色 - #808080</span><br><span class="line">- 棕色 - #A52A2A</span><br><span class="line">- 金色 - #FFD700</span><br><span class="line">浅红色: #FFCCCC</span><br><span class="line">淡粉红: #FFE5E5</span><br><span class="line">番茄红: #FF7373</span><br><span class="line">珊瑚红: #FF8888</span><br><span class="line">淡橙色: #FFE5CC</span><br><span class="line">淡黄色: #FFFFCC</span><br><span class="line">柠檬黄: #FFFF99</span><br><span class="line">淡绿色: #CCFFCC</span><br><span class="line">米色: #FFFFCC</span><br><span class="line">天蓝色: #CCFFFF</span><br><span class="line">淡蓝色: #CCE5FF</span><br><span class="line">淡紫色: #E5E5FF</span><br><span class="line">浅紫色: #CCCCFF</span><br><span class="line">浅灰色: #CCCCCC</span><br><span class="line">翡翠绿: #CCFFCC</span><br></pre></td></tr></table></figure><h1 id="文字颜色"><a href="#文字颜色" class="headerlink" title="文字颜色"></a>文字颜色</h1></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;font color=&quot;#FF0000&quot;&gt;这是红色文本&lt;/font&gt;</span><br></pre></td></tr></table></figure><font color="#FF0000">这是红色文本</font><font color="#FFA500">这是橙色文本</font><font color="#0000FF">这是蓝色文本</font># 高亮文本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;mark&gt;这里是高亮文本&lt;/mark&gt;</span><br><span class="line">&lt;mark style=&quot;background-color: #FFB6C1;&quot;&gt;这是背景色为浅红色的高亮文本&lt;/mark&gt;</span><br></pre></td></tr></table></figure><mark>这里是高亮文本</mark><mark style="background-color: #FFB6C1;">这是背景色为浅红色的高亮文本</mark><mark style="background-color: #ffe599;">这是背景色为淡橘色的高亮文本</mark><mark style="background-color: #00FFFF;">这是背景色为淡蓝色的高亮文本</mark># 背景框<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;background-color: #f1f1f1;padding:10px;&quot;&gt; 这是一个灰色背景的文本框 &lt;/div&gt; </span><br><span class="line">&lt;div style=&quot;background-color: #ffe599;padding:15px;&quot;&gt; 这是一个浅黄色背景的文本框 &lt;/div&gt; </span><br><span class="line">&lt;div style=&quot;background-color: #fffacd;padding:20px;&quot;&gt; 这是一个淡橘色背景的文本框 &lt;/div&gt;</span><br></pre></td></tr></table></figure><div style="background-color: #f1f1f1;padding:10px;"> 这是一个灰色背景的文本框 </div> <div style="background-color: #ffe599;padding:15px;"> 这是一个浅黄色背景的文本框 </div> <div style="background-color: #fffacd;padding:20px;"> 这是一个淡橘色背景的文本框 </div># 下滑线<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;这是下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><u>这是下划线文本</u># 代码片段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;printf(&quot;Hello World&quot;);&lt;/code&gt;</span><br></pre></td></tr></table></figure><code>printf("Hello World");</code># 上下标<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E = MC&lt;sup&gt;2&lt;/sup&gt;</span><br><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure>E = MC<sup>2</sup>H<sub>2</sub>O# 居中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;center&gt;这是一段文字&lt;/center&gt;</span><br></pre></td></tr></table></figure><center>这是一段文字</center># 列表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;列表项&lt;/li&gt;</span><br></pre></td></tr></table></figure><li>列表项</li># 图片居中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;图片地址&quot; alt=&quot;图片alt&quot;&gt; &lt;/p&gt;</span><br></pre></td></tr></table></figure># 字体大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;font size=&quot;3&quot;&gt;这是小号字体&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">&lt;font size=&quot;5&quot;&gt;这是大号字体&lt;/font&gt;</span><br></pre></td></tr></table></figure><font size="3">这是小号字体</font><font size="5">这是大号字体</font><h1 id="表格合并"><a href="#表格合并" class="headerlink" title="表格合并"></a>表格合并</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| 标题1 | 标题2 | 标题3 |</span><br><span class="line">| :-- | :--: | --: |</span><br><span class="line">| 合并内容1 | &lt;td rowspan=&quot;2&quot;&gt;跨行合并&lt;/td&gt; | 内容3 |</span><br><span class="line">| 合并内容2 | 内容5 | 内容6 |</span><br><span class="line"></span><br><span class="line">| 标题1 | &lt;th colspan=&quot;2&quot;&gt;跨列合并&lt;/th&gt; | </span><br><span class="line">| :-- | :--: | --: |</span><br><span class="line">| 内容1 | 内容2 | 内容3 |</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">标题1</th><th style="text-align:center">标题2</th><th style="text-align:right">标题3</th></tr></thead><tbody><tr><td style="text-align:left">合并内容1</td><td style="text-align:center"><td rowspan="2">跨行合并</td></td><td style="text-align:right">内容3</td></tr><tr><td style="text-align:left">合并内容2</td><td style="text-align:center">内容5</td><td style="text-align:right">内容6</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">标题1</th><th style="text-align:center"><th colspan="2">跨列合并</th></th></tr></thead><tbody><tr><td style="text-align:left">内容1</td><td style="text-align:center">内容2</td><td style="text-align:right">内容3</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/undefined/79666db.html"/>
      <url>/undefined/79666db.html</url>
      
        <content type="html"><![CDATA[<h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181106524.jpg" alt="崩坏 星穹铁道 女孩 相机 星空 高清壁纸_彼岸壁纸 (1).jpg"></p><h2 id="数据结构概念"><a href="#数据结构概念" class="headerlink" title="数据结构概念"></a>数据结构概念</h2><blockquote><p>概念：</p><ul><li>数据元素：一个数据体，考虑为一个人，一份订单…</li><li>数据项：数据体内的各项，人的信息项，订单的信息项…</li><li>数据对象：具有相同性质，数据元素的集合<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302328740.png" alt="image.png"></li><li>数据类型：是指一个值得集合，和定义在此集合上一组操作的总称<ul><li>原子类型：基本数据类型<br>  结构体运算：+ - * % …</li><li>结构类型：结构体(可以再分为若干分量)<br>  结构体运算—&gt;封装为函数</li><li>抽象数据类型：抽象数据组织及与之相关操作(描述了数据的<code>逻辑结构</code>和<code>抽象运算</code>)，可以用其定义一个完整的数据结构</li><li>数据结构：相互间存在一种或多种特定关系的数据元素的集合</li></ul></li></ul><p>数据结构三要素：</p><ul><li><code>逻辑结构</code><ul><li>线性结构</li><li>非线性结构(集合结构、树形结构、图状结构)</li></ul></li><li><code>存储结构</code><ul><li>链式存储：离散存放的</li><li>顺序存储：占用大片连续空间</li><li>索引存储</li><li>散列存储</li></ul></li><li><code>数据的运算</code>：比如，栈的抽象运算是<code>先进后出</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341139.png" alt="image.png"></li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302341254.png" alt="image.png"></p><h2 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1.数据的逻辑结构独立于其存储结构，逻辑结构是抽象表达方式，例如图的逻辑结构，采用顶点与边</span><br><span class="line">而图的存储结构采用二维数组(顺序存储)或链表结点(链式存储)</span><br><span class="line"></span><br><span class="line">2.存储数据时，不仅要存储数据的值，还要存储数据元素之间的关系(例如顺序表存储元素有下标，表示与其他数据元素的位置关系)</span><br><span class="line"></span><br><span class="line">3.对于两种不同的数据结构，他们的逻辑结构完全有可能相同，</span><br><span class="line"></span><br><span class="line">4.举例说明，对相同的逻辑结构，同一种运算在不同的存储方式下实现时，其运算效率不同？</span><br><span class="line">线性表，可以顺序存储，可以链式存储，顺序存储方式，插入删除操作要平均移动一半元素，O(n)</span><br><span class="line">链式存储方式，插入删除时间复杂度O(1)</span><br><span class="line"></span><br><span class="line">5.以下与数据存储结构无关的术语是：D</span><br><span class="line">  A 循环队列  B 链表  C 哈希表  D 栈 </span><br><span class="line">  解析：栈是一种抽象数据类型，可采用顺序存储，链式存储，只表示逻辑结构</span><br><span class="line"></span><br><span class="line">6.以下属于逻辑结构的是（c）。</span><br><span class="line">A.顺序表</span><br><span class="line">B.哈希表</span><br><span class="line">C.有序表</span><br><span class="line">·D.单链表</span><br><span class="line"></span><br><span class="line">顺序表体现数组存储方式，哈希表体现散列存储方式，单链表体现链式存方式，有序表体现有序的逻辑结构</span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><blockquote><p>算法：求解问题的步骤<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304061942250.png" alt="image.png"><br>-算法特性：</p><ul><li>有穷性，有限步骤内完成，有穷时间内完成</li><li>确定性，意义明确，无歧义；给定相同的输入，输出结果确定唯一</li><li>可行性，可以通过基本运算执行有限次来实现</li><li>输入，0个或多个输入</li><li>输出，1个或多个输出</li></ul><p>好的算法具备特质：</p><ul><li>正确性，能正确实现目的</li><li>可读性，容易理解阅读</li><li>健壮性，可以灵活处理数据中的非法数据，给出反应进行处理</li><li>高效率地存储需求，花费时间少(时间复杂度低)，不费内存(空间复杂度低)</li></ul><p><mark class="hl-label blue">时间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th>a</th><th>结论</th></tr></thead><tbody><tr><td>1</td><td>顺序执行的代码只影响常数项</td></tr><tr><td>2</td><td>只需要挑去循环当中的某一个基本操作分析它的执行次数与n的关系</td></tr><tr><td>3</td><td>如果有多层嵌套循环，只需要关注最深层得循环执行了几次</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072136217.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072140867.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072141426.png" alt="image.png"></p><blockquote><p><mark class="hl-label blue">空间复杂度</mark> ：</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">普通程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">只需关注存储空间大小与问题规模相关的变量</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">分析所占空间x与问题规模n的关系 x=f(n)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">递归程序</th><th style="text-align:center">结论</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">找到递归深度x与问题规模n的关系</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">x的数量级O(x)就是算法空间复杂度S(n)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072151890.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072152388.png" alt="image.png"></p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">总结</th></tr></thead><tbody><tr><td style="text-align:center">定义</td><td style="text-align:center">数据类型同类型、有限、有序(先后顺序)</td></tr><tr><td style="text-align:center">位序</td><td style="text-align:center">线性表数据元素的位序从1开始(数组下标以0开始)</td></tr><tr><td style="text-align:center">基本操作</td><td style="text-align:center">创销、增删改查；判空、判长、打印输出</td></tr><tr><td style="text-align:center">注意</td><td style="text-align:center">函数名要有可读性、见名知意</td></tr><tr><td style="text-align:center">包括</td><td style="text-align:center">链表(链式存储)、顺序表(顺序存储)</td></tr></tbody></table></div><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072231315.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304072232709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">构造方法框架：</span><br><span class="line">InitL1st(&amp;L）:初始化表。构造一个空的线性表。</span><br><span class="line">Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class="line">LocateElem(L,e):按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class="line">GetE1em(L,i):按位查找操作。获取表L中第1个位置的元素的值。</span><br><span class="line">ListInsert(&amp;L,i,e):插入操作。在表L中的第i个位置上插入指定元素e.</span><br><span class="line">ListDelete(&amp;L,i,&amp;e):别除操作，别除表L中第1个位置的元素，并用e返回别除元素的值。</span><br><span class="line">Pr1 ntList(L):输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class="line">Empty(L):判空操作。若L为空表，则返回true,否则返回false.</span><br><span class="line">DestroyList(&amp;L):销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br></pre></td></tr></table></figure><h1 id="线性表顺序存储"><a href="#线性表顺序存储" class="headerlink" title="线性表顺序存储"></a>线性表顺序存储</h1><h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><h3 id="顺序表定义"><a href="#顺序表定义" class="headerlink" title="顺序表定义"></a>顺序表定义</h3><blockquote><p>顺序表实现方式：<br><code>静态分配</code>：ElemType data[MaxSize]（存储空间不可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType data [MaxSize];</span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; <span class="comment">//定义的是结构体的数据类型</span></span><br></pre></td></tr></table></figure><p><code>动态分配</code>：ElemType  * data （存储空间可调控）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Initsize10 <span class="comment">//默认的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data ;</span><br><span class="line"><span class="type">int</span> Maxsize;<span class="comment">//记录最大容量</span></span><br><span class="line"><span class="type">int</span> Length;</span><br><span class="line">&#125;SqList; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SeqList &amp;L)</span>&#123;</span><br><span class="line"><span class="comment">//用ma11oc函数申请一片连续的存储空间</span></span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>(Initsize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">L.MaxSize=Initsize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Increasesize</span><span class="params">(SeqList &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="type">int</span> *p=L.data;</span><br><span class="line">L.data=(<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//申请另一块内存空</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line">L.data[i]=p[i];<span class="comment">//将数据复制到新区域</span></span><br><span class="line">&#125;</span><br><span class="line">L.MaxSize=L.MaxSize+len;<span class="comment">//顺序表最大长度增加len</span></span><br><span class="line"><span class="built_in">free</span>(p);<span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344408.png" alt="image.png"></p><p>顺序表特点</p><ul><li>随机访问：可以在O(1)时间内找到第i给元素</li><li>存储密度高，只能存储数据本身，不能存储指针信息</li><li>拓展容量不方便：每次拓展容量都需要开拓一个新的内存空间，并复制过去</li><li>插入删除元素不方便，需要移动大量的元素</li></ul></blockquote><h3 id="顺序表插入操作"><a href="#顺序表插入操作" class="headerlink" title="顺序表插入操作"></a>顺序表插入操作</h3><blockquote><p>健壮性，异常处理：</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>方法要进行，判满，判断插入位置是否有效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(SqList&amp;L <span class="type">int</span> i，<span class="type">int</span> e)</span>&#123;<span class="comment">//i插入位置，e要插入元素</span></span><br><span class="line"><span class="keyword">if</span>（i&lt;<span class="number">1ll</span>i&gt;L.length+<span class="number">1</span>） <span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">if</span>（L.length&gt;=MaxSize） <span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>；</span><br><span class="line"><span class="keyword">for</span>（intj=L.length;j&gt;=i；j--） <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">L.data[j]=L.data[j<span class="number">-1</span>]；</span><br><span class="line">L.data[i<span class="number">-1</span>]=e； <span class="comment">//在位置i处放入e</span></span><br><span class="line">L.length++； <span class="comment">//长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>；</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：插入到表尾i=n+1，无需移动元素 <code>O(1)</code></li><li>最坏：插入到表头i=1，全部后移一位<code>O(n)</code></li><li>平均：假设新元素插入到任何一个位置的概率相同，即i=1,2,3,,length+1的概率都是p=1/n+1,i=1,循环n次：i=2时，循环n-1次：i=3,循环n-2次…i=n+1时，循环0次;平均循环次数=np+(n-1)p+(n-2)p+…+1p=n/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的删除操作"><a href="#顺序表的删除操作" class="headerlink" title="顺序表的删除操作"></a>顺序表的删除操作</h3><blockquote><p>健壮性异常处理</p><ul><li>返回布尔型变量用于判断操作是否成功</li><li>判空、判断删除位置i是否有效</li><li>要加一个变量e(注意要&amp;e)，将被删除元素的值带回来</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;<span class="comment">//引用，否则无法带回数据</span></span><br><span class="line"><span class="keyword">if</span>(i&lt;<span class="number">1</span> i&gt;L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">e=L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;L.length;j++)<span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">L.data[j<span class="number">-1</span>]=L.data[j];</span><br><span class="line">L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题规模n:顺序表表长length<br>时间复杂度：</p><ul><li>最好：删除表尾i=n，无需移动元素 <code>O(1)</code></li><li>最坏：删除表头i=1，全部前移一位<code>O(n)</code></li><li>平均：假设删除任何一个位置的概率相同，即i=1,2,3,,length的概率都是p=1/n,i=1,循环n-1次：i=2时，循环n-2次：i=3,循环n-3次…i=n时，循环0次;平均循环次数=(n-1)p+(n-2)p+(n-3)p+…+1p=n-1/2,  <code>O(n)</code></li></ul></blockquote><h3 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h3><h4 id="按位查找"><a href="#按位查找" class="headerlink" title="按位查找"></a>按位查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="title function_">GetElem</span><span class="params">(SeqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<code>O(1)</code></p><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SeqList L,ElemType e)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;<span class="number">1</span>++)</span><br><span class="line"><span class="keyword">if</span>(L.data[i]==e)</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//数组下标为i的元素值等于e,返回其位i+1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出循环，说明查找失败</span></span><br></pre></td></tr></table></figure><p>时间复杂度：</p><ul><li>最好：<code>O(1)</code> 查找元素在表头</li><li>最坏：<code>O(n)</code> 查找元素在表尾</li><li>平均：<code>O(n)</code>  循环n+1/2次</li></ul><h2 id="对称矩阵的压缩存储"><a href="#对称矩阵的压缩存储" class="headerlink" title="对称矩阵的压缩存储"></a>对称矩阵的压缩存储</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231535705.png" alt="image.png"></p><h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li><li class="tab"><button type="button" data-href="#test1-7">7</button></li><li class="tab"><button type="button" data-href="#test1-8">8</button></li><li class="tab"><button type="button" data-href="#test1-9">9</button></li><li class="tab"><button type="button" data-href="#test1-10">10</button></li><li class="tab"><button type="button" data-href="#test1-11">11</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.从顺序表中别除具有最小值的元素（假设唯一）并由函数返回被别元素的值。空出的位</span></span><br><span class="line"><span class="comment">//置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_min</span><span class="params">(SqList T,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> min=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]&lt;T.data[min])&#123;</span><br><span class="line">min=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">e=T.data[min];</span><br><span class="line">T.data[min]=T.data[length<span class="number">-1</span>];</span><br><span class="line">T.length--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.设计一个高效算法，将顺序表L的所有元素逆置，要求算法的空间复杂度为O（1）,</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inverse</span><span class="params">(SqList T)</span>&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">temp=T.data[i];</span><br><span class="line">T.data[i]=T.data[T.length-i];</span><br><span class="line">T.data[T.length-i]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3.对长度为n的顺序表L,编写一个时间复杂度为O（n）、空间复杂度为O（1）的算法，该算</span></span><br><span class="line"><span class="comment">法别除线性表中所有值为x的数据元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void delet(Sqlist T,int pos)&#123;</span></span><br><span class="line"><span class="comment">if(T.length=0||pos&gt;T.length||pos&lt;0)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int i=pos;i&lt;=T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">T.data[i]=T.data[i+1];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void delet_x(Sqlist T,int x)&#123;</span></span><br><span class="line"><span class="comment">int* arr;</span></span><br><span class="line"><span class="comment">int k=0;</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;T.length;i++)&#123;</span></span><br><span class="line"><span class="comment">if(T.data[i]=x)&#123;</span></span><br><span class="line"><span class="comment">arr[k]=i;</span></span><br><span class="line"><span class="comment">k++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(k;k&gt;=0;k--)&#123;</span></span><br><span class="line"><span class="comment">delet(T,arr[k]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//上述代码，不符合时间复杂度与空间复杂度要求</span></span><br><span class="line"><span class="comment">//解法1.正确思路：用k记录值不等于x的元素的个数，然后，将不等于x的值移到下标为x的位置，然后调整k位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]!=x)&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2，用k记录值等于x的元素个数，边扫描L边统计k,并将不等于x的元素前移k位</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">del_x</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(T.data[i]==x)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.len=L.len-k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.从顺序表中删除其值在给定值s与t之间(要求s&lt;t)的所有元素，若s或t不合理</span></span><br><span class="line"><span class="comment">或顺序表为空，则显示出错信息并退出运行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法1.用k记录不符合删除条件的元素个数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(T.data[i]&gt;s&amp;&amp;T.data[i]&lt;t))&#123;</span><br><span class="line">T.data[k]=T.data[i];</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T.length=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法2.用k记录在s和t之间的元素个数，并边扫描，边统计k，将不在s和t之间的元素前移k位</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_st</span><span class="params">(Sqlist &amp;L,<span class="type">int</span> s,<span class="type">int</span> t)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s&gt;=t||T.length==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(L.data[i]&gt;s&amp;&amp;L.data[i]&lt;t)&#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">L.data[i-k]=L.data[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L.length-=k;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SqTable</span>&#123;</span>  </span><br><span class="line">    <span class="type">int</span>* data;  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">&#125;Sqlist;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=pos+<span class="number">1</span>;i&lt;T.length;i++)&#123;  </span><br><span class="line">        T.data[i<span class="number">-1</span>]=T.data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    T.length--;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T.length==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T.length<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;T.length;j++)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(j==T.length)&#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(T.data[i]==T.data[j])&#123;  </span><br><span class="line">                delet(T,j);  </span><br><span class="line">                j--;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优化思路，先排序，后遍历删除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delet_repeat</span><span class="params">(Sqlist &amp;T)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先排序</span></span><br><span class="line">    qsort(T.data, T.length, <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp); </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; T.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T.data[i] != T.data[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            T.data[i] = T.data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T.length = i + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序的时间复杂度为O(nlogn),遍历的时间复杂度为O(n),所以总时间复杂度为O(nlogn)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*6.将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表*/</span></span><br><span class="line"><span class="comment">//算法思想：首先，按顺序不断取下两个顺序表表头较小的结点存入新的顺序表中。然后，看</span></span><br><span class="line"><span class="comment">//哪个表还有剩余，将剩下的部分加到新的顺序表后面。</span></span><br><span class="line">Sqlist <span class="title function_">merge</span><span class="params">(Sqlist T1,Sqlist T2)</span>&#123;  </span><br><span class="line">    Sqlist T3;  </span><br><span class="line">    T3.data=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(T1.length+T2.length));  </span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length&amp;&amp;j&lt;T2.length)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(T1.data[i]&lt;=T2.data[j])&#123;  </span><br><span class="line">            T3.data[k]=T1.data[i];  </span><br><span class="line">            i++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            T3.data[k]=T2.data[j];  </span><br><span class="line">            j++;  </span><br><span class="line">            k++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;T1.length)&#123;  </span><br><span class="line">        T3.data[k]=T1.data[i];  </span><br><span class="line">        k++;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(j&lt;T2.length)&#123;  </span><br><span class="line">        T3.data[k]=T2.data[j];  </span><br><span class="line">        k++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    T3.length=k;  </span><br><span class="line">    <span class="keyword">return</span> T3;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">7.[2010统考真题]设将n(n&gt;1)个整数存放到一维数组R中。设计一个在时间和空间</span></span><br><span class="line"><span class="comment">两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&lt;p&lt;n)个位置，即将R</span></span><br><span class="line"><span class="comment">中的数据由(X0,X1,…,Xn-1)变换为(XpXp+1,…,Xn-1,X0,X1,…,Xp-1).要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度和空间复杂度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">答：</span></span><br><span class="line"><span class="comment">1.可以将问题看做将数组ab转换成ba,可以先将a逆转置，再将b逆置，再将整体逆置，就得到ba</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_singel</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> bengin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(begin,end;begin&lt;end;begin++,end--)&#123;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=T.data[begin];</span><br><span class="line">T.data[begin]=T.data[end];</span><br><span class="line">T.data[end]=temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reserve_all</span><span class="params">(Sqlist &amp;T,<span class="type">int</span> p)</span>&#123;</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,p<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,p,n<span class="number">-1</span>);</span><br><span class="line">reserve_singel(T,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以上算法中三个reserve_all的时间复杂度分别是O(p/2),O((n-p)/2),O(n/2);</span></span><br><span class="line"><span class="comment">//总时间复杂度是O(n),空间复杂度O(1)</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">8.线性表(a1,a2,a3,an)中元素递增有序且按顺序存储于计算机内。要求设计一算法完成用最少时间在表中查找数值为x的元素，若找到将其与后继元素位置相交换，若找不到将其插入表中并使表中元素仍递增有序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//算法思路：二分查找函数+交换函数+插入函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(SSTable &amp;S,<span class="type">int</span> i)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=S.len)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp;</span><br><span class="line">temp=S.data[i];</span><br><span class="line">S.data[i]=S.data[i+<span class="number">1</span>];</span><br><span class="line">S.data[i+<span class="number">1</span>]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">(SSTable &amp;S,<span class="type">int</span> x,<span class="type">int</span> pos)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=S.len<span class="number">-1</span>;i&gt;=pos;i--)&#123;</span><br><span class="line">S.data[i+<span class="number">1</span>]=S.data[i];</span><br><span class="line">&#125;</span><br><span class="line">S.len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Binary_Search_insert</span><span class="params">(SSTable S,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=S.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(S.data[mid]==x)&#123;</span><br><span class="line">Swap(S,mid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(S.data[mid]&lt;x)&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Insert(S,x,low);  <span class="comment">//没有查到，那么low所指向位置，就是插入位置,low一定是比x大的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-9"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050853124.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-10"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305050947008.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-11"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051013253.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMissMin</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> *B;</span><br><span class="line">B=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*n); <span class="comment">//创建一个存放标记的数组</span></span><br><span class="line"><span class="built_in">memset</span>(B,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>)*n);  <span class="comment">//赋值初始0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(A[i]&gt;<span class="number">0</span>&amp;&amp;A[i]&lt;=n)&#123;</span><br><span class="line">B[A[i]<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线性表链式存储"><a href="#线性表链式存储" class="headerlink" title="线性表链式存储"></a>线性表链式存储</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="单链表的定义"><a href="#单链表的定义" class="headerlink" title="单链表的定义"></a>单链表的定义</h3><hr><ul><li>定义结构体</li><li>初始化</li><li>判空</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">不带头结点的链表</button></li><li class="tab"><button type="button" data-href="#test1-2">带头结点链表</button></li><li class="tab"><button type="button" data-href="#test1-3">区别</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=<span class="literal">NULL</span>; <span class="comment">//空表，暂时还没有任何结点,同时为了防止脏数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L =<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode *LinkList;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个空的单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));</span><br><span class="line"><span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123; <span class="comment">//内存不足，分配失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">LinkList L; <span class="comment">//声明一个指向单链表的指针</span></span><br><span class="line"><span class="comment">//初始化一个空的表</span></span><br><span class="line">InitList(L);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344241.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位插入不带头结点</button></li><li class="tab"><button type="button" data-href="#test1-2">按位插入带头结点</button></li><li class="tab"><button type="button" data-href="#test1-3">指定结点的前插操作O(n)</button></li><li class="tab"><button type="button" data-href="#test1-4">指定结点的前插操作O(1)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231344545.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345110.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">指定结点，这种方式，先找到指定节点的前驱结点--&gt;遍历</span><br><span class="line">平均复杂度O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345224.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种方式，无需找到指定结点前驱结点，先插入到后面，然后交换data,等效为前插</span><br><span class="line">O(1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345353.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><hr><div class="note blue [icon] [style] flat"><p>这里就不讨论不带头结点的链表删除情况了</p></div><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">按位序删除</button></li><li class="tab"><button type="button" data-href="#test1-2">指定结点删除</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">按位置删除，只能通过遍历找到第i-1个结点</span><br><span class="line">最坏，平均都是O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345569.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这种指定节点删除方式，时间复杂度`O(1)`,但是极限情况，当p最后结点的时候</span><br><span class="line">就无法通过转移数据的方式完成删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231345879.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h3><hr><h4 id="按位查找-1"><a href="#按位查找-1" class="headerlink" title="按位查找"></a>按位查找</h4><p><code>时间复杂度O(n)</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">优化前</button></li><li class="tab"><button type="button" data-href="#test1-2">优化后</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Linklist p;</span><br><span class="line">    p=L;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li><code>无需再定义一个p指针用来遍历，直接用头结点L进行遍历，然后返回L，由于L没有用引用,最终并不会改变L</code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h4 id="按值查找-1"><a href="#按值查找-1" class="headerlink" title="按值查找"></a>按值查找</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">Linklist <span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line"><span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line"><span class="keyword">while</span> (L !=<span class="literal">NULL</span>&amp;&amp;L-&gt;data!=e)</span><br><span class="line">L = L-&gt;next;</span><br><span class="line"><span class="keyword">return</span> L;<span class="comment">//找到后返回该结点指针，否则返回WULL</span></span><br></pre></td></tr></table></figure></p><h4 id="统计表长"><a href="#统计表长" class="headerlink" title="统计表长"></a>统计表长</h4><p><code>时间复杂度O(n)</code></p><h3 id="单链表建立"><a href="#单链表建立" class="headerlink" title="单链表建立"></a>单链表建立</h3><h4 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_head_insert</span><span class="params">(LNode* &amp;L)</span>&#123;  </span><br><span class="line">    L= (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//给L申请一个头结点结点空间  </span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;<span class="comment">//读取的第一个元素  </span></span><br><span class="line">    LinkList s;<span class="comment">//用来指向新节点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));<span class="comment">//给s申请一个新的空间  </span></span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//实现头插法，s成为第一个结点  </span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//L作为头结点，任然指向第一个结点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//读取x的值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><code>重要性质：头插法实现的链表数据是逆置的，用于链表的逆置</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346377.png" alt="image.png"></p><p><code>链表逆置：循环依次读取老链表数据，然后用头插法依次建立新链表/再次用头插法插入到之后，这样就是实现了链表逆置</code></p><h4 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h4><p><code>时间复杂度O(n)</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点 ,将L赋给s,r ,相当于s,r,L都是头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  <span class="comment">//将s赋给r,r重新指向尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了克服单链表无法直接通过一个结点访问其前驱</span><br><span class="line">提出了双链表</span><br><span class="line">双链表结点结构体，有两个指针，一个指向前驱，另一个指向后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双链表中结点类型的描述如下：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title function_">DNode</span><span class="params">(            <span class="comment">//定义双链表结点类型</span></span></span><br><span class="line"><span class="params">ElemType data;               <span class="comment">//数据域</span></span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> DNode *prior,*next;   <span class="comment">//前驱和后继指针</span></span></span><br><span class="line"><span class="params">&#125;DNode,*DLinklist;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346859.png" alt="image.png"></p><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在循环单链表中，表尾结点*r的next域指向L，故表中没有指针域为NULL的结点，因此，</span><br><span class="line">循环单链表的判空条件不是头结点的指针是否为空，而是它是否等于头指针。</span><br><span class="line"></span><br><span class="line">循环单链表的插入、删除算法与单链表的几乎一样，所不同的是若操作是在表尾进行，则执</span><br><span class="line">行的操作不同，以让单链表继续保持循环的性质。当然，正是因为循环单链表是一个“环”，因</span><br><span class="line">此在任何一个位置上的插入和删除操作都是等价的，无须判断是否是表尾。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346340.png" alt="image.png"></p><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态链表借助数组，表示链式存储结构</span><br><span class="line">需要大片的连续的空间，删除或增加结点不需要移动其他元素</span><br><span class="line">结点有指针域(下一个结点的数组下标)，数据域(存储的数据)；</span><br><span class="line">静态链表以next=-1表示结束</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50           <span class="comment">//静态链表的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>              <span class="comment">//静态链表结构类型的定义</span></span><br><span class="line">ElemType data;               <span class="comment">//存储数据元素</span></span><br><span class="line"><span class="type">int</span> next;                    <span class="comment">//下一个元素的数组下标</span></span><br><span class="line">&#125;SLinkList [Maxsize];</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231346580.png" alt="image.png"></p><h2 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.静态链表中指针表示的是（C）。</span></span><br><span class="line"><span class="comment">A.下一元素的地址</span></span><br><span class="line"><span class="comment">B.内存储器地址</span></span><br><span class="line"><span class="comment">C.下一个元素在数组中的位置</span></span><br><span class="line"><span class="comment">D.左链或右链指向的元素的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：静态链表就是用数组(顺序存储)的链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用（C）</span></span><br><span class="line"><span class="comment">最节省时间。</span></span><br><span class="line"><span class="comment">A.不带头结点的单循环链表</span></span><br><span class="line"><span class="comment">B.双链表</span></span><br><span class="line"><span class="comment">C不带头结点且有尾指针的单循环链表</span></span><br><span class="line"><span class="comment">D.单链表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.[2021统考真题]已知头指针h指向一个带头结点的非空单循环链表，结点结构为</span></span><br><span class="line"><span class="comment">【data next】</span></span><br><span class="line"><span class="comment">,其中next是指向直接后继结，点的指针，p是尾指针，q是临时指针。现要</span></span><br><span class="line"><span class="comment">删除该链表的第一个元素，正确的语句序列是（D）。</span></span><br><span class="line"><span class="comment">A.h-&gt;nextsh-&gt;next-&gt;next;q=h-&gt;next;free(q)</span></span><br><span class="line"><span class="comment">B.q=h-&gt;next;h-&gt;next=h-&gt;next-&gt;next;free(q);</span></span><br><span class="line"><span class="comment">C.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p!=q) p=h;free(q);.</span></span><br><span class="line"><span class="comment">D.q=h-&gt;next;h-&gt;next=q-&gt;next;if(p==q) p=h;free(q);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：如果删除的元素是尾结点，则需要判断是否是尾结点，是则将尾指针指向头结点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.[2009统考真题]已知一个带有表头结，点的单链表，结点结构为</span></span><br><span class="line"><span class="comment">data link</span></span><br><span class="line"><span class="comment">假设该链表只给出了头指针11st。在不改变链表的前提下，请设计一个尽可能高效的</span></span><br><span class="line"><span class="comment">算法，查找链表中倒数第k个位置上的结点(k为正整数)。若查找成功，算法输出该结</span></span><br><span class="line"><span class="comment">点的data域的值，并返回l;否则，只返回0。要求：</span></span><br><span class="line"><span class="comment">1)描述算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)描述算法的详细实现步骤。</span></span><br><span class="line"><span class="comment">3)根据设计思想和实现步骤，采用程序设计语言描述算法（使用C、C++或Java语言</span></span><br><span class="line"><span class="comment">实现），关健之处请给出简要注释。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本思路：设置p、q两个指针，p指针先走当p指针走到底k的结点时，q开始移动，当p移动到尾部时，q停止</span></span><br><span class="line"><span class="comment">//此时q所指得结点就是倒数第k个结点</span></span><br><span class="line"></span><br><span class="line">LinkList <span class="title function_">search_k</span><span class="params">(LinkList L,<span class="type">int</span> k)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;  </span><br><span class="line">    LinkList p=L-&gt;next;  </span><br><span class="line">    LinkList q=L-&gt;next;<span class="comment">//p、q起点可以不是L-&gt;next,因为求得是倒数，只要倒数个数比起点更右端即可  </span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;next;  </span><br><span class="line">            q=q-&gt;next;    </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(count&lt;k)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> q;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5.[2012统考真题]假定采用带头结点的单链表保存单词，当两个单词有相同的后缎时，</span></span><br><span class="line"><span class="comment">可共享相同的后缀存储空间；例如，loading和being的存储映像如下图所示。</span></span><br><span class="line"><span class="comment">   str1</span></span><br><span class="line"><span class="comment">  头结点1 -&gt; l -&gt; o -&gt; a -&gt; d ----&gt; i -&gt; n -&gt; g</span></span><br><span class="line"><span class="comment">                                   ^</span></span><br><span class="line"><span class="comment">   str2                            |</span></span><br><span class="line"><span class="comment">  头结点2 -&gt; b -&gt; e ----------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">设str1和str2分别指向两个单词所在单链表的头结点，链表结，点结构为[data next]</span></span><br><span class="line"><span class="comment">请设计一个时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀</span></span><br><span class="line"><span class="comment">的起始位置(如图中字符1所在结点的位置p)。要求：</span></span><br><span class="line"><span class="comment">1)给出算法的基本设计思想。</span></span><br><span class="line"><span class="comment">2)根据设计思想，采用C或C++或Java语言描述算法，关键之处给出注释。</span></span><br><span class="line"><span class="comment">3)说明你所设计算法的时间复杂度。  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解：因为是单链表无法，从后往前遍历，于是只能单向从前往后遍历，p 、q指针分别指向str1 str2的头结点，判断str1和str2的长度m、n.如果m&gt;n则p先走，使得p q到尾结点的距离一致。然后p、q共同移动直到遇到结点内容一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历两条链表的长度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Get_length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(L)&#123;</span><br><span class="line">L=L-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找出共同后缀起始地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_same_str</span><span class="params">(LinkList str1,LinkList str2)</span>&#123;</span><br><span class="line">m=Get_length(str1);</span><br><span class="line">n=Get_length(str2);</span><br><span class="line"><span class="keyword">for</span>(str1;m&gt;n;m--)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(str2;n&gt;m;n--)&#123;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(str1-&gt;next!=<span class="literal">NULL</span>&amp;&amp;str1-&gt;next!=str2-&gt;next)&#123;</span><br><span class="line">str1=str1-&gt;next;</span><br><span class="line">str2=str2-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度 m+n+(m-n)+2(n-x)=2m+2n-2x 所以时间复杂度为O(m+n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.将链表L&#123;a1,a2 a3 a4 a5...an-2 an-1an&#125;--&gt;L&#123;a1 an a2 an-1 a3...&#125;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resort</span><span class="params">(LinkNode *L)</span>&#123;</span><br><span class="line">LinkNode *k,kk=L;</span><br><span class="line">LinkNode *r,s;</span><br><span class="line"><span class="keyword">while</span>(kk-&gt;next)&#123;</span><br><span class="line">k=k-&gt;next;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(kk-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">kk=kk-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将链表后半段逆置</span></span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=k-&gt;next;</span><br><span class="line">k-&gt;next=kk;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">s=L-&gt;next;</span><br><span class="line">kk=k-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(kk)&#123;</span><br><span class="line">r=kk-&gt;next;</span><br><span class="line">kk-&gt;next=s-&gt;next;</span><br><span class="line">s-&gt;next=q;</span><br><span class="line">s=q-&gt;next;</span><br><span class="line">kk=r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><p><code>定义</code>：一种只允许在一端进行插入或删除<code>的线性表</code></p><blockquote><p><em>栈实现—顺序存储</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line">typeof <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> top;  <span class="comment">//栈针</span></span><br><span class="line">&#125;SqStack</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line">S.top=<span class="number">-1</span>;  <span class="comment">//初始指向-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span>  <span class="title function_">isEmpty</span><span class="params">(SqStack &amp;S)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">S.data[++S.top]=x; <span class="comment">//先+，后赋值</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x=S.data[S.top--]; <span class="comment">//先赋值，后-</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>栈实现—链式存储</em><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义栈结点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span> <span class="comment">//定义单链表结点类型</span></span><br><span class="line"><span class="type">int</span> data;         <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">next</span>;</span> <span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;SNode, *LiStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个链栈（单链表实现，栈顶在链头）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitStack</span><span class="params">(LiStack &amp;S)</span> &#123;</span><br><span class="line">    S = (SNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode)); <span class="comment">//分配一个头结点</span></span><br><span class="line">    S-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头结点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">StackEmpty</span><span class="params">(LiStack S)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(S-&gt;next==<span class="literal">NULL</span>) <span class="comment">//头结点后面没有结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回true，表示栈为空</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈（本质上是单链表的“头插法”）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span> <span class="params">(LiStack &amp;S, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">    SNode * p = (SNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SNode)); <span class="comment">//新分配一个结点</span></span><br><span class="line">    p-&gt;data = x; <span class="comment">//存入新元素</span></span><br><span class="line">    p-&gt;next = S-&gt;next;</span><br><span class="line">    S-&gt;next = p; <span class="comment">//新结点插入到头结点后面</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈（本质上是单链表的“头删法”）</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span> <span class="params">(LiStack &amp;S, <span class="type">int</span> &amp;x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StackEmpty(S)) <span class="comment">//栈空，出栈操作失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    SNode * p = S-&gt;next; <span class="comment">//栈不空，链头结点出栈</span></span><br><span class="line">    x = p-&gt;data; <span class="comment">//x返回栈顶元素</span></span><br><span class="line">    S-&gt;next = p-&gt;next; <span class="comment">//头删法，栈顶元素&quot;断链&quot;</span></span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">//释放结点</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="栈在括号匹配中应用"><a href="#栈在括号匹配中应用" class="headerlink" title="栈在括号匹配中应用"></a>栈在括号匹配中应用</h2><blockquote><p><code>括号匹配问题</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最后出现的左括号，最先被匹配</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051432873.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051433730.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遇到左括号--&gt;入栈</span><br><span class="line">遇到右括号--&gt;出栈，并且匹配检查</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051434299.png" alt="image.png"></p><p><code>算法实现</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051439016.png" alt=""></p></blockquote><h2 id="栈在表达式求值应用"><a href="#栈在表达式求值应用" class="headerlink" title="栈在表达式求值应用"></a>栈在表达式求值应用</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051442887.png" alt="image.png"></p><blockquote><p><code>前缀、中缀、后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051522948.png" alt="image.png"></p><p><code>中缀转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051524252.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虽然两种后序表达式都是正确的，但是由于计算机运算遵循左优先原则，尽可能的先算左边运算符</span><br><span class="line">这样就保证运算顺序唯一</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051529561.png" alt="image.png"></p><p><code>用栈实现后缀表达式的计算</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从左往右依次扫描</span><br><span class="line">2.扫描到数字，则压入栈</span><br><span class="line">3.扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，继续1</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051548740.png" alt="image.png"></p><p><code>用栈实现中缀表达式转后缀表达式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051613746.png" alt="image.png"></p><p><code>用栈实现中缀表达式求值</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">中缀转后缀+后缀计算</span><br><span class="line"></span><br><span class="line">1.扫描中缀表达式，从左往右</span><br><span class="line">2.扫描到数，入数栈；扫描到符号，入符号栈</span><br><span class="line">3.扫描到符号如果前面有优先级更高的，则要先弹出高优先级，再入栈当前符号，并弹出两个操作数</span><br><span class="line">  与弹出的符号运算，并将结果入回数栈顶部</span><br><span class="line">4.如果扫描到的符号前面没有优先级更高的，则无需操作，继续扫描</span><br><span class="line">5.遇到 ( 则 直接入栈，遇到 ) 依次弹出栈内运算符，并弹出相应数进行运算，直到弹出 ( 为止</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051619822.png" alt="image.png"></p></blockquote><h2 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h2><blockquote><p><code>递归工作栈</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051744820.png" alt="image.png"></p></blockquote><h2 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h2><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">3</button></li><li class="tab"><button type="button" data-href="#test1-5">4</button></li><li class="tab"><button type="button" data-href="#test1-6">5</button></li><li class="tab"><button type="button" data-href="#test1-7">6</button></li><li class="tab"><button type="button" data-href="#test1-8">7</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051804701.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051939158.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基本操作是指能直接实现的操作，ACD都属于基本操作，但是B栈不能直接删除栈底元素，需要一个一个移开上面元素，再删除，再放回之前的元素</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052010610.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052024207.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链栈,头指针为栈顶--&gt;才能实现先进后出</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3个不同元依次进栈，能得到（B)种不同的出栈序列。</span><br><span class="line">A.4</span><br><span class="line">B.5</span><br><span class="line">C.6</span><br><span class="line">D.7</span><br><span class="line"></span><br><span class="line">解析：卡特兰数，(6x5x4)/(3x2x1)/4=5</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052151736.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符可以字母，下划线开头，不可以数字开头</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-7"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">共享栈，可以节省存储空间，降低发生上溢的可能</span><br><span class="line"></span><br><span class="line">共享栈是一种两个栈共享同一片存储空间的数据结构。它的特点是两个栈的栈底在这片存储空间的两</span><br><span class="line">端，当元素入栈时，两个栈的栈顶指针相向而行。这样可以更有效地利用存储空间，只有在整个空间</span><br><span class="line">满时才会发生上溢</span><br><span class="line"></span><br><span class="line">共享栈栈满条件判断有两种：</span><br><span class="line">栈顶指针初始指向-1:</span><br><span class="line">栈顶指针初始指向0：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052212674.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-8"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305052231925.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><hr><p><code>是只允许在一端进行插入，在另一端删除的线性表</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">队列(顺序存储)</button></li><li class="tab"><button type="button" data-href="#test1-2">队列(链式存储-带头结点)</button></li><li class="tab"><button type="button" data-href="#test1-3">队列(链式存储-不带头结点)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MaxSize];</span><br><span class="line"><span class="type">int</span> rear,front;</span><br><span class="line">&#125;SqSueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.rear=Q.front=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==Q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//为空</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(SqQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==q.front)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsFull(Q))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.data[Q.rear]=x;</span><br><span class="line">Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize; </span><br><span class="line"><span class="comment">//取模，例如x%7,最终得到的值只能是0,1,2,3,4,5,6</span></span><br><span class="line"><span class="comment">//循环往复变化，采用取模方式的队列，被称为&quot;循环队列&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.front=(Q.front+<span class="number">1</span>)%MaxSize;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051245346.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 队列中元素个数=(rear+MaxSize-front)%MaxSize</span><br><span class="line">- 队列中最多存储MaxSize-1个元素，留一个空位给rear用来(rear+1)%MaxSize判定</span><br><span class="line">  否则，全装满，rear=front,那么判空，判满无法区分</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种判断队列空满的方法，增加辅助变量，可以充分利用存储单元，可以装满</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051252761.png" alt="image.png"></p><p><code>回顾</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051257769.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051400428.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，带头结点                           </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;                </span><br><span class="line">L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">Q.front=Q.rear=L;                        </span><br><span class="line">Q.front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判空，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;                   </span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear)&#123;                         </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;                                 </span><br><span class="line">&#125;                                           </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;                               </span><br><span class="line">&#125;                                            </span><br><span class="line"></span><br><span class="line"><span class="comment">//无需判满，链表可以无限长</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，带头结点                             </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;           </span><br><span class="line">LinkList s;                                  </span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));        </span><br><span class="line">s-&gt;data=x;                                     </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;                                </span><br><span class="line">Q.rear-&gt;next=s;                              </span><br><span class="line">Q.rear=s;                                        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出队，带头结点                             </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;  <span class="comment">//x将出队元素带出</span></span><br><span class="line"><span class="keyword">if</span>(IsEmpty)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">LinkList p=Q.front-&gt;next;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front-&gt;next=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(Q.rear==p)&#123;  <span class="comment">//如果是出队队尾元素，要考虑rear的变化</span></span><br><span class="line">Q.rear=Q.front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;                            </span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051416101.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">Q.rear=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//盘空，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==Q.rear==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//入队，不带头结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">linkList s;</span><br><span class="line">s=(Linklist)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">s-&gt;data=x; </span><br><span class="line">s-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.front-&gt;next=s;</span><br><span class="line">Q.rear=s;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q.rear-&gt;next=s;</span><br><span class="line">    Q.rear=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出队，不带头结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(Q.front==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Linklist p=Q.front;</span><br><span class="line">x=p-&gt;data;</span><br><span class="line">Q.front=p-&gt;next;</span><br><span class="line"><span class="keyword">if</span>(p==Q.rear)&#123;  <span class="comment">//如果删除的最后一元素</span></span><br><span class="line">Q.rear=<span class="literal">NULL</span>:</span><br><span class="line">Q.front=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><blockquote><p><code>注意</code>：顺序存储，<code>rear</code>指向的是尾部元素的后一位；链式存储，<code>rear</code>指向的就是尾部元素</p></blockquote><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">主要用于判断输出序列的合法性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051419921.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305051424490.png" alt="image.png"></p><h2 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061135804.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这题实质上问的需要多少个队列</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061155791.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061203327.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">迷宫求解，本质是岔路选择，遇到选择则入栈</span><br><span class="line"></span><br><span class="line">缓冲区，本质是一个队列，将信息，按原本顺序输出(先入先出)，作用是缓存信息(延长信息存在时间)，以防止计算机反应慢接收不到</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">1.一个问题的递归算法求解和其相对应的非递归算法求解，（B）。</span><br><span class="line">A.递归算法通常效率高一些 B.非递归算法通常效率高一些</span><br><span class="line">C.两者相同    D.无法比较</span><br><span class="line"></span><br><span class="line">解析：递归算法--&gt;代码简洁，容易理解，但是效率低，因为递归存在大量重复运算；非递归算法--&gt;代码繁琐，但是效率较高，没有多余运算</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">2.执行（B）操作时，需要使用队列作为辅助存储空间。</span><br><span class="line">A.查找散列（哈希）表 B 广度优先搜索图</span><br><span class="line">C．前序（根）遍历二叉树 D.深度优先搜索图</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">B：图的广度优先遍历：以广度为优先考虑，使用队列</span><br><span class="line">C：前中后序遍历二叉树，在递归方法中都隐含 递归栈。 那么非递归方法中必然是使用栈来进行这些  </span><br><span class="line">   相关操作的。</span><br><span class="line"></span><br><span class="line">3.下列说法中正确的是（A）。</span><br><span class="line">A.消除递归不一定需要使用栈</span><br><span class="line">B。对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同</span><br><span class="line">C.通常使用队列来处理函数或过程调用</span><br><span class="line">D.队列和栈都是运算受限的线性表，只允许在表的两端进行运算</span><br><span class="line"></span><br><span class="line">解析：A本来没必要使用递归的算法，使用递归，那么消除递归就不一定需要使用栈替代</span><br><span class="line"></span><br><span class="line">4.为解决计算包主机省打印机之间速度不匹配问题，通常设置一个打印数缓冲区，庄机将要输出的数据依次写入该缓冲，而打机则依次从该缓冲区中取出数据。该缓冲区的逻辑结应该是(A)</span><br><span class="line">A.栈</span><br><span class="line">B.队列</span><br><span class="line">C.树</span><br><span class="line">D.图</span><br><span class="line"></span><br><span class="line">5.某汽车轮渡口，过江渡船每次能载10辆车过江。过江车辆分为客车类和货车类，上渡船有如下规定：同类车先到先上船；客车先于货车上渡船，且每上4辆客车，才允许放上一辆货车；若等待客车不足4辆，则以货车代替；若无货车等待，允许客车都上船。试设计一个算法模拟渡口管理。</span><br><span class="line"></span><br><span class="line">“同类车先到先上船’一一队列。一个队列负责一种车。</span><br><span class="line">接下来是按照条件进行按顺序上车。</span><br><span class="line">每次上限是10，也就是4客车+1货车，4客车+1货车。</span><br><span class="line">最后两个条件，其实就是“没客车的话货车可以替代客车”和“没货车的话客车可以替代货车”。</span><br><span class="line">写两个函数，用于上客车和上货车，每一个内部再进行判断是否够用。</span><br><span class="line">经过上面的过程，整个算法的思路就明确下来了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061647514.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="type">int</span> n;        <span class="comment">//保存n</span></span><br><span class="line"><span class="type">double</span> val;   <span class="comment">//保存Pn的值</span></span><br><span class="line">&#125;Stack[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">comculate</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">Stack a; <span class="comment">//结构体数组，最大限制100</span></span><br><span class="line"><span class="type">int</span> top=<span class="number">-1</span>,i;</span><br><span class="line"><span class="keyword">for</span>(i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">top++;</span><br><span class="line">a[top].n=i;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> fv1=<span class="number">1</span>,fv2=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">while</span>(top&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">a.[top].val=<span class="number">2</span>*x*fv2<span class="number">-2</span>*(a.[top].n)*fv1;</span><br><span class="line">fv1=fv2;</span><br><span class="line">fv2=a.[top].val;</span><br><span class="line">top--;     <span class="comment">//出栈</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> fv1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fv2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><hr><ul><li><code>分支结点</code>：有左孩子或右孩子或都有的结点</li><li><code>叶子结点</code>：没有左右孩子的结点</li><li><code>结点之间的路径</code>：结点与结点之间的边的数量，只能单方向从上往下</li><li><code>结点的层次(深度)</code>：从上往下数，<code>默认从1开始</code></li><li><code>结点的高度</code>：从下往上数</li><li><code>树的高度(深度)</code></li><li><code>结点的度</code>：结点有多少个分支</li><li><code>树的度</code>：各结点的度的最大值</li><li><code>森林</code>：m个(m&gt;=0)互不相交的树组成</li><li><code>前驱</code>：<code>遍历后的顺序</code>，当前节点的前一个节点为该节点的前驱节点</li><li><code>后继</code>：<code>遍历后的顺序</code>，当前节点的后一个节点为该节点的前驱节点</li></ul><h2 id="树的常考性质"><a href="#树的常考性质" class="headerlink" title="树的常考性质"></a>树的常考性质</h2><hr><ul><li><mark style="background-color: 00FFFF;">1.结点数=总度数+1</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336588.png" alt="image.png"></li></ul><ul><li><mark style="background-color: 00FFFF;">2.度为m的树第i层最多有<code>m^(i-1)</code>个结点</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231336371.png" alt="image.png"></li></ul><ul><li>**<mark style="background-color: 00FFFF;">3.高度为h的m叉树最多有(m^h - 1)/(m - 1)个结点</mark><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337980.png" alt="image.png"></li></ul><ul><li>4.具有n个结点的m叉树的最小高度为 <strong>⌈log<sub>m</sub>(n(m-1)+1)⌉</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231337731.png" alt="image.png"></li></ul><ul><li><strong>5.具有n个结点的二叉树，总共有n+1个空链域</strong></li></ul><h2 id="完全二叉树与满二叉树"><a href="#完全二叉树与满二叉树" class="headerlink" title="完全二叉树与满二叉树"></a>完全二叉树与满二叉树</h2><ul><li><code>满二叉树</code>：度全为2或0</li><li><p><code>完全二叉树</code>:最多只有一个度为1的结点<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338981.png" alt="image.png"></p></li><li><p><code>二叉排序树</code>：左子树上所有节点均小于根节点，右子树上均大于根节点</p></li><li><code>平衡二叉树</code>：树上任意结点的左子树和右子树的深度只差不超过1,能有更高的搜索效率<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338997.png" alt="image.png"></li></ul><h2 id="二叉树的常考性质"><a href="#二叉树的常考性质" class="headerlink" title="二叉树的常考性质"></a>二叉树的常考性质</h2><p><code>1.具有n个结点的完全二叉树的高度</code><br><code>向上取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231338666.png" alt="image.png"></p><p><code>向下取整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339299.png" alt="image.png"></p><p><code>2.完全二叉树，度为0、1、2的结点个数</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设度为0、1、2的结点个数分别为n0、n1、n2</span><br><span class="line">yw 是完全二叉树</span><br><span class="line">sy n0=0或1</span><br><span class="line">yw n0=n2+1</span><br><span class="line">sy n0+n2--&gt;奇数</span><br><span class="line">sy n0+n2+n0的奇偶性看n1</span><br><span class="line">sy 当n1=1时，结点数是偶数；当n1=0时，结点数为奇数</span><br></pre></td></tr></table></figure></p><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><h3 id="定义顺序存储的二叉树—下标从1开始"><a href="#定义顺序存储的二叉树—下标从1开始" class="headerlink" title="定义顺序存储的二叉树—下标从1开始"></a><em>定义顺序存储的二叉树—下标从1开始</em></h3><blockquote><p>二叉树顺序存储的数据结构定义，需要注意以下两点：<br> 1 .二叉树的结点用数组存储，每个结点需要标记“是否为空”<br> 2.各结点的数组下标隐含结点关系，要能根据一个结点的数组下标 i，计算出其父节点、左孩子、右孩子的数组下标</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">若顺序二叉树从数组下标1开始存储结点，则：</span><br><span class="line"></span><br><span class="line">● 结点 i 的父结点编号为 i/2</span><br><span class="line">● 结点 i 的左孩子编号为 i*2</span><br><span class="line">● 结点 i 的右孩子编号为 i*2+1</span><br><span class="line"></span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="type">int</span> data; <span class="comment">//结点中的数据元素</span></span><br><span class="line"><span class="type">bool</span> isEmpty; <span class="comment">//结点是否为空</span></span><br><span class="line">&#125; TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化顺序存储的二叉树，所有结点标记为&quot;空&quot;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSqBiTree</span> <span class="params">(TreeNode t[], <span class="type">int</span> length)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">   t[i].isEmpty=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现函数，找到结点-i-的父结点、左孩子、右孩子"><a href="#实现函数，找到结点-i-的父结点、左孩子、右孩子" class="headerlink" title="实现函数，找到结点 i 的父结点、左孩子、右孩子"></a><em>实现函数，找到结点 i 的父结点、左孩子、右孩子</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断下标为 index 的结点是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index &gt;= length || index &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//下标超出合法范围</span></span><br><span class="line"><span class="keyword">return</span> t[index].isEmpty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的左孩子，并返回左孩子的下标，如果没有左孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getLchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> lChild = index * <span class="number">2</span>; <span class="comment">//如果左孩子存在，则左孩子的下标一定是 index * 2</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, lChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//左孩子为空</span></span><br><span class="line"><span class="keyword">return</span> lChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的右孩子，并返回右孩子的下标，如果没有右孩子，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRchild</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="type">int</span> rChild = index * <span class="number">2</span> + <span class="number">1</span>; <span class="comment">//如果右孩子存在，则右孩子的下标一定是 index * 2 + 1</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, rChild)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//右孩子为空</span></span><br><span class="line"><span class="keyword">return</span> rChild;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到下标为 index 的结点的父节点，并返回父节点的下标，如果没有父节点，则返回 -1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getFather</span><span class="params">(TreeNode t[], <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//根节点没有父节点</span></span><br><span class="line"><span class="type">int</span> father = index / <span class="number">2</span>; <span class="comment">//如果父节点存在，则父节点的下标一定是 index/2，整数除法会自动向下取整</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, father)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> father;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用上述三个函数，实现先-中-后序遍历"><a href="#利用上述三个函数，实现先-中-后序遍历" class="headerlink" title="利用上述三个函数，实现先/中/后序遍历"></a><em>利用上述三个函数，实现先/中/后序遍历</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从下标为 index 的结点开始先序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">PreOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//先序遍历左子树</span></span><br><span class="line">PreOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//先序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始中序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">InOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//中序遍历左子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">InOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//中序遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从下标为 index 的结点开始后序遍历</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrderSqTree</span> <span class="params">(TreeNode *t, <span class="type">int</span> length, <span class="type">int</span> index)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isEmpty(t, length, index)) <span class="comment">//当前为空节点</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">PostOrderSqTree(t, length, getLchild(t, length, index)); <span class="comment">//后序遍历左子树</span></span><br><span class="line">PostOrderSqTree(t, length, getRchild(t, length, index)); <span class="comment">//后序遍历右子树</span></span><br><span class="line">visitNode(t[index]); <span class="comment">//访问结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    TreeNode t[<span class="number">100</span>]; <span class="comment">//定义一棵顺序存储的二叉树</span></span><br><span class="line">InitSqBiTree(t, <span class="number">100</span>); <span class="comment">//初始化为空树</span></span><br><span class="line"><span class="comment">//...在空二叉树中插入数据</span></span><br><span class="line"><span class="comment">//...略</span></span><br><span class="line">InOrderSqTree (t, <span class="number">100</span>, <span class="number">1</span>); <span class="comment">//从根节点1出发，进行中序遍历</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义顺序存储的二叉树（从数组下标0开始存储）"><a href="#定义顺序存储的二叉树（从数组下标0开始存储）" class="headerlink" title="定义顺序存储的二叉树（从数组下标0开始存储）"></a><em>定义顺序存储的二叉树（从数组下标0开始存储）</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">与 上面思路相同，只不过结点编号的计算有些区别而已</span><br><span class="line">若顺序二叉树从数组下标0开始存储结点，则：</span><br><span class="line">● 结点 i 的父结点编号为 [(i+1)/2] - 1</span><br><span class="line">● 结点 i 的左孩子编号为 [(i+1)*2] - 1 = 2*i + 1</span><br><span class="line">● 结点 i 的右孩子编号为 [(i+1)*2+1] - 1 = 2*i + 2</span><br></pre></td></tr></table></figure><h3 id="定义链式存储的二叉树"><a href="#定义链式存储的二叉树" class="headerlink" title="定义链式存储的二叉树"></a><em>定义链式存储的二叉树</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h2 id="课后习题-5"><a href="#课后习题-5" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">1.树的路径长度是指树根到每个结点的路径长的总和，根到每个结点的路径长度的最大值应是树的高度-1</span><br><span class="line"></span><br><span class="line">2.[2010统考真题]在一棵度为4的树T中，若有20个度为4的结点，10个度为3的结</span><br><span class="line">点，1个度为2的结，点，10个度为1的结点，则树T的叶结点个数是（82）</span><br><span class="line"></span><br><span class="line">解析：结点总数=20x4+10x3+1x2+10x1+1=123;又因为结点总数=有度结点（20+10+1+10）+无度结点所以</span><br><span class="line">123-41=82;</span><br><span class="line"></span><br><span class="line">3.度为2的有序树不一定是二叉树，因为，二叉树的每个结点都有左右次序，若一个树有两个结点但是没有左右次序，那么就不算是二叉树</span><br><span class="line"></span><br><span class="line">4.重要--&gt;n个结点的完全二叉树的高度为(log2n) + 1  或log2(n+1)</span><br><span class="line"></span><br><span class="line">5.设二叉树有2n个结点，且m&lt;n,则不可能存在（）的结点。</span><br><span class="line">A.n个度为0</span><br><span class="line">B.2m个度为0</span><br><span class="line">C.2m个度为1</span><br><span class="line">D.2m个度为2</span><br><span class="line"></span><br><span class="line">解析：因为2n=n0 + n1 + 2n2，所以n1=2(n-n2)-1是奇数</span><br><span class="line"></span><br><span class="line">5.重要总结：高度为h的满二叉树的结点个数=2^h-1--&gt;类比，二进制位计算</span><br><span class="line"></span><br><span class="line">6.[2009统考真题]已知一棵完全二叉树的第6层(设根为第1层)有8个叶结，点，则该</span><br><span class="line">完全二叉树的结点个数最多是（）</span><br><span class="line">A.39</span><br><span class="line">B.52</span><br><span class="line">C.111</span><br><span class="line">D.119</span><br><span class="line"></span><br><span class="line">解析：第六层有8个叶子结点，说明树有可能6层有可能7层，最多就是7层的时候，计算得到111</span><br><span class="line"></span><br><span class="line">7.[2011统考真题]若一棵完全二叉树有768个结，点，则该二叉树中叶结点的个数是（）。</span><br><span class="line">A.257</span><br><span class="line">B.258</span><br><span class="line">C.384</span><br><span class="line">D.385</span><br><span class="line"></span><br><span class="line">解析：完全二叉树最后一个分支结点的序号是n/2，有小数舍去小数部分</span><br><span class="line"></span><br><span class="line">8.2018统考真题]设一棵非空完全二叉树T的所有叶结点均位于同一层，且每个非叶结</span><br><span class="line">点都有2个子结点。若T有k个叶结点，则T的结点总数是（）。</span><br><span class="line">A.2k-1</span><br><span class="line">B.2k</span><br><span class="line">C.2^k</span><br><span class="line">D.2^k-1</span><br><span class="line"></span><br><span class="line">解析：A</span><br><span class="line"></span><br><span class="line">9.[2020统考真题]对于任意一棵高度为5且有10个结点的二叉树，若采用顺序存储结构</span><br><span class="line">保存，每个结点占1个存储单元（仅存放结点的数据信息），则存放该二叉树需要的存</span><br><span class="line">储单元数量至少是（）。</span><br><span class="line">A.31</span><br><span class="line">B.16</span><br><span class="line">C.15</span><br><span class="line">D.10</span><br><span class="line"></span><br><span class="line">解析：顺序存储，数组存放，又因为逻辑结构的二叉树高5层，却只有10个结点，说明没有放满想象成一颗5层的满二叉树 A，为什么不能是完全二叉树？如果只是完全二叉树，如果第五层的最后一个结点放了一个结点，那么数组如果按照完全二叉树给空间，明显放不下，所以考虑最坏情况，想象满二叉树，保证所有情况都满足</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序-深度优先遍历"><a href="#先序-深度优先遍历" class="headerlink" title="先序/深度优先遍历"></a>先序/深度优先遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339295.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339938.png" alt="image.png"></p><h2 id="递归遍历求树的深度"><a href="#递归遍历求树的深度" class="headerlink" title="递归遍历求树的深度"></a>递归遍历求树的深度</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339775.png" alt="image.png"></p><h2 id="层序-广度优先遍历-BFS"><a href="#层序-广度优先遍历-BFS" class="headerlink" title="层序/广度优先遍历(BFS)"></a>层序/广度优先遍历(BFS)</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231339790.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340204.png" alt="image.png"></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340268.png" alt="image.png"></p><h2 id="确定一颗二叉树"><a href="#确定一颗二叉树" class="headerlink" title="确定一颗二叉树"></a>确定一颗二叉树</h2><ul><li><code>如果只是给定一个二叉树的前\中\后\层序\遍历序列中的一种，那么是无法确定唯一的一颗二叉树的</code></li><li>至少要知道两种不同遍历的序列：<code>前+中</code>、<code>后+中</code>、<code>层序+中</code></li><li>基本思路都是通过<code>前\后\层序遍历</code>确定根节点，再通过<code>中序遍历</code>确定左右子树</li></ul><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">前序+中序</button></li><li class="tab"><button type="button" data-href="#test1-2">后序+中序</button></li><li class="tab"><button type="button" data-href="#test1-3">层序+中序</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><code>前+中</code><br>前序遍历，可以确定序列<code>第一个是根节点</code><br>—&gt;然后再中序遍历中找到根节点位置，根节点左边就是<code>左子树</code>，右边就是<code>右子树</code><br>—&gt;接着，可以找出前序遍历中左子树的位置，和右子树的位置，分别看做新的独立二叉树<br>—&gt;找出左子树的根节点，和右子树的根结点，再分别在中序遍历中找出对应根结点位置<br>—&gt;重复直到确定一颗二叉树所有结点位置</p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340641.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340184.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231340293.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h1><hr><h2 id="线索二叉树定义"><a href="#线索二叉树定义" class="headerlink" title="线索二叉树定义"></a>线索二叉树定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尾部结点的左右指针，由指向NULL转变为指向前驱和后继</span><br><span class="line">这样有利于二叉树寻找前驱和后继</span><br><span class="line">疑问？那如果左右指针不是空的结点该如何指向自己的前驱后继呢？</span><br></pre></td></tr></table></figure><ul><li><code>注意</code>：这里讲的前驱，后继是指的是遍历后<code>序列</code>顺序的前后结点，不是二叉树结构上的前后关系<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341836.png" alt="image.png"></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码如下</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">ElemType data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>,<span class="title">rchild</span></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ltag</span>,<span class="title">rtag</span>;</span><span class="comment">//左右线索标记</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当线索标记为1时，左右指针才作为线索，指向前驱后继</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341247.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">中序线索二叉树、后序线索二叉树、前序线索二叉树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231341794.png" alt="image.png"></p><h2 id="线索二叉树的实现"><a href="#线索二叉树的实现" class="headerlink" title="线索二叉树的实现"></a>线索二叉树的实现</h2><ul><li>这里只举例<code>中序遍历线索化</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">本质就是二叉树的中序遍历</span><br><span class="line"></span><br><span class="line">只是在参数里多传递了一个前驱指针pre</span><br><span class="line"></span><br><span class="line">主要结构 左、根、右 --&gt;就是一个中序遍历结构</span><br><span class="line"></span><br><span class="line">pre指向的是p的前驱</span><br><span class="line">当遍历到最底层时，开始执行访问结点操作，也就是中间黄色代码操作</span><br><span class="line">如果p左节点为空，那么可以转为线索指向前驱pre,标记变为1</span><br><span class="line">接着如果pre的右结点有空位，也可以指向前驱p</span><br><span class="line">接着，pre后移为后继p</span><br><span class="line">p后移为后继</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree &amp;p,ThreadTree spre)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">InThread(p-&gt;<span class="number">1</span>child,pre); <span class="comment">//递归，线索化左子树</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)(  <span class="comment">//左子树为空，建立前驱线索</span></span></span><br><span class="line"><span class="params">p-&gt;lchild=pre;</span></span><br><span class="line"><span class="params">p-&gt;<span class="number">1</span>tag=<span class="number">1</span>:</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;<span class="number">6</span>pre-&gt;rchild==<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params">pre-&gt;rchild=p;           <span class="comment">//建立前驱结点的后继线索</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">pre=p;                                <span class="comment">//标记当前结点成为刚刚访问过的结点</span></span></span><br><span class="line"><span class="params">InThread(p-&gt;rchild,pre); <span class="comment">//递归，线索化右子树</span></span></span><br><span class="line"><span class="params">&#125;<span class="comment">//if (p!=NULL)</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="type">void</span> CreateInThread(ThreadTree T)&#123;</span></span><br><span class="line"><span class="params">ThreadTree pre=<span class="literal">NULL</span>; <span class="comment">//pre传入的是NULL,因为递归遍历到最低部结点(序列第一个结点)，没有前驱</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span></span><br><span class="line"><span class="params"><span class="comment">//非空二叉树，线索化</span></span></span><br><span class="line"><span class="params">InThread(T,pre);</span></span><br><span class="line"><span class="params"><span class="comment">//线索化二叉树</span></span></span><br><span class="line"><span class="params">pre-&gt;rchild=<span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params"><span class="comment">//处理遍历的最后一个结点</span></span></span><br><span class="line"><span class="params">pre-&gt;rtag=<span class="number">1</span>;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304152226551.png" alt="image.png"></p><h2 id="线索二叉树的遍历"><a href="#线索二叉树的遍历" class="headerlink" title="线索二叉树的遍历"></a>线索二叉树的遍历</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只举例中序线索二叉树的遍历</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求中序线索二叉树中中序序列下的第一个结点</span></span><br><span class="line">ThreadNode *<span class="title function_">Firstnode</span><span class="params">(ThreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">p=p-&gt;lchi1d;<span class="comment">//最左下结点（不一定是叶结点）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求中序线索二叉树中结点p的后继</span></span><br><span class="line">TreadNode *<span class="title function_">Nextnode</span><span class="params">(TreadNode *p)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Firstnode(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> p-&gt;right;<span class="comment">//rtsg==1直接返回线索</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//综合上述两个方法，能够写出遍历中序线索二叉树的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inorder</span><span class="params">(TreadNode *T)</span>&#123;</span><br><span class="line">TreadNode *p;</span><br><span class="line"><span class="keyword">for</span>(p=Firstnode(T);p!=<span class="literal">NULL</span>;p=Nextnode(p))&#123;</span><br><span class="line">visit(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="课后习题-6"><a href="#课后习题-6" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.引入线索二叉树的目的是（）</span><br><span class="line">A,加快查找结点的前驱或后继的速度</span><br><span class="line">B.为了能在二叉树中方便插入和删除</span><br><span class="line">C.为了能方便找到双亲</span><br><span class="line">D.使二叉树的遍历结果唯一</span><br><span class="line"></span><br><span class="line">解析：线索是结点的前驱和后继结点的指针，可以加快遍历</span><br><span class="line"></span><br><span class="line">2.线索二叉树是一种(C)结构。</span><br><span class="line">A.逻辑B.逻辑和存储C.物理D.线性</span><br><span class="line"></span><br><span class="line">解析：二叉树是一种逻辑结构。</span><br><span class="line">而线索二义树明确指明了在存储过程中的数据存放方式(指明了线索是标记为1的时候)，就是物理结构了。</span><br><span class="line">(物理结构=存储结构)</span><br><span class="line"></span><br><span class="line">3.n个结点的线索二叉树上含有的线索数为(B)</span><br><span class="line">A.2n</span><br><span class="line">B.n-1</span><br><span class="line">C.n+l</span><br><span class="line">D.n.</span><br><span class="line"></span><br><span class="line">解析：每个结点有两条链域指针，总共2n条，每个结点被一条指针指向，剩余的构成线索，2n-(n-1)</span><br><span class="line"></span><br><span class="line">4.二叉树在线索化后，仍不能有效求解的问题是（D）。</span><br><span class="line">A.先序线索二叉树中求先序后继</span><br><span class="line">B.中序线索二叉树中求中序后继</span><br><span class="line">C.中序线索二叉树中求中序前驱</span><br><span class="line">D.后序线索二叉树中求后序后继</span><br><span class="line"></span><br><span class="line">4.注意，前序、中序线索树的遍历不需要通过弹栈的方式来遍历后继结点，因为后继都可以通过线索来指向</span><br><span class="line">但是，后序线索二叉树的遍历必须通过弹栈的方式，返回上一层及的后继结点，如下图所示，结点3既没有左右孩子指针指向4结点，又没有后继线索指向4结点(左右子树占用了线索)</span><br><span class="line"></span><br><span class="line">所以，中序，前序线索二叉树不需要栈支持了，但是后序线索二叉树任然需要</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231343369.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5.[2011统考真题]一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1,</span><br><span class="line">该二叉树的中序遍历序列不会是（C）。</span><br><span class="line">A.1,2,3,4</span><br><span class="line">B.2,3,4,1</span><br><span class="line">C.3,2,4,1</span><br><span class="line">D.4,3,2,1</span><br><span class="line"></span><br><span class="line">解析：前后序遍历序列相反，说明每个结点只能有左孩子或只能有右孩子,不会同时存在两个子树</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.编写后序遍历二叉树的非递归算法</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路先将左子树遍历到底，再遍历右子树，最后根</span></span><br><span class="line"><span class="comment">//1.沿着根的左孩子，依次入栈，直到左孩子为空</span></span><br><span class="line"><span class="comment">//2.读栈顶元素：若其右孩子不空且未被访问过，将右子树转执行1;否则，栈顶元素出栈并访问。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Stack S; 指针访问标记r ; 当前指针p; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p||!isEmpty(S))&#123;</span><br><span class="line"><span class="keyword">if</span>(p)&#123;</span><br><span class="line">push(S,p);</span><br><span class="line">p=p-&gt;lift;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Getop(S,p);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right&amp;&amp;p-&gt;right!=r)&#123; <span class="comment">//标记r,结点弹栈之后要防止原来的再入栈</span></span><br><span class="line">p=p-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">pop(S,p);</span><br><span class="line">visit(p-&gt;data);</span><br><span class="line">r=p;</span><br><span class="line">p=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">7.试给出二叉树的自下而上、从右到左的层次遍历算法。</span><br><span class="line"></span><br><span class="line">解析：思路，按照层序遍历遍历，新增一个栈，用于存放出队列的结点，这样就能将原有序列取反，并在最后通过弹栈进行后续操作</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InvertLevel</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Queue Q;</span><br><span class="line">Init(Q);</span><br><span class="line">BiTree q;</span><br><span class="line">Q.EnQueue(T); <span class="comment">//入栈T</span></span><br><span class="line"><span class="keyword">while</span>(!iSEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line">Push(S,q);<span class="comment">//出队列，入栈</span></span><br><span class="line"><span class="keyword">if</span>(T-&gt;left)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right)&#123;</span><br><span class="line">EnQueue(Q,T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(S))&#123;</span><br><span class="line">Pop(S,p);</span><br><span class="line">Visit(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//8.采用非递归算法，遍历一棵树并得到树的高度</span></span><br><span class="line"><span class="comment">//思路，采用层序遍历的方式，设置变量level记录当前层数。设置变量last,指向当前层的最后一个结点，当辅助队列的front=last时，就表示，当前层的结点遍历完了,那么level+1；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">BiNode data[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">level_order</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">int</span> level=<span class="number">0</span>,last=<span class="number">0</span>;</span><br><span class="line">Queue Q;</span><br><span class="line">InitQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(!T)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">EnQueue(T);</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">BiTree p=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(p-&gt;left)&#123;</span><br><span class="line">EnQueue(p-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;right)&#123;</span><br><span class="line">EnQueue(Q-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q.front=last)&#123;</span><br><span class="line">level++;</span><br><span class="line">last=Q.rear;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072029018.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">BiTree data[MaxSize];</span><br><span class="line"><span class="type">int</span> level[MaxSize];</span><br><span class="line"><span class="type">int</span> front,rear;</span><br><span class="line">&#125;Qu;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">BiWide</span><span class="params">(Bitree T)</span>&#123;</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max i;</span><br><span class="line">Qu Q;</span><br><span class="line">Q.front=Q.rear=<span class="number">-1</span>;</span><br><span class="line">Q.rear++;   <span class="comment">//T入队</span></span><br><span class="line">Q.data[rear]=T</span><br><span class="line">Q.level[rear]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q.front&lt;Q.rear)&#123;</span><br><span class="line">Q.front++;  <span class="comment">//出队</span></span><br><span class="line">q=Q.data[front];</span><br><span class="line">k=Q.level[front];</span><br><span class="line"><span class="keyword">if</span>(q-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;left;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">Q.rear++;</span><br><span class="line">Q.data[Q.rear]=q-&gt;right;</span><br><span class="line">Q.level[Q.rear]=k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历level数组，看那个层次的个数最多</span></span><br><span class="line">max=<span class="number">0</span>;i=<span class="number">0</span>;</span><br><span class="line">k=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear)&#123;</span><br><span class="line"><span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=Q.rear&amp;&amp;k==Q.level[i])&#123;  <span class="comment">//统计第k层的结点的个数</span></span><br><span class="line">i++;</span><br><span class="line">n++;</span><br><span class="line">&#125;</span><br><span class="line">k=Q.level[i];</span><br><span class="line"><span class="keyword">if</span>(n&gt;max)&#123;</span><br><span class="line">max=n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062342344.png" alt="image.png"></p><p>10.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设有一颗满二叉树，已知其先序序列为pre,设计一个算法求其后序序列post</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ProToPost</span><span class="params">(Element pre[],<span class="type">int</span> l1,<span class="type">int</span> h1,Element post[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>)&#123;</span><br><span class="line"><span class="type">int</span> half;</span><br><span class="line"><span class="keyword">if</span>(l1&lt;=h1)&#123;</span><br><span class="line">post[h2]=pro[l1];</span><br><span class="line">half=(l1+h1)/<span class="number">2</span>;</span><br><span class="line">ProToPost(pre,l1+<span class="number">1</span>,l1+half,post,l2,l2+half<span class="number">-1</span>); <span class="comment">//转换左子树</span></span><br><span class="line">ProToPost(pre,l1+half+<span class="number">1</span>,h1,post,l2+half,h2<span class="number">-1</span>); <span class="comment">//转换右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072042893.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11.设一颗二叉树中各个结点的值不相同，其先序遍历和中序遍历的序列分别存放在数组A[1..n]和数组B[1..n]中，试编写一个算法建立该二叉树的二叉链表</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//1.现根据先序序列确定树的根节点</span></span><br><span class="line"><span class="comment">//2.在结合中序遍历，确定左子树右子树节点个数--&gt;划分左右子树--&gt;也就是划分数组中左右</span></span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line">BiTree <span class="title function_">BuildTree</span><span class="params">(ElemType A[],<span class="type">int</span> l1,<span class="type">int</span> h1,ElemType B[],<span class="type">int</span> l2,<span class="type">int</span> h2)</span>&#123;</span><br><span class="line"><span class="comment">//初始调用时，设l1,l2=1，h1,h2=n</span></span><br><span class="line">BiTree root=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiNode))  <span class="comment">//建立根节点</span></span><br><span class="line">root-&gt;data=A[l1];                          <span class="comment">//将根节</span></span><br><span class="line"><span class="type">int</span> i=l2;</span><br><span class="line"><span class="keyword">while</span>(A[l1]!=B[i])&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">llen=i-l2;   <span class="comment">//左子树结点个数</span></span><br><span class="line">rlen=h2-i;  <span class="comment">//右子树结点个数</span></span><br><span class="line"><span class="keyword">if</span>(llen)&#123;   <span class="comment">//对左子树递归</span></span><br><span class="line">root-&gt;left=BuildTree(A,l1+<span class="number">1</span>,l1+llen,B,l2,l2+llen<span class="number">-1</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;     <span class="comment">//左子树为空</span></span><br><span class="line">root-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rlen)&#123;</span><br><span class="line">root-&gt;right=BuildTree(A,h1-rlen+<span class="number">1</span>,h1,B,h2-rlen+<span class="number">1</span>,h2);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>13.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071436493.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取层次遍历算法，将所有结点入队(包括空节点，当遍历遇到空节点时，如果是满二叉树，其后必定是全部为空，如果还有非空节点就不是完全二叉树)</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsCompelet</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Queue Q;</span><br><span class="line">init(Q);</span><br><span class="line">EnQueue(Q,T);</span><br><span class="line">BiTree q;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line">EnQueue(q-&gt;left);</span><br><span class="line">EnQueue(q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isEmpty(Q))&#123;</span><br><span class="line">    q=OutQueue(Q);</span><br><span class="line"><span class="keyword">if</span>(q)&#123;</span><br><span class="line"><span class="keyword">return</span> fasle;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>14.<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306071454344.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采取任意一种遍历算法即可，这里采取最基本的中序遍历算法，对当前节点处理时，判断其是否存在左右孩子，并设置一个static变量用于统计具有双分支结点的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">InOrder(T-&gt;left);</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>&amp;&amp;T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">InOrder(T-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h1><h2 id="什么是森林？"><a href="#什么是森林？" class="headerlink" title="什么是森林？"></a>什么是森林？</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062345931.png" alt="image.png"></p><h2 id="树、森林转化为二叉树"><a href="#树、森林转化为二叉树" class="headerlink" title="树、森林转化为二叉树"></a>树、森林转化为二叉树</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先将树转化为二叉树</span><br><span class="line">将树转化为二叉树</span><br><span class="line">1.给兄弟加线</span><br><span class="line">2.将除长子外的与父节点的线去掉</span><br><span class="line">3.最后层次调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070951715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将森林转化为二叉树</span><br><span class="line">1.先将所有树先转化为二叉树</span><br><span class="line">2.将第一课树的根节点，将自己的子树森林转化为左子树，右子树指向下一棵树的根节点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071001666.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071002020.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树、森林、二叉树遍历序列等价问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071103398.png" alt="image.png"></p><h2 id="课后习题-7"><a href="#课后习题-7" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062357926.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305070943205.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071004393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071008954.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设树原始分支只有一条</span><br><span class="line">想象树每多一条分支，就会出现一个叶子结点，且多一组兄弟结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305071021560.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1.若森林F有15条边、25个结点，则F包含树的个数是</span><br><span class="line">A.8</span><br><span class="line">B.9</span><br><span class="line">C.10</span><br><span class="line">D.11</span><br><span class="line"></span><br><span class="line">解析：对于一棵树而言，除了根节点，其他每个结点都由一条边指向，也就是说，其他每个结点都对应一条边，所以，一棵树的结点数=边数+1</span><br><span class="line">所以，结点数-边数=25-15=10，所以有10棵树</span><br><span class="line"></span><br><span class="line">2.编程求以孩子兄弟表示法存储的森林的叶子结点数。</span><br><span class="line"></span><br><span class="line">解析：题目意思是，求在森林转化的二叉树中，找到原森林中叶子结点的个数</span><br><span class="line">找规律发现，森林中的叶子结点，在二叉树中都没有左子树，所以可以通过遍历二叉树，每次碰到结点判断一下该节点是否有左孩子，没有就num++</span><br><span class="line"></span><br><span class="line">3.在二叉树中有两个结点m和n,如果m是n的祖先，使用（C）可以找到从m到n的路径。</span><br><span class="line">A.先序遍历</span><br><span class="line">B.中序遍历</span><br><span class="line">C.后序遍历</span><br><span class="line">D.层次遍历</span><br><span class="line"></span><br><span class="line">解析：后序遍历是从后往前，在找到n之后，层层往上层父节点寻找，这个过程一定能找到m，并且父节点入栈顺序是按照从后往前的顺序。</span><br><span class="line">但是先序遍历，在找到n之后，因为在这之间先访问了父节点，所以这个父节点入栈顺序是从前往后，从一开始就要入栈的话，就无法保证找到n</span><br><span class="line">中序遍历一样抽象</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><h2 id="带权路径长度"><a href="#带权路径长度" class="headerlink" title="带权路径长度"></a>带权路径长度</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结点的带权路径长度：从树的根节点到该结点的路径长度(经过的边数)与该结点上值得乘积</span><br><span class="line">树的带权路径长度：树种所有叶子结点的带权路径之和(WPL,Weight Path Length)</span><br><span class="line">带权路径长度最小的二叉树被称为哈夫曼树，也称最优二叉树</span><br></pre></td></tr></table></figure><h2 id="哈夫曼树定义"><a href="#哈夫曼树定义" class="headerlink" title="哈夫曼树定义"></a>哈夫曼树定义</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树是为了达到 使编码串变短的目的</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>编码问题</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">000</td><td style="text-align:center">001</td><td style="text-align:center">010</td><td style="text-align:center">011</td><td style="text-align:center">100</td></tr></tbody></table></div><p>S=AAABBACCCDEEA<br>T(S)=000000000001001000010010010011100100000</p><p><code>S中出现次数</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th></tr></thead><tbody><tr><td style="text-align:center">5</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">为了使得编码变短，尽量将出现次数较多的编码缩短</span><br><span class="line">于是建立如下哈夫曼树</span><br><span class="line"></span><br><span class="line">1.将字符按出现次数从多到少排列</span><br><span class="line">2.从最少的两个次数相加组成 次数结点</span><br><span class="line">3.同样的过程完全建立一颗抽象的树状结构</span><br><span class="line">4.在树上左分支0,右分支1</span><br><span class="line">5.向右寻找一位,编码1，向左寻找一位编码0</span><br><span class="line">6.例如 B --&gt; 110</span><br><span class="line">7.A次数最多5--&gt;编码最短0  ；D次数最少1--&gt;编码最长1110</span><br><span class="line">8.达到了编码串缩短的目的</span><br><span class="line"></span><br><span class="line">如何解码呢？</span><br><span class="line">从左到右逐个扫描编码串字符，0向左走，1向右走，如果走到叶子结点（字符位置），就读取</span><br><span class="line">然后再次回到根节点，没有就继续扫描</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707509.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707805.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.权值越大的字符，离根节点越近(权值看做字符的次数)</span><br><span class="line">2.哈夫曼树中，没有度为1的结点，这类树叫做&quot;正则二叉树&quot;(严格二叉树)</span><br><span class="line">3.哈夫曼树的带权路径长度最短(也称最优二叉树)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707715.png" alt="image.png"></p><h2 id="哈夫曼树带权路径长度的计算"><a href="#哈夫曼树带权路径长度的计算" class="headerlink" title="哈夫曼树带权路径长度的计算"></a>哈夫曼树带权路径长度的计算</h2><p><strong>概念</strong></p><ol><li>路径：在一棵树中，从一个结点到另一个结点所经过的所有结点，被我们称为两个结点之间的路径</li><li>路径长度：在一棵树中，从一个结点到另一个结点所经过的“边”的数量，被我们称为两个结点之间的路径长度。</li><li>结点的带权路径长度：树的根结点到该结点的路径长度和该结点权重的乘积</li><li>树的带权路径长度：在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</li></ol><p><strong>计算方法</strong></p><p><strong>问题描述：给定树T，有n个叶结点，并且其权重值为{A1,A2,A3…An};如何计算树T的WPL</strong></p><p>例如2021年408这道题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若某二叉树有5个叶子结点，其权值分别为10，12，16，21，30。则其最小的带权路径长度(WPL)是()</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><ol><li>按照算法步骤画出哈夫曼树</li></ol><p>具体算法如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)</span><br><span class="line">2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</span><br><span class="line">3. 从森林中删除选取的两棵树，并将新树加入森林</span><br><span class="line">4. 重复2、3步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树</span><br></pre></td></tr></table></figure><p>举例说明</p><ul><li>首先对集合进行排序得到<code>&#123;10，12，16，21，30&#125;</code></li><li>我们找到权值最小的两个结点10和12合并；得到新的森林根结点为22。现在结点集合为<code>&#123;16,21,22,30&#125;</code></li></ul><p><img src="https://pic2.zhimg.com/80/v2-84b2ca308c5690aea73c72b20a4329c9_720w.webp" alt=""></p><ul><li>接着我们找到当前最小的结点16和21合并：得到新的森林根结点为37。现在结点集合为<code>&#123;22,30,37&#125;</code></li></ul><p><img src="https://pic1.zhimg.com/80/v2-3cdf36dc196f1ab7abdc9f63d1958b2c_720w.webp" alt=""></p><ul><li>接着我们找到当前最小的结点22和30合并：得到新的森林根结点为53。现在结点集合为<code>&#123;37,53&#125;</code></li></ul><p><img src="https://pic4.zhimg.com/80/v2-6db96b3200f97cfe3c1111dc093dc6f3_720w.webp" alt=""></p><ul><li>接着我们找到当前最小的结点37和53合并：得到新的森林根结点为90。现在结点集合为<code>&#123;90&#125;</code>；由于结点个数只剩一个，所以算法结束、构造哈夫曼树完毕</li></ul><p><img src="https://pic4.zhimg.com/80/v2-ee8db18db2add6152c414fe41aef766f_720w.webp" alt=""></p><blockquote><p>可以看到哈夫曼树的构造堆左右子树的顺序是没有要求的，当然我们画哈夫曼树的可以按照一定规律来这样更明确思路更清晰，比如我这里是按照<code>左节点&lt;右结点</code>的原则来画的</p></blockquote><ol><li>依次累加计算所有叶结点的带权路径长度</li></ol><p>从上面构造的哈夫曼树可知所有结点的路径长度，例如结点”16“的路径长度为2。所以<code>WPL=(16+21+30)*2+(10+12)*3=200</code></p><h2 id="二叉树的估计"><a href="#二叉树的估计" class="headerlink" title="二叉树的估计"></a>二叉树的估计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">右侧的分别是表示遍历后的顺序 黑色表示要删除的</span><br><span class="line">注意：前后结果相反，有两种情况，没有左(L)或没有右(R)都满足</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231707899.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708586.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708670.png" alt="image.png"></p><h2 id="二叉存储表达式"><a href="#二叉存储表达式" class="headerlink" title="二叉存储表达式"></a>二叉存储表达式</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据二叉存储表达式建立二叉树：3+4*5*(2+3)</span><br><span class="line">手工方法：1.加括号明确运算次序(3+((4*5)*(2+3)))</span><br><span class="line">         2.列出数字元素 3  4  5  2  3 作为叶子结点</span><br><span class="line">         3.按运算次序 用运算符作为分支节点 建立二叉树</span><br><span class="line">栈方法：不介绍</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708561.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用树，来求表达式的值 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305231708601.png" alt="image.png"></p><h2 id="课后习题-8"><a href="#课后习题-8" class="headerlink" title="课后习题"></a>课后习题</h2><hr><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">1</button></li><li class="tab"><button type="button" data-href="#test1-2">2</button></li><li class="tab"><button type="button" data-href="#test1-3">3</button></li><li class="tab"><button type="button" data-href="#test1-4">4</button></li><li class="tab"><button type="button" data-href="#test1-5">5</button></li><li class="tab"><button type="button" data-href="#test1-6">6</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.前缀码是一种编码系统，通常是可变长度码，在其中的每个码字，都具备「前缀性质」(prefix property)，也就说，在编码中的每个码字，都不能被其他码字当成前置部位。例如，编码字&#123;9,55&#125;具备了前缀性质，但编码字&#123;9,5,59,55&#125;就不具备，因为其中的&quot;5”，是59&quot;及&quot;55&quot;的前缀</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目已对两个字符编码1和01，因为哈夫曼树只对叶子结点进行编码，所以1和01两个结点就是叶子结点，不能继续延伸。故只能往左下继续寻找，最终如图，注意要数的是叶子结点的个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061929244.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">哈夫曼树如果有n个叶子结点，那么总共有2n-1个结点</span><br><span class="line">因为n个叶子结点，经过n-1次整合，构建出n-1个非叶子结点，总共2n-1个结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061936631.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一次整合需要m个，之后整合只需m-1个叶子结点，每次整合有一个非叶子结点，所以n-1/m-1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305061956033.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1对于哈夫曼树的说法错误的是（D）</span><br><span class="line">A.对应一组权值构造出来的哈夫曼树一能不是唯一的</span><br><span class="line">B.哈夫曼树具有最小的带权路径长度</span><br><span class="line">C.哈夫曼树中没有度为1的结点</span><br><span class="line">D.哈夫曼树中除了度为1的结点外，还有度为2的结点和叶结点</span><br><span class="line"></span><br><span class="line">解析：</span><br><span class="line">A:确实不唯一。仅思考两个结点的情况：1和2，就有两种：1在左子树2在右子树和反过来。</span><br><span class="line">B:正确。正是我们使用哈夫曼树进行编码的意义所在。</span><br><span class="line">C:正确。任意非叶子结点都是由两个树（数据元素）构成的，因此不存在度为1的结点。</span><br><span class="line">D:解析同C,因此错误。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓定长编码集，就是所有字符编码位数都一样，0001 1100 1010 ..</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062100296.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-6"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062127393.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="课后习题-9"><a href="#课后习题-9" class="headerlink" title="课后习题"></a>课后习题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1.图中有关路径的定义是(A).</span><br><span class="line">A.由顶点和相邻顶点序偶构成的边所形成的序列</span><br><span class="line">B.由不同顶，点所形成的序列</span><br><span class="line">C.由不同边所形成的序列</span><br><span class="line">D.上述定义都不是</span><br><span class="line"></span><br><span class="line">解析：A路径是由顶点与相邻顶点序偶构成的边的序列 例如顶点A到顶点D的路劲 &lt;A B&gt; &lt;B C&gt; &lt;C D&gt; ; B路劲不是由顶点构成 ；C没有讲明是由相邻的边形成的序列</span><br><span class="line"></span><br><span class="line">2.[2017统考真题]已知无向图G含有16条边，其中度为4的顶点个数为3，度为3的顶</span><br><span class="line">点个数为4，其他顶点的度均小于3。图G所含的顶点个数至少是（11）</span><br><span class="line"></span><br><span class="line">解析：无向图边数的2倍等于各顶点度数的总和。为求至少的顶点数，应使每个顶点的度取最大，由</span><br><span class="line">于其他顶点的度均小于3，可以设它们的度都为2，设它们的数量是x,列出方程4×3+3×4+2x=16×2,</span><br><span class="line">解得x=4。因此至少包含4+4+3=11个顶点。</span><br><span class="line"></span><br><span class="line">3.图G是一个非连通无向图，共有28条边，该图至少有多少个项点？</span><br><span class="line"></span><br><span class="line">解析：由于图G是一个非连通无向图，在边数固定时，顶点数最少的情况是该图由两个连通子图构</span><br><span class="line">成，且其中之一只含一个顶点，另一个为完全图。其中只含一个顶点的子图没有边，另一个完全</span><br><span class="line">图的边数为n(n-1)2=28,得n=8。所以该图至少有1+8=9个顶点。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图的逻辑结构-王道"><a href="#图的逻辑结构-王道" class="headerlink" title="图的逻辑结构(王道)"></a>图的逻辑结构(王道)</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顶点与顶点的关系</span><br><span class="line">- 路径一一顶点v到顶点v之间的一条路径是指顶点序列</span><br><span class="line">- 回路一一第一个顶点和最后一个顶点相同的路径称为回路或环</span><br><span class="line">- 简单路径一一在路径序列中，顶点不重复出现的路径称为简单路径。</span><br><span class="line">- 简单回路一一除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。</span><br><span class="line">- 路径长度一一路径上边的数目</span><br><span class="line">- 点到点的距离一一从顶点u出发到顶点v的最短路径若存在，则此路径的长度称为从u到的距离</span><br><span class="line">  若从u到v根本不存在路径，则记该距离为无穷(∞)。</span><br><span class="line">- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的</span><br><span class="line">- 有向图中，若从项点到项w和从项点w到项点之间都有路径，则称这两个项点是强连通的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162341036.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连通图、强连通图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162353758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部图的研究--子图</span><br><span class="line">- 子图：部分顶点，与部分边构成的较小的局部图</span><br><span class="line">- 生产子图：包含原图所有顶点的子图，不一定要所有边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162355746.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">连通分量--描述无向图</span><br><span class="line">- 包含尽可能多的顶点和边</span><br><span class="line">- 下面三个部分都是极大连通子图，属于单独的一个分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162357370.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">强连通分量--描述有向图</span><br><span class="line">同上</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305170000437.png" alt="image.png"></p><h2 id="图逻辑结构-天勤"><a href="#图逻辑结构-天勤" class="headerlink" title="图逻辑结构(天勤)"></a>图逻辑结构(天勤)</h2><ul><li>图由<code>顶点</code>和<code>边</code>构成</li><li><code>无向图</code>：边没有指向方向 (A1,A3)   没有指向 </li><li><code>有向图</code>：边有箭头方向    <A1,A3> 表示A1—&gt;A3 ,不能反过来</li><li><code>顶点的度</code>：多少条边与该顶点相连<ul><li>无向图：A1的度为3</li><li>有向图：A1入度为1，出度为2，度为3</li></ul></li><li><code>简单图</code>：不存在重复的边，并且没有指向自身的边</li><li><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302311509.png" alt="image.png"></p></li><li><p><code>无向完全图</code>：任意两个顶点之间，都存在边，总共<code>n(n-1)/2</code>条边</p></li><li><p>有向完全图：任意两个顶点之间，都存在两条方向相反的边，总共<code>n(n-1)</code>条边<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302312402.png" alt="image.png"></p></li><li><p>若边含有权值则称为网<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342083.png" alt="image.png"></p></li><li><p><code>路径</code>：一个顶点到相邻顶点序偶构成的<code>边</code>的序列,例如：（A1 A2）（A2 A3）（ A3 A6）</p></li><li><code>简单路径</code>：序列中顶点不重复出现的路径 例如：A1 A2 A3 A2 A4就不是简单路径，其中A2重复了</li><li><code>回路(环)</code>：第一个顶点和最后一个顶点相同，例如：A1 A4 A3 A1</li><li><p><code>简单回路</code>：除了第一个顶点和最后顶点，中间没有重复出现顶点</p></li><li><p><code>连通图</code>：针对<code>无向图</code>不一定要闭合，只要任意顶点间有路径即可<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342495.png" alt="image.png"></p></li><li><p><code>非连通图</code>：<img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342005.png" alt="image.png"></p></li></ul><ul><li><code>强连通图</code>：针对有向图。如果有向图中的任意两个节点都可以互相到达，则该有向图是强连通的</li><li><code>弱连通图</code>：针对有向图。如果将有向图中的所有有向边都看作无向边，得到的无向图是连通的，则该有向图是弱连通的。</li><li><code>极大强连通子图（强连通分量）</code>：针对有向图</li><li><code>极小强连通子图</code>：针对有向图</li></ul><h2 id="极小连通子图与最小生成树"><a href="#极小连通子图与最小生成树" class="headerlink" title="极小连通子图与最小生成树"></a>极小连通子图与最小生成树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 极小连通子图是指一个无向图的子图，如果它是连通的，并且在保持子图连通的前提下，不能从子图中删除任何边，那么它就是极小连通子图。</span><br><span class="line"></span><br><span class="line">- 最小生成树是指一个连通无向图的生成树，它包含图中所有的顶点，并且边的权值之和最小。生成树是一种特殊的极小连通子图，它没有环，并且边数等于顶点数减1。如果一个极小连通子图是一个树，那么它也是原图的生成树。但是，并不是所有的极小连通子图都是树，也不是所有的极小连通子图都是最小生成树。</span><br></pre></td></tr></table></figure><h2 id="有向-无向图的连通问题"><a href="#有向-无向图的连通问题" class="headerlink" title="有向-无向图的连通问题"></a>有向-无向图的连通问题</h2><hr><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161023514.png" alt="image.png"></p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里只讨论有向图强连通，弱连通就是无向图的情况，不再讨论</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161039922.png" alt="image.png"></p><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><hr><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用一个二维数组，形成的一个矩阵表示顶点之间的关系</span><br><span class="line">这里演示的是带权的路径</span><br><span class="line">用行标、列标组合表示两个顶点之间路径</span><br><span class="line">按行列找到的数值就是路径权值，例如(1,0)=2,表示1--&gt;0的路径权值为2</span><br><span class="line">这里规定对角线上的值为无穷，也就是顶点到自身的路径为无穷(有的地方也规定为0)</span><br><span class="line"></span><br><span class="line">注意：当二位数组对称，说明是无向图，互相指向；当二维数组不对称，说明是有向图</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302342024.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0行 X 3列</span><br><span class="line">只有0行与3列对应相乘都不为0时才有值</span><br><span class="line">结果=3，说明有3个点，与0和3都存在路径</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302343697.png" alt="image.png"></p><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a><em>邻接矩阵</em></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxVertexNum 100                  <span class="comment">//顶点最大数目</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> Vex[MaxVertexNum];               <span class="comment">//顶点</span></span><br><span class="line"><span class="type">int</span> Edge[MaxVertexNum][MaxVertexNum]; <span class="comment">//边</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum;                    <span class="comment">//顶点数和边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231506419.png" alt="image.png"></p><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只能表示出边，或只能表示入边</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//适用于稀疏图，避免矩阵造成大量空间的浪费</span></span><br><span class="line"><span class="comment">//采用了顺序存储+链式存储</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 8</span></span><br><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjvex;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line"><span class="type">char</span> data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;  <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">VNode vex[N]       <span class="comment">//N个顶点</span></span><br><span class="line"><span class="type">int</span> vexnum,arcnum; <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph;              <span class="comment">//ALGraph是以邻接表存储的图类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//下图邻接表由两部分构成，左边的顶点数组(存着下标信息)+右边的边结点链表(1.数字是顶点下标，2.右侧是相接该顶点的另一条边的指针)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//各个边在边组成链表中出现的先后顺序不是固定的，所以图邻接表的表示方式并不唯一，</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011638260.png" alt="image.png"></p><h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">针对有向图</span><br><span class="line">只能用于存储有向图</span><br><span class="line">由于邻接表无法表示入边，与出边，所以改进为十字链表</span><br><span class="line">左结构体--&gt;顶点   右结构体--&gt;边</span><br><span class="line">in表示入边，out表示出边，由first引出第一条，由next引出下一条，01、14、20...表示边(有方向)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639953.png" alt="image.png"></p><h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">针对无向图</span><br><span class="line">左结构体--&gt;顶点  右结构体--&gt;边</span><br><span class="line">由于边是双向</span><br><span class="line">接下来有点抽象自己看^o^</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639673.png" alt="image.png"></p><h4 id="课后习题-10"><a href="#课后习题-10" class="headerlink" title="课后习题"></a>课后习题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.邻接表可以用于存储无向图，，只是把每条边都视为两条方向相反的有向边，因此需要存储两次</span><br><span class="line"></span><br><span class="line">2.在有向图的邻接表存储结构中，顶，点v在边表中出现的次数是（C）。</span><br><span class="line">A顶点v的度</span><br><span class="line">B.顶点v的出度</span><br><span class="line">C:顶点v的入度</span><br><span class="line">D.依附于顶，点v的边数</span><br><span class="line"></span><br><span class="line">3.n个顶点的无向图的邻接表最多有(B)个边表结点。</span><br><span class="line">A.n2</span><br><span class="line">B.n(n-1)</span><br><span class="line">C.n(n+1)·</span><br><span class="line">D.n(n-1)/2</span><br><span class="line"></span><br><span class="line">解析：n个顶点的无向图最多有(n-1)/2条边，每条边在邻接表中存储两次，所以边表结点最多为</span><br><span class="line">n(n-l)个。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.带权有向图G用邻接矩阵存储，则的入度等于邻接矩阵中(D).</span><br><span class="line">A.第i行非∞的元素个数</span><br><span class="line">B.第i列非∞的元素个数：</span><br><span class="line">C.第i行非∞且非0的元素个数</span><br><span class="line">D.第i列非∞且非0的元素个数</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6.写出从图的邻接表表示转换成邻接矩阵表示的算法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//思路：通过普通的遍历，依次序的遍历所有的顶点，并修改邻接矩阵的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Convert</span><span class="params">(AlGraph *G,<span class="type">int</span> [M][N])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">ArcNode *p = G-&gt;v[i].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="type">int</span>[i][p-&gt;adjv]=<span class="number">1</span>;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152205562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点的连通图，最多有n(n-1)/2条边--&gt;每个顶点与其他n-1个顶点相连，最后每条边重复考虑了一次。</span><br><span class="line">所以28条边的连通图最少有8个顶点，要是非连通图则+1顶点 与其他顶点隔离 --&gt;8+1=9</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152210169.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个顶点，组成连通无向图，边最少n-1，因为 形成单链</span><br><span class="line">组成强连通有向图，边最少n ，因为形成有向环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152218916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无向图将所有顶点的度相加=边数x2 ，因为每条边会多重复算一次，利用这个特性，求出度为2的点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152229507.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向图,求每个顶点最大的度--&gt;每个顶点最多与n-1个顶点相连--&gt;出边+入边--&gt;(n-1)*2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152235585.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152256350.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">环任意去除一条边都是一颗生成树--&gt;共有n条边--&gt;有n条生成树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152313137.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在树中，每个顶点都有一条边指向，除了根节点，所以n-e=根结点数目</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152317313.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这道题比较难</span><br><span class="line">保证形成连通图的最少变数，7个顶点，前6个保证连通边数达到最大无法再增多，再多加1条连接剩下的顶点，7个就保证连通了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152329630.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无向图双向的，所以邻接矩阵沿对角线一定对称；由于这个矩阵不对成所以一定是有向图</span><br><span class="line">第i个顶点的度=矩阵中i行i列的1之和</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305152347902.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Edge --&gt; E 边</span><br><span class="line">Vertex --&gt; V 顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161019171.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28条边用最少顶点充分利用n(n-1)=26--&gt;8个顶点--&gt;再额外+1孤立顶点--&gt;实现非连通--&gt;最少9顶点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161042675.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">所有1集中在对角线往上</span><br><span class="line">- i&lt;j</span><br><span class="line">- i到j有边</span><br><span class="line"></span><br><span class="line">运用拓扑排序方式，对顶点号依次编号</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161111107.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161116342.png" alt="image.png"></p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历犯法</span><br><span class="line"></span><br><span class="line">为了防止出现图遍历的时候的死循环问题需要，将遍历过得结点进行标记，防止再次遍历</span><br><span class="line">于是</span><br><span class="line">1.设置一个与顶点数组相对应的标记数组(设为全局变量)，数组初始=0；</span><br><span class="line">2.遍历过后标记为1，visit[v]=1;</span><br><span class="line">3.然后ArcNode*q=G-&gt;adjList [v].first 找到第一条与该顶点相连的边</span><br><span class="line">4.找到第二条与该顶点相连的边，访问下一个顶点(往深处找)，先判断是否访问过</span><br><span class="line">5.如果没有访问过进行递归</span><br><span class="line">6.如果访问过就找与之相连的下一条边，直到与该顶点相连的边遍历完</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> adjV;            <span class="comment">//边指向顶点位置(下标)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一条边(兄弟边)的指针</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">VertexType data;       <span class="comment">//顶点信息</span></span><br><span class="line">ArcNode *first;        <span class="comment">//第一条边</span></span><br><span class="line">&#125; VNode,AdjList[MaxSize]   <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">AdjList vertice;       <span class="comment">//顶点数组指针(也可以说顶点数组)</span></span><br><span class="line"><span class="type">int</span> n,e                <span class="comment">//顶点的数量，边得数量 </span></span><br><span class="line">&#125;ALGraph</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011639135.png" alt="image.png"></p><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">讨论的是邻接表的遍历</span><br><span class="line">要点：</span><br><span class="line">1.找到与一个顶点相邻的所有顶点</span><br><span class="line">2.标记哪些顶点被访问过</span><br><span class="line">3.需要一个辅助队列，这里采用循环队列</span><br><span class="line"></span><br><span class="line">采用循环的队列作为辅助队列</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">typedeof <span class="type">int</span> maxSize</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(AGraph *G,<span class="type">int</span> v,<span class="type">int</span> visited[maxSize])</span>&#123;</span><br><span class="line">ArcNode *p;</span><br><span class="line"><span class="type">int</span> que[maxSize],front=<span class="number">0</span>,rear=<span class="number">0</span>;  <span class="comment">//辅助队列</span></span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line">visit(v);                         <span class="comment">//访问出队顶点；</span></span><br><span class="line">vistted[v]=<span class="number">1</span>;</span><br><span class="line">rear = (rear+<span class="number">1</span>)%maxSize;  </span><br><span class="line">que[rear]=v;                      <span class="comment">//顶点入队,入队的其实是位置下标</span></span><br><span class="line"><span class="keyword">while</span>(front!=rear)&#123;</span><br><span class="line">front = (front+<span class="number">1</span>)%maxSize;     <span class="comment">//出队一个顶点，赋值给j</span></span><br><span class="line">j=que[front];</span><br><span class="line">p=G-&gt;AdjList[j].first;         <span class="comment">//找到与这个顶点出去的边</span></span><br><span class="line"><span class="keyword">while</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(visited[p-&gt;adjV]==<span class="number">0</span>)&#123;   <span class="comment">//判断是否访问过</span></span><br><span class="line">visit(p-&gt;adjV);</span><br><span class="line">visited[p-&gt;adjV]==<span class="number">1</span>;</span><br><span class="line">rear=(rear+<span class="number">1</span>)%maxSize; </span><br><span class="line">que[rear]=p-&gt;adjV      <span class="comment">//入队</span></span><br><span class="line">&#125;</span><br><span class="line">p = p-&gt;next;               <span class="comment">//寻找下一条边(找与之相连的下一个)</span></span><br><span class="line">&#125;                  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640748.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640524.png" alt="image.png"></p><h2 id="最小生成树-Prim算法"><a href="#最小生成树-Prim算法" class="headerlink" title="最小生成树(Prim算法)"></a>最小生成树(Prim算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">生成树：由一个图按照某一种规则，导出里面包含的一颗树(就是由图所有顶点，与部分边，构成的一颗树，就是极小连通子图)</span><br><span class="line"></span><br><span class="line">最小生成树：构成的这颗生成树的所有分支的权值和最小(所以讨论的是带权图)</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.先确定一个根节点A0</span><br><span class="line">2.找到与根节点相邻的所有的边，选择权值最小的并入树中(如果产生环，则选择第二小的)，此时A0  A1两个结点</span><br><span class="line">3.继续，找到与A0 A1相邻的所有的边，3,2,7,8 --&gt;将权值为2的边并入树，此时结点A0 A1 A2</span><br><span class="line">4.重复...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011640486.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641608.png" alt="image.png"></p><h2 id="最小生成树-Kruskal算法"><a href="#最小生成树-Kruskal算法" class="headerlink" title="最小生成树(Kruskal算法)"></a>最小生成树(Kruskal算法)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">大致思想是</span><br><span class="line">1.将每条边都列举出来，按照权值从小到大排列</span><br><span class="line">2.从最小的边开始，如果边两边的顶点并未&quot;连通&quot;，则连通这条边</span><br><span class="line">3.如果两边顶点处于同一个&quot;并查集&quot;，即连通，则遍历下一条边</span><br><span class="line">4.直到所有顶点处于同一个&quot;并查集&quot;中，即生成了最小生产树</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641841.png" alt="image.png"></p><h2 id="最短路径-DIjkstra"><a href="#最短路径-DIjkstra" class="headerlink" title="最短路径(DIjkstra)"></a>最短路径(DIjkstra)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">求某一个顶点(确定某一点)到其余各顶点之间的最短路径</span><br><span class="line"></span><br><span class="line">设置3个数组</span><br><span class="line">dist[] --&gt;树中，min[从起点经过新增顶点与上述顶点间的距离,原本直接距离] ，初始=无穷</span><br><span class="line">path[] --&gt; 表示，上述顶点的起始顶点 ,初始=-1</span><br><span class="line">set[] --&gt; 0表示未并入树中，1表示已在树中 ，初始=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641285.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011641565.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新 ，&#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新，&#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><h2 id="最短路径-Floyd"><a href="#最短路径-Floyd" class="headerlink" title="最短路径(Floyd)"></a>最短路径(Floyd)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">求带权图中各顶点之间的最短路劲</span><br><span class="line"></span><br><span class="line">A矩阵：记录顶点到顶点的距离(一开始无中转点，无路径则为∞)</span><br><span class="line">path矩阵：记录顶点到顶点之间中转点(一开始无设为-1)</span><br><span class="line"></span><br><span class="line">接下来依次将中转点由V0~Vn遍历</span><br><span class="line">确定每一个中转点后，又在A距离矩阵遍历，比较加入中转点后与原距离的大小</span><br><span class="line">比如A(-1)[2][1] &gt; A(-1)[2][0] + A(-1)[0][1] 表示将0作为中转点，V2到V1的距离缩短了 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161335255.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三层循环，时间复杂度O(V^3)；空间复杂度O(V^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161351010.png" alt="image.png"></p><h2 id="最短路劲总结"><a href="#最短路劲总结" class="headerlink" title="最短路劲总结"></a>最短路劲总结</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161410881.png" alt="image.png"></p><h2 id="有向无环图-DAG"><a href="#有向无环图-DAG" class="headerlink" title="有向无环图(DAG)"></a>有向无环图(DAG)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不存在环路的有向图，也称DAG图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642453.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式，将重复部分，只保留一个(可以节省空间)，由两个指针指向同一个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642293.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011642866.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DAG表达式的构建</span><br><span class="line">1.将出现的元素罗列出来</span><br><span class="line">2.按照运算次序，按顺序加入运算符结点，并且将运算符号分层</span><br><span class="line">3.最后从最底层检查是否有重复部分，并合并</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643679.png" alt="image.png"></p><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列是有向无环图（DAG）中所有顶点的一种线性排序，使得对于每一条有向边 &lt;u, v&gt;，顶点 u 在拓扑序列中都排在顶点 v 的前面。换句话说，拓扑序列可以看作是一个 DAG 中所有顶点的一种合法排序方式。</span><br></pre></td></tr></table></figure><blockquote><p>AOV网：用顶点表示活动的网</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643547.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例，下列拓扑排序总共有5种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序，实现的是，将AOV网中依次的输出具有传递性的活动(顶点),找到做事的先后顺序</span><br><span class="line"></span><br><span class="line">AOV网允许有多个入度为0的顶点活动</span><br><span class="line"></span><br><span class="line">实现思路：</span><br><span class="line">1.找到入度为0的顶点，先输出</span><br><span class="line">2.删除顶点，与顶点有关的边（出边，也就是将由该顶点指向的所有顶点入度-1）</span><br><span class="line">3.重复1 2 直到为空</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">代码实现需要定义两个数组，一个栈</span><br><span class="line">indegree[] 记录当前所有顶点的入度</span><br><span class="line">print[] 记录拓扑排好的的顶点序列</span><br><span class="line">Stack S 保存度为0的顶点(也可以用队列代替)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">TopoSort</span><span class="params">(Graph G)</span>&#123;</span><br><span class="line">InitStack(S);  <span class="comment">//初始化栈</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.n;i++)&#123; <span class="comment">//遍历找出所有入度为0的顶点</span></span><br><span class="line"><span class="keyword">if</span>(indegree[i]==<span class="number">0</span>)&#123;</span><br><span class="line">push(S,i);      <span class="comment">//将入度为0的顶点进栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count=<span class="number">0</span>;<span class="comment">//记录当前已经输出的顶点数目</span></span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Pop(S); <span class="comment">//栈顶元素出栈</span></span><br><span class="line">print[count]=i;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span>(p=G.vertices[i].first;p!=<span class="literal">NULL</span>;p=p-&gt;next)&#123;<span class="comment">//将所有由i指向的顶点入度-1</span></span><br><span class="line"><span class="type">int</span> v=p-&gt;adjV;</span><br><span class="line"><span class="keyword">if</span>(!(--indegree[v]))&#123;</span><br><span class="line">push(S,v); <span class="comment">//入度为0，入栈</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count&lt;G.n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//说明有回路，排序失败</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//拓扑排序成功</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该算法。每一个顶点要被处理一次，每一条边也要遍历一次，所以时间复杂度O(|V|+|E|) </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643741.png" alt="image.png"></p><h2 id="DFS实现逆拓扑排序"><a href="#DFS实现逆拓扑排序" class="headerlink" title="DFS实现逆拓扑排序"></a>DFS实现逆拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里和深度优先遍历几乎一样</span><br><span class="line">只是将Visit(v)放到最后</span><br><span class="line">实现了，只有递归结束之后访问本节点(在这之前已经先访问了递归里面的结点，也就是深处结点)</span><br><span class="line">这样就实现了逆拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011643774.png" alt="image.png"></p><h2 id="DFS算法实现拓扑排序"><a href="#DFS算法实现拓扑排序" class="headerlink" title="DFS算法实现拓扑排序"></a>DFS算法实现拓扑排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1)假设结点u是结点v的祖先，则在调用DFS访问u的过程中，必然会在这个过程结束之</span><br><span class="line">前递归地对y调用DFS访问，即v的DFS函数结束时间先于u的DFS结束时间。从而</span><br><span class="line">可以考虑在DFS调用过程中设定一个时间标记，在DFS调用结束时，对各结点计时。因</span><br><span class="line">此，祖先的结束时间必然大于子孙的结束时间。</span><br><span class="line"></span><br><span class="line">2)若u是结点v的子孙，则v为u的祖先，按上述思路，v的结束时间大于u的结束时间。</span><br><span class="line">3)若u和v没有关系，则u和v在拓扑序列的关系任意。</span><br><span class="line">从而按结束时间从大到小，可以得到一个拓扑序列。</span><br><span class="line"></span><br><span class="line">实际上和深度优先遍历算法完全相同，只不过加入了变量time</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> v,ALGraph *G,<span class="type">int</span> time,<span class="type">int</span> Time[])</span>&#123;</span><br><span class="line">vistit[v]=<span class="number">1</span>;</span><br><span class="line">ArcNOde *p=G-&gt;AdjList[v].first;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="keyword">if</span>(visit[q-&gt;AdjV]==<span class="number">0</span>)&#123;</span><br><span class="line">DFS(q-&gt;AdjV,G);</span><br><span class="line">&#125;</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">time++;</span><br><span class="line">Time[v]=time;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后再按照time从多到少的顺序，输出，就得到了拓扑排序结果</span></span><br></pre></td></tr></table></figure><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p>图中所有路径长度=总工期的路径 ，都是关键路径。<br><strong>*关键路径(Critical Path )</strong>：在AOE网络中, 有些活动顺序进行，有些活动并行进行。从源点到各个顶点，以至从源点到汇点的有向路径可能不止一条。这些路径 的长度也可能不同。完成不同路径的活动所需的时间虽然不同，但只有各条路径上所有活动都完成了，整个工程才算完成。因此， 完成整个工程所需的时间取决于从源点到汇点的最长路径长度，即在这条路径上所有活动的持续时间之和。这条路径长度最长的路 径就叫做关键路径(Critical Path)。*</p><blockquote><p>AOE网，边表示活动，顶点表示事件<br>1.只有顶点事件发生后，各条边活动才能开始<br>2.顶点的所有入边活动都结束时，顶点事件才能发生<br>3.有些活动是能并行进行的</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AOE网只有1个入度为0的顶点，开始顶点(源点)，他表示整个工程的开始</span><br><span class="line">也只有1个出度为0的顶点，结束顶点(汇点)，他表示整个工程的结束</span><br><span class="line"></span><br><span class="line">从源点到汇点的所有路径中，具有最大路径长度(总权值)的路径称为关键路径，关键路径上的活动称为，关键活动</span><br><span class="line"></span><br><span class="line">在这里关键路径的总长度就是整个工程完成所需最短时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644443.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vk--&gt;顶点(事件)  ai--&gt;活动(边)</span><br><span class="line"></span><br><span class="line">1.事件vk的最早完成时间ve(k)</span><br><span class="line">2.事件vk的最晚完成时间vl(k)</span><br><span class="line">3.边ai的最早完成时间e(i)</span><br><span class="line">4.边ai的最晚完成时间l(i)</span><br><span class="line"></span><br><span class="line">规定将发生时间最长的路线定为汇点的 最晚发生时间=最早发生时间(如果不规定一下最晚发生时间，那么没有意义，因为，前面的事件可以一直拖下去永远不执行)</span><br><span class="line"></span><br><span class="line">可以通过逆拓扑排序先从后往前的倒推每个事件的最迟发生时间(由汇点来反推)</span><br><span class="line"></span><br><span class="line">关键活动是，活动最迟发生时间=活动最早发生时间 的活动</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011644666.png" alt="image.png"></p><h2 id="课后习题1"><a href="#课后习题1" class="headerlink" title="课后习题1"></a>课后习题1</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.以下叙述中，正确的是（A）。</span><br><span class="line">A.只要无向连通图中没有权值相同的边，则其最小生成树唯一</span><br><span class="line">B.只要无向图中有权值相同的边，则其最小生成树一定不唯一</span><br><span class="line">C.从n个顶，点的连通图中选取n-1条权值最小的边，即可构成最小生成树</span><br><span class="line">D.设连通图G含有n个顶点，则含有n个顶点、n-1条边的子图一定是G的生成树</span><br><span class="line"></span><br><span class="line">解析：选项A最小生成树的算法是基于贪心策略的，每次从事选取权值最小的，且满足条件的边，如果各边权值不同，则每次选择的新的顶点也是唯一的，因此最小生成树是唯一的</span><br><span class="line">选项B,若无向图本身就是一棵树，则最小生成树就是它本身，这时就是唯一的。选项C,选取的一1条边可</span><br><span class="line">能构成回路。选项D,含有n个顶点、n-1条边的子图可能构成回路，也可能不连通。</span><br><span class="line"></span><br><span class="line">2.最短路径一定是简单路劲</span><br><span class="line"></span><br><span class="line">3.下面的（A）方法可以判断出一个有向图是否有环（回路）。</span><br><span class="line">I.深度优先遍历Ⅱ.拓扑排序Ⅱ.求最短路径V.求关键路径</span><br><span class="line">A.I、Ⅱ、IV</span><br><span class="line">B.I、II、V,</span><br><span class="line">C.:I、IⅡ、IⅢ</span><br><span class="line">D.全部可以</span><br><span class="line"></span><br><span class="line">解析：深度优先遍历，深度优先遍历是逐层遍历的,通过栈等数据结构可以记录已经访问过的顶点。一旦发现重复顶点,立即结束遍历,返回最终结果。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最小生成树不唯一的话，得到的最小生成树就可能相同也可能不同</span><br><span class="line">但是如果最小生成树唯一，那不同算法得到的就一定相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161206652.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基础</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161210191.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.先画出图</span><br><span class="line">2.根据图直接判断，因为是选择题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161413553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序结束条件时找到直至为空，如果有环，则无法找到拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161418914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己理解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161426088.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不能排成拓扑序列，说明有环，那么D正确</span><br><span class="line">强连通分量--&gt;就是顶点之间可以相互抵达，那么就是存在闭环</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161444715.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下列拓扑排序总共5种，理解什么是拓扑排序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161453083.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵 顶点指向方向 i-&gt;j 行-&gt;列  </span><br><span class="line">如果上三角矩阵：那么必定 编号小指向编号大</span><br><span class="line">如果下三角矩阵：那么必定 编号大指向编号小的</span><br><span class="line"></span><br><span class="line">而拓扑排序，必定是小编号指向大编号，那么体现在邻接矩阵就是上三角矩阵</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161456601.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图拓扑序列唯一 但是图却不止一种</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161503337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">关键路径手算</span><br><span class="line">1.画出图</span><br><span class="line">2.画表格，最早开始时间 ；最晚开始时间</span><br><span class="line">3.从前往后依次计算各个顶点最早开始时间(就是等顶点之前所有顶点完成的时间)</span><br><span class="line">4.之后再从后往前，求各个顶点的最晚开始时间(应该满足不影响工期，就是最后一个顶点的最早开始时间 21)</span><br><span class="line">5.找出最早、最晚开始时间相等的点组成关键路径</span><br><span class="line"></span><br><span class="line">关键路径的长度必然=整个工程完成的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161515079.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I ：加入只有一个路径，那么关键路径就是自己，怎么变都是一条关键路径</span><br><span class="line">II ：关键路径就是整个工程时间，没问题</span><br><span class="line">III：如果有多条关键路径，降低某一条不影响其他条</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161608871.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DFS深度优先遍历</span><br><span class="line">这样想，比如1这个结点最先入栈，在它后面的结点没有弹栈之前不会弹栈</span><br><span class="line">递归的思考，对于每个结点都是这样，于是就神奇的发现，实现了逆拓扑排序，只需要在弹栈之后再输出元素就可以了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161635017.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra算法</span><br><span class="line">前提：列出所有顶点与a的直接距离，没有直接相连设为∞；</span><br><span class="line">1轮：a直接到达的是b、c。与原距离对比 </span><br><span class="line">一样，不更新距离，入路径更短的 b </span><br><span class="line"></span><br><span class="line">2轮：b直接到达的是c、d。与原距离对比</span><br><span class="line">&#123;abc&#125;&lt;&#123;ac&#125; &#123;abd&#125;&lt;&#123;ad&#125;;更新距离，入路径更短的 c</span><br><span class="line"></span><br><span class="line">3轮：c直接到达的是d、e、f。与原距离对比</span><br><span class="line">&#123;acd&#125;&gt;&#123;abd&#125;不更新  &#123;ace&#125;&lt;&#123;ae&#125;更新，&#123;acf&#125;&lt;&#123;af&#125;更新 入路径更短的 f </span><br><span class="line"></span><br><span class="line">4轮：f直接到达的是 没有</span><br><span class="line">只剩下 d、e 入路径更短的 d </span><br><span class="line"></span><br><span class="line">5轮：d直接到达的是f、e。与原距离对比，&#123;acde&#125;=&#123;ace&#125;不更新 &#123;acdf&#125;&gt;&#123;acf&#125;不更新</span><br><span class="line">入最后的 e</span><br><span class="line"></span><br><span class="line">每一轮，根据新增顶点作为试探，列出所有与其直接相连的顶点，并将新开辟出的路径与原路径对比</span><br><span class="line">如果更短就更新路径。并且最后将与之相连的最近的顶点，入到路径之中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161719573.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缩短工期问题，必须缩短所有关键路径共有的边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161806152.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">举例子，举最简单例子 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161809806.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">拓扑序列，边推进边删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161813650.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305161854380.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">4...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162037259.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">顶点的最早开始时间与最晚开始时间容易求</span><br><span class="line">需要注意的是，边的最早开始时间就是顶点的最早开始时间(顶点刚开始，就开启活动)</span><br><span class="line">但是，边的最晚开始时间却不是起始顶点的最晚开始时间(活动可能有剩余时间等待)，所以</span><br><span class="line">应该从 下一个顶点的最晚开始时间减去活动所需时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162102546.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有向无环图 DAG 表达式应用</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162112044.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">拓扑排序</span><br><span class="line">1.寻找入度为0的顶点</span><br><span class="line">2.删除该顶点与其发出的边(由这个顶点指向的其他顶点的入度-1)</span><br><span class="line">3.接着寻找入度为0的顶点</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">注意：如果存在多个入度=0的顶点，那么拓扑序列可能有多个</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162135908.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间余量：就是不拖延工期前提，活动最多能拖延多久</span><br><span class="line">活动时间余量=结束顶点的最迟开始时间-开始顶点的最早开始时间-该活动的时间</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305162216094.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2)该图有多少个强连通分量？</span><br><span class="line">只有入度没有出度，或者只有出度没有入度的顶点，必然不可能和其他顶点连通，所以这种顶点自身就是一个强连通分量。通过不断去除已经找到的强连通分量进而更加清晰的寻找另外的强连通分量</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172253366.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">综合3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305172318917.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">说明如何用DFS 实现拓扑排序?</span><br><span class="line">- 深度优先遍历，会将先经过的结点入栈，先入后出，一般用于实现逆拓扑排序</span><br><span class="line">- 如果反过来要实现逆拓扑排序，则需要定义一个全局变量time,标记当前结点的结束时间</span><br><span class="line">- 然后将顶点按时间从大到小排序，得到的的就是拓扑序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181137335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Dijkstra最短路径算法能否给出一颗生产树？该树是否一定是最小生成树？</span><br><span class="line">- 能，但不一定是最下生成树。</span><br><span class="line"></span><br><span class="line">解答：Dijkstra最短路径算法能够给出一棵生成树，但该树不一定为最小生成树。虽然Dijkstra算法和Prim算法的思路与步骤较为相似，但两者的更新算法不一致，而其余部分完全一致。</span><br><span class="line"></span><br><span class="line">Dijkstra算法对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;Min[k]+G[k][j]);</span><br><span class="line">Min[j]=Min[k]+G[k][j];</span><br><span class="line"></span><br><span class="line">而Pim算法Q对应的Min更新算法为</span><br><span class="line">if(Min[j]&gt;G[k][j]);</span><br><span class="line">Min[j]=G[k][j]</span><br><span class="line"></span><br><span class="line">为此，可考虑以下的反例</span><br><span class="line">对于以下的带权连通无向图</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181208563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181147863.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2011年真题</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181217437.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">（2）.本质就是图结构体=顶点结构体+边结构体</span><br><span class="line">（3）.本质就是找出R1到各个路由器的最短路劲，然后按照从小到大的顺序排序，Dijkstra算发就是按照，先入较短路径的顶点，然后根据新入顶点找下一个较短路劲顶点，这样得到的顶点路劲必然是后面加入的顶点路劲更长</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232316553.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.按照prim算法过程依次选出边即可</span><br><span class="line">（2）.题目只问一个问题——是否唯一？；答，唯一即可，无需多做解释</span><br><span class="line">（3）.题目只问满足什么条件时？；答一个充分条件即可。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232328694.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（1）.&quot;所有可能&quot;，说明要列出所有，的最小生成树的情况</span><br><span class="line">（2）.写prim算法名称--&gt;奇怪怎么会有怎么简单的问题？</span><br><span class="line">（3）.TTL就是信息保留时间，当路径长度大于TTL时，信息销毁</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305232343584.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储的图</span><br><span class="line">DFS遍历使用了栈--&gt;栈内存的顶点最多不超过顶点数n</span><br><span class="line">BFS使用了队列--&gt;队列内的顶点数，最多也不超过n</span><br><span class="line">那么DFS BFS空间复杂度都与n都有关,空间复杂度&#x27;不可避免&#x27;的O(n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241436702.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无论是DFS还是BFS</span><br><span class="line">邻接矩阵都有nxn个空间需要依次遍历，所以时间复杂度是O(n^2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241535428.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DFS遍历</span><br><span class="line">分析D选项</span><br><span class="line">从a作为开始结点a--&gt;e--&gt;d--&gt;f--&gt;c </span><br><span class="line">到c往下DFS发现边为NULL，执行到底不再递归弹栈,返回到c</span><br><span class="line">返回c，发现c的next为空，执行到底，退出栈</span><br><span class="line">返回f,发现..</span><br><span class="line">返回d,发现...</span><br><span class="line">返回e,发现e的next边与b相连，于是对b递归，访问b</span><br><span class="line">--&gt;最终顺序是a e d f c b</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241553960.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305241544054.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.关键路径有争议，因为求关键路径，需要先求各个事件的最早开始时间和最晚开始时间，但是如果有环的话，那么就导致事件无限循环无法结束，最终报错--&gt;至于通过报错判断是否有环是否可以利用还存在争议</span><br><span class="line">B.Dijikstra算法是求最短路劲，通过依次加入顶点，更新距离的操作与有没有环没有关系</span><br><span class="line">C.深度优先遍历算法.这里可以微调一下深度优先算法.将弹栈后的结点，清除器访问标记--&gt;</span><br><span class="line">这样做虽然会导致访问重复结点，但是我们的目的是判断是否有环，而不是遍历。所以有环的话，必然会在某一条深度递归中，压入已经存在栈内的顶点(重复顶点)，那么就可以判断有环存在。至于清除访问标记是因为该深度已经遍历，那么将节点释放相当于弹栈，以便判断下一条单条深度递归中的重复顶点。</span><br><span class="line">D.广度优先遍历,无法实现有向图是否有环的判断，因为，广度优先遍历无法判断图是否有环，因为广度优先遍历是按照图的层次结构，从起始顶点开始，依次访问与它相邻的所有顶点，然后再访问这些顶点的邻接点，直到所有顶点都被访问为止¹。在这个过程中，如果一个顶点有一条边指向已经访问过的顶点，并不能说明这两个顶点在同一个环中，因为它们可能是不同层次的顶点。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242130768.png" alt="Uploading file...urh96"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">关于图的概念辨别题，主要是要理清楚图的概念</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242257386.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这道题目需要注意的点：</span><br><span class="line">1.对于写出深度优先生成树，不能根据给出的表，画出完整的图G后再进行深搜。因为给定的表隐含着遍历顺序，而你完整图中进行的遍历没有符合题目要求的顺序,因此，应该直接根据邻接表来深度搜索--&gt; 1--&gt;2--&gt;3--&gt;4--&gt;5</span><br><span class="line">2.对于写出广度优先生成树，同样的道理不能按照画出的完整图来遍历，原因依然是要按照题目中邻接表中隐含的顺序来进行推进--&gt;1 2 3 4 5 如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242335365.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305242328392.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算法设计</span><br><span class="line">1.切入点：树的顶点=数的边+1</span><br><span class="line">2.步骤：初始化两个变量i j,分别存储顶点数目，边的数目；遍历顶点，没访问一个顶点i++,在访问与该点所有相连的边,每条边j++;最终边的数量统计了两次，因为一条边连接了两个顶点，所以最终统计i=j/2 + 1是否成立</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252008877.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DFS如果不用递归，那么必须需要栈的数据结构来替代递归栈.</span><br><span class="line">邻接表采用深度优先遍历，从i开始--&gt;i入栈--&gt;遍历j--&gt;j入栈--&gt;跳转到j开头那一行--&gt;遍历k--&gt;k入栈--&gt;跳转到k的那一行--&gt;...--&gt;遍历到最深层--&gt;一次往回弹栈</span><br><span class="line">从过程中，入栈需要存入两种信息：</span><br><span class="line">1.该入栈结点的编号 </span><br><span class="line">2.该入栈顶点位于哪行的地几个位置(为了使得弹栈之后回到相对应的位置继续遍历) </span><br><span class="line">3.另外还需要，用一种数据结构存储已经遍历过的顶点，防止重复遍历</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252034320.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用遍历算法判断邻接表方式存储的有向图中，是否存在顶点i到j的路径</span><br><span class="line">1.将i作为遍历的开始顶点</span><br><span class="line">2.采用任意遍历算法，遍历只要寻找到顶点j就说明存在从i到j的路径,返回true，否则返回false</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252052716.png" alt="image.png"></p><h2 id="课后习题2"><a href="#课后习题2" class="headerlink" title="课后习题2"></a>课后习题2</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252202149.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">完全图的定义：任意两个顶点之间都存在边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252206168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">邻接矩阵:nxn</span><br><span class="line">无向图:矩阵中2e个1</span><br><span class="line">0个数=n^2-2e</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252208299.png" alt="Uploading file...p539r"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于邻接矩阵而言，&quot;行出列入&quot;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252219197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图的邻接表的存储结构--&gt;左边一列，顶点结构体；右边的是由顶点引出的与顶点相连的所有边结构体。</span><br><span class="line"></span><br><span class="line">这题顶点v在边表中的出现次数，是指边表中存储的是边指向的下一个顶点(有向图)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271149779.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">邻接表存储无向图，由于无向图边是双向的，所以n(n-1)条边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271202239.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">删除有向图某个顶点v相关的所有边</span><br><span class="line">1.删除该顶点引出的所有一连串的边表结点，最多引出n-1条边 O(n) </span><br><span class="line">2.删除所有指向该顶点的所有边，由于无法判断起始点是哪一个，所以只能从头到尾遍历O(e)</span><br><span class="line"></span><br><span class="line">最终时间复杂度O(n+e)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271210580.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">十字链表是存储有向图</span><br><span class="line">邻接多重表是存储无向图</span><br><span class="line"></span><br><span class="line">推出十字链表和邻接多重表的目的是为了将某一条边的两个顶点都表示出来，以至于可以直接通过一条边找到两端的两个顶点，而不是只能从一个顶点出发</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271422325.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271515927.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> numVertice,numEdge;</span><br><span class="line"><span class="type">char</span> Vertice[maxV];    <span class="comment">//顶点表</span></span><br><span class="line"><span class="type">int</span> Edge[maxv][maxv];  <span class="comment">//邻接矩阵</span></span><br><span class="line">&#125;Graph;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsExistEL</span><span class="params">(Mgraph G)</span>&#123;</span><br><span class="line"><span class="type">int</span> degree,count;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;G.numV;i++)&#123;</span><br><span class="line">degree =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j;j&lt;G.numV;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(G.Edge[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">degree++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(degree%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(count==<span class="number">2</span>||count==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271544169.png" alt="image.png"></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><blockquote><p>基本概念<br><code>查找长度</code>：查找运算中，需要对比关键字的次数<br><code>平均查找长度</code>：（ASL  Average Search Length），所有查找过程中进行关键字比较次数的平均值</p></blockquote><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>时间复杂度 无论如何优化，始终为<code>O(n)</code></p><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041349757.png" alt="image.png"><br><mark>针对有序的顺序表</mark><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">ElemType *data;</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(SSTable T,ElemType key)</span>&#123;</span><br><span class="line"><span class="type">int</span> low=<span class="number">0</span>,high=T.len,mid;</span><br><span class="line"><span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">mid=(low+high)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(T.data[mid]==key)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(T.data[mid]&lt;key)&#123;</span><br><span class="line">high=mid<span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low=mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//查找失败</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041428775.png" alt="image.png"><br><code>折半查找判定树</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041435628.png" alt="image.png"><br><code>折半查找判定树的性质</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- mid=(low+high)/2 采用的是向下取整方式</span><br><span class="line">- 结点数n为奇数，右子树结点数-左子树结点数=1</span><br><span class="line">- 结点数n为偶数，右子树结点数=左子树结点速</span><br><span class="line"></span><br><span class="line">- 折半查找判定树一定是平衡二叉树</span><br><span class="line">- 折半查找判定树，只有最下面一层不是满的，因此求树高h于完全二叉树公式一致</span><br><span class="line">- 失败结点：n+1个也就是查找成功结点的空链域数量</span><br><span class="line">- 每个元素所在层数表示查找次数，所以查找成功，失败的时间复杂度不会超过树高(树高不包括失败</span><br><span class="line">  结点)log2(n+1),时间复杂度O(log2n)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041446033.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041448619.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树高不包含失败的结点(紫色的空节点)，因为查找失败的查找次数也就是查找到其父节点的查找次数(也就是失败结点的父节点的树高)，因为，当查找到树梢结点发现没找到就查找失败，那么查找是吧的次数也就是树梢结点的高度了</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041453663.png" alt="image.png"></p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">特点：块内无序，块间有序,块内存放数据个数不同，索引中保存每个块的最大关键字和起始到末尾的地址</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041501254.png" alt="image.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- 考察选择，不要求代码</span><br><span class="line"></span><br><span class="line">索引表中保存的是每个区块中最大的关键字</span><br><span class="line"></span><br><span class="line">分块查找</span><br><span class="line">- 对分块的索引表采用顺序查找</span><br><span class="line"></span><br><span class="line">- 对分块的索引表采用折半查找</span><br><span class="line">分两种情况：</span><br><span class="line">1.查找元素正好是索引表的元素,例如30</span><br><span class="line">2.查找元素不是索引表的元素此时，折半查找，最终low&gt;high，low指向的就是目标元素</span><br><span class="line"> 所在区块</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041711226.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">顺序查找方式</span><br><span class="line">ASL=查索引表的平均查找长度+查分块的平均查找长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041723622.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找方式</span><br><span class="line">ASl分析，不太重要，就不讨论了...</span><br></pre></td></tr></table></figure><h2 id="二叉查找-排序-树-BST"><a href="#二叉查找-排序-树-BST" class="headerlink" title="二叉查找(排序)树(BST)"></a>二叉查找(排序)树(BST)</h2><h3 id="查找-插入-构造树"><a href="#查找-插入-构造树" class="headerlink" title="查找-插入-构造树"></a><code>查找-插入-构造树</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">二叉查找(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-2">二叉查找(递归)</button></li><li class="tab"><button type="button" data-href="#test1-3">二叉排序树插入(递归)</button></li><li class="tab"><button type="button" data-href="#test1-4">二叉排序树插入(非递归)</button></li><li class="tab"><button type="button" data-href="#test1-5">二叉排序树的建立</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">T=t-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BSTNode *<span class="title function_">BST_Search</span><span class="params">(BSTree T,<span class="type">int</span> key)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(key==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;left,key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key&gt;T-&gt;key,key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Search(T-&gt;right,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//若原二叉树为空，则直接插入结点，否则关键字k小于根节点值，则插入到左子树，若关键字k大于根节点值，则插入到右子树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=key;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;left,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> BST_Insert(T-&gt;right,k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-4"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">BST_Search</span><span class="params">(BSTree &amp;T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k=T-&gt;key)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k&lt;T-&gt;key)&#123;</span><br><span class="line">T=T-&gt;left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">T=T-&gt;right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">T=(BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">T-&gt;key=k;</span><br><span class="line">T-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">T-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-5"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="type">int</span> str[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">BST_Insert(T,str[i]); <span class="comment">//插入方法</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p><code>查找ASL分析</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">查找成功ASL分析</button></li><li class="tab"><button type="button" data-href="#test1-2">查找失败ASL分析</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042035408.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042036128.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><h3 id="二叉排序树删除"><a href="#二叉排序树删除" class="headerlink" title="二叉排序树删除"></a><code>二叉排序树删除</code></h3><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">情况1-删叶节点</button></li><li class="tab"><button type="button" data-href="#test1-2">情况2-只有左或·右结点-</button></li><li class="tab"><button type="button" data-href="#test1-3">同时有左右结点</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接删除，不影响排序树结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042039542.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也是可以直接删除</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042040203.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><code>有两种方式</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将删除节点的右子树的最小节点替代删除节点</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042048914.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将左子树的最大节点替代删除结点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042049351.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a><code>回顾</code></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305042051390.png" alt="image.png"></p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><hr><h3 id="平衡二叉树概念"><a href="#平衡二叉树概念" class="headerlink" title="平衡二叉树概念"></a>平衡二叉树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树(Balanced Binary Tree)，在二叉排序树基础上，树上任意结点的左子树与右子树高度只差不超过1</span><br><span class="line"></span><br><span class="line">平衡因子=左子树高度-右子树高度</span><br><span class="line"></span><br><span class="line">如果二叉树平衡，各个结点的平衡因子只能是0,-1,1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072211245.png" alt="image.png"></p><h3 id="平衡二叉树插入调整"><a href="#平衡二叉树插入调整" class="headerlink" title="平衡二叉树插入调整"></a>平衡二叉树插入调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树插入新结点如何保持平衡？</span><br><span class="line"></span><br><span class="line">只需调整引起不平衡的最小的那个子树，画圈的部分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072213624.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如何调整？</span><br><span class="line"></span><br><span class="line">插入导致不平衡分为四种情况：(A是最小不平衡子树)</span><br><span class="line">LL 在A的左孩子的左子树中插入导致不平衡</span><br><span class="line">RR 在A的右孩子的右子树中插入导致不平衡</span><br><span class="line">LR 在A的左孩子的右子树中插入导致不平衡</span><br><span class="line">RL 在A的右孩子的左子树中插入导致不平衡</span><br><span class="line"></span><br><span class="line">通过旋转来调整二叉树的失衡</span><br><span class="line">要找到最小的那颗失衡的二叉树调整</span><br></pre></td></tr></table></figure><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><p><code>LL右旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231082.png" alt="image.png"></p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><p><code>RR左旋调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072231424.png" alt="image.png"></p><p><code>LL&amp;RR代码思路</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072232020.png" alt="image.png"></p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><p><code>LR</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072238460.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072239049.png" alt="image.png"></p><h4 id="RL"><a href="#RL" class="headerlink" title="RL"></a>RL</h4><p><code>RL</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072241280.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072242585.png" alt="image.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072243530.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072250049.png" alt="image.png"></p><h3 id="平衡二叉树ASL分析"><a href="#平衡二叉树ASL分析" class="headerlink" title="平衡二叉树ASL分析"></a>平衡二叉树ASL分析</h3><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305072259228.png" alt="image.png"></p><h3 id="平衡二叉树删除调整"><a href="#平衡二叉树删除调整" class="headerlink" title="平衡二叉树删除调整"></a>平衡二叉树删除调整</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①删除结点(方法同“二叉排序树”)</span><br><span class="line">②一路向北找到最小不平衡子树，找不到就完结撒花</span><br><span class="line">③找最小不平衡子树下，“个头”最高的儿子、孙子</span><br><span class="line">④根据孙子的位置，调整平衡(LL/RR/LR/RL)</span><br><span class="line">⑤如果不平衡向上传导，继续②，对最小不平衡子树的旋转可能导致树变矮，从而导致上层祖先不平衡（不平衡向上传递）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081219106.png" alt="image.png"></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><hr><h3 id="红黑树定义性质"><a href="#红黑树定义性质" class="headerlink" title="红黑树定义性质"></a>红黑树定义性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虽然平衡二叉树与红黑树，search、Insert、Delete操作时间复杂度都是O(log2(n)),但是平衡二叉树需要频繁调整数的形态；如：插入操作导致不平衡，则需要先计算平衡因子，找到最小不平衡子树（时间开销大），再进行LL/RR/LR/RL调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081233506.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">红黑树特性：</span><br><span class="line">1.每个结点或是红或是黑色</span><br><span class="line">2.根节点一定是黑</span><br><span class="line">3.叶子结点均是黑(指的是失败结点，查找失败结点，也叫NULL结点)</span><br><span class="line">4.不存在两个相邻红结点(即红结点的父、孩子结点一定是黑)</span><br><span class="line">5.对于每个结点，从该结点到任一叶子结点的简单路劲，所含黑结点数量一致</span><br><span class="line"></span><br><span class="line">=&gt;1.红黑树从根节点到叶结点(NULL结点)的最长路径长度不大于最短路径的两倍</span><br><span class="line">  2.n个结点的红黑树高度h&lt;=2log2(n+1) --&gt; search时间复杂度O(log2(n))</span><br></pre></td></tr></table></figure><p><code>红黑树结点结构体</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RBnode</span>&#123;</span></span><br><span class="line"><span class="type">int</span> key;           <span class="comment">//保存得值</span></span><br><span class="line">RBnode* parent;    <span class="comment">//父节点指针</span></span><br><span class="line">RBnode* lChild;</span><br><span class="line">RBnode* rChild;</span><br><span class="line"><span class="type">int</span> color;         <span class="comment">//结点颜色，也可用0/1表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081253235.png" alt="image.png"></p><h3 id="红黑树插入"><a href="#红黑树插入" class="headerlink" title="红黑树插入"></a>红黑树插入</h3><p><a href="[7.3_5_红黑树的插入_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=77&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081354530.png" alt="image.png"></p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="B树概念"><a href="#B树概念" class="headerlink" title="B树概念"></a>B树概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">考察选择，不考察代码</span><br><span class="line"></span><br><span class="line">B树性质如下</span><br><span class="line"></span><br><span class="line">1.最少有1个关键字，也就最少有2个分叉;最多有4个关键字，最多就5个分叉</span><br><span class="line"></span><br><span class="line">如何保证查找效率？</span><br><span class="line">- m叉查找树中，规定除了根节点，任何结点都必须至少有[m/2向上取整]个分叉，</span><br><span class="line">  即保证 除了根结点之外的结点至少有[m/2向上取整]-1个关键字</span><br><span class="line">- m叉查找树中，规定对于任何一个结点，其所有子树的高度都相同</span><br><span class="line">-- &gt;保证了上述两个条件的m叉查找树就是B树</span><br><span class="line"></span><br><span class="line">- B树,又称为多路平衡查找树</span><br><span class="line">- B树的阶，是B树中所有节点的分支数的最大值</span><br><span class="line">- ...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081519493.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301813773.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305081516407.png" alt="image.png"></p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B树的高度不包括叶子结点(失败结点)</span><br><span class="line">要使得n个结点的B树高度最小--&gt;尽可能的让结点里的关键字多，且分叉多--&gt;推导--&gt;</span><br><span class="line">m-1个关键字，m个分叉，则有(m-1)(1 + m + m^2 + m^3 +...+ m^h-1) = m^h - 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301833168.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">要使得含有n个关键字的B树的高度最大--&gt;让每个结点包含的关键字尽可能的少，分叉尽可能的少--&gt;记k=[m/2向上取整]，--&gt;每个结点关键字(根节点可以只有1个关键字，其他结点都为k-1个结点)，分叉最少为k --&gt;如下表</span><br><span class="line"></span><br><span class="line">h层的m阶B树至少包含多少关键字--&gt;就是B树高度最高的情况--&gt;根据上面的推到求得</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301857073.png" alt="image.png"></p><h3 id="B树的插入和删除"><a href="#B树的插入和删除" class="headerlink" title="B树的插入和删除"></a>B树的插入和删除</h3><hr><p><a href="[7.4_2_B树的插入删除_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1b7411N798?p=80&amp;vd_source=cbf004b023311fdd28400217ca0339bb">视频地址</a>)</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p><em>只考察基本概念</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231326339.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231326680.png" alt="image.png"></p><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="散列表的基本概念"><a href="#散列表的基本概念" class="headerlink" title="散列表的基本概念"></a><em>散列表的基本概念</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221757707.png" alt="image.png"></p><h4 id="什么是散列表、散列函数？"><a href="#什么是散列表、散列函数？" class="headerlink" title="什么是散列表、散列函数？"></a><em>什么是散列表、散列函数？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221758673.png" alt="image.png"></p><h4 id="同义词和冲突"><a href="#同义词和冲突" class="headerlink" title="同义词和冲突"></a><em>同义词和冲突</em></h4><p><strong>*冲突（碰撞）</strong>：在散列表中插⼊⼀个数据元素时，需要根据关键字的值确定其存储地址，若该地址已经存储了其他元素，则称这种情况为“冲突（碰撞）”。<br><strong>同义词</strong>：若不同的关键字通过散列函数映射到同⼀个存储地址，则称它们为“同义词”。*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221800954.png" alt="image.png"></p><h4 id="如何减少冲突？"><a href="#如何减少冲突？" class="headerlink" title="如何减少冲突？"></a><em>如何减少冲突？</em></h4><blockquote><p><strong><em>拉链法</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221801733.png" alt="image.png"></p><blockquote><p><strong><em>开放地址法</em></strong></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221802399.png" alt="image.png"></p><h3 id="散列函数的构造"><a href="#散列函数的构造" class="headerlink" title="散列函数的构造"></a><em>散列函数的构造</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221948070.png" alt="image.png"></p><h4 id="设计散列函数应该注意什么？"><a href="#设计散列函数应该注意什么？" class="headerlink" title="设计散列函数应该注意什么？"></a><em>设计散列函数应该注意什么？</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221949614.png" alt="image.png"></p><h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a><em>除留余数法</em></h4><p>除留余数法 —— H(key) = key % p<br>散列表表⻓为m，取⼀个不⼤于m但最接近或等于m的质数p<br>注：质数⼜称素数。指除了1和此整数⾃身外,不能被其他⾃然数整除的数<br><code>适⽤场景：较为通⽤，只要关键字是整数即可</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221951184.png" alt="image.png"></p><blockquote><p><em>为什么要取质数</em></p></blockquote><p><em>原因：对质数取余，可以分布更均匀，从⽽减少冲突</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221952933.png" alt="image.png"></p><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a><em>直接定址法</em></h4><p>直接定址法 —— H(key) = key 或 H(key) = a × key + b<br>其中，a和b是常数。这种⽅法计算最简单，且不会产⽣冲突。若关键字分布不连续，空位较多，则会造成存储空间的浪费。<br><code>适⽤场景：关键字分布基本连续</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221954750.png" alt="image.png"></p><h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a><em>数字分析法</em></h4><p>数字分析法 —— 选取数码分布较为均匀的若⼲位作为散列地址；<br>设关键字是r进制数（如⼗进制数），⽽r个数码在各位上出现的频率不⼀定相同，可能在某些位上分布均匀⼀些，每种数码出现的机会均等；⽽在某些位上分布不均匀，只有某⼏种数码经常出现，此时可选取数码分布较为均匀的若⼲位作为散列地址。<br><code>适⽤场景：关键字集合已知，且关键字的某⼏个数码位分布均匀</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221956595.png" alt="image.png"></p><h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a><em>平方取中法</em></h4><p>平⽅取中法——取关键字的平⽅值的中间⼏位作为散列地址。<br>具体取多少位要视实际情况⽽定。这种⽅法得到的散列地址与关键字的每位都有关系，因此使得散列地址分布⽐较均匀。<br><code>适⽤场景：关键字的每位取值都不够均匀</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308221957730.png" alt="image.png"></p><ul><li><em>平方取中间两位，由于中间的两位的值受到了原来每一个数码位的影响，所以，相对具有代表性</em></li></ul><h3 id="处理冲突的方法—拉链法"><a href="#处理冲突的方法—拉链法" class="headerlink" title="处理冲突的方法—拉链法"></a><em>处理冲突的方法—拉链法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222005727.png" alt="image.png"></p><h4 id="拉链法散列表的插入"><a href="#拉链法散列表的插入" class="headerlink" title="拉链法散列表的插入"></a><em>拉链法散列表的插入</em></h4><p><em>散列表数组中，存的是链表的头指针，这里采用的是头插法，也可以尾插法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222006557.png" alt="image.png"></p><h4 id="拉链法散列表的查找"><a href="#拉链法散列表的查找" class="headerlink" title="拉链法散列表的查找"></a><em>拉链法散列表的查找</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222007281.png" alt="image.png"></p><h4 id="拉链法散列表的删除"><a href="#拉链法散列表的删除" class="headerlink" title="拉链法散列表的删除"></a><em>拉链法散列表的删除</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222009631.png" alt="image.png"></p><h3 id="处理冲突的方法—开放地址法"><a href="#处理冲突的方法—开放地址法" class="headerlink" title="处理冲突的方法—开放地址法"></a><em>处理冲突的方法—开放地址法</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222021171.png" alt="image.png"><br>开放定址法：如果发⽣“冲突”，就给新元素找另⼀个空闲位置。<br>为什么叫“开放定址”？—— ⼀个散列地址，既对同义词开放，也对⾮同义词开放。</p><h4 id="开发地址法的基本原理"><a href="#开发地址法的基本原理" class="headerlink" title="开发地址法的基本原理"></a><em>开发地址法的基本原理</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222024354.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222025380.png" alt="image.png"></p><h4 id="线性探测法"><a href="#线性探测法" class="headerlink" title="线性探测法"></a><em>线性探测法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222025605.png" alt="image.png"></p><h4 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a><em>平方探测法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222025950.png" alt="image.png"></p><h4 id="双散列法"><a href="#双散列法" class="headerlink" title="双散列法"></a><em>双散列法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222026154.png" alt="image.png"></p><h4 id="伪随机序列法"><a href="#伪随机序列法" class="headerlink" title="伪随机序列法"></a><em>伪随机序列法</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222026554.png" alt="image.png"></p><h4 id="特别注意：关于删除操作"><a href="#特别注意：关于删除操作" class="headerlink" title="特别注意：关于删除操作"></a><em>特别注意：关于删除操作</em></h4><p><em>注意：采⽤“开放定址法”时，删除元素不能简单地将被删元素的空间置为空，否则将截断在它之后的探测路径，可以做⼀个“已删除”标记，进⾏逻辑删除。【注：⽆论线性探测法、平⽅探测法、双散列法、伪随机序列法原理都⼀样。删除元素时，只能逻辑删除】</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308222029979.png" alt="image.png"></p><h2 id="课后习题-11"><a href="#课后习题-11" class="headerlink" title="课后习题"></a>课后习题</h2><hr><h3 id="顺序查找、折半查找、分块查找"><a href="#顺序查找、折半查找、分块查找" class="headerlink" title="顺序查找、折半查找、分块查找"></a>顺序查找、折半查找、分块查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序查找概念，从一端到另一端，适合链式存储结构和顺序存储结构</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271605230.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为查找的目标元素是任意的，对有序表而言，需要一次从头查找直到遇到mubiao,而对无序表而言依然需要从头查找直到遇到目标，所以，无论有序还是无序表，只要查找目标四任意的，那么查找平均时间都是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271615270.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平均查找长度=∑（查找概率*查找长度）</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271620424.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271627148.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B.字符型不能比较，所以没法做到有序，也就无法二分查找</span><br><span class="line">D.二分查找只能以顺序方式存贮</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271629499.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271635334.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">折半查找树一定是一颗平衡二叉树，因为查找的元素一定是中间的元素，那么就有左半部分与右半部分，也就是左右结点，最极端的情况也就是两端没有左或没有右，也就是说，左右子树的高度只差不会大于1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271644073.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">折半查找对应着一颗平衡二叉树，任意结点的左右子树高度只差不超过1，所以对应查找时间（=树高=查找次数=log2(n)）,但是二叉排序树，没有限制高度相差，所以二叉排序树可以单个高度很高，加入要查的目标元素就在这个很高的分支里面，那么查找次数就多。</span><br><span class="line">所以，折半查找和二叉排序树的查找时间性能上，时而相同时而不同，但是大部分是折半查找效率高，</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271649628.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">折半查找树是平衡二叉树</span><br><span class="line">但是不是所有平衡二叉树都满足折半查找树要求，折半查找树，左右子树都平均，最多相差一两个结点，但是平衡二叉树比如下图，右下有一大部分空缺。</span><br><span class="line">所以如果找折半查找树的高度，可以把其当成一颗完全二叉树来求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271703396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">了解一下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271716769.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">空节点的个数就是查找失败的个数，但是查找失败所需次数(查找长度)不是失败结点的高度，而是查找到的最后一个结点的查找次数，也就是失败结点没有高度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271734741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分块查找，将数据分为若干块，块间有序是指按每块的最大值排序，块内无序，块内数据个数无需相同</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271749420.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据下面推到，块内最理想块长=根号n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271806326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最好情况：最理想分块 √n ;块内有序;块内快外都进行二分查找；</span><br><span class="line">在上述最好情况下，最多比较16次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271811217.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比较5次最多</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271855161.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于A 500,200说明500向左走,左边的应该都比500小符合；200,450,说明200向右走，说明200右边应该比比200大且比500小,不符合；</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271859916.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该题的算法本质就是顺序查找，而顺序查找如果要比折半查找比较次数更少，那只有x接近数组开头处</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271905335.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B.折半查找当结点个数为偶数时，要么统一选取左边结点为中间结点，要么统一选取右边结点为中间结点，看图B 末梢处，剩余两个结点，一边的选取了靠右的为中间结点，另一边选取了考左的为中间结点，不符合算法</span><br><span class="line">C.与B类似</span><br><span class="line">D.左子树4结点，右子树5结点，说明偶数结点数，统一选取考左的为中间结点，那么又因为，更小的子树的左子树为2，右子树为1，选取的又是靠右的，互相矛盾，所以不符合算法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305271914099.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当个例题来看吧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272138000.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k分查找成功时间复杂度--&gt;查找树的高度logk n + 1--&gt;查找成功次数最多logk n + 1时间复杂度O(logk n)</span><br><span class="line">查找不成功查找次数最多也为logk n + 1--&gt;时间复杂度也为O(logk n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272205598.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">顺序查找查找成功7,15，23...8N-1 ---&gt;共n个--&gt;查找长度1+2+3+..+n</span><br><span class="line">二分查找查找成功</span><br><span class="line">第一层结点查找长度分别为2,3,4,5,..n+1</span><br><span class="line">第二层结点查找长度分别为2x3,2x4,2x5...2x(n+2)</span><br><span class="line">第三层.. 4x4,4x5,4x6...4x(n+3)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272220088.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSearch</span><span class="params">(SSTable ST,x,<span class="type">int</span> begin,<span class="type">int</span> end)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;=end)&#123;</span><br><span class="line"><span class="type">int</span> mid = (begin+end)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(ST.data[mid]=x)&#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ST.data[mid]&lt;x)&#123;</span><br><span class="line">end = mid<span class="number">-1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">begin = mid+<span class="number">1</span>;</span><br><span class="line">Bsearch(ST,x,begin,end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272249235.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_swap</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ST.data[i]!=x&amp;&amp;i&lt;ST.length)&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=ST.length)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Swap(ST.data[i],ST.data[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line">LinkList <span class="title function_">Search_swap</span><span class="params">(Linklist &amp;L,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">LinkList p,q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(L-&gt;next.data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> L-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(p=L;p-&gt;next-&gt;next.data!=x;p=p-&gt;next)&#123;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q=p-&gt;next;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line">q-&gt;next=q-&gt;next-&gt;next;</span><br><span class="line">p-&gt;next-&gt;next=q;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272312095.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305272350405.png" alt="image.png"></p><h3 id="平衡二叉树习题"><a href="#平衡二叉树习题" class="headerlink" title="平衡二叉树习题"></a>平衡二叉树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.查找失败则插入所查找的结点，查找失败说明找到结点的右边或左边已经无节点才导致失败</span><br><span class="line">那么，直接在空的位置上插入结点，并不会导致树的分裂和组合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282215672.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">完全二叉树才是二叉排序树的最理想情况</span><br><span class="line">完全二叉树求深度以满二叉树为模板</span><br><span class="line">，根据等比数列求和 --&gt; n=2^h -1 --&gt;这是n完全沾满第h层的时候</span><br><span class="line">但是第h层没有完全沾满时，数的高度同样是h,这样就需要对log2(n+1)向上取整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282251776.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据平衡二叉树，高度为h所需最少结点数的关系，解决此题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282321303.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树任意结点的左右子树高度只差不超过1</span><br><span class="line">H=1, n=1</span><br><span class="line">H=2, h左=1，h右=0 ; 1+1+0=2</span><br><span class="line">H=3, h左=2，h右=1 ; 1+2+1=4 --&gt;h左 根据前面H=2求得的n，h右 根据前面H=1求得的n</span><br><span class="line">...</span><br><span class="line">递推</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291911448.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">平衡二叉树RL 型调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292125948.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">平衡因子均为1--&gt;用最少的结点构成高度最高的平衡二叉树</span><br><span class="line">与之前那题一模一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292137300.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">全程用到RR的情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292146525.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292157774.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292205741.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.平衡二叉树的调整，需要调整的是插入后导致的最小的不平衡子树</span><br><span class="line">2.这题是RL型，RL是指，新插入的导致二叉树不平衡的结点是相对于最小不平衡子树的头号结点的位置，是先往右，再往左</span><br><span class="line">3.相对应的树的调整相当于打方向盘，从后往前考虑，先是往左偏了，就要右旋。接着考虑上层往右偏了，就要左旋</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292214226.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直到一个二叉排序树的先序遍历序列。--&gt;数字从小到大就是中序遍历序列--&gt;结合中序遍历序列和先序遍历序列，就能完整的画出一颗二叉排序树--&gt;在根据树来进行分析</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292226147.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//定义一个栈用于存放结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsOrderTree</span><span class="params">(BiTree T)</span>&#123;</span><br><span class="line">Stack S;</span><br><span class="line">Push(S,T);</span><br><span class="line">BiTree Q;</span><br><span class="line"><span class="keyword">while</span>(!IsEmpty(S))&#123;</span><br><span class="line">Q=Pop(S);</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;lift-&gt;data&lt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;lift);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;right-&gt;data&gt;Q-&gt;data)&#123;</span><br><span class="line">Push(S,Q-&gt;right);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292251685.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树求指定结点所在的树的层次</span></span><br><span class="line"><span class="comment">//思路是，通过二叉排序树查找算法，查找指定结点，查找的次数就是结点所在层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BS_Search_high</span><span class="params">(BSTree T,<span class="type">int</span> x)</span>&#123;</span><br><span class="line">BSTree Q = T;</span><br><span class="line"><span class="type">int</span> count=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(Q)&#123;</span><br><span class="line"><span class="keyword">if</span>(Q-&gt;data=x)&#123;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(Q-&gt;data&lt;x)&#123;</span><br><span class="line">Q=Q-&gt;left;</span><br><span class="line">count++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Q=Q-&gt;right;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//没找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301546891.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个二叉树的平衡标记balance(1,表示平衡；0表示不平衡)</span></span><br><span class="line"><span class="comment">//h为二叉树的高度，</span></span><br><span class="line"><span class="comment">//如果树空，高度为0，如果树只有一个结点高度为1，</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Jude_AVL</span><span class="params">(BiTree T,<span class="type">int</span> &amp;balance,<span class="type">int</span> &amp;h)</span>&#123;</span><br><span class="line"><span class="type">int</span> bl=<span class="number">0</span>,br=<span class="number">0</span>,hl=<span class="number">0</span>,hr=<span class="number">0</span>;  <span class="comment">//左右子树的平衡标记和高度</span></span><br><span class="line"><span class="keyword">if</span>(bt==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">0</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lichild==<span class="literal">NULL</span>&amp;&amp;bt-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">h=<span class="number">1</span>;</span><br><span class="line">balance=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">Judge_AVL(bt-&gt;lchild,bl,hl);  <span class="comment">//递归判断左子树</span></span><br><span class="line">Judge_AVL(bt-&gt;rchild,br,hr);  <span class="comment">//递归判断右子树</span></span><br><span class="line">h=(h1&gt;h2?h1:h2)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(h1-h2)&lt;<span class="number">2</span>)&#123;    <span class="comment">//若树的高度差的绝对值&lt;2,则看左右子树是否平衡</span></span><br><span class="line">balance=bl&amp;&amp;br;    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">balance=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301559886.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从大到小输出--&gt;中序遍历稍作修改</span><br><span class="line">2.输出的值不小于k，对中间结点输出的时候，做一个判断</span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_dechute</span><span class="params">(BSTree T)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;right); <span class="comment">//先大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;data&gt;=k)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,T-&gt;data);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;left!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">print_dechute(T-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301637025.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这题思路是</span><br><span class="line">在每个结点里面保存，以当前结点为根的子树中总共有多少个结点</span><br><span class="line">假设这棵树的根节点是T</span><br><span class="line">一下几种情况：</span><br><span class="line">1.T-&gt;lchild==NULL </span><br><span class="line">- 若T-&gt;rchild非空且k=1,则T就是滴k小节点</span><br><span class="line">- 若T-&gt;rchild非空且k!=1,则第k小元素在T的右子树上</span><br><span class="line">2.T-&gt;lchild!==NULL</span><br><span class="line">- T-&gt;lchild-&gt;count=k-1,则T就是第k小元素</span><br><span class="line">- T-&gt;lchild-&gt;count&gt;k-1,则第k小元素必在左子树，继续到左子树中去找</span><br><span class="line">- T-&gt;lchild-&gt;count&lt;k-1,则第k小元素必在右子树，继续搜索右子树，寻</span><br><span class="line">   找第k-(T-&gt;lchild-&gt;count+1)小的元素</span><br><span class="line"></span><br><span class="line">代码如下</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">BSTree <span class="title function_">Search_Small</span><span class="params">(BSTree T,<span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">1</span>||k&gt;T-&gt;count)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count==k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&gt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;lchild,k<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(T-&gt;lchild-&gt;count&lt;k<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> Search_Small(T-&gt;rchild,k-(T-&gt;lchild-&gt;count+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305301709526.png" alt="image.png"></p><h3 id="红黑树习题"><a href="#红黑树习题" class="headerlink" title="红黑树习题"></a>红黑树习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">熟悉红黑树的性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291920684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">D选项：根据两个性质解答</span><br><span class="line">1.红黑树对于每个结点，到叶子结点的任意一条路径上的黑结点的个数相同</span><br><span class="line">2.红结点不能与红结点相邻</span><br><span class="line">所以红黑树的单条从根结点到叶子结点的路径上的黑色结点个数是确定的设为x</span><br><span class="line">假设出发结点是black:</span><br><span class="line">- 高度最小的子树，全部位黑色结点，高度为 x-1</span><br><span class="line">- 高度最高的子树，黑色结点与红色结点相间出现</span><br><span class="line">- 子树原结点是black--&gt; x-1 + (x-2)=2x-3</span><br><span class="line">- 子树原结点是red --&gt; (x-1)+(x-1)=2x-2</span><br><span class="line">假设出发结点是red:</span><br><span class="line">- 高度最小子树，x</span><br><span class="line">- 高度最大子树，2x-1</span><br><span class="line">左右子树高度之比都小于2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305291937703.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.红黑树是自平衡的树，但不是平衡二叉树</span><br><span class="line">B.红黑树所有结点都是黑色，那么它一定是满二叉树因为从根节点出发，到叶子结点，黑色结点数是一样的</span><br><span class="line">C.红色结点孩子结点可以全为黑</span><br><span class="line">D.一看就是错的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292029968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">红黑树的插入操作</span><br><span class="line">1.插入的结点始终一致染成红色</span><br><span class="line">2.如果违反了不红红，则看叔叔的颜色</span><br><span class="line">3.黑叔，影响不向上传递，只需先按照平衡二叉树旋转，然后将旋转后的爷爷结点染黑</span><br><span class="line">4.红叔，影响向上传递，只需向先将爷爷结点染红，儿子染黑，然后爷爷结点作为新插入结点继续向上判断</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292043633.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305292116716.png" alt="image.png"></p><h3 id="B、B-树习题"><a href="#B、B-树习题" class="headerlink" title="B、B+树习题"></a>B、B+树习题</h3><blockquote><p><em>B树与B+树区别</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231329042.png" alt="image.png"></p><p><em>m阶B 树，对于根节点的子树，子树2~m；除了根节点的非叶子结点，子树<strong>⌈m/2⌉~m</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231335734.png" alt="image.png"></p></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><em>注1：通常来说，408算法题不会限制你具体使用哪种算法<br>注2：408算法题通常按复杂度给分，复杂度越低，给分越高<br>注3：若题目没有特别要求，答题时回答“平均复杂度”即可</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231132014.png" alt="image.png"><br><strong><em>快速排序最实用，代码简，时间复杂度低；相比堆排序代码更简洁，、相比2路归并，空间复杂度小</em></strong></p><h2 id="课后习题-12"><a href="#课后习题-12" class="headerlink" title="课后习题"></a>课后习题</h2><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.拓扑排序是将有向图中所有结点排成一个线性序列，虽然也是在内存中进行的，但它不属于我们这里所提到的内部排序范畴，也不满足前面排序的定义。</span><br><span class="line"></span><br><span class="line">2.排序算法的稳定性是指? 经过排序后，能使关键字相同的元素保持原顺序中的相对位置不变</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">加入需要排序的数组是arr=[1,0,6,3,2,7,5]</span><br><span class="line">需要两个下标指针i、j</span><br><span class="line">初始时，只有第一个元素有序，那i从 1开始，j=i-1</span><br><span class="line"></span><br><span class="line">arr=[  1,  0,  6,  3,  2,  7,  5]</span><br><span class="line">       j   i</span><br><span class="line">先将arr[i]=temp存着</span><br><span class="line">如果arr[j] &gt; arr[i],arr[j]往后移一位，arr[j+1]=arr[j],j--;</span><br><span class="line"></span><br><span class="line">arr[  1,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1   </span><br><span class="line">      </span><br><span class="line">arr[j+1]=temp</span><br><span class="line"></span><br><span class="line">arr[  0,  1,  6,  3,  2,  7,  5]</span><br><span class="line">    j     i </span><br><span class="line">     j+1    </span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(ElemType *str,<span class="type">int</span> n)</span>&#123; <span class="comment">//n为数组长度 </span></span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        temp=str[i];<span class="comment">//暂时存目标元素  </span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;str[j]&gt;temp)&#123;<span class="comment">//将比插入的数大的全部往后移一格  </span></span><br><span class="line">            str[j+<span class="number">1</span>]=str[j];  </span><br><span class="line">            j--;</span><br><span class="line">        &#125;  </span><br><span class="line">        str[j+<span class="number">1</span>]=temp;<span class="comment">//j来到了插入位置，将temp插入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">在最好情况下，表中元素已经有序，此时每插入一个元素，都只需比较一次而不用</span><br><span class="line">移动元素，</span><br><span class="line">因而时间复杂度为O（n）.</span><br><span class="line">在最坏情况下，表中元素顺序刚好与排序结果中的元素顺序相反（逆序），总的比较次数达</span><br><span class="line">到最大，总的移动次数也达到最大，总的时间复杂度为O（n^2）.</span><br><span class="line">平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的平均值作为</span><br><span class="line">平均情况下的时间复杂度，总的比较次数与总的移动次数均约为n^2/4。</span><br><span class="line">稳定性：</span><br><span class="line">由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相对位置</span><br><span class="line">发生变化的情况，即直接插入排序是一个稳定的排序方法</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308232051991.png" alt="image.png"></p><h3 id="课后习题-13"><a href="#课后习题-13" class="headerlink" title="课后习题"></a>课后习题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在待排序的元素序列基本有序的前提下，效率最高的排序方法是（）。</span><br><span class="line">A.直接插入排序B.简单选择排序C.快速排序</span><br><span class="line">D.归并排序</span><br><span class="line"></span><br><span class="line">解析:待排序序列基本有序，只需比较n-1次时间复杂度O(n),达到效率最高</span><br></pre></td></tr></table></figure><h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">从后往前(或从前往后)两两比较相邻元素的值，如果逆序，就交换，直到将最小元素，交换到最上层</span><br><span class="line">第1轮，比较n个元素，比较n-1次，找到最小的，放到第一位</span><br><span class="line">第2轮，比较n-1个元素，比较n-2次，找到剩余中最小，放到第二位</span><br><span class="line">...</span><br><span class="line">比较n-1轮</span><br><span class="line"></span><br><span class="line">n-1 + n-2 + ...+ 3 + 2 + 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(ElemType arr[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="type">bool</span> flag;  <span class="comment">//用来标记是否发生了交换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环需要比较n-1次  </span></span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//内层循环  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);  </span><br><span class="line">                flag=<span class="literal">true</span>;<span class="comment">//有交换就返回true  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;<span class="comment">//如果这一趟没有比较，直接结束无须比较  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line">最好情况：数组本身有序，那么比较第一轮比较了n-1次后，标记返回false，退出排序，O(n)</span><br><span class="line">最坏情况：O(n^2)</span><br><span class="line">平均：O(n^2)</span><br><span class="line">空间复杂度：O(1)</span><br><span class="line">稳定性：由于i&gt;j且A[i]=A[j]时，不会发生交换，因此冒泡排序是一种稳定的排序方法。</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个顺序表</span><br><span class="line">以第一个数为基数，赋值给mid存起来，此时，基数的位置看做为空</span><br><span class="line">定义两个指针i j</span><br><span class="line">i从左往右找比3大的数，i停止</span><br><span class="line">j从右往左找比3小的数，j停止</span><br><span class="line">然后i j 对应的数完成一次交换，i j 继续前进</span><br><span class="line">循环..直到ij相遇i==j</span><br><span class="line">arr[i]=mid</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(ElemTypeA[],intlow，inthigh）&#123; <span class="comment">//一趟划分</span></span></span><br><span class="line"><span class="params">ElemType mid=A[<span class="number">1</span>ow]：<span class="comment">//将当前表中第一个元素设为枢轴，对表进行划分</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high）&#123; <span class="comment">//循环跳出条件</span></span></span><br><span class="line"><span class="params"><span class="keyword">while</span>（low&lt;high&amp;sA[high]&gt;=mid)</span></span><br><span class="line">--high；</span><br><span class="line">A[low]=A[high]； <span class="comment">//将比框轴小的元素移动到左端</span></span><br><span class="line"><span class="keyword">while</span>(low&lt;high&amp;sA[low]&lt;=mid)</span><br><span class="line">++<span class="number">1</span>ow；</span><br><span class="line">A[high]=A[low] <span class="comment">//将比框轴大的元素移动到右端</span></span><br><span class="line">&#125;</span><br><span class="line">A[low]=mid <span class="comment">//框轴元素存放到最终位置</span></span><br><span class="line"><span class="keyword">return</span> low； <span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序方法  </span></span><br><span class="line"><span class="type">void</span> quick_sort(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;<span class="comment">//low high用来限定分割的范围  </span></span><br><span class="line">        <span class="type">int</span> postion = partition(str, low, high);<span class="comment">//partition方法是核心方法，每一次分割的方法  </span></span><br><span class="line">        quick_sort(str, low, postion - <span class="number">1</span>);<span class="comment">//递归左边的数组  </span></span><br><span class="line">        quick_sort(str, postion + <span class="number">1</span>, high);<span class="comment">//递归数组右边  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645079.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231146875.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308231150945.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度</span><br><span class="line">最好情况：每次分割都能平均分成两份则2^x=n; x=log2 n;每轮分割，所有子数组</span><br><span class="line">的比较总次数n-1次</span><br><span class="line">所以是(n-1)log2 n,O(n)=nlog2 n</span><br><span class="line">平均状态：接近最好情况O(n)=nlog2 n</span><br><span class="line">最差情况：如果数组本来就有序，那么每次都无法一次切一半，变成从1到n-1都要</span><br><span class="line">分割一次,每轮分割依旧比较n-1次，那么O(n)=n^2</span><br><span class="line">空间复杂度</span><br><span class="line">容量与递归的最大深度一致，最好情况log2 n ;最坏n-1</span><br><span class="line"></span><br><span class="line">稳定性：</span><br><span class="line">在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换</span><br><span class="line">到左端区间后，它们的相对位置会发生变化，即快速排序是一种不稳定的排序方</span><br><span class="line">法。例如，表L=&#123;3,2,2&#125;,经过一趟排序后L=&#123;2,2,3&#125;,最终排序序列也是L=</span><br><span class="line">&#123;2,2,3&#125;,显然，2与2的相对次序已发生了变化。</span><br><span class="line"></span><br><span class="line">快速排序时内部排序算法中平均性能最优的一种算法</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组设置两个指针</span><br><span class="line">min j</span><br><span class="line">第一轮：</span><br><span class="line">min指向第1个数据，j指向min后一个,j移动寻找比min小的，然后min=j，j遍历到最后，最终交换arr[i]和arr[min]</span><br><span class="line"></span><br><span class="line">第二轮：</span><br><span class="line">min指向第2个数据，重复上述步骤</span><br><span class="line"></span><br><span class="line">...重复n-1趟</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(ElemType A[],<span class="type">int</span> n)</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;   <span class="comment">//一共进行n-1趟</span></span></span><br><span class="line"><span class="params"><span class="type">int</span> min=i;        <span class="comment">//记录最小元素位置  </span></span></span><br><span class="line"><span class="params"><span class="keyword">for</span>(<span class="type">int</span> j=i+l;j&lt;n;j++)&#123;      <span class="comment">//在A[i.n-1]中选择最小的元素</span></span></span><br><span class="line"><span class="params"><span class="keyword">if</span> (A[j]&lt;A(min])&#123;  </span></span><br><span class="line"><span class="params">min=j;              <span class="comment">//更新最小元素位置</span></span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br><span class="line"><span class="params">swap(A(i],A[min]);  </span></span><br><span class="line"><span class="params">&#125; </span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645595.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：第一轮比较n-1次 第二轮比较n-2次 ...最后一次比较1次</span><br><span class="line">n-1 + n-2 + n-3 +...+3 + 2 + 1=(n-1)n/2  所以是O(n^2)</span><br><span class="line">最好最坏都是O(n^2)</span><br><span class="line">稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同</span><br><span class="line">关键字元素的相对位置发生改变。例如，表L=&#123;2,2,1&#125;,经过一趟排序后L=&#123;1,2,2&#125;,最终排</span><br><span class="line">序序列也是L=&#123;1,2,2&#125;,显然，2与2的相对次序已发生变化。因此，简单选择排序是一种不稳</span><br><span class="line">定的排序方法</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">引入大根堆的概念：</span><br><span class="line">对于一颗二叉树，任意结点的数值要比左右子树的所有结点的值都大</span><br><span class="line">这样一来，根节点成为了最大的结点</span><br><span class="line">既然大根堆的根节点最大，就不断调整为大根堆：</span><br><span class="line">对非叶子结点进行检测，判断这些非根节点是否大于左右</span><br><span class="line">非叶子结点也就是--&gt;叶子结点的父节点--&gt;i/2向下取整</span><br><span class="line"></span><br><span class="line">例如下面这个例子：</span><br><span class="line">想要调整为大根堆，从8/2=4号结点(非终端结点)开始调整,</span><br><span class="line">然后3号结点78,接着2号结点17,最后1号结点53</span><br><span class="line">这样从后往前调整--&gt;若元素互换破坏了下一级的堆--&gt;则采用相同的方法继续往下调整</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312317433.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305312340910.png" alt="image.png"></p><p>1.实现逻辑<br> <code>1.建立大根堆</code> :<br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">建堆</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>把所有非终端结点都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整</li><li>检查当前结点是否满足龈≥左、右若不满足，将当前结点与更大的一个孩子互换</li><li>若元素互换破坏了下一级的堆，则采用相同的方法继续往下调整(<code>小元素不断下坠</code>)</li><li>一般从<code>最底层的分支结点开始调整</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011645508.png" alt="image.png"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BuildMaxHeap</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(i=len/<span class="number">2</span>,i&gt;<span class="number">0</span>,i--)&#123;</span><br><span class="line">HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadAdjust</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">A[<span class="number">0</span>]=A[k];</span><br><span class="line"><span class="keyword">for</span>(son;son&lt;=len;son*=<span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(son&lt;length&amp;&amp;A[son]&lt;A[son+<span class="number">1</span>])&#123; <span class="comment">//son&lt;len == son+1&lt;=len</span></span><br><span class="line">son++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(A[k]&lt;A[son])&#123;</span><br><span class="line">A[k]=A[son];</span><br><span class="line">k=son;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A[k]=A[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646852.png" alt="image.png"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p><code>2.交换堆顶元素与最后一个元素.并将小元素下坠,恢复成大根堆</code><br><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">排序过程</button></li><li class="tab"><button type="button" data-href="#test1-2">时间复杂度O(nlog2n)</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><ul><li>交换顶部元素和末尾元素</li><li>小元素下坠</li><li>排除末尾最大元素，<code>len-1</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646651.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010950043.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306010952356.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[A],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">BuildMaxHeap(A,len);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;i--)&#123;</span><br><span class="line">swap(A[<span class="number">1</span>],A[i]);</span><br><span class="line">HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><ul><li>根节点最多才下坠<code>h-1</code>次，且没下坠一次最多比较2次，根结点最多比较2(h-1)次 时间复杂度 <code>O(h)</code></li><li>时间复杂度,其他结点<code>&lt;</code>根节点 , 假设每个都是 O(h),公有n个结点<code>O(nh)</code></li><li>h高度=log2n ，总时间复杂度<code>O(nh)=O(nlog2n)</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011646722.png" alt="image.png"></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div></p><p>2.算法稳定性</p><ul><li>堆排序<code>不稳定</code></li><li>假设只有<code>1、a1、a2</code>当左右子节点相同时a1=a2，会优先考虑左结点和根结点交换</li><li>排序时，交换根结点与最后结点，使得位序在前的a1跑到a2后面，—&gt;<code>1、a2、a1</code> 因此是不稳定的 </li></ul><h2 id="堆的插入和删除"><a href="#堆的插入和删除" class="headerlink" title="堆的插入和删除"></a>堆的插入和删除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆的插入：</span><br><span class="line">1.插入的新元素放到表尾，最末尾的结点</span><br><span class="line">2.与父节点对比，对于小根堆而言，如果新元素比父结点更小，二者互换</span><br><span class="line">3.新元素一路上升,直至无法继续上升为止</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011005919.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">堆的删除：</span><br><span class="line">1.被删除的元素空出来的位置，用堆底部的元素替代</span><br><span class="line">2.最后让该元素不断下坠，直至无法下坠</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011009010.png" alt="image.png"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><hr><h3 id="什么是归并？"><a href="#什么是归并？" class="headerlink" title="什么是归并？"></a>什么是归并？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">归并两个有序数组</span><br><span class="line">定义指针i指向有序数组1，指针j指向有序数组2,指针k指向要放入的数组</span><br><span class="line">对比i,j所指向的元素，选择更小的一个放入k中</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011017728.png" alt="image.png"></p><h3 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4路归并，就是归并4个数组</span><br><span class="line">根据规律发现，m路归并，每次选出一个元素，最少需要比较关键字m-1次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011022249.png" alt="image.png"></p><h3 id="单个归并代码实现"><a href="#单个归并代码实现" class="headerlink" title="单个归并代码实现"></a>单个归并代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge的时候，需要三个指针,i指向A的有序的前半段，j指向A有序的后半段，k指向放入的数组的当前位置</span><br><span class="line"></span><br><span class="line">1、将A[] 元素全部复制放到B[] ，i ,j分别对应low\mid+1起始位置，k=i.</span><br><span class="line"></span><br><span class="line">2、i j 先比较，小的放入A[k],i++,j不动，k++</span><br><span class="line"></span><br><span class="line">3、直到有剩余，i到头了，j还没到头;或者j到头了，i还没到头。while循环将剩余的全部放入,k随着++</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B=(<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high,<span class="type">int</span> mid)</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k;</span><br><span class="line"><span class="keyword">for</span>(k=low;k&lt;high;k++)&#123;</span><br><span class="line">B[k]=A[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(B[i]&lt;=B[j])&#123;</span><br><span class="line">A[k]=B[i];</span><br><span class="line">i++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">A[k]=B[j];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">A[k++]=B[i++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(j&lt;=high)&#123;</span><br><span class="line">A[k++]=B[j++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011030720.png" alt="image.png"></p><h3 id="归并排序完整代码"><a href="#归并排序完整代码" class="headerlink" title="归并排序完整代码"></a>归并排序完整代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(low&lt;=high)&#123;</span><br><span class="line"><span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">MergeSort(A,low,mid);  <span class="comment">//不断递归的左右划分</span></span><br><span class="line">MergeSort(A,mid+<span class="number">1</span>,high);</span><br><span class="line">Merge(A,low,mid,high); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011043727.png" alt="image.png"></p><h3 id="归并排序效率分析"><a href="#归并排序效率分析" class="headerlink" title="归并排序效率分析"></a>归并排序效率分析</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">递归调用栈的所占的空间不会超过log2 n 数量级；运用了额外的数组B空间O(n)</span><br><span class="line">相加O(log2 n)+O(n);舍去小的--&gt; O(n)</span><br><span class="line">时间复杂度：</span><br><span class="line">每一层归并时间复杂度O(n),共h=log2 n 层，时间复杂度O(nlog2 n)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011048307.png" alt="image.png"></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="基数排序算法"><a href="#基数排序算法" class="headerlink" title="基数排序算法"></a>基数排序算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">基数排序：</span><br><span class="line">递增排序：</span><br><span class="line">1.分别对一组数据根据他的的个位、十位、百位、分别先后进行排序</span><br><span class="line">2.其中个位为最次位关键字(对整体的值影响最小)，百为为最主要关键字(对</span><br><span class="line">值影响最大)</span><br><span class="line">3.先根据对权重最低的个位对数进行分配收集，然后在第一次排好的序列之</span><br><span class="line">上，再根据十位进行分配收集，最后是百位--&gt;最红会得到一个有序序列</span><br><span class="line">递减排序：</span><br><span class="line">步骤与递增相同，不过是先对高位进行分配收集，后对低位进行分配和收集</span><br><span class="line">注意：</span><br><span class="line">基数排序不是基于“比较”的排序算法，而是根据相同位数字的不同进行分类规整然</span><br><span class="line">后收集的过程，只是这个分类收集的顺序导致了最后的有序</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011400022.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011351923.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011404664.png" alt="image.png"></p><h3 id="基数排序算法效率分析"><a href="#基数排序算法效率分析" class="headerlink" title="基数排序算法效率分析"></a>基数排序算法效率分析</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度：</span><br><span class="line">初始序列为一串链表，定义了一个链式队列的数组用来分配各个数字，由于数组里</span><br><span class="line">只是存放队头指针+队尾指针，实际所需的空间只有数组的10个空间，里面的队列是</span><br><span class="line">在原有链表序列的基础上修改指针指向得到，并没有消耗多余的空间。所以空间复</span><br><span class="line">杂度O(r)--&gt;r是数字可能出现的种类0~9</span><br><span class="line">时间复杂度：</span><br><span class="line">一趟分配n个O(n);一次收集扫描r个队列O(r) --&gt;因为只需将队列整个拆下来拼接</span><br><span class="line">总共分配收集3趟,设趟数为d</span><br><span class="line">时间复杂度 O(d(n+r))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011429831.png" alt="image.png"></p><h3 id="基数排序应用"><a href="#基数排序应用" class="headerlink" title="基数排序应用"></a>基数排序应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">基数排序适用：</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011433515.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306011435864.png" alt="image.png"></p><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">什么是外部排序？</span><br><span class="line">对磁盘(外存)中的数据进行排序，由于外存容量很大，但内存容量很小，要对外存中所有</span><br><span class="line">数据进行啊排序的话，内存放不下</span><br></pre></td></tr></table></figure><h1 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h1><h2 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041049305.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041048131.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">题目转化--&gt;4个结点的二叉树有多少种形状，然后可以将a b c d按照先序遍历填进二叉树里(填法唯一)</span><br><span class="line">(每种形状必定能按照一定顺序填 a b c d 使得先序遍历出来次序符合要求)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041051053.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为1入栈马上出栈，接着2入栈马上出栈，所以只看后面三个数的出栈序列</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305041058998.png" alt="image.png"></p><h2 id="并查集-2022新增考点"><a href="#并查集-2022新增考点" class="headerlink" title="并查集(2022新增考点)"></a>并查集(2022新增考点)</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008040.png" alt="image.png"></p><p><code>Find查操作</code>：如何查到一个元素到底属于哪个集合？</p><ul><li>从指定元素出发，一路向北，找到根节点，判断根节点是否相同 <img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008041.png" alt="image.png"></li></ul><p><code>Union并操作</code>：如何把两个集合合并为一个集合？</p><ul><li>让一棵树成为另一棵树的子树即可<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008042.png" alt="image.png"></li></ul><p><code>双亲表示法</code>：便于找到父节点(查)，便于合并两棵树(并)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008043.png" alt="image.png"></p><blockquote><p><code>代码实现</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//数组元素结构体定义，也就是结点定义</span></span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  <span class="comment">//树的定义</span></span><br><span class="line">PTNode node[MaxSize];</span><br><span class="line"><span class="type">int</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Size 20</span></span><br><span class="line"><span class="type">int</span> UFSets[Size]; <span class="comment">//集合元素数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size;i++)&#123;</span><br><span class="line">S[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008044.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find查操作，找到x所属集合</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">x=S[x]; <span class="comment">//找父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏：O(n)，树高=n,find时间复杂度与树高相关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//Union并操作，将两个集合合并为一个</span></span><br><span class="line"><span class="comment">void Union(int S[],int root1,int root2)&#123;</span></span><br><span class="line"><span class="comment">if(root2==root1)&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">S[root2]=root1;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//`Union优化`：小树合并到大树上(用树结点绝对值表示)，避免高度增加</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> root1,<span class="type">int</span> root2)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root2==root1)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S[root1]&gt;S[root2])&#123; </span><br><span class="line">S[root1] += S[root2];</span><br><span class="line">S[root2]=root1;  <span class="comment">//小树合并到大树</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">S[root2] += S[root1];</span><br><span class="line">S[root1] = root2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化后，树高&lt;=log2n ,find最坏时间复杂度O(log2n)</span></span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008045.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008046.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008047.png" alt="image.png"></p></blockquote><p><code>总结</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008048.png" alt="image.png"></p><p><code>find优化+Union优化</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008049.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062008050.png" alt="image.png"></p><h2 id="课后习题-14"><a href="#课后习题-14" class="headerlink" title="课后习题"></a>课后习题</h2><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305062010458.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高数基础</title>
      <link href="/undefined/95b2ede4.html"/>
      <url>/undefined/95b2ede4.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础扫盲"><a href="#基础扫盲" class="headerlink" title="基础扫盲"></a>基础扫盲</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181104621.jpg" alt="ai绘画 动漫女孩 粉色长发 水手服 高清电脑壁纸_彼岸壁纸.jpg"></p><h2 id="偏导数存在-连续-可微-偏导数连续关系"><a href="#偏导数存在-连续-可微-偏导数连续关系" class="headerlink" title="偏导数存在-连续-可微-偏导数连续关系"></a>偏导数存在-连续-可微-偏导数连续关系</h2><details>  <summary>点击展开</summary>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续(x.y)</span><br><span class="line">一阶偏导数连续的意思是，该函数的图像是一条连续的线，无论从哪个方向接近某一点，偏导数的</span><br><span class="line">极限都存在且相等。也就是说，偏导数函数在每一点都满足连续性的定义。如果一个函数在某个区</span><br><span class="line">域内的所有点都有一阶连续偏导数，那么这个函数就是可微的(x、y方向的偏导数都连续)</span><br><span class="line">可微(x.y其他任意方向)</span><br><span class="line">是指曲面某一个点处存在一个切面，该点的各个方向的偏导数都存在(x、y和其他任意方向)</span><br><span class="line">偏导数存在(x.y)</span><br><span class="line">偏导数存在的意思是，一个多变量函数的偏导数，就是它关于其中一个变量的导数而保持其他变量</span><br><span class="line">恒定。也就是说，如果一个多元函数在某一点沿着某个方向的偏增量与该方向的增量之比当增量趋</span><br><span class="line">于零时的极限存在，那么这个极限值就是该函数在该点沿着该方向的偏导数(对于二元函数来说</span><br><span class="line">变量只有x.y那么要xy方向都存在偏导数，那么偏导数存在，要考虑两个变量)</span><br><span class="line">函数连续</span><br><span class="line">就是说二元函数所形成的的曲面是连续的没有断口，判断方法--&gt;该点函数值是否等于函数极限值</span><br><span class="line">等于就是连续</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">综上可以得到</span><br><span class="line"></span><br><span class="line">偏导数连续</span><br><span class="line">=&gt;可微</span><br><span class="line">=&gt;连续</span><br><span class="line">=&gt;偏导数存在</span><br></pre></td></tr></table></figure></details><div class="row">    <embed src="/pdf/基础扫盲题.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="三大核心计算"><a href="#三大核心计算" class="headerlink" title="三大核心计算"></a>三大核心计算</h1><h2 id="函数求极限"><a href="#函数求极限" class="headerlink" title="函数求极限"></a>函数求极限</h2><h3 id="无穷小的比较-泰勒公式-极限"><a href="#无穷小的比较-泰勒公式-极限" class="headerlink" title="无穷小的比较-泰勒公式-极限"></a>无穷小的比较-泰勒公式-极限</h3><div class="row">    <embed src="/pdf/无穷小的比较-泰勒公式-极限.pdf" width="100%" height="550" type="application/pdf"></div><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><div class="row">    <embed src="/pdf/习题.pdf" width="100%" height="550" type="application/pdf"></div><h2 id="函数与求导"><a href="#函数与求导" class="headerlink" title="函数与求导"></a>函数与求导</h2><h3 id="导数的定义"><a href="#导数的定义" class="headerlink" title="导数的定义"></a>导数的定义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135693.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051135205.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051139974.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051146278.png" alt="image.png"></p><h3 id="导数的几何意义"><a href="#导数的几何意义" class="headerlink" title="导数的几何意义"></a>导数的几何意义</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051150223.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051229079.png" alt="image.png"></p><h3 id="各类函数求导"><a href="#各类函数求导" class="headerlink" title="各类函数求导"></a>各类函数求导</h3><h4 id="基本求导公式与四则运算"><a href="#基本求导公式与四则运算" class="headerlink" title="基本求导公式与四则运算"></a>基本求导公式与四则运算</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051700546.png" alt="image.png"></p><h4 id="复合函数求导"><a href="#复合函数求导" class="headerlink" title="复合函数求导"></a>复合函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051701696.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708912.png" alt="image.png"></p><h4 id="隐函数求导"><a href="#隐函数求导" class="headerlink" title="隐函数求导"></a>隐函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051708838.png" alt="image.png"></p><h4 id="参数方程求导"><a href="#参数方程求导" class="headerlink" title="参数方程求导"></a>参数方程求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051747241.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051757501.png" alt="image.png"></p><h4 id="反函数求导"><a href="#反函数求导" class="headerlink" title="反函数求导"></a>反函数求导</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051804246.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051810310.png" alt="image.png"></p><h4 id="高阶导数求导"><a href="#高阶导数求导" class="headerlink" title="高阶导数求导"></a>高阶导数求导</h4><h5 id="找规律"><a href="#找规律" class="headerlink" title="找规律"></a>找规律</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821928.png" alt="image.png"></p><h5 id="莱布尼茨公式"><a href="#莱布尼茨公式" class="headerlink" title="莱布尼茨公式"></a>莱布尼茨公式</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304051821393.png" alt="image.png"></p><h5 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h5><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304052214444.png" alt="image.png"></p><h2 id="不定积分的计算"><a href="#不定积分的计算" class="headerlink" title="不定积分的计算"></a>不定积分的计算</h2><h3 id="四大积分方法"><a href="#四大积分方法" class="headerlink" title="四大积分方法"></a>四大积分方法</h3><hr><h4 id="基本积分公式"><a href="#基本积分公式" class="headerlink" title="基本积分公式"></a>基本积分公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081717182.png" alt="image.png"></p><h4 id="第一类换元法-凑微分"><a href="#第一类换元法-凑微分" class="headerlink" title="第一类换元法(凑微分)"></a>第一类换元法(凑微分)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.两部分相乘，其中一项的导数是否与另外一项有关</span><br><span class="line">2.提到dx里面</span><br><span class="line">3.换元整体求积分</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081709362.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304081727642.png" alt="image.png"></p><h4 id="第二类换元法-去根号"><a href="#第二类换元法-去根号" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根号下x是一次，整体换成t</span><br><span class="line">根号下x是二次，三角换元</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082024835.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082211375.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304082333064.png" alt="image.png"></p><h4 id="第三类分部积分法"><a href="#第三类分部积分法" class="headerlink" title="第三类分部积分法"></a>第三类分部积分法</h4><hr><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091242072.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091447042.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091457248.png" alt="image.png"></p><h4 id="第四类有理函数积分"><a href="#第四类有理函数积分" class="headerlink" title="第四类有理函数积分"></a>第四类有理函数积分</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假分式：分子幂次比分母幂次高--&gt;一定可以写成`多项式+真分式`</span><br><span class="line">真分式：分子的幂次比分母低--&gt;例如 </span><br><span class="line">?/(1)(2) --&gt; a/(1) + b/(2)</span><br><span class="line">?/(1)(2)(3)--&gt;a/(1) + b/(2) + c/(3); </span><br><span class="line">?/(1)(2)^2 --&gt; a/(1) + b/(2) + c/(2)^2</span><br><span class="line">其中(1)(2)(3)都是x的一次多项式</span><br><span class="line">多项式的除法如下：</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091523975.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091533686.png" alt="image.png"><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091544726.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091550885.png" alt="image.png"></p><h3 id="三角有理式积分"><a href="#三角有理式积分" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">奇数次凑微分</span><br><span class="line">偶数次降幂</span><br><span class="line">化为同倍角</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091623849.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091632455.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091637269.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304091639418.png" alt="image.png"></p><h2 id="定积分的计算"><a href="#定积分的计算" class="headerlink" title="定积分的计算"></a>定积分的计算</h2><h3 id="定积分的性质"><a href="#定积分的性质" class="headerlink" title="定积分的性质"></a>定积分的性质</h3><h4 id="线性性质"><a href="#线性性质" class="headerlink" title="线性性质"></a>线性性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092231993.png" alt="image.png"></p><h4 id="不等式性质"><a href="#不等式性质" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092232647.png" alt="image.png"></p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304092239776.png" alt="image.png"></p><h3 id="定积分的计算-1"><a href="#定积分的计算-1" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><h4 id="牛顿莱布尼茨公式"><a href="#牛顿莱布尼茨公式" class="headerlink" title="牛顿莱布尼茨公式"></a>牛顿莱布尼茨公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101351992.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101357337.png" alt="image.png"></p><h4 id="定积分的换元法"><a href="#定积分的换元法" class="headerlink" title="定积分的换元法"></a>定积分的换元法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101404616.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101410502.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101413007.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304101426085.png" alt="image.png"></p><h4 id="华里士公式"><a href="#华里士公式" class="headerlink" title="华里士公式"></a>华里士公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132472.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102132831.png" alt="image.png"></p><h4 id="定积分的分部积分法"><a href="#定积分的分部积分法" class="headerlink" title="定积分的分部积分法"></a>定积分的分部积分法</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038875.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102038203.png" alt="image.png"></p><h4 id="区间在线公式"><a href="#区间在线公式" class="headerlink" title="区间在线公式"></a>区间在线公式</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102944.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304102102751.png" alt="image.png"></p><h2 id="变限积分与反常积分"><a href="#变限积分与反常积分" class="headerlink" title="变限积分与反常积分"></a>变限积分与反常积分</h2><h1 id="高数1-函数-极限-连续"><a href="#高数1-函数-极限-连续" class="headerlink" title="高数1-函数-极限-连续"></a>高数1-函数-极限-连续</h1><hr><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="考试内容要点精讲"><a href="#考试内容要点精讲" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="函数的概念及常见函数"><a href="#函数的概念及常见函数" class="headerlink" title="函数的概念及常见函数"></a>函数的概念及常见函数</h4><blockquote><p>略</p></blockquote><h4 id="函数的性态"><a href="#函数的性态" class="headerlink" title="函数的性态"></a>函数的性态</h4><h5 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a><em>单调性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052057975.png" alt="image.png"></p><h5 id="奇偶性"><a href="#奇偶性" class="headerlink" title="奇偶性"></a><em>奇偶性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052058171.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100778.png" alt="image.png"></p><h5 id="周期性"><a href="#周期性" class="headerlink" title="周期性"></a><em>周期性</em></h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052059224.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052100563.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052106503.png" alt="image.png"></p><h5 id="有界性"><a href="#有界性" class="headerlink" title="有界性"></a><em>有界性</em></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个f(x)函数[a,b]上连续，则在[a,b]上有界</span><br><span class="line">2.f(x)在(a,b)上连续，且limf(a+), limf(b-)存在,则f(x)在(a,b)上有界</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052105228.png" alt="image.png"></p><h3 id="常考题型方法与技巧"><a href="#常考题型方法与技巧" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-复合函数"><a href="#题型1-复合函数" class="headerlink" title="题型1-复合函数"></a>题型1-复合函数</h4><h4 id="题型2-函数性态"><a href="#题型2-函数性态" class="headerlink" title="题型2-函数性态"></a>题型2-函数性态</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052117557.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052138255.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307052155476.png" alt="image.png"></p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><h3 id="考试内容要点精讲-1"><a href="#考试内容要点精讲-1" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="极限概念"><a href="#极限概念" class="headerlink" title="极限概念"></a>极限概念</h4><h5 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061313246.png" alt=""></p><h5 id="函数极限"><a href="#函数极限" class="headerlink" title="函数极限"></a>函数极限</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061315178.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061326428.png" alt=""></p><h5 id="需要分左右极限求极限的三种情况"><a href="#需要分左右极限求极限的三种情况" class="headerlink" title="需要分左右极限求极限的三种情况"></a>需要分左右极限求极限的三种情况</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061328805.png" alt=""></p><h4 id="极限性质-局部有界、保号、保序"><a href="#极限性质-局部有界、保号、保序" class="headerlink" title="极限性质(局部有界、保号、保序)"></a>极限性质(局部有界、保号、保序)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061341030.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061343978.png" alt=""></p><h4 id="极限存在准则"><a href="#极限存在准则" class="headerlink" title="极限存在准则"></a>极限存在准则</h4><p><em>夹逼准则、单调有界准则</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061347339.png" alt=""></p><h4 id="无穷小"><a href="#无穷小" class="headerlink" title="无穷小"></a>无穷小</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061348994.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061351785.png" alt=""><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061353923.png" alt=""></p><h4 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061402353.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061404007.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061408279.png" alt=""></p><h3 id="常考题型方法与技巧-1"><a href="#常考题型方法与技巧-1" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-极限的概念性质及其存在准则"><a href="#题型1-极限的概念性质及其存在准则" class="headerlink" title="题型1-极限的概念性质及其存在准则"></a>题型1-极限的概念性质及其存在准则</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061417690.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061426091.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061429689.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061438026.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061539946.png" alt="image.png"></p><h4 id="题型2-求极限"><a href="#题型2-求极限" class="headerlink" title="题型2 求极限"></a>题型2 求极限</h4><h5 id="8种求极限方法"><a href="#8种求极限方法" class="headerlink" title="8种求极限方法"></a>8种求极限方法</h5><h6 id="method1-基本极限求极限"><a href="#method1-基本极限求极限" class="headerlink" title="method1-基本极限求极限"></a>method1-基本极限求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012219540.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012220359.png" alt="image.png"></p><h6 id="method2-等价无穷小求极限"><a href="#method2-等价无穷小求极限" class="headerlink" title="method2-等价无穷小求极限"></a>method2-等价无穷小求极限</h6><ul><li><code>等价无穷小</code>才能代换</li><li>加减关系 在一定条件下可以换<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221508.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012221512.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081035273.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061838287.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061852881.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061706618.png" alt="image.png"></p><h6 id="method3-有理运算法则求极限"><a href="#method3-有理运算法则求极限" class="headerlink" title="method3-有理运算法则求极限"></a>method3-有理运算法则求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">相加的极限=极限相加，前提是,两部分的极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222899.png" alt="image.png"></p><h6 id="method4-洛必达法则求极限"><a href="#method4-洛必达法则求极限" class="headerlink" title="method4-洛必达法则求极限"></a>method4-洛必达法则求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222158.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222786.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012222445.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总结：f(x) n阶可导，最多用洛必达到n-1阶</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012223174.png" alt="image.png"></p><h6 id="method5-泰勒公式求极限"><a href="#method5-泰勒公式求极限" class="headerlink" title="method5-泰勒公式求极限"></a>method5-泰勒公式求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061734684.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061734035.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061736381.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224130.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.传统方法</span><br><span class="line">2.各个击破</span><br><span class="line">3.代入选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012224551.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意，不能拆分成两部分，因为有理运算前提是两部分函数，极限都存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225514.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225840.png" alt="image.png"></p><h6 id="method6-夹逼定理求极限"><a href="#method6-夹逼定理求极限" class="headerlink" title="method6-夹逼定理求极限"></a>method6-夹逼定理求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n项和的极限</span><br><span class="line">放缩法，分母放大，缩小，求一个范围</span><br><span class="line">然后用夹逼定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225906.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种形式开n方，放大时--&gt;全部换成最大项；缩小时--&gt;只保留最大项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012225588.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226412.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226541.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">假如，根号里常数是2,可以写成1+1,最终还是可以舍去分成3段函数求最大</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226674.png" alt="image.png"></p><h6 id="method7-单调有界准则求极限"><a href="#method7-单调有界准则求极限" class="headerlink" title="method7-单调有界准则求极限"></a>method7-单调有界准则求极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226920.png" alt="image.png"></p><h6 id="method8-定积分定义求极限"><a href="#method8-定积分定义求极限" class="headerlink" title="method8-定积分定义求极限"></a>method8-定积分定义求极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题用夹逼定则做不出来，基本思路是，看做求定积分，将函数平均划分为n部分，每部分1/n</span><br><span class="line">底x高</span><br><span class="line">看做f(x)求0~n的积分,主要是要抽提出f(x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012226489.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061744403.png" alt="image.png"></p><h5 id="求极限常见题型"><a href="#求极限常见题型" class="headerlink" title="求极限常见题型"></a>求极限常见题型</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061756108.png" alt="image.png"></p><h6 id="0-0-型-极限"><a href="#0-0-型-极限" class="headerlink" title="0/0 型 极限"></a>0/0 型 极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常用的方法有三种</span><br><span class="line">1)洛必达法则</span><br><span class="line">2)等价无穷小代换</span><br><span class="line">3)泰勒公式</span><br><span class="line">【原式化简】</span><br><span class="line">1)极限非零的因子极限先求出</span><br><span class="line">2)有理化</span><br><span class="line">3)变量代换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061759317.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061809413.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061810079.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061814083.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061816882.png" alt="image.png"></p><p><em>题目3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061822490.png" alt="image.png"></p><p><em>题目4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061843841.png" alt="image.png"></p><p><em>题目5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061858852.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061858804.png" alt="image.png"></p><p><em>题目6</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061904712.png" alt="image.png"></p></blockquote><h6 id="∞-∞-型极限"><a href="#∞-∞-型极限" class="headerlink" title="∞/∞ 型极限"></a>∞/∞ 型极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际上就是抓大头，忽略低阶无穷大，这样就能快速的找到极限(用于选填)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061945142.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061953358.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307061955452.png" alt="image.png"></p></blockquote><h6 id="∞-∞型-极限"><a href="#∞-∞型-极限" class="headerlink" title="∞-∞型 极限"></a>∞-∞型 极限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用的方法有三种</span><br><span class="line">1)通分化为0/0（适用于分式差）</span><br><span class="line">2)根式有理化（适用于根式差）</span><br><span class="line">3)提无穷因子，然后等价代换或变量代换，泰勒公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062002687.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307062010773.png" alt="image.png"></p></blockquote><h6 id="0x∞型极限"><a href="#0x∞型极限" class="headerlink" title="0x∞型极限"></a>0x∞型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072059652.png" alt="image.png"></p><h6 id="1-∞型极限"><a href="#1-∞型极限" class="headerlink" title="1^∞型极限"></a>1^∞型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072136795.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072138361.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072139454.png" alt="image.png"></p><p><em>题目2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072149021.png" alt="image.png"></p></blockquote><h6 id="∞-0-0-0型极限"><a href="#∞-0-0-0型极限" class="headerlink" title="∞^0 ,0^0型极限"></a>∞^0 ,0^0型极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072153693.png" alt="image.png"></p><blockquote><p><em>题目1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072203098.png" alt="image.png"></p></blockquote><h6 id="数列不定式的极限"><a href="#数列不定式的极限" class="headerlink" title="数列不定式的极限"></a>数列不定式的极限</h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072219695.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072219882.png" alt="image.png"></p><h6 id="n项和的数列极限"><a href="#n项和的数列极限" class="headerlink" title="n项和的数列极限"></a><em>n项和的数列极限</em></h6><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072222306.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072223713.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072233723.png" alt="image.png"></p><blockquote><p><em>小结</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072226909.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072230787.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072236891.png" alt="image.png"></p></blockquote><h6 id="n项连乘的数列极限"><a href="#n项连乘的数列极限" class="headerlink" title="n项连乘的数列极限"></a><em>n项连乘的数列极限</em></h6><blockquote><p><em>1.夹逼 2.取对数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072239494.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072241247.png" alt="image.png"></p></blockquote><h6 id="递推关系数列极限"><a href="#递推关系数列极限" class="headerlink" title="递推关系数列极限"></a><em>递推关系数列极限</em></h6><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072248858.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下都是使用方法1，先证明出数列单调、有界--&gt;得到极限存在，然后再求极限</span><br></pre></td></tr></table></figure><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072254033.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307072300552.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081046927.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当数列不单调时，使用方法2,先假设极限为A,然后证明该极限是数列的极限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081055977.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当题目条件出现f&#x27;(x)与f(x)时，需要建立导数与函数之间的关系，两种方法</span><br><span class="line">1.拉格朗日</span><br><span class="line">2.积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081121965.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081121039.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081122391.png" alt="image.png"></p><h4 id="题型3-确定极限式中的参数"><a href="#题型3-确定极限式中的参数" class="headerlink" title="题型3-确定极限式中的参数"></a>题型3-确定极限式中的参数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081151898.png" alt="image.png"></p><h4 id="题型4-无穷小量阶的比较"><a href="#题型4-无穷小量阶的比较" class="headerlink" title="题型4 无穷小量阶的比较"></a>题型4 无穷小量阶的比较</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081204556.png" alt="image.png"></p><blockquote><p><em>变上限积分型无穷小量阶的比较</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081203105.png" alt="image.png"></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081223704.png" alt="image.png"></p><blockquote><p><em>利用泰勒公式展开求量阶</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081238252.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081244643.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081246900.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">有理化--&gt;分母极限先求</span><br><span class="line">等价代换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227140.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">方法2.</span><br><span class="line">由于x-&gt;0, 两个根式都趋向于1</span><br><span class="line">构建f(x)=x^(1/2)的拉格朗日中值定理 x2&lt;ζ&lt;x1 </span><br><span class="line">f(x1)-f(x2)=f&#x27;(ζ)(x1-x2)</span><br><span class="line"></span><br><span class="line">方法3.</span><br><span class="line">等价代换</span><br><span class="line">1-cosx~x^2/2 --&gt; 1-(cosx)^α=(α/2)x^2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012227233.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231623122.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304231627897.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.构成等价代换</span><br><span class="line">方法2.拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012230880.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231913.png" alt="image.png"></p><h2 id="连续"><a href="#连续" class="headerlink" title="连续"></a>连续</h2><h3 id="考试内容要点精讲-2"><a href="#考试内容要点精讲-2" class="headerlink" title="考试内容要点精讲"></a>考试内容要点精讲</h3><h4 id="连续性概念"><a href="#连续性概念" class="headerlink" title="连续性概念"></a>连续性概念</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081251811.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">连续需要满足，该点极限=该点函数值</span><br><span class="line">连续=左连续+右连续</span><br><span class="line">左连续--&gt;该点左极限=该点函数值</span><br><span class="line">右连续--&gt;该点右极限=该点函数值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231169.png" alt="image.png"></p><h4 id="间断点定义及分类"><a href="#间断点定义及分类" class="headerlink" title="间断点定义及分类"></a>间断点定义及分类</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231532.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012231662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要有一个极限是无穷,就是无穷间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232300.png" alt="image.png"></p><h4 id="连续性的运算与性质"><a href="#连续性的运算与性质" class="headerlink" title="连续性的运算与性质"></a>连续性的运算与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本初等函数是指最基本的函数：例如sinx cosx ...，在定义域内连续</span><br><span class="line"></span><br><span class="line">初等函数是指，最基本初等函数经过有限加减乘除运算后得到的例如√cosx-1 ,只在定义区间是定义域内连续的区间，所以只有存在连续区间，才能在区间内连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232062.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012232410.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">由于f(x)是初等函数，所以，除x=0,1外处处连续</span><br><span class="line"></span><br><span class="line">x-&gt;0 左右极限没有区别 ，算出极限=-1 ，是第一类可去间断点</span><br><span class="line">x-&gt;1 左右极限不同 ，要分开讨论左右极限，左极限=0，右极限=1 ，是跳跃间断点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233337.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x^n，n趋于无穷，讨论4种情况：|x|&lt;1 、|x|&gt;1 、x=1、x=-1</span><br><span class="line">e^nx ,n趋于无穷，讨论3种情况：x&lt;0 、x&gt;0 、x=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233122.png" alt="image.png"></p><h3 id="常考题型方法与技巧-2"><a href="#常考题型方法与技巧-2" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h3><h4 id="题型1-讨论连续性及间断点类型"><a href="#题型1-讨论连续性及间断点类型" class="headerlink" title="题型1-讨论连续性及间断点类型"></a>题型1-讨论连续性及间断点类型</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081307119.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081346105.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081358741.png" alt="image.png"></p><h4 id="题型2-介值定理、最值定理及零点定理的证明题"><a href="#题型2-介值定理、最值定理及零点定理的证明题" class="headerlink" title="题型2-介值定理、最值定理及零点定理的证明题"></a>题型2-介值定理、最值定理及零点定理的证明题</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081539699.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081540242.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这题用到了介值定理--&gt;零点一定介于函数值是正负的两点之间</span><br><span class="line">那么函数f(x)/x当 x-&gt;∞(注意这里是函数的区域∞，是同时趋于正负∞)，极限=0</span><br><span class="line">所以令F(x)=f(x) + x ; 则lim x-&gt;∞ F(x)/x = 1 ;</span><br><span class="line">所以存在X&gt;0,使得|x|&gt;X时，F(x)/x &gt;0 </span><br><span class="line">取a&gt;X ,则F(a)/a &gt;0 --&gt; F(a)&gt;0 ,F(-a)/-a &gt;0 --&gt;F(-a)&lt;0 </span><br><span class="line">从而(-a,a)之间存在 ζ，使得F(ζ)=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081531333.png" alt="image.png"></p><h1 id="高数2-导数-微分"><a href="#高数2-导数-微分" class="headerlink" title="高数2-导数-微分"></a>高数2-导数-微分</h1><h2 id="导数概念"><a href="#导数概念" class="headerlink" title="导数概念"></a>导数概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导数：函数在哪一点的变化率</span><br><span class="line">导数定义是△x-&gt;0 的极限(或x-&gt;x0的极限)</span><br><span class="line">注意:△x-&gt;0 是函数的趋近--&gt;是同时趋近与0+,0- ;同理x-&gt;x0+,x-&gt;x0</span><br><span class="line">所以，&lt;导数存在&gt; &lt;=&gt; &lt;是指左导数和右导数都存在，且相等&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">该点左函数的极限值=该点函数值，所以左连续，可以直接求导</span><br><span class="line">该点右函数的极限值!=该点函数值，右不连续，右导数不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234982.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234642.png" alt="image.png"></p><h2 id="微分概念"><a href="#微分概念" class="headerlink" title="微分概念"></a>微分概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">微分：函数改变量的近似值，忽略了高阶无穷小，微分实际就是函数改变量的 线性主部</span><br><span class="line"></span><br><span class="line">eg.A△x--&gt;是一个关于x的线性函数--&gt;也称为线性主部分(微分)</span><br><span class="line"></span><br><span class="line">一元函数里面：可微等价于可导</span><br><span class="line">多元函数里面：可微=&gt;可导 ，可导不能推出可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012234144.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235565.png" alt="image.png"></p><h2 id="导数几何意义"><a href="#导数几何意义" class="headerlink" title="导数几何意义"></a>导数几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">导数微分就是解决函数 &lt;非均匀变化&gt; 的问题,用用微分(线性主部，均匀变化)来代替非均匀，来研究函数变化</span><br><span class="line"></span><br><span class="line">微分就是A△x =Adx,导数就是斜率A,在一个微观角度，将函数看做线性均匀变化的小的直线</span><br><span class="line">--&gt;所以积分就是 无数个微分 f&#x27;(x)dx --&gt;在x的一个范围内的求和 </span><br><span class="line"></span><br><span class="line">可导=&gt;切线存在</span><br><span class="line">切线存在 不一定 可导 (切线斜率为∞，导数不存在)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235642.png" alt="image.png"></p><h2 id="微分几何意义"><a href="#微分几何意义" class="headerlink" title="微分几何意义"></a>微分几何意义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">微分几何意义=切线上的增量dy=A△x</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012235182.png" alt="image.png"></p><h2 id="连续-可微-可导关系"><a href="#连续-可微-可导关系" class="headerlink" title="连续-可微-可导关系"></a>连续-可微-可导关系</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一元函数 </span><br><span class="line"></span><br><span class="line">可导：是指，f(x)在x0点处导数存在</span><br><span class="line">连续：f(x)在点x0处连续</span><br><span class="line"></span><br><span class="line">可微&lt;=&gt;可导 </span><br><span class="line">连续不一定可导(尖点)，所以连续不一定可微；</span><br><span class="line">可导/可微=&gt;连续 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236684.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)在x0的邻域内一阶可导，推不出，导函数在x0连续，也推不出，导函数在x0的极限存在</span><br><span class="line"></span><br><span class="line">所以总结：</span><br><span class="line">f(x)n阶可导 ,洛必达中中最多出现n-1阶导数</span><br><span class="line">f(x)n阶导数连续，洛必达可以出现n阶导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012236777.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x趋于0的函数极限,与x=0的值毫无关系</span><br><span class="line">排除AB</span><br><span class="line">C:x=0处可导，说明函数在x=0处连续，既然连续，那么x=0处的极限存在即lim x-&gt;0 (f(x)/x)存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237415.png" alt="image.png"></p><h2 id="导数公式及求导法则"><a href="#导数公式及求导法则" class="headerlink" title="导数公式及求导法则"></a>导数公式及求导法则</h2><h3 id="基本初等函数求导公式"><a href="#基本初等函数求导公式" class="headerlink" title="基本初等函数求导公式"></a>基本初等函数求导公式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237303.png" alt="image.png"></p><h3 id="复合函数求导法则"><a href="#复合函数求导法则" class="headerlink" title="复合函数求导法则"></a>复合函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237240.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">奇函数的导数是偶函数</span><br><span class="line">偶函数的导数是奇函数  </span><br><span class="line"></span><br><span class="line">周期函数的导数任然是周期函数</span><br><span class="line"></span><br><span class="line">运用了奇函数过(0,0)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012237438.png" alt="image.png"></p><h3 id="隐函数求导法则"><a href="#隐函数求导法则" class="headerlink" title="隐函数求导法则"></a>隐函数求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238267.png" alt="image.png"></p><h3 id="反函数求导法则"><a href="#反函数求导法则" class="headerlink" title="反函数求导法则"></a>反函数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看到反函数，先写出原函数</span><br><span class="line">反函数对y求导数=原函数对x求导数的倒数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238483.png" alt="image.png"></p><h3 id="参数方程求导法则"><a href="#参数方程求导法则" class="headerlink" title="参数方程求导法则"></a>参数方程求导法则</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238001.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238200.png" alt="image.png"></p><h3 id="对数求导法则"><a href="#对数求导法则" class="headerlink" title="对数求导法则"></a>对数求导法则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两边ln</span><br><span class="line">两边求导。左边对y求，右边对x求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012238662.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">取对数，把连乘连除变成加减</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239343.png" alt="image.png"></p><h2 id="高阶导数"><a href="#高阶导数" class="headerlink" title="高阶导数"></a>高阶导数</h2><h3 id="高阶导数定义"><a href="#高阶导数定义" class="headerlink" title="高阶导数定义"></a>高阶导数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n阶可导，那么就具有&lt;n阶的一切导数的存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239942.png" alt="image.png"></p><h3 id="常用高阶导数"><a href="#常用高阶导数" class="headerlink" title="常用高阶导数"></a>常用高阶导数</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012239042.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240996.png" alt="image.png"></p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="导数定义应用"><a href="#导数定义应用" class="headerlink" title="导数定义应用"></a>导数定义应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种题，基本思路，认为凑成f(x)导数的定义式</span><br><span class="line"></span><br><span class="line">填空题，直接代入一个具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240723.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代入具体函数，秒杀</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012240649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际要化为导数的定义式，转变化为求x=0的导数问题</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241229.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论：如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241771.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由定义式推出导数存在，要求左右极限都存在</span><br><span class="line">A.  h-&gt;+∞ ，1/h-&gt;0+  不行</span><br><span class="line">B.  n-&gt;∞，默认n-&gt;+∞,1/n-&gt;0+ ,不行</span><br><span class="line">C.  定义式求导数要求两个点,一定一动，两个点都动，不行</span><br><span class="line">D.  h-&gt;0，默认h-&gt;0+ &amp;&amp; h-&gt;0- ,可以</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012241531.png" alt="image.png"></p><h3 id="复合-隐函-参数求导应用"><a href="#复合-隐函-参数求导应用" class="headerlink" title="复合-隐函-参数求导应用"></a>复合-隐函-参数求导应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要求二阶导数</span><br><span class="line">根据方程</span><br><span class="line">分别求出x=1时</span><br><span class="line">y=?</span><br><span class="line">y&#x27;=?</span><br><span class="line">最后</span><br><span class="line">y&#x27;&#x27;=?</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242620.png" alt="image.png"></p><h3 id="高阶导数应用"><a href="#高阶导数应用" class="headerlink" title="高阶导数应用"></a>高阶导数应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242698.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.高阶导数公式</span><br><span class="line">方法2.泰勒公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242415.png" alt="image.png"></p><h3 id="导数应用"><a href="#导数应用" class="headerlink" title="导数应用"></a>导数应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对方程求导</span><br><span class="line">求出y&#x27;-&gt;斜率</span><br><span class="line">继而求出切线方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012242257.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243534.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012243968.png" alt="image.png"></p><h2 id="常考题型方法与技巧-3"><a href="#常考题型方法与技巧-3" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h2><h3 id="题型1-导数与微分的概念"><a href="#题型1-导数与微分的概念" class="headerlink" title="题型1-导数与微分的概念"></a>题型1-导数与微分的概念</h3><h4 id="利用导数定义求极限"><a href="#利用导数定义求极限" class="headerlink" title="利用导数定义求极限"></a>利用导数定义求极限</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将原极限式子，凑成该点导数形式，利用现有的导数值来求解。</span><br><span class="line">另外由于是填空题，可以直接构造一个符合条件的函数来代入计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081647015.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081933181.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081933716.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307081951939.png" alt="image.png"></p><h4 id="利用导数定义求导数"><a href="#利用导数定义求导数" class="headerlink" title="利用导数定义求导数"></a>利用导数定义求导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082011740.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082039132.png" alt="image.png"></p><h4 id="利用导数定义判断函数的可导性"><a href="#利用导数定义判断函数的可导性" class="headerlink" title="利用导数定义判断函数的可导性"></a>利用导数定义判断函数的可导性</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082232692.png" alt="image.png"></p><blockquote><p><em>结论1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082257636.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082300275.png" alt="image.png"></p><p><em>结论2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082319379.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082319993.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307082323866.png" alt="image.png"></p><p><em>结论3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307090953890.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307090953749.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091027211.png" alt="image.png"></p></blockquote><h3 id="题型2-导数的集合意义"><a href="#题型2-导数的集合意义" class="headerlink" title="题型2-导数的集合意义"></a>题型2-导数的集合意义</h3><h3 id="题型3-导数与微分的计算"><a href="#题型3-导数与微分的计算" class="headerlink" title="题型3-导数与微分的计算"></a>题型3-导数与微分的计算</h3><h4 id="复合函数求导数"><a href="#复合函数求导数" class="headerlink" title="复合函数求导数"></a>复合函数求导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091056047.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091057814.png" alt="image.png"></p><h4 id="隐函数的导数"><a href="#隐函数的导数" class="headerlink" title="隐函数的导数"></a>隐函数的导数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于函数对于y，x难以分离的函数，求导数，只能两边对x求导</span><br><span class="line">这样的就是隐函数求导，注意，将原方程带到一阶导数方程化简，这样求二阶导数方程时，可更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091102652.png" alt="image.png"></p><h4 id="参数方程的导数"><a href="#参数方程的导数" class="headerlink" title="参数方程的导数"></a>参数方程的导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091134761.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091221738.png" alt=""></p><h4 id="反函数的求导"><a href="#反函数的求导" class="headerlink" title="反函数的求导"></a>反函数的求导</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091229196.png" alt="image.png"></p><h4 id="对数求导法"><a href="#对数求导法" class="headerlink" title="对数求导法"></a>对数求导法</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091230038.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091235678.png" alt="image.png"></p><h4 id="高阶导数-1"><a href="#高阶导数-1" class="headerlink" title="高阶导数"></a>高阶导数</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091241032.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求不定点，n阶导数，找规律</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091246868.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091252942.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求具体某一点的n阶导数，方法1.利用n阶导数公式  2.利用泰勒公式在某一点的展开</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091255466.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091300011.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重要结论sinx的n阶导数=six(x+n(π/2))</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091500937.png" alt="image.png"></p><h1 id="高数3-微分中值定理及导数应用"><a href="#高数3-微分中值定理及导数应用" class="headerlink" title="高数3-微分中值定理及导数应用"></a>高数3-微分中值定理及导数应用</h1><h2 id="内容概要"><a href="#内容概要" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微分中值定理目的是为了</span><br><span class="line">建立函数与导数之间的关系</span><br></pre></td></tr></table></figure><ul><li><code>费马定理</code></li><li><code>罗尔定理</code></li><li><code>拉格朗日中值定理</code></li><li><code>柯西中值定理</code>:在运动中，两者一定有某处的瞬时速度之比等于平均速度之比<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011611443.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">实际上就是 x-&gt;0 处的泰勒展开</span><br><span class="line"></span><br><span class="line">建立了 函数 与 高阶导数 之间的关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612549.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由罗尔定理推导出拉格朗日中值定理和柯西中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252354448.jpg" alt="Screenshot_2023-05-24-20-47-07-55_769977972775e0c.jpg"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252355825.jpg" alt="Screenshot_2023-05-24-21-00-10-12_769977972775e0c.jpg"></p><h3 id="导数应用-1"><a href="#导数应用-1" class="headerlink" title="导数应用"></a>导数应用</h3><h4 id="函数极值"><a href="#函数极值" class="headerlink" title="函数极值"></a>函数极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">驻点：导数为0的点</span><br><span class="line">极值点不一定驻点 |x|</span><br><span class="line">驻点不一定是极值点 x^3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612417.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612184.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011612620.png" alt="image.png"></p><h4 id="函数最值"><a href="#函数最值" class="headerlink" title="函数最值"></a>函数最值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">极值点是函数内部领域内的“凸点或尖点”，可以有多个，不一定是最大最小</span><br><span class="line">最值点，可以是某一个极值点，也可以是端点</span><br></pre></td></tr></table></figure><ul><li><code>连续函数f(x)</code>在（a,b）内有<code>多个极值点</code>，那么最值点要么是极值点，要么是端点</li><li><code>连续函数f(x)</code>在（a,b）内有`唯一极值点·，那么这个极值点就是(a,b)内的最大值或最小值点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求最值3部曲：</span><br><span class="line">- 求出函数f(x)的所有驻点、不可导点</span><br><span class="line">- 分别求出各自函数值</span><br><span class="line">- 比较函数值大小</span><br></pre></td></tr></table></figure><h4 id="函数凹凸性"><a href="#函数凹凸性" class="headerlink" title="函数凹凸性"></a>函数凹凸性</h4><ul><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&gt;0</code>,函数就是<code>凹的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)&lt;0</code>,函数就是<code>凸的</code></li><li>若在区间 <code>I</code>上，<code>f&#39;&#39;(x)=0</code>,该点就是函数<code>拐点</code>，左右凹凸性变化<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092155259.png" alt="image.png"></li></ul><h4 id="函数的渐近线"><a href="#函数的渐近线" class="headerlink" title="函数的渐近线"></a>函数的渐近线</h4><ul><li><code>水平渐近线</code></li><li><code>垂直渐进线</code></li><li><code>斜渐近线</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613369.png" alt="image.png"></li></ul><h4 id="弧微分与曲率"><a href="#弧微分与曲率" class="headerlink" title="弧微分与曲率"></a>弧微分与曲率</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613748.png" alt="image.png"></p><h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="求函数极值最值及确定函数凹向与拐点"><a href="#求函数极值最值及确定函数凹向与拐点" class="headerlink" title="求函数极值最值及确定函数凹向与拐点"></a>求函数极值最值及确定函数凹向与拐点</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613878.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011613028.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这种分段函数，求导数和极值问题</span><br><span class="line"></span><br><span class="line">求f&#x27;(x)</span><br><span class="line">1.首先要判断断点处，导数是否存在(即左导数是否等于右导数)</span><br><span class="line">2.根据在断点处导数是否存在，再写f&#x27;(x)，以判断是否在断点处要写等号</span><br><span class="line"></span><br><span class="line">求f(x)极值</span><br><span class="line">3.极值点是驻点或不可导点，列出驻点、不可导点</span><br><span class="line">4.在不可导电需要判断函数是否连续(不能跳跃),连续就继续求，不连续就不属于极值点</span><br><span class="line">5.分别求出驻点、不可导点，根据f&#x27;(x)的正负形判断极大极小</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614666.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614341.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">目标函数选取的重要性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614024.png" alt="image.png"></p><p><code>画图</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614910.png" alt="image.png"></p><h3 id="求渐近线"><a href="#求渐近线" class="headerlink" title="求渐近线"></a>求渐近线</h3><ul><li><code>ln(1+e^x)-x=ln[(1+e^x)/e^x]</code></li><li>或者<code>ln(1+e^x)-x=x+ln(e^-x + 1)-x</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614026.png" alt="image.png"></li></ul><p><code>去绝对值，分别讨论正负</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011614805.png" alt="image.png"></p><h3 id="方程的根"><a href="#方程的根" class="headerlink" title="方程的根"></a>方程的根</h3><p><code>证明根的存在性</code></p><ul><li>罗尔定理：两端为零，之间至少存在一个导数为零</li><li>零点定理：左端右端一正一负，之间至少存在一个值为零<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615914.png" alt="image.png"></li></ul><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615726.png" alt="image.png"></p><p><code>给定根数量，求范围</code></p><ul><li>画图<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615579.png" alt="image.png"></li></ul><h3 id="不等式证明"><a href="#不等式证明" class="headerlink" title="不等式证明"></a>不等式证明</h3><p><code>1.利用拉格朗日中值定理</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)=lnx</span><br><span class="line">至少存在一个ζ</span><br><span class="line">f(1+x)-f(1)=f&#x27;(ζ)(1+x-1)</span><br><span class="line">然后放大分母为1+x,--&gt;最小</span><br><span class="line">缩小分母--&gt;最大</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011615051.png" alt="image.png"></p><p><code>2.利用单调性证明不等式</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616425.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616772.png" alt="image.png"></p><h3 id="中值定理的证明"><a href="#中值定理的证明" class="headerlink" title="中值定理的证明"></a>中值定理的证明</h3><p><code>两次罗尔定理</code><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616005.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用拉格朗日中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011616926.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011617692.png" alt="image.png"></p><h2 id="常考题型方法与技巧-4"><a href="#常考题型方法与技巧-4" class="headerlink" title="常考题型方法与技巧"></a>常考题型方法与技巧</h2><h3 id="题型1-函数的单调性、极值及最值"><a href="#题型1-函数的单调性、极值及最值" class="headerlink" title="题型1-函数的单调性、极值及最值"></a>题型1-函数的单调性、极值及最值</h3><blockquote><p><em>变上限积分函数极值问题</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">求函数单调区间--&gt;列出所有驻点(导数为0的点)，接着判断驻点两侧导数的正负性判断出函数增减性--&gt;画出函数图像--&gt;找最值</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307091503863.png" alt="image.png"></p><p><em>隐函数极值问题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092038329.png" alt="image.png"></p><p><em>运用极限保号性求极值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092047530.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092053720.png" alt="image.png"></p><p><em>例5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092100111.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092100616.png" alt="image.png"></p></blockquote><h3 id="题型2-曲线的凹向、拐点、渐近线及曲率"><a href="#题型2-曲线的凹向、拐点、渐近线及曲率" class="headerlink" title="题型2-曲线的凹向、拐点、渐近线及曲率"></a>题型2-曲线的凹向、拐点、渐近线及曲率</h3><blockquote><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092136152.png" alt="image.png"></p><p><em>例题3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092219206.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092219733.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307092224807.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101028180.png" alt="image.png"></p><p><em>例子5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101033936.png" alt="image.png"></p></blockquote><h3 id="题型3-方程的根的存在性及个数"><a href="#题型3-方程的根的存在性及个数" class="headerlink" title="题型3-方程的根的存在性及个数"></a>题型3-方程的根的存在性及个数</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101126829.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101125852.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101128025.png" alt="image.png"></p><p><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101130085.png" alt="image.png"></p><p><em>例3</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101150565.png" alt="image.png"></p></blockquote><h3 id="题型4-证明函数不等式"><a href="#题型4-证明函数不等式" class="headerlink" title="题型4-证明函数不等式"></a>题型4-证明函数不等式</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101159151.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101200832.png" alt="image.png"></p><p><em>例题2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101200275.png" alt="image.png"></p><p><em>例3</em><br><strong>题目给出二阶导数，要证明的是函数不等式，怎么才能将函数与高阶导数联系在一起?—&gt;想到用泰勒公式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101203461.png" alt="image.png"></p><p><em>例3其他方法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101209128.png" alt="image.png"></p><p><em>2021大纲修改，9大题-&gt;6大题，证明不等式出现在选择题概率更高</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101216068.png" alt="image.png"></p></blockquote><h3 id="题型5-微分中值定理有关的证明题"><a href="#题型5-微分中值定理有关的证明题" class="headerlink" title="题型5-微分中值定理有关的证明题"></a>题型5-微分中值定理有关的证明题</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101722824.png" alt="image.png"></p><h4 id="证明一个存在一个中值点…，"><a href="#证明一个存在一个中值点…，" class="headerlink" title="证明一个存在一个中值点…，"></a>证明一个存在一个中值点…，</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101336631.png" alt="image.png"></p><blockquote><p><em>例题1</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101358378.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101358182.png" alt="image.png"></p><p><em>例2</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101406883.png" alt="image.png"></p><p><em>构造辅助函数纠结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101405730.png" alt="image.png"></p><p><em>没有需要证明的等式中没有出现导数—直接零点定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101603405.png" alt="image.png"></p><p><em>例4</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101422052.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101424577.png" alt="image.png"></p><p><em>例5</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101427000.png" alt="image.png"></p><p><em>柯西、拉格朗日实质就是通过构造辅助函数证明的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101442351.png" alt="image.png"></p><p><em>例6-积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101442713.png" alt="image.png"></p><p><em>例7-变上限积分函数-构造辅助函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101504848.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101505567.png" alt="image.png"></p></blockquote><h4 id="证明存在两个中值点"><a href="#证明存在两个中值点" class="headerlink" title="证明存在两个中值点"></a>证明存在两个中值点</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101526198.png" alt="image.png"></p><blockquote><p><em>没有要求两个中值不相等</em></p><p><strong>1.将两个中值分离到两边<br>2.再根据两边函数形势，判断用柯西还是拉格朗日中值定理</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101540675.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101540161.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101552242.png" alt="image.png"></p><p><em>要求两个中值不相等<br>通过点c，将区域划分为左右两端</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101606123.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101630661.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101630646.png" alt="image.png"></p></blockquote><h4 id="证明存在一个中值点（含高阶导数）"><a href="#证明存在一个中值点（含高阶导数）" class="headerlink" title="证明存在一个中值点（含高阶导数）"></a>证明存在一个中值点（含高阶导数）</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101705983.png" alt="image.png"></p><blockquote><p><strong>1.判断所证明等式中是否含有高阶导数，含有则选用拉格朗日余项泰勒公式<br>2.接着在哪一点展开呢?—&gt;在提供信息最多的点展开(其中能提供导数信息的优先)<br>3.提供信息一样多的时候，都展开代入</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101708834.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101710062.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101723749.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307101723067.png" alt="image.png"></p></blockquote><h1 id="高数4-不定积分"><a href="#高数4-不定积分" class="headerlink" title="高数4-不定积分"></a>高数4-不定积分</h1><h2 id="内容概要-1"><a href="#内容概要-1" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="不定积分概念性质"><a href="#不定积分概念性质" class="headerlink" title="不定积分概念性质"></a>不定积分概念性质</h3><h4 id="原函数存在定理"><a href="#原函数存在定理" class="headerlink" title="原函数存在定理"></a><code>原函数存在定理</code></h4><ul><li>若f(x)<code>在区间I连续</code>，则f(x)在区间I上一定存在原函数(导函数连续，原函数必定连续)</li><li>若f(x)在区间I上<code>有第一类间断点</code>，则一定没有原函数</li><li>若f(x)在区间I上<code>有第二类间断点</code>，则可能有原函数(有原函数的导数不一定连续)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011039122.png" alt="image.png"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数连续,所以有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011041496.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一类间断点(跳跃)，一定没有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011042885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第二类间断点(震荡)，可能有原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011047495.png" alt="image.png"></p><h4 id="不定积分性质"><a href="#不定积分性质" class="headerlink" title="不定积分性质"></a>不定积分性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011053012.png" alt="image.png"></p><h4 id="不定积分基本公式"><a href="#不定积分基本公式" class="headerlink" title="不定积分基本公式"></a>不定积分基本公式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cscx=1/sinx</span><br><span class="line">secx=1/cosx</span><br><span class="line">cotx=1/tanx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141412806.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011110068.png" alt="image.png"></p><h3 id="三大积分方法"><a href="#三大积分方法" class="headerlink" title="三大积分方法"></a>三大积分方法</h3><h4 id="第一类换元-凑微分"><a href="#第一类换元-凑微分" class="headerlink" title="第一类换元(凑微分)"></a>第一类换元(凑微分)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011121307.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011123543.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011130757.png" alt="image.png"></p><h4 id="第二类换元法-去根号-1"><a href="#第二类换元法-去根号-1" class="headerlink" title="第二类换元法(去根号)"></a>第二类换元法(去根号)</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011134848.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153689.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011153143.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154683.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011154305.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152947.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011152136.png" alt="image.png"></p><h4 id="第三类分部积分"><a href="#第三类分部积分" class="headerlink" title="第三类分部积分"></a>第三类分部积分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">何时用？</span><br><span class="line">出现两类不同函数相乘</span><br><span class="line">如何用？</span><br><span class="line">Pn(x)代表多项式；如下，画圈的代表先凑进去</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011156648.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238404.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011238473.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011242946.png" alt="image.png"></p><h3 id="三类常见可积函数积分"><a href="#三类常见可积函数积分" class="headerlink" title="三类常见可积函数积分"></a>三类常见可积函数积分</h3><h4 id="可积函数概念"><a href="#可积函数概念" class="headerlink" title="可积函数概念"></a>可积函数概念</h4><p><code>可积函数</code>，是指积分可以用<code>初等函数</code>的<code>加减乘除表示</code>，下列是三种常见积不出的函数<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011244308.png" alt="image.png"></p><h4 id="常见可积函数"><a href="#常见可积函数" class="headerlink" title="常见可积函数"></a>常见可积函数</h4><h5 id="有理函数积分"><a href="#有理函数积分" class="headerlink" title="有理函数积分"></a>有理函数积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有理函数积分都能积分出来</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011246229.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011247873.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011256885.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">回顾之前的有理函数积分方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011259165.png" alt="image.png"></p><h5 id="三角有理式积分-1"><a href="#三角有理式积分-1" class="headerlink" title="三角有理式积分"></a>三角有理式积分</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">三角函数可以代换为有理函数，因为有理函数都能积分出来，所以三角函数一定能积分出来</span><br><span class="line"></span><br><span class="line">左三角函数积分有两类方法</span><br><span class="line">- 万能代换(万不得已不使用)</span><br><span class="line">- 三角变形、换元、分部</span><br><span class="line"></span><br><span class="line">总结的三个简单规律：</span><br><span class="line">下图R(-sinx,cosx)=-R(sinx,cosx)--&gt;意思是原函数用-sinx替换sinx，只需在函数前加-,这种一般换元cosx=u</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011302914.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011305711.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332411.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011332272.png" alt="image.png"></p><h5 id="简单无理式积分"><a href="#简单无理式积分" class="headerlink" title="简单无理式积分"></a>简单无理式积分</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353852.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011353702.png" alt="image.png"></p><h2 id="不定积分常考题"><a href="#不定积分常考题" class="headerlink" title="不定积分常考题"></a>不定积分常考题</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011452143.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分段函数，求原函数</span><br><span class="line">- 首先保证原函数F(x)连续(这样才能处处可导)--&gt;断点处，原函数要连续--&gt;趋于断点处左右原函数极限相等</span><br><span class="line">- 可以得到c1 c2关系--&gt; c2 = c1 + 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011503967.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分段函数求原函数</span><br><span class="line">- f(x)处处有定义--&gt;原函数F(x)连续</span><br><span class="line">- 原函数要连续--&gt;满足断点处连续--&gt;左右极限相等</span><br><span class="line">- 得到c1 c2关系</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011509154.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011603033.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下方的</span><br><span class="line">有理函数积分，将分子 利用分母有的两种因子 凑成1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011623381.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两次分部积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011627054.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011634510.png" alt="image.png"></p><h1 id="高数5-定积分"><a href="#高数5-定积分" class="headerlink" title="高数5-定积分"></a>高数5-定积分</h1><h2 id="内容概要-2"><a href="#内容概要-2" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="定积分的概念"><a href="#定积分的概念" class="headerlink" title="定积分的概念"></a>定积分的概念</h3><h4 id="定积分定义"><a href="#定积分定义" class="headerlink" title="定积分定义"></a>定积分定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011722857.png" alt="image.png"></p><h4 id="定积分存在充分条件"><a href="#定积分存在充分条件" class="headerlink" title="定积分存在充分条件"></a>定积分存在充分条件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定积分存在就是可积</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011728280.png" alt="image.png"></p><h4 id="定积分存在必要条件"><a href="#定积分存在必要条件" class="headerlink" title="定积分存在必要条件"></a>定积分存在必要条件</h4><p><code>可积</code>=&gt;<code>有界</code>(反过来不成立)<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011731879.png" alt="image.png"></p><h4 id="定积分几何意义"><a href="#定积分几何意义" class="headerlink" title="定积分几何意义"></a>定积分几何意义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011733974.png" alt="image.png"></p><h3 id="定积分性质"><a href="#定积分性质" class="headerlink" title="定积分性质"></a>定积分性质</h3><h4 id="不等式性质-1"><a href="#不等式性质-1" class="headerlink" title="不等式性质"></a>不等式性质</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011736842.png" alt="image.png"></p><h4 id="中值定理"><a href="#中值定理" class="headerlink" title="中值定理"></a>中值定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(1)的证明</span><br><span class="line">- f(x)在区间[a,b]连续，即导函数连续，必有原函数F(x)，存在F(a)-F(b)=F&#x27;(ζ)(a-b),拉格朗日中值定理</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305011741252.png" alt="image.png"></p><h3 id="积分上限的函数"><a href="#积分上限的函数" class="headerlink" title="积分上限的函数"></a>积分上限的函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于第二个定理</span><br><span class="line">若f(x)是奇函数，那么0到x对f(t)dt积分是偶函数，积分下限可以是任意常数，相当于偶函数+常数</span><br><span class="line">但是对于f(x)是偶函数，积分下限只能是0，因为奇函数+常数 就不是奇函数了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012252269.png" alt="image.png"></p><h3 id="定积分的计算-2"><a href="#定积分的计算-2" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012304896.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305012306157.png" alt="image.png"></p><h2 id="常考题型-1"><a href="#常考题型-1" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="定积分定义、几何性质应用"><a href="#定积分定义、几何性质应用" class="headerlink" title="定积分定义、几何性质应用"></a>定积分定义、几何性质应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这类题型</span><br><span class="line">- 提取1/n</span><br><span class="line">- 写成定积分形式求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021020359.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021022319.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021026083.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021028407.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.常规根据上下限，算出面积</span><br><span class="line">解法2(快速).根据定积分奇偶性，根据图像,被积函数是奇函数，所以原函数是偶函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021036825.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021042331.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解法1.f&#x27;&#x27;(x)&gt;0 ,函数凹的，根据定积分性质</span><br><span class="line">解法2.排除法，找一个满足题目要求的函数，代入即可</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021050490.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分中值定理+微分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021421295.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021422494.png" alt="image.png"></p><h3 id="定积分的计算-3"><a href="#定积分的计算-3" class="headerlink" title="定积分的计算"></a>定积分的计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+点火公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021425241.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">奇偶性判断+几何意义</span><br><span class="line">常用的几种圆的积分形式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021428611.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用公式∫0-&gt;π xf(sinx) dx = π/2 ∫0-&gt;π f(sinx) dx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021433961.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021443943.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021445163.png" alt="image.png"></p><h3 id="变上限积分"><a href="#变上限积分" class="headerlink" title="变上限积分"></a>变上限积分</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021510612.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521763.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021509396.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于上下限有x的，且被积分函数含有x的因式因子，首先将x当成常数，将x提出到外面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021521474.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意x&gt;=0,∫-1-&gt;x  包括了-1-&gt;0 要分两段计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021542735.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021554116.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021613968.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解法2.利用积分中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021610552.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021606709.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021614121.png" alt="image.png"></p><h2 id="强化题型"><a href="#强化题型" class="headerlink" title="强化题型"></a>强化题型</h2><h3 id="题型1-定积分计算"><a href="#题型1-定积分计算" class="headerlink" title="题型1-定积分计算"></a>题型1-定积分计算</h3><blockquote><p><em>区间再现，定积分的计算，当被积函数原函数很难找到的时候，使用积分再现。令u=a+b-x</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252228126.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252228949.png" alt="image.png"></p><p><em>给了一个 变上限积分等式 ,被积函数里含有x—&gt;求f(x)定积分；方法是：先变量代换，区间再现，然后求导</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252229332.png" alt="image.png"></p><p><em>这种函数内层嵌套一个函数本身的积分式形式的函数，要求f(x)的题，方法思路：1.按照内层嵌套的函数定积分形式对外层函数作相同的积分(这样可以消除掉内层的积分式，因为定积分式是一个常数)，然后就得到了积分式的值，代入原函数就得到原函数的原貌</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252231520.png" alt="image.png"></p></blockquote><h3 id="题型2-变上限积分及其应用"><a href="#题型2-变上限积分及其应用" class="headerlink" title="题型2-变上限积分及其应用"></a><em>题型2-变上限积分及其应用</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252233131.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252235271.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252235553.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252236354.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252236202.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252236987.png" alt="image.png"></p><p><em>变上限积分求极限的题型 传统方法：洛必达，快捷方法：积分中值定理</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252237593.png" alt="image.png"></p><p><em>直接根据图像法分析正负性，快速，高效</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252238893.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252239919.png" alt="image.png"></p><p><em>待做</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture3/picture/202308252239291.png" alt="image.png"></p></blockquote><h3 id="题型4-积分不等式"><a href="#题型4-积分不等式" class="headerlink" title="题型4-积分不等式"></a>题型4-积分不等式</h3><h1 id="高数5-反常积分"><a href="#高数5-反常积分" class="headerlink" title="高数5-反常积分"></a>高数5-反常积分</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021617496.png" alt="image.png"></p><h2 id="内容概要-3"><a href="#内容概要-3" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="无穷区间上的反常积分"><a href="#无穷区间上的反常积分" class="headerlink" title="无穷区间上的反常积分"></a>无穷区间上的反常积分</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021640001.png" alt="image.png"></p><h4 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021647869.png" alt="image.png"></p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">找合适的p函数，p的取值，可以是，分母x的幂次-分子x的幂次</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305021657042.png" alt="image.png"></p><h3 id="无界函数的反常积分"><a href="#无界函数的反常积分" class="headerlink" title="无界函数的反常积分"></a>无界函数的反常积分</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022201133.png" alt="image.png"></p><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用结论中：画蓝线的为无界点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022207691.png" alt="image.png"></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">积分上下限都是无界点，需要分别算--&gt;拆成两部分0-&gt;1/2 和1/2-&gt;1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022208858.png" alt="image.png"></p><h2 id="常考题型-2"><a href="#常考题型-2" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="反常积分敛散性"><a href="#反常积分敛散性" class="headerlink" title="反常积分敛散性"></a>反常积分敛散性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126385.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031126832.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">包含无穷区间，和无界点，需要拆成两部分分别计算</span><br><span class="line">0-&gt;1      此时，主要看0点(无界点)，(1+x)^b-&gt;1 ,,所以p积分指数取a  </span><br><span class="line">1-&gt;无穷   此时,主要看无穷区间，1+x--&gt;x ,所以p积分指数取a+b   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031134500.png" alt="image.png"></p><h3 id="反常积分计算"><a href="#反常积分计算" class="headerlink" title="反常积分计算"></a>反常积分计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031156742.png" alt="image.png"></p><h1 id="高数6-定积分应用"><a href="#高数6-定积分应用" class="headerlink" title="高数6-定积分应用"></a>高数6-定积分应用</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031157707.png" alt="image.png"></p><h2 id="内容概要-4"><a href="#内容概要-4" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="几何应用"><a href="#几何应用" class="headerlink" title="几何应用"></a>几何应用</h3><h4 id="平面图形面积"><a href="#平面图形面积" class="headerlink" title="平面图形面积"></a>平面图形面积</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本质上还是二重积分，利用二重积分更加容易</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031327184.png" alt="image.png"></p><h4 id="旋转体体积"><a href="#旋转体体积" class="headerlink" title="旋转体体积"></a>旋转体体积</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031344267.png" alt="image.png"></p><h4 id="曲线弧长"><a href="#曲线弧长" class="headerlink" title="曲线弧长"></a>曲线弧长</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031345840.png" alt="image.png"></p><h2 id="常考题型-3"><a href="#常考题型-3" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="几何应用-1"><a href="#几何应用-1" class="headerlink" title="几何应用"></a>几何应用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用二重积分，先对x求积分，再对y求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031355804.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031401556.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427671.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031427969.png" alt="image.png"></p><h3 id="物理应用"><a href="#物理应用" class="headerlink" title="物理应用"></a>物理应用</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031500543.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031459946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031508079.png" alt="image.png"></p><h1 id="高数7-常微分方程"><a href="#高数7-常微分方程" class="headerlink" title="高数7-常微分方程"></a>高数7-常微分方程</h1><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031510341.png" alt="image.png"></p><h2 id="内容概要-5"><a href="#内容概要-5" class="headerlink" title="内容概要"></a>内容概要</h2><h3 id="常微分方程概念"><a href="#常微分方程概念" class="headerlink" title="常微分方程概念"></a>常微分方程概念</h3><hr><p><code>微分方程</code>：含有未知数导数的方程称为微分方程<br><code>微分方程的阶</code>：含有的未知数导数的最高阶导数的阶数<br><code>微分方程的解</code>：例如微分方程<code>y&#39;&#39;=e^x</code>，那么解可以是<code>y=e^x ，e^x + c1x , e^x + c1x + c2</code><br><code>微分方程的通解</code>：上面<code>y=e^x + c1x + c2</code>就是<code>y&#39;&#39;=e^x</code>的通解<br><code>微分方程的特解</code>：<code>y=e^x , e^x + c1x</code>都是特解<br><code>积分曲线</code>：微分方程的解对应的那条曲线就是微分方程的积分曲线</p><h3 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h3><hr><h4 id="可分离变量微分方程"><a href="#可分离变量微分方程" class="headerlink" title="可分离变量微分方程"></a>可分离变量微分方程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以将dx,dy分别移到两边，然后求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031657268.png" alt="image.png"></p><h4 id="齐次方程"><a href="#齐次方程" class="headerlink" title="齐次方程"></a>齐次方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031703516.png" alt="image.png"></p><h4 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031751173.png" alt="image.png"></p><h4 id="伯努利方程及全微分方程"><a href="#伯努利方程及全微分方程" class="headerlink" title="伯努利方程及全微分方程"></a>伯努利方程及全微分方程</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031759927.png" alt="image.png"></p><h3 id="可降阶方程"><a href="#可降阶方程" class="headerlink" title="可降阶方程"></a>可降阶方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最简单</span><br><span class="line">2.基本思路，将y&#x27;替换为P,转换为一阶微分方程计算</span><br><span class="line">3.令y&#x27;=P，则y&#x27;&#x27;=(dP/dy)*P   </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031811741.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031815908.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031823129.png" alt="image.png"></p><h3 id="高阶线性微分方程"><a href="#高阶线性微分方程" class="headerlink" title="高阶线性微分方程"></a>高阶线性微分方程</h3><h4 id="变系数线性微分方程"><a href="#变系数线性微分方程" class="headerlink" title="变系数线性微分方程"></a>变系数线性微分方程</h4><hr><p><code>齐次线性微分方程</code><br><code>非齐次线性微分方程</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">暂时还停留在理论层面，实际问题不好求特解</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031857961.png" alt="image.png"></p><h4 id="常系数齐次线性微分方程"><a href="#常系数齐次线性微分方程" class="headerlink" title="常系数齐次线性微分方程"></a>常系数齐次线性微分方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与线性齐次微分方程对比不同点，实际上就是，y导数的系数是常数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031901716.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031905608.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031925959.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031926834.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">三阶，三解，单独拆开看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305031944218.png" alt="image.png"></p><h4 id="常系数非齐次线性微分方程"><a href="#常系数非齐次线性微分方程" class="headerlink" title="常系数非齐次线性微分方程"></a>常系数非齐次线性微分方程</h4><hr><p>非齐次线性方程的解=<code>齐次通解</code>+<code>非齐次特解</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找特解</span><br><span class="line">1.k值看 λ 是几重根</span><br><span class="line">2.k值看 α+iβ 是几重根(α、β看f(x)里面的形式)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032048454.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.确定非齐次项类型</span><br><span class="line">2.根据特征方程特征根，得出齐次方程的通解</span><br><span class="line">3.设出合适非齐次特解，根据非齐次项得知 λ ,再根据λ比较特征方程的根，看是几重根,本题λ=0 != r,所以</span><br><span class="line">  k=0</span><br><span class="line">4.将假设的y*带回方程，求出系数</span><br><span class="line">5.非齐次线性方程的解=`齐次通解`+`非齐次特解`</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032101045.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032109778.png" alt="image.png"></p><h4 id="欧拉方程"><a href="#欧拉方程" class="headerlink" title="欧拉方程"></a>欧拉方程</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D^2--&gt;r^2</span><br><span class="line">D--&gt;r</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305032114735.png" alt="image.png"></p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202307131145843.png" alt="image.png"></p><h2 id="常考题型-4"><a href="#常考题型-4" class="headerlink" title="常考题型"></a>常考题型</h2><h3 id="方程求解"><a href="#方程求解" class="headerlink" title="方程求解"></a>方程求解</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的齐次方程求解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131818514.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断，首先是一阶微分方程 然后是中的线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131914887.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判别类型：二阶(导数是二阶导数)  线性  常系数 齐次 微分方程 </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305131903867.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">二阶 非齐次 线性 微分方程</span><br><span class="line">非其次项分为两种类型，因为非齐次线性微分方程的解具有叠加性</span><br><span class="line">所以可以分别设两种解，然后分别求出，再相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132117987.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">二阶齐次线性微分方程,选取对应方法</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132132649.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.首先判断(1/2)e^2x 只能是齐次的通解，因为如果是非齐次特解，那么代入方程得不到ce^x</span><br><span class="line">2.然后判断xe^x，是非齐次的特解，因为如果是齐次通解，由于是xe^x形式，原齐次特征方程特征根必然是二重根，且为1，但是之前已经知道一个齐次通解--&gt;其中一个根可知=2,；矛盾，所以必然是非齐次特解</span><br><span class="line">3.不难判断最后一个是齐次通解</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132147848.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经典例题，多看看</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132213446.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由二阶微分方程可知--&gt;y二阶可导--&gt;洛必达可以洛到一阶导数--&gt;2x/y&#x27;(0)--&gt;还是0/0型--&gt;由二阶微分方程可知y&#x27; y e^3x都连续，所以y&#x27;&#x27;也连续--&gt;所以可以洛到二阶导数--&gt;2/y&#x27;&#x27;(0)--&gt;2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132221621.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f括号里的变量和d后面的变量相同，就无所谓是t还是t/3。变量前面的d表示你对该变量求导。所以f(t)dt和f(t/3)dt是等价的表达式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132308460.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">综合性，很强</span><br><span class="line">1.令x-t=u，便于求导</span><br><span class="line">2.第二步处理，分开进行求导</span><br><span class="line">3.最终得到一阶线性方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305132321419.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.分析微分方程类型，二阶微分方程，但是没有y，不属于高阶类型，降阶，令y&#x27;=p,则y&#x27;&#x27;=p&#x27;</span><br><span class="line">2.得到xp&#x27;-p+2=0;--&gt;线性微分方程，带对应公式</span><br><span class="line">3.这一步关键，积分过程中x&gt;0,所得y通解x&gt;0,所以不能直接代入y(0),因为是连续函数，应该取极限</span><br><span class="line">得到C2=0，</span><br><span class="line">4.旋转体体积积分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305141104530.png" alt="image.png"></p><h1 id="高数8-多元函数微分学"><a href="#高数8-多元函数微分学" class="headerlink" title="高数8-多元函数微分学"></a>高数8-多元函数微分学</h1><h2 id="重极限-连续-偏导数-全微分"><a href="#重极限-连续-偏导数-全微分" class="headerlink" title="重极限-连续-偏导数-全微分"></a>重极限-连续-偏导数-全微分</h2><h3 id="多元函数的极限"><a href="#多元函数的极限" class="headerlink" title="多元函数的极限"></a>多元函数的极限</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">证明该重极限不存在(某点重极限存在，要函数延任意方向趋向于该点，极限都存在且相等)</span><br><span class="line">1.假设y=kx;(y延莫一条路径趋向于0，假设延kx路径，看看极限存不存在，如果不存在，极限就不存在)</span><br><span class="line">2.代入原式，得到极限=k/1+k^2</span><br><span class="line">3.由于极限随k变化而变化，所以极限不存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181231264.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常用下列建立不等式，然后夹逼</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308020934491.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308020935584.png" alt="image.png"></p><h3 id="多元函数的连续性"><a href="#多元函数的连续性" class="headerlink" title="多元函数的连续性"></a>多元函数的连续性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">与一元函数性质类似</span><br><span class="line">多元函数不考察间断点及其分类，因为过于复杂</span><br><span class="line">多元主要考察用定义判断，分段函数，在分界点上的连续性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181237219.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多元函数证明连续性问题</span><br><span class="line">1.如果是分段函数，利用该点的极限=该点函数值，即可证明是否连续</span><br><span class="line">2.这就需要用到，上面的多元函数求极限的方法--常用不等式，然后夹逼</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308020945645.png" alt="image.png"></p><h3 id="偏导数"><a href="#偏导数" class="headerlink" title="偏导数"></a>偏导数</h3><blockquote><p><strong><em>偏导数定义</em></strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数用的是偏增量</span><br><span class="line">偏导数本质上就是一元函数导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247801.png" alt="image.png"></p><p><strong><em>求偏导数，常常先代后求，求偏x导数，就将该点y0值先代入，因为y不影响偏x</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308020950925.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308020957656.png" alt="image.png"></p><blockquote><p><strong><em>偏导数几何意义</em></strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">偏导数几何意义</span><br><span class="line">偏x导数 : 作过y=y0垂直于xy平面的平面，与空间曲面上交于一曲线，这条曲线沿x轴方向的导数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181247505.png" alt="image.png"></p><blockquote><p><strong><em>高阶偏导数</em></strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果函数在D内连续，混合偏导数与偏导次序无关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181254091.png" alt="image.png"></p><h3 id="全微分"><a href="#全微分" class="headerlink" title="全微分"></a>全微分</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">定义法-判断二元函数是否可微？</span><br><span class="line">1.首先判断x、y的偏导数是否都存在，如果有1个不存在，肯定不可微</span><br><span class="line">2.两个偏导数存在，接着根据全微分定义，看O(ρ)是否是ρ的高阶无穷小，如果不是就不可微</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181401379.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021008696.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">充分条件-判断是否可微?</span><br><span class="line">两个偏导数在(x0,y0)处连续，则函数在(x0,y0)一定可微</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181405682.png" alt="image.png"></p><h3 id="连续-可偏导-可微关系"><a href="#连续-可偏导-可微关系" class="headerlink" title="连续-可偏导-可微关系"></a>连续-可偏导-可微关系</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181424194.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数存在(x、y方向偏导存在、可偏导)--&gt;可能会有缺失,所以可能不连续，可微更推不出</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181451922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续(四面八方不存在空缺)--&gt;面上可能有尖点，不存在切平面，也可能不存在切线</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181441922.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微--&gt;某点有切平面(一定连续、可导)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181440267.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏导数连续--&gt;等级最高</span><br></pre></td></tr></table></figure><h3 id="常考题型-5"><a href="#常考题型-5" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="题型1-讨论连续性、可导性、可微性"><a href="#题型1-讨论连续性、可导性、可微性" class="headerlink" title="题型1 讨论连续性、可导性、可微性"></a>题型1 讨论连续性、可导性、可微性</h4><blockquote><p><em>判断多元是否连续、可导、可微综合应用</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021053623.png" alt="image.png"></p><blockquote><p><em>定义判断是否可微<br>1.分别求出两个偏导数，是否都存在，一个不存在，肯定不可微<br>2.利用定义式，O(ρ)是否是ρ的高阶无穷小，如果不是就不可微</em></p></blockquote><p><em>A，说明函数在（0,0）连续；<br>B，说明两个偏导数存在<br>C，利用定义判定了可微<br>D，不能说明偏导数连续，偏导数连续应该是：lim(x-&gt;0,y-&gt;0) fx(x,y) - f x(0,0) =0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021107210.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021111775.png" alt="image.png"><br><em>由题目给出的形式，与判定是否可微的式子对照<br>原式没有A(x-x0)+B(y-y0)项，所以可以认为A=0,B=0,那么就可以得到原式<br>也就证明了函数可微</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021142062.png" alt="image.png"></p><blockquote><p><em>承接上面例子，作了一点变形</em><br><em>A，该极限存在，于可不可微不搭边<br>C，D,该极限存在于可不可微不搭边<br>B，上面例题，可微判定式变形</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021145594.png" alt="image.png"><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021148184.png" alt="image.png"></p><p><em>再变形<br>1.通过函数连续，得到f(0,1)=1<br>2将原始凑成可微判定式形式<br>3.dz=Adx+Bdy</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021153285.png" alt="image.png"></p><p><em>超级难题</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021301510.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021301595.png" alt="image.png"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断在点(0,0)连不连续： 求x-&gt;0,y-&gt;0 时，函数的极限。该极限之前求过，不存在，所以不连续</span><br><span class="line">2.判断在点(0,0)处偏导数存不存在，用定义式，先求偏x，令y=0代入，发现分子恒=0，分母趋近与0却不等于0，所以极限=0.偏x导数存在；接着求p偏y，令x=0...</span><br><span class="line">3.最后得出不连续，偏导存在</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181746558.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181754311.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种填空题，一眼令f(x,y)=2x-y+2, dz=Adx+Bdy</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181824197.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.直接法</span><br><span class="line">题目对x偏导数&gt;0 ,说明z随x增大而增大;偏y&lt;0,随y增大而减小</span><br><span class="line"></span><br><span class="line">2.特殊方程法</span><br><span class="line">根据题目要求，设一个函数，代入数值求证</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181859413.png" alt="image.png"></p><h4 id="四个经典反例"><a href="#四个经典反例" class="headerlink" title="四个经典反例"></a>四个经典反例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">连续，但不可导</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181842665.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可导但不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181843326.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可导但不可微例子</span><br><span class="line"></span><br><span class="line">1.先判断可不可微，两部曲--a.判断两个偏导存不存在 b.求(△z-A△x-B△y)/(△x^2 +△y^2)^1/2</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181841705.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可微但偏导数不连续</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181854359.png" alt="image.png"></p><h2 id="多元函数微分法"><a href="#多元函数微分法" class="headerlink" title="多元函数微分法"></a>多元函数微分法</h2><h3 id="复合函数微分法"><a href="#复合函数微分法" class="headerlink" title="复合函数微分法"></a>复合函数微分法</h3><p><em>微分形式不变性要理解— 举个例子：dz =(∂z/∂x)dx +(∂z/∂y)dy ==&gt;<br>dz =(∂z/∂u)du +(∂z/∂v)dv =(∂z/∂u)(∂u/∂x)dx + (∂z/∂v)(∂v/∂x)dx =(∂z/∂x)dx +(∂z/∂y)dy；这就是微分形式不变性</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192118819.png" alt="image.png"></p><h3 id="隐函数微分法"><a href="#隐函数微分法" class="headerlink" title="隐函数微分法"></a>隐函数微分法</h3><blockquote><p><strong><em>由一个方程所确定的隐函数</em></strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.如何判断谁是谁的函数？</span><br><span class="line">F&#x27;z(x0,y0,z0)!=0 ==&gt; 说明z是x、y的函数 =&gt;z=f(x,y)</span><br><span class="line">同理如果F&#x27;x(x0,y0,z0) != 0 ==&gt; 说明x是y、z的函数 ==&gt;x=f(y,z)</span><br><span class="line"></span><br><span class="line">2.由方程F(x,y,z)=0 确定的隐函数z=z(x,y)</span><br><span class="line">a.该函数在点P(x0,y0,z0)的某一领域内有连续偏导数</span><br><span class="line">b.F(x0,y0,z0)=0</span><br><span class="line">c.Fz&#x27;(x0,y0,z0)!=0</span><br><span class="line">==&gt;则方程F(x,y,z)=0,在点P(x0,y0,z0)的某一邻域可</span><br><span class="line">   唯一确定一个具有连续偏导数的函数 z=z(x,y)</span><br></pre></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021710383.png" alt="image.png"></p><p><strong><em>由方程组所确定的隐函数</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021715542.png" alt="image.png"></p></blockquote><h3 id="常考题型-6"><a href="#常考题型-6" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="复合函数偏导数与全微分"><a href="#复合函数偏导数与全微分" class="headerlink" title="复合函数偏导数与全微分"></a>复合函数偏导数与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1.直接导两次</span><br><span class="line">方法2.先导一次，然后将y=2代入--&gt;只剩下x的函数--&gt;求x=0时的导数--&gt;运用导数定义</span><br><span class="line">      --&gt;求x=0处导数--&gt; f(x)-f(0)/x-0 --&gt; 求极限=4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192147510.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法1.换元</span><br><span class="line">考到了微分的有理运算法则</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192210116.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192220636.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">∂z/∂x = (∂z/∂u)*(∂u/∂/x)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192233290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数z=f(u,v)</span><br><span class="line">fu&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f1&#x27; </span><br><span class="line">fv&#x27;依然是u v的函数,通常习惯将fu&#x27;写为f2&#x27;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192245416.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例5</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192300736.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f12&#x27;=f21&#x27;本质是一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192317760.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这种求具体某一点的二阶偏导数</span><br><span class="line">可以先求出一阶偏x导数之后，代入x的值</span><br><span class="line">然后继续求偏y，不影响，更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192329042.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.多元复合求偏导</span><br><span class="line">2.微分方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336697.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192336916.png" alt="image.png"></p><h4 id="隐函数偏导与全微分"><a href="#隐函数偏导与全微分" class="headerlink" title="隐函数偏导与全微分"></a>隐函数偏导与全微分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法1.微分形式不变性</span><br><span class="line"></span><br><span class="line">两边dK=dM ,看做两个新函数，x,y,z为变量</span><br><span class="line">同时求全微分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201615692.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2.先代后求</span><br><span class="line">利用全微分定义</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201627288.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">隐函数求偏微分三种方法应用</span><br><span class="line">1.两边对x求导</span><br><span class="line">2.代隐函数偏导数公式</span><br><span class="line">3.两边求全微分(微分形式不变性)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305201637250.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252222727.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">例13.</span><br><span class="line">方法1.使用隐函数偏导数公式。写成F(x,y,z)=0的形式--&gt;代偏导公式--&gt;再利用全微分公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246104.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法2.利用微分形式不变，对两边求微分，求出dz</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252246977.png" alt="image.png"></p><h3 id="强化题型-1"><a href="#强化题型-1" class="headerlink" title="强化题型"></a>强化题型</h3><h4 id="题型1-求一点处的偏导数与全微分"><a href="#题型1-求一点处的偏导数与全微分" class="headerlink" title="题型1-求一点处的偏导数与全微分"></a><em>题型1-求一点处的偏导数与全微分</em></h4><blockquote><p><em>就是给了一个具体点，直接代入，求出一个导数值，不需要写出偏导数表达式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021721683.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021725441.png" alt="image.png"></p><h4 id="题型2-求已给出具体表达式函数的偏导数与全微分"><a href="#题型2-求已给出具体表达式函数的偏导数与全微分" class="headerlink" title="题型2-求已给出具体表达式函数的偏导数与全微分"></a><em>题型2-求已给出具体表达式函数的偏导数与全微分</em></h4><blockquote><p><em>就是不给具体点，求出所有偏导数的表达式</em></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021738670.png" alt="image.png"></p><p><em>知道偏导数，求函数本身—&gt;逆向偏积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021742104.png" alt="image.png"></p><p><em>条件是，某个函数全微分，可以通过混合偏导相等的性质，解出未知数，得到原函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021756795.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021754658.png" alt="image.png"></p><h4 id="题型3-含有抽象函数的符合函数偏导数与全微分"><a href="#题型3-含有抽象函数的符合函数偏导数与全微分" class="headerlink" title="题型3-含有抽象函数的符合函数偏导数与全微分"></a><em>题型3-含有抽象函数的符合函数偏导数与全微分</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021916614.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021922763.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021925380.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021935301.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021937046.png" alt="image.png"></p><p><em>有些特别</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021948456.png" alt="image.png"></p><p><em>u仅为r的函数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308021957742.png" alt="image.png"></p><p><em>重要结论：<strong>f(x,y)是n次齐次函数时 &lt;=&gt;有 x( ∂f/∂x) +y (∂f/∂y) =n f(x,y)</strong></em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022047550.png" alt="image.png"></p><p><em>利用到了上面的结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022051004.png" alt="image.png"></p><h4 id="题型4-隐函数的偏导数与全微分"><a href="#题型4-隐函数的偏导数与全微分" class="headerlink" title="题型4-隐函数的偏导数与全微分"></a><em>题型4-隐函数的偏导数与全微分</em></h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022055659.png" alt="image.png"></p><p><em>积分的逆过程就是微分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022101245.png" alt="image.png"></p><p><em>微分形式不变性的优越性，在于不需要理清楚变量之间的关系</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022125331.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022125261.png" alt="image.png"></p><p><em>难点在于，将f(x,y)=C为一条直线，得到隐函数y=y(x)的二阶导数=0</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022129467.png" alt="image.png"></p><h2 id="多元函数的极值与最值"><a href="#多元函数的极值与最值" class="headerlink" title="多元函数的极值与最值"></a>多元函数的极值与最值</h2><hr><h3 id="无约束极值"><a href="#无约束极值" class="headerlink" title="无约束极值"></a>无约束极值</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252310840.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">对于二元函数,极值不一定是驻点，驻点不一定是极值</span><br><span class="line">驻点推不出极值，典例xy</span><br><span class="line">极值推不出驻点，典例|x|+|y|</span><br><span class="line"></span><br><span class="line">极值点有三种可能</span><br><span class="line">1.驻点</span><br><span class="line">2.fx&#x27;与fy&#x27;都不存在的点</span><br><span class="line">3.fx=0,且fy不存在;或fy=0且fx不存在的点</span><br><span class="line"></span><br><span class="line">一般只考察第一种可能</span><br><span class="line">--&gt;如何判断驻点是极大值还是极小值还是有没有极值</span><br><span class="line">--&gt;下面这个公式</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252311524.png" alt="image.png"></p><h3 id="有条件极值与拉格朗日数乘法"><a href="#有条件极值与拉格朗日数乘法" class="headerlink" title="有条件极值与拉格朗日数乘法"></a>有条件极值与拉格朗日数乘法</h3><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">条件极值概念，在某一个约束条件下，函数的极值。</span><br><span class="line"></span><br><span class="line">例如下面这幅图，φ(x,y)=0的条件--&gt;得到一条曲线--&gt;在这条曲线对应的x,y范围内求f(x,y)的极值，这种极值被称为条件极值。</span><br><span class="line"></span><br><span class="line">如何求条件极值？</span><br><span class="line">--&gt;将f(x,y)与φ(x,y)两个函数写成非条件极值的形式</span><br><span class="line">--&gt;F(x,y,λ)分别对x,y,λ求偏导=0，</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br><span class="line"></span><br><span class="line">如果有两个约束条件呢？</span><br><span class="line">--&gt;那就假设四个变量的函数F(x,y,λ,Φ)</span><br><span class="line">--&gt;分别对四个变求偏导数，分别都等于0</span><br><span class="line">--&gt;就能求出可能存在的极值点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305252334882.png" alt="image.png"></p><h3 id="最大值最小值"><a href="#最大值最小值" class="headerlink" title="最大值最小值"></a>最大值最小值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261155130.png" alt="image.png"></p><h3 id="常考题型-7"><a href="#常考题型-7" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="求极值"><a href="#求极值" class="headerlink" title="求极值"></a>求极值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法1.</span><br><span class="line">根据题目可知全微分dz=xdx+ydy --&gt; fx&#x27;=x ;fy&#x27;=y --&gt; 代入点(0,0) --&gt; 两个偏导数都为0，是驻点(满足了极值点必要条件) --&gt; 接着求二阶偏导数，利用公式AC-B^2 ,判断时极小值还是极大值</span><br><span class="line"></span><br><span class="line">方法2.偏积分(找函数本身)</span><br><span class="line">方法3.凑微分(找函数本身)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261206463.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261222061.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例3</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261227562.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261239426.png" alt="image.png"></p><h4 id="求最大最小值"><a href="#求最大最小值" class="headerlink" title="求最大最小值"></a>求最大最小值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不考条件极值而考条件最值？</span><br><span class="line">因为求得了驻点，我们无法判断时极大还是极小值。而一个问题如果存在最大值，那么驻点必是最值，所以可以根据最值必存在，推出该驻点是最大还是最小值</span><br><span class="line"></span><br><span class="line">根据条件约束--&gt;写出拉格朗日数乘法--&gt;求出所有可能极值点--&gt;再根据题目隐含意思推出该极值点大概是极大值还是极小值(注意这里没有公式可以得知是极大值还是极小值)。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261248743.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">求连续二元函数闭区域D上的最大最小值</span><br><span class="line">1.求出D内所有可能极值点</span><br><span class="line">2.求D边沿的最大最小值</span><br><span class="line">3.比较</span><br><span class="line"></span><br><span class="line">像这种全微分为dz=2xdx - 2ydy --&gt;全微分存在说明可微--&gt;fx&#x27;=2x ;fy&#x27;=2y --&gt;驻点只有(0,0),是唯一驻点--&gt;可微说明函数光滑，接着驻点唯一，说明驻点要么是最大值或最小值或单调的水平过渡点。--&gt;意味着二元函数要么是单调的或凸的或凹的--&gt;这些情况都只需要我们求出边界上的极值点与驻点一比较就能得出最大值，最小值</span><br><span class="line"></span><br><span class="line">有两种方法：</span><br><span class="line">方法1.得出驻点之后，根据约束条件函数，将x或y代换，转变为一元函数化条件为无条件，在求边界最值。</span><br><span class="line">方法2.得出驻点之后，构造拉格朗日数乘法，求出边界极值</span><br><span class="line">方法3.参数方程，化条件为无条件，出现这种椭圆的可以转化为参数方程</span><br><span class="line"></span><br><span class="line">最终在与驻点函数值比较</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301211.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305261301186.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305262253388.png" alt="image.png"></p><h3 id="强化题型-2"><a href="#强化题型-2" class="headerlink" title="强化题型"></a>强化题型</h3><h4 id="题型1-求无条件极值"><a href="#题型1-求无条件极值" class="headerlink" title="题型1-求无条件极值"></a><em>题型1-求无条件极值</em></h4><p><em>求无条件极值普通版</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022147910.png" alt="image.png"></p><p><em>特殊的，是隐函数求极值，所以还是按照方法<br>1.求得 令 隐函数z=z(x,y)的导数等于0 ，所得到驻点 ,—&gt;这里利用的是两边对x求导，也可以带公式<br>2.在得到驻点后，求隐函数 二阶偏导 (还是等式两边求导，方法很多)，通过判别式判断极大极小</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308022143212.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031034142.png" alt="image.png"></p></blockquote><p><em>利用保号性，直接得出极大值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031045355.png" alt="image.png"></p><p><em>极值点附近邻域内一定是同号</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031103910.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031102966.png" alt="image.png"></p><h4 id="题型2-求最大最小值"><a href="#题型2-求最大最小值" class="headerlink" title="题型2-求最大最小值"></a><em>题型2-求最大最小值</em></h4><p><em>分析过程<br>1.根据条件呼出区域D<br>2.分析区域内部与边界，分别分析。令俩偏导数=0，得驻点位于(0,y)、(4,0)、(2,1),只有(2,1)是区域内驻点，且是唯一驻点，那么在区域内(2,1)必定是极大/极小值<br>3.再讨论边界上的点，求得x=0时，z=0 ; x=4时，z=-64 ;<br>4.结合z(2,1)=4,  函数区域与边界是连续的，所以最大值=4，最小值=-64</em><br><strong><em>这题的限制条件是直线，所以很好将y用x换，可以不用拉格朗日数乘法</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031116894.png" alt="image.png"></p><p><strong><em>当限制条件是一个曲线，比如圆，只能通过拉个朗日数乘法来转换为无条件极值</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031147176.png" alt="image.png"></p><p><em>距离公式，目标函数简化</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031201168.png" alt="image.png"></p><p><em>三角形面积公式—海伦公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031227414.png" alt="image.png"></p><p><em>条件极值证明不等式<br>思路：利用其中一边作为约束条件，构建拉格朗日数乘法，求左边的极大值，并且计算其最大值不会超过右边</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308031237719.png" alt="image.png"></p><h1 id="高数9-二重积分"><a href="#高数9-二重积分" class="headerlink" title="高数9-二重积分"></a>高数9-二重积分</h1><h2 id="二重积分的概念和性质"><a href="#二重积分的概念和性质" class="headerlink" title="二重积分的概念和性质"></a>二重积分的概念和性质</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二重积分几何意义：区域D内，以函数为顶的，这个圆柱体的体积</span><br><span class="line">二重积分的性质：不等式性质、中值定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282116780.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282118635.png" alt="image.png"></p><h2 id="二重积分的计算"><a href="#二重积分的计算" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h2><h3 id="利用直角坐标计算"><a href="#利用直角坐标计算" class="headerlink" title="利用直角坐标计算"></a>利用直角坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149154.png" alt="image.png"></p><h3 id="利用极坐标计算"><a href="#利用极坐标计算" class="headerlink" title="利用极坐标计算"></a>利用极坐标计算</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282149068.png" alt="image.png"></p><h4 id="适合极坐标计算的二重积分特征"><a href="#适合极坐标计算的二重积分特征" class="headerlink" title="适合极坐标计算的二重积分特征"></a>适合极坐标计算的二重积分特征</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282134528.png" alt="image.png"></p><h3 id="利用对称性奇偶性计算"><a href="#利用对称性奇偶性计算" class="headerlink" title="利用对称性奇偶性计算"></a>利用对称性奇偶性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.如果积分区域关于y轴对称</span><br><span class="line">- f(x,y)为关于x是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于x是奇函数--&gt; 积分就等于0</span><br><span class="line">2.如果积分区域关于x轴对称</span><br><span class="line">- f(x,y)为关于y是偶函数--&gt; 积分就等于两倍其中一侧的积分</span><br><span class="line">- f(x,y)为关于y是奇函数--&gt; 积分就等于0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282145694.png" alt="image.png"></p><h3 id="利用变量对称性计算"><a href="#利用变量对称性计算" class="headerlink" title="利用变量对称性计算"></a>利用变量对称性计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量对称性也称轮换对称性</span><br><span class="line">积分区域关于y=x对称就有如下性质</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282204438.png" alt="image.png"></p><h3 id="常考题型-8"><a href="#常考题型-8" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="累次积分交换次序或计算"><a href="#累次积分交换次序或计算" class="headerlink" title="累次积分交换次序或计算"></a>累次积分交换次序或计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.根据积分上下限，画出积分区域</span><br><span class="line">2.根据积分区域重新定限</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305282210754.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302117455.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">极坐标转化为直角坐标--&gt;画域</span><br><span class="line">右边对ρ积分下限=0 ;对ρ积分上限=cosx;</span><br><span class="line">ρcosθ=0 --&gt; x=0 --&gt;积分区域在x=0上方</span><br><span class="line">ρ^2=x^2+y^2=ρcosθ=x --&gt; 积分区域在x^2+y^2=x的下方</span><br><span class="line">--&gt;最终就是如图所示的半圆区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302126758.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这题是将直角坐标转化为极坐标</span><br><span class="line">对y=0 --&gt; ρsinθ =0 --&gt; ρ=0</span><br><span class="line">y=(2x-x^2)^0.5 --&gt; y^2=2x-x^2 --&gt; ρ=2cosθ</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302143241.png" alt="image.png"></p><h4 id="二重积分的计算-1"><a href="#二重积分的计算-1" class="headerlink" title="二重积分的计算"></a>二重积分的计算</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用轮换对称性质+奇偶对称性</span><br><span class="line">1.积分区域(圆)关于y=x对称</span><br><span class="line">2.因为y是关于y轴的奇函数，积分区域关于y，所以对称积分为0</span><br><span class="line">3.轮换对称，对x^2积分=对y^2积分=1/2(x^2+y^2)积分 --&gt;转换成极坐标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302208501.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域--&gt;划分为关于y轴对称的区域+关于x轴对称的区域</span><br><span class="line">2.对xy积分，x是关于x轴的奇函数，y是关于y轴的奇函数--&gt;所以两个部分积分区域积分=0</span><br><span class="line">3.对cosxsiny积分，siny是关于y轴的奇函数，cosx是关于x轴的偶函数--&gt;所以关于x轴对称积分区域=0；只剩下关于y轴对称的积分区域的积分</span><br><span class="line">4.就如A选项</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302217243.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分区域,积分区域关于y轴对称</span><br><span class="line">2.将被积函数拆开--&gt;x^2 + 2x + 1 ,其中2x是关于x轴的奇函数,积分区域有时关于y轴对称,</span><br><span class="line">  2x积分=0</span><br><span class="line">3.剩下x^2 + 1,关于x轴的偶函数--&gt;由于积分区域是圆--&gt;化成极坐标好做一点</span><br><span class="line">4.最后点火公式带走</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302233155.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">根据区域判断被积函数绝对值正负</span><br><span class="line">1.画出的积分区域是一个正方形</span><br><span class="line">2.被积函数有绝对值，所以要讨论函数的正负性</span><br><span class="line">3.发现被积函数是一个圆，小于圆时为负，入D1区域;大于该圆的部分为正，如D2区域</span><br><span class="line">4.于是分开两个区域讨论,圆内的区域，被积函数为负，圆外的积分区域，被积函数为正</span><br><span class="line">5.其中D1部分区域的积分用极坐标，D2部分积分化为正方形区域-圆的区域</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302253981.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302311344.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finashing...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305302314653.png" alt="image.png"></p><h1 id="高数10-无穷级数"><a href="#高数10-无穷级数" class="headerlink" title="高数10-无穷级数"></a>高数10-无穷级数</h1><h2 id="常数项级数"><a href="#常数项级数" class="headerlink" title="常数项级数"></a>常数项级数</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061714753.png" alt="image.png"></p><h3 id="级数概念"><a href="#级数概念" class="headerlink" title="级数概念"></a>级数概念</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是无穷多个常数项相加</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720100.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061720954.png" alt="image.png"></p><h3 id="级数的性质"><a href="#级数的性质" class="headerlink" title="级数的性质"></a>级数的性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.若一个级数收敛，则其每一项相都乘以常数k,这个级数任然收敛</span><br><span class="line"></span><br><span class="line">2.两个级数收敛，相加相减之后任然收敛，收敛于他们各自极限的和或差</span><br><span class="line"></span><br><span class="line">3.去掉或加上改变有限项不影响级数的敛散性--&gt;也就是说只有后面无穷多项会影响敛散性</span><br><span class="line"></span><br><span class="line">4.收敛级数加括号任然收敛，但是加括号收敛无法推出原级数收敛</span><br><span class="line"></span><br><span class="line">5.如果一个级数收敛--&gt;它的第n项(n趋于无穷)，一定趋近于0</span><br><span class="line">  但是通项趋近于0，不能得到级数收敛(例如∑1/n)</span><br><span class="line">  通项不趋近于0，一定发散</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061730770.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061742981.png" alt="image.png"></p><h3 id="级数的审敛准则"><a href="#级数的审敛准则" class="headerlink" title="级数的审敛准则"></a>级数的审敛准则</h3><h4 id="正项级数"><a href="#正项级数" class="headerlink" title="正项级数"></a>正项级数</h4><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.比较判别法</span><br><span class="line">2.比较法的极限形式</span><br><span class="line">3.比值法</span><br><span class="line">4.根值法</span><br><span class="line">5.积分判别法</span><br><span class="line"></span><br><span class="line">5不常用，1，2,3,4做题比较常用</span><br><span class="line"></span><br><span class="line">1,2 适用范围广 但不方便(因为要找别的函数比较)</span><br><span class="line">3,4 适用范围窄 但方便比较(直接和自己比较)</span><br><span class="line"></span><br><span class="line">通常做题先用3,4 然后做不出再用1,2</span><br><span class="line"></span><br><span class="line">出现a^n 、n! 、n^n --&gt;使用3,4 </span><br><span class="line">出现n^p 、ln n 使用1,2</span><br><span class="line"></span><br><span class="line">正项级数与负项级数本质一样，只不过多个负号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061800727.png" alt="image.png"></p><ul><li><strong><em>比值法收到等比数列级数的启发：关注的是比值</em></strong></li><li><strong><em>根值法也收到等比数列级数启发：√(aq^n) ，当n-&gt;∞，开根号就=q比值，当比值&gt;1，发散，&lt;1收敛</em></strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061801216.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802574.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061802116.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061816942.png" alt="image.png"></li></ul><h4 id="交错级数"><a href="#交错级数" class="headerlink" title="交错级数"></a>交错级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">交错级数--&gt;正负项交替出现，有规律的级数</span><br><span class="line">莱布尼兹准则：</span><br><span class="line">1.若Un单调减小，且趋近于无穷是Un趋近于0，--&gt; 交错级数收敛</span><br><span class="line">2.但是反过来，交错级数收敛无法推出，Un递减</span><br><span class="line">为什么交错级数，Un递减，且Un趋近于0才能推出交错级数收敛？</span><br><span class="line">因为如果Un递减，但不趋向于0而如果是趋向于1，那么级数会在-1 1之间摇摆不可能收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061902443.png" alt="image.png"></p><h4 id="任意项级数"><a href="#任意项级数" class="headerlink" title="任意项级数"></a>任意项级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">任意项级数--&gt;有正项有负项，正负项没有规律，正负项都是无穷项</span><br><span class="line">- 既然没有规律，那应该怎么判定是否收敛呢？</span><br><span class="line">- 引入绝对收敛和条件收敛：</span><br><span class="line">1.绝对收敛: 当级数的绝对值收敛那么原级数一定收敛，称原级数绝对收敛</span><br><span class="line">2.条件收敛：如果原级数是收敛的，但是他的绝对值是发散的，那么是条件收敛</span><br><span class="line">- 基本结论： </span><br><span class="line">- 绝对收敛的级数一定是收敛的</span><br><span class="line">- 条件收敛的级数，它的正项构成的级数发散，负向构成的级数也发散</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306061917627.png" alt="image.png"></p><h2 id="常考题型-9"><a href="#常考题型-9" class="headerlink" title="常考题型"></a>常考题型</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062156822.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062217881.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062226142.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A.bn收敛 举反例bn=(-1)^n/√n ; an=(-1)^n/√n =&gt;相乘-调和级数1/n 发散</span><br><span class="line"></span><br><span class="line">B.举反例bn=1/n ;an=1/n =&gt; 相乘1/n^2 收敛</span><br><span class="line"></span><br><span class="line">C.</span><br><span class="line">首先</span><br><span class="line">∑|bn| 收敛 =&gt; |bn|-&gt;0 =&gt; |bn|&lt;1 =&gt; |bn|&gt;bn^2 大收则小收</span><br><span class="line">然后</span><br><span class="line">an-&gt;0 =&gt; |an|&lt;1 =&gt; a^2&lt;1 =&gt; an^2bn^2&lt;bn^2  </span><br><span class="line"></span><br><span class="line">D.举反例，与上面反例类似</span><br><span class="line"></span><br><span class="line">总结：常用结论--&gt; |bn|收敛=&gt; bn^2收敛</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062230522.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202306062257669.png" alt="image.png"></p><h2 id="强化题型-3"><a href="#强化题型-3" class="headerlink" title="强化题型"></a>强化题型</h2><h3 id="题型1-正项级数敛散性判定"><a href="#题型1-正项级数敛散性判定" class="headerlink" title="题型1-正项级数敛散性判定"></a><em>题型1-正项级数敛散性判定</em></h3><blockquote><p><em>(1)</em><br><em>$n^n$型，适合根值法</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051655969.png" alt="image.png"><br><em>(2)</em><br><em>$a^n$、$n!$ 型适合比值法</em><br><em>最后，a=e时，比值=1，可能收敛，这时，判断数列是单调增加的，且大于0<br>，所以无穷项不会趋向于0，就不会收敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051701099.png" alt="image.png"><br><em>(3)</em><br><em>利用等价代换？—&gt;依据 比较法的极限形式，极限=1，同敛散</em><br><em>等价代换后，是一个p级数，$\frac{1}{n^p}$,p&gt;1，收敛</em><br><em>(4)</em><br><em>转化为与积分同敛散</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051729840.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051739713.png" alt="image.png"></p><p><em>1.位置数列项与已知项乘积=常数；转化为相比形式，根据得出同敛散的级数<br>2.这个同敛散的级数是一个p级数，2nsin1/n ~ 2 ,所以是1/n^2 ，取一个略小与2，例如1/n^(3/2)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051758380.png" alt="image.png"></p></blockquote><h3 id="题型2-交错级数敛散性的判定"><a href="#题型2-交错级数敛散性的判定" class="headerlink" title="题型2-交错级数敛散性的判定"></a><em>题型2-交错级数敛散性的判定</em></h3><blockquote><p><em>莱布尼茨公式—，只要交错级数的数值部分（绝对值）是单调减小的，且极限趋近0，那么该交错级数就是收敛，不同于正项级数敛散性，交错级数的要求更低(因为正项级数不仅需&lt;单调减小,趋近于0&gt;,还需要通过5种审敛方法，来判定是否收敛)</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051818153.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051820251.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051823497.png" alt="image.png"></p></blockquote><h3 id="题型3-任意项级数敛散性的判定"><a href="#题型3-任意项级数敛散性的判定" class="headerlink" title="题型3-任意项级数敛散性的判定"></a>题型3-<em>任意项级数敛散性的判定</em></h3><blockquote><p><em>任意项级数由于有正有负，且没有规律，所以要证明收敛，就间接证明级数的绝对值是收敛的，那么小的就业一定收敛；接着这题来一个放缩；再一个等价代换；再利用对正项级数根植审敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051854382.png" alt="image.png"></p><p><em>通过比值审敛法，得出的绝对值发散，必然原级数发散；<br>不是说绝对值发散，不能保证原级数发散吗？<br>是这样的，但是通过比值法，可以另外知道，级数项是不趋于0的，而无穷项趋于0，是级数收敛的必要条件，所以可以知到原级数也是发散的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051917519.png" alt="image.png"></p><p>*典型的交错级数，1.Un递减  2.趋近于0  —&gt;所以收敛<br>在根据规则</p><ol><li>绝对收敛±条件收敛=条件收敛<br>2.绝对收敛±绝对收敛=绝对收敛<br>3.条件收敛±条件收敛=条件或绝对收敛*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051926477.png" alt="image.png"></li></ol><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308051936851.png" alt="image.png"></p><p><em>D肯定正确，收敛+收敛=收敛<br>B，要成立，需要题目条件的级数，是正项级数，或者绝对收敛<br>C，反例1-1/2+1/3-1/4… 交错p级数，本来是收敛的，但是…就不收敛了</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052000376.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052123707.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052123170.png" alt="image.png"></p></blockquote><h3 id="题型4-证明题与综合题"><a href="#题型4-证明题与综合题" class="headerlink" title="题型4-证明题与综合题"></a><em>题型4-证明题与综合题</em></h3><blockquote><p><em>遇到相减的，首先想到级数定义，展开消去</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052131582.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052138531.png" alt="image.png"></p><p><em>关键点：1.有界、单调，证明极限存在<br>2.放缩，转化通项相减，大收则小收</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052158440.png" alt="image.png"></p><p><em>根据条件可知f(0)=0,f(‘0)=0,直接泰勒展开，只留下f‘’(α)项，由于二阶导数领域内连续所以有界，设为M ，|f(1/n)|&lt;=M/2 (1/n^2)，小于p级数，且p&gt;2，所以收敛，既然绝对值收敛，那么绝对收敛</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308052206818.png" alt="image.png"></p></blockquote><h2 id="幂级数"><a href="#幂级数" class="headerlink" title="幂级数"></a>幂级数</h2><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102219380.png" alt="image.png"></p><h3 id="幂级数的收敛半径、收敛区间、收敛域"><a href="#幂级数的收敛半径、收敛区间、收敛域" class="headerlink" title="幂级数的收敛半径、收敛区间、收敛域"></a>幂级数的收敛半径、收敛区间、收敛域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么不直接讨论改幂级数是收敛还是发散？</span><br><span class="line">因为幂级数∑an*x^n, 当x=1时，他就是一个常数项级数 a1,a2,a3,a4...an</span><br><span class="line">当x=2,就是一个另外一个常数项级数2a1,4a2,8a3,...</span><br><span class="line">--&gt;因为x是变化的，所以只能讨论x取什么时，级数的敛散性--&gt;也就是讨论收敛半径、区</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102220953.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">定理1(阿贝尔定理)：</span><br><span class="line">(1) x=x0(x0!=0),时收敛，则当|x|&lt;|x0|时,幂级数就是绝对收敛的</span><br><span class="line">(2) x=x0,时发散，则|x|&gt;|x0|时，幂级数发散</span><br><span class="line"></span><br><span class="line">定理2.</span><br><span class="line">幂级数的收敛性有且仅有一下三种可能</span><br><span class="line">(1).要么R上都收敛</span><br><span class="line">(2).要么只在x=0收敛</span><br><span class="line">(3).要么只在一个半径内收敛</span><br><span class="line">注意：如果幂级数在点x=x0出条件收敛，则点x0必为幂级数收敛区间(-R,R)上的一端点</span><br><span class="line"></span><br><span class="line">定理3.lim an+1/an = ρ，则收敛半径R=1/ρ </span><br><span class="line">因为假如R=1/2，那么x=1/3时，是收敛的，级数∑an*(1/3)^n --&gt; 比值法</span><br><span class="line">设bn+1=an+1*(1/3)^n+1 ，bn=an*(1/3)^n  ;bn+1/bn= (1/3)an+1/an=2/3&lt;1,收敛成</span><br><span class="line">立</span><br><span class="line">定理4.如果lim|an|^(1/n)=ρ，则收敛半径R=1/ρ</span><br><span class="line">--&gt;根值法证明</span><br><span class="line"></span><br><span class="line">概念：</span><br><span class="line">收敛半径:R </span><br><span class="line">收敛区间:(-R,R) --&gt;区间都是是开的区间</span><br><span class="line">收敛域：需要确定端点x=-R,x=R，处是否收敛，确定区间闭合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102237267.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102244221.png" alt="image.png"></p><h3 id="幂级数的性质"><a href="#幂级数的性质" class="headerlink" title="幂级数的性质"></a>幂级数的性质</h3><hr><h4 id="有理运算性质"><a href="#有理运算性质" class="headerlink" title="有理运算性质"></a>有理运算性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当幂级数A,收敛半径R1!,幂级数B收敛半径R2,R1!=R2,时</span><br><span class="line">令R=min&#123;R1,R2&#125;,当x∈(-R,R)</span><br><span class="line">1.幂级数加减法后新的幂级数的收敛半径=R</span><br><span class="line">2.乘除法一样</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102317028.png" alt="image.png"></p><h4 id="分析性质"><a href="#分析性质" class="headerlink" title="分析性质"></a>分析性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">幂级数的收敛半径为R,和函数S(x)有一下性质</span><br><span class="line">1.连续性：&lt;收敛域内&gt;</span><br><span class="line">和函数S(x)在收敛域内连续</span><br><span class="line"></span><br><span class="line">2.可导性：(任意阶可导) &lt;收敛区间内&gt;</span><br><span class="line">和函数S(x)在(-R,R)上可导，且逐项可导，半径不变</span><br><span class="line">例如S&#x27;(x)=(∑an*x^n)&#x27;=∑(an*x^n)&#x27;=∑n*an*x^n-1 --&gt;任然是幂级数，收敛半径任</span><br><span class="line">然与an有关，ρ=lim an+1/an, R=1/ρ不变 --&gt;所以是任意阶可导(可一直导下去)</span><br><span class="line">3.可积分性：&lt;收敛域内&gt;</span><br><span class="line">可导性逆过程</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306102330711.png" alt="image.png"></p><h3 id="函数的幂级数的展开"><a href="#函数的幂级数的展开" class="headerlink" title="函数的幂级数的展开"></a>函数的幂级数的展开</h3><p><strong>泰勒公式的定义</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111216906.png" alt="image.png"><br>我们常说求极限0/0可以用泰勒展开，为什么呢？<br>    这样去想，因为将函数展开为幂级数，∑an (x-x0)^n ,其中x=x0时，必有级数收敛且=0<br>    lim(x-&gt;1/3) sinx<br>        1.首先确定展开级数∑an (x-x0)^n =0 ,sinx-&gt;0时，x-&gt;0，收敛中心x0=0<br>        2.接着，x-&gt;1/3,展开级数∑an (x-x0)^n=∑an (x)^n = ∑an (1/3)^n<br>    lim(x-&gt;1/3) x/sin(x-1)</p><pre><code>    - 求sin(x-1/3)极限为什么不能直接套上面的展开式呢？    - 因为sin(x-1)展开级数∑an (x-1)^n =0 ，收敛中心是x0=1    - 接着，x-&gt;1/3,其展开级数为∑an (x-x0)^n=∑an (x-1)^n = ∑an (1/3-1)^n</code></pre><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110004937.png" alt="image.png"></p><h4 id="几个常用的展开"><a href="#几个常用的展开" class="headerlink" title="几个常用的展开"></a>几个常用的展开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">级数，power series，指的是麦克劳林级数。</span><br><span class="line">也就是在 x = 0 附近展开的泰勒级数。</span><br><span class="line">.</span><br><span class="line">展开的条件是 n 阶连续可导，而 n 趋向于无穷。</span><br><span class="line">y = x⁴ + x³ + x² + x + 1，就不可能展开成无穷项的幂级数。</span><br><span class="line">.</span><br><span class="line">y = sinx，可以展开为无穷项的幂级数。</span><br><span class="line">但是 y = sin|x| , 在 x = 0 处是不可导的，就不可以展开为幂级数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110005861.png" alt="image.png"></p><h4 id="函数展开为幂级数的方法"><a href="#函数展开为幂级数的方法" class="headerlink" title="函数展开为幂级数的方法"></a>函数展开为幂级数的方法</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110006907.png" alt="image.png"></p><h3 id="常考题型-10"><a href="#常考题型-10" class="headerlink" title="常考题型"></a>常考题型</h3><hr><h4 id="求收敛半径、收敛区间、收敛域"><a href="#求收敛半径、收敛区间、收敛域" class="headerlink" title="求收敛半径、收敛区间、收敛域"></a>求收敛半径、收敛区间、收敛域</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">两种方法：</span><br><span class="line"></span><br><span class="line">注意这里幂级数是从n=1开始，因为有限项不影响收敛性，所以无关紧要</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306110019509.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">缺项，x只有奇数次幂2n-1 </span><br><span class="line">采取根值法如下</span><br><span class="line">重要的步骤是对an取绝对值--&gt;因为(-3)^n正负性会变化--&gt;将(-3)^n提取出来取绝对值就可以</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111029840.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求完收敛区间之后，判断端点的收敛性</span><br><span class="line">1.代入端点，判断级数的类别(正项级数、还是交错还是，任意项)</span><br><span class="line">2.然后根据相对的审敛准则取判别就OK</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111115663.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111114107.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">灵活使用阿贝尔定理</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111127198.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111126688.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.幂级数和函数可导性，且收敛半径不变</span><br><span class="line">2.幂级数条件收敛点必定是收敛区间端点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111138377.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111138415.png" alt="image.png"></p><h4 id="将级数展开为幂级数"><a href="#将级数展开为幂级数" class="headerlink" title="将级数展开为幂级数"></a>将级数展开为幂级数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">有理函数的展开</span><br><span class="line">1.将有理分式拆开</span><br><span class="line">2.利用1/1+x  或1/1-x 的幂级数展开展开</span><br><span class="line">3.因为1/1+x 形式的幂级数展开的收敛区间是(-1,1)</span><br><span class="line">4.将两个级数相加之后，新的级数的收敛半径R=min&#123;R1,R2&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111418024.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.转化ln(x²+x)=lnx + ln(x+1) = ln(1+(x-1)) + ln(1+x) </span><br><span class="line">2.利用ln(1+x)展开幂级数=∑((-1)^n) (x^n)/n</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111428010.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下，需要注意的是，两边积分是做x的变上限积分，目的是为了消除常数项C</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111446506.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111449509.png" alt="image.png"></p><h4 id="级数求和"><a href="#级数求和" class="headerlink" title="级数求和"></a>级数求和</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运用常用的幂级数展开，将幂级数写为和函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111457760.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111501846.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111513581.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111513545.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111525933.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111524725.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">很综合</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306111558946.png" alt="image.png"></p><h3 id="强化题型-4"><a href="#强化题型-4" class="headerlink" title="强化题型"></a><em>强化题型</em></h3><h4 id="题型1-求收敛区间及收敛域"><a href="#题型1-求收敛区间及收敛域" class="headerlink" title="题型1-求收敛区间及收敛域"></a><em>题型1-求收敛区间及收敛域</em></h4><blockquote><p><em>（3）<br>先通过比值法，求出通项比值，ρ，接着因为(x-1)^2n，<br>看做[(x-1)^2]^n，(x-1)^2 &lt; 1/ρ  所以（x-1）&lt; √1/ρ  ,所以收敛半径就是<br>R = √1/ρ</em><br><em>（4）<br>直接求不出收敛半径，因为，通项之比不存在，分奇偶分开计算<br>   求出奇数项的级数 偶数项级数的收敛半径，在根据级数收敛半径取小的</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061606320.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061606885.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061719228.png" alt="image.png"></p></blockquote><h4 id="题型2-将函数展开为幂级数"><a href="#题型2-将函数展开为幂级数" class="headerlink" title="题型2-将函数展开为幂级数"></a><em>题型2-将函数展开为幂级数</em></h4><blockquote><p><em>转换为熟悉的常用的展开式，特别是遇到arctanx、arcsinx的时候，先求导展开，然后再积分回去，因为求导，例如 arctanx 不好展开 求导 1/1+x^2 ，是我们熟悉的形式，展开后，然后逐项积分</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061742765.png" alt="image.png"></p><p><em>在指定点展开为幂级数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061816823.png" alt="image.png"></p><p><em>泰勒与幂级数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061823799.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061830694.png" alt="image.png"></p></blockquote><h4 id="题型3-级数求和"><a href="#题型3-级数求和" class="headerlink" title="题型3-级数求和"></a><em>题型3-级数求和</em></h4><blockquote><p><em>幂级数求和函数</em></p></blockquote><p><em>$\sum_{n=1}^{\infty}\frac{x^n}{n}$  = -ln(1-x),这个常用的要记住</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061848956.png" alt="image.png"></p><p><em>有时需要导数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061915549.png" alt="image.png"></p><p><em>只有奇数项或只有偶数项，往往，x取个负，然后，相加抵消</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061925745.png" alt="image.png"></p><blockquote><p><em>求常数项级数的和</em></p></blockquote><p><em>找到a^n形式，—&gt; 当做x^n形式的幂级数，求和函数S(x),然后令x=a ,S(a)就是常数项级数的和</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061923233.png" alt="image.png"></p><p><em>综合性很强难题$\sum<em>{n=1}^{\infty}n^2x^n$ —&gt; $\sum</em>{n=1}^{\infty}n(n-1)x^n$ + $\sum_{n=1}^{\infty}nx^n$<br>然后利用其是某某的二阶导数，和一阶导数，将某某原函数1/1-x 求导就行</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308061932142.png" alt="image.png"></p><blockquote><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308062043059.png" alt="image.png"></p></blockquote><h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><hr><h3 id="傅里叶系数与傅里叶级数"><a href="#傅里叶系数与傅里叶级数" class="headerlink" title="傅里叶系数与傅里叶级数"></a>傅里叶系数与傅里叶级数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121455442.png" alt="image.png"></p><h3 id="收敛定理-狄利克雷"><a href="#收敛定理-狄利克雷" class="headerlink" title="收敛定理(狄利克雷)"></a>收敛定理(狄利克雷)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于一个周期函数,f(x)在(-l,l)上连续或有有限个第一类间断点，有且仅有有限个极值点，则f(x)的傅里叶级数在[-l,l]上处处收敛</span><br><span class="line">(1).当x是连续点 --&gt; 就收敛于f(x)</span><br><span class="line">(2).当x是间断点 --&gt; 收敛于f(x-)+f(x+)/2 --&gt;左+右极限平均值</span><br><span class="line">(3).当x是区间端点 ±l --&gt; f((-l)+) + f((l)-)/2 --&gt; 左端点右极限+右端点左极限的平均值</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121456469.png" alt="image.png"></p><h3 id="周期为2π的函数展开"><a href="#周期为2π的函数展开" class="headerlink" title="周期为2π的函数展开"></a>周期为2π的函数展开</h3><h4 id="在-π，π-上展开"><a href="#在-π，π-上展开" class="headerlink" title="在[-π，π]上展开"></a>在[-π，π]上展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121505750.png" alt="image.png"></p><h4 id="在-π，π-上奇偶函数的展开"><a href="#在-π，π-上奇偶函数的展开" class="headerlink" title="在[-π，π]上奇偶函数的展开"></a>在[-π，π]上奇偶函数的展开</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(x)是奇函数时</span><br><span class="line">f(x)cosnx --&gt; 奇函数 --&gt;[-π，π]积分=0 --&gt; an=0</span><br><span class="line">f(x)sin nx --&gt;偶函数 --&gt;[-π，π]积分=2倍[0,π]积分 --&gt;bn ...</span><br><span class="line">f(x)是偶函数时</span><br><span class="line">与上面相反</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121505271.png" alt="image.png"></p><h4 id="在-0-π-上展为正弦或余弦"><a href="#在-0-π-上展为正弦或余弦" class="headerlink" title="在[0,π]上展为正弦或余弦"></a>在[0,π]上展为正弦或余弦</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">将f(x)在[0,π]上展开为正弦</span><br><span class="line">展开为正弦，那么an=0 ,将f(x)补齐为奇函数F(x),</span><br><span class="line">F(x)为奇函数：</span><br><span class="line">使得an=0</span><br><span class="line">bn=...,只剩下bn,bn是[0,π]上F(x)sinnx积分，由于[0,π]上F(x)=f(x),所以实际</span><br><span class="line">没变化</span><br><span class="line">将f(x)在[0,π]上展开为余弦</span><br><span class="line">展开为余弦，那么bn=0 ,将f(x)补齐为偶函数函数F(x),</span><br><span class="line">F(x)为奇函数</span><br><span class="line">使得bn=0</span><br><span class="line">只是剩下an，an是[0,π]上F(x)cosnx积分，由于[0,π]上F(x)=f(x),所以实际</span><br><span class="line">就是用f(x)求得</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121526212.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121506866.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121522043.png" alt="image.png"></p><h3 id="周期为2l的函数展开"><a href="#周期为2l的函数展开" class="headerlink" title="周期为2l的函数展开"></a>周期为2<em>l</em>的函数展开</h3><h4 id="在-l-l-上展开"><a href="#在-l-l-上展开" class="headerlink" title="在[-l,l] 上展开"></a>在[-l,l] 上展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121500736.png" alt="image.png"></p><h4 id="在-l-l-上奇偶函数的展开"><a href="#在-l-l-上奇偶函数的展开" class="headerlink" title="在[-l,l]上奇偶函数的展开"></a>在[-l,l]上奇偶函数的展开</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121501534.png" alt="image.png"></p><h4 id="在-0-l-上展开为正弦或余弦"><a href="#在-0-l-上展开为正弦或余弦" class="headerlink" title="在[0,l]上展开为正弦或余弦"></a>在[0,l]上展开为正弦或余弦</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121501330.png" alt="image.png"></p><h3 id="常考题型-11"><a href="#常考题型-11" class="headerlink" title="常考题型"></a>常考题型</h3><hr><h4 id="狄利克雷收敛定理"><a href="#狄利克雷收敛定理" class="headerlink" title="狄利克雷收敛定理"></a>狄利克雷收敛定理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=1是区间端点--&gt; 收敛与 左端点右极限+右端点左极限/2 = 2+1/2=3/2  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121541162.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">☆</span><br><span class="line">S(x)=∑bn Sin nx ,根据周期π/l=1 ∴l=1 </span><br><span class="line">∵ 区间[0,1) ,内展开,an=0</span><br><span class="line">∴ 做了奇延脱，将函数补齐为奇函数 使得an=0</span><br><span class="line">那么 奇延托函数 F(x)是奇函数--&gt; F(-x) =-F(x)=-f(x)=-1/4</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121549416.png" alt="image.png"></p><h4 id="将函数展开为傅里叶级数"><a href="#将函数展开为傅里叶级数" class="headerlink" title="将函数展开为傅里叶级数"></a>将函数展开为傅里叶级数</h4><hr><script type="math/tex; mode=display">b3=1/{\pi}\int_{-\pi}^{\pi}({\pi}x+x^2)sin3xdx</script><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121559093.png" alt="Uploading file...iodwj"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wating to finish</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121625119.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121700093.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121659769.png" alt="image.png"></p><h1 id="高数11-向量代数与空间解析几何及多元微分学在几何上的应用"><a href="#高数11-向量代数与空间解析几何及多元微分学在几何上的应用" class="headerlink" title="高数11-向量代数与空间解析几何及多元微分学在几何上的应用"></a>高数11-向量代数与空间解析几何及多元微分学在几何上的应用</h1><h2 id="向量代数"><a href="#向量代数" class="headerlink" title="向量代数"></a>向量代数</h2><h3 id="数量积"><a href="#数量积" class="headerlink" title="数量积"></a>数量积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数量积得到一个数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121818749.png" alt="image.png"></p><hr><h3 id="向量积"><a href="#向量积" class="headerlink" title="向量积"></a>向量积</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">向量积，得到一个向量</span><br><span class="line">|a×b| =|a||b| sinα </span><br><span class="line">a×b几何表示，右手四指从a-&gt;b，大拇指朝向就是向量积方向</span><br><span class="line">注意b×a ,右手四指从b-&gt;a,大拇指朝向与a×b相反</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121818710.png" alt="image.png"></p><hr><h3 id="混合积"><a href="#混合积" class="headerlink" title="混合积"></a>混合积</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101002166.png" alt="image.png"></p><hr><h3 id="常考题型-12"><a href="#常考题型-12" class="headerlink" title="常考题型"></a>常考题型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121831866.png" alt="image.png"></p><h2 id="空间平面与直线"><a href="#空间平面与直线" class="headerlink" title="空间平面与直线"></a>空间平面与直线</h2><h3 id="平面方程"><a href="#平面方程" class="headerlink" title="平面方程"></a>平面方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一般式:</span><br><span class="line">2.点法式：知道一点(x0,y0,z0)，和平面法线向量&#123;A,B,C&#125;</span><br><span class="line">3.截距式:知道平面分别与x,y,z轴的三个截距a,b,c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121843769.png" alt="image.png"></p><hr><h3 id="直线方程"><a href="#直线方程" class="headerlink" title="直线方程"></a>直线方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1一般式：两组平面方程联立，几何意义两组平面相交所得到的的直线</span><br><span class="line"></span><br><span class="line">2.对称式：找一组方向向量(l,m,m),然后以直线经过的某一点(x0,y0,z0),通过两点确定一个方向(x-x0)/l=(y-y0)/m=(z-z0)/n ,也就是直线上任何一点(x,y)与(x0,y0)组成的向量都是</span><br><span class="line">方向向量(l,m,n)等了比例放大缩小得到--&gt;(x-x0)/l=(y-y0)/m=(z-z0)/n</span><br><span class="line"></span><br><span class="line">3.参数式：根据(x-x0)/l=(y-y0)/m=(z-z0)/n=t </span><br><span class="line"> =&gt; x=x0+lt , y=y0+mt, z=z0+nt</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306121844902.png" alt="image.png"></p><hr><h3 id="平面与直线的位置关系"><a href="#平面与直线的位置关系" class="headerlink" title="平面与直线的位置关系"></a>平面与直线的位置关系</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122048860.png" alt="image.png"></p><hr><h3 id="点到面的距离"><a href="#点到面的距离" class="headerlink" title="点到面的距离"></a>点到面的距离</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122049678.png" alt="image.png"></p><hr><h3 id="点到直线的距离"><a href="#点到直线的距离" class="headerlink" title="点到直线的距离"></a>点到直线的距离</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A是直线上一点，B是目标点</span><br><span class="line">求B到直线的距离--&gt;通过 AB向量 叉乘 直线方向向量 = 平行四边形面积</span><br><span class="line">--&gt; 面积/底=高 --&gt; 高就是B点到直线的距离</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122050775.png" alt="image.png"></p><hr><h3 id="常考题型-13"><a href="#常考题型-13" class="headerlink" title="常考题型"></a>常考题型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.直线1的参数方程，得到方向向量(0,1,1); 直线2的对称式方程得到方向向量(1,2,3)</span><br><span class="line">2.两方向向量 叉乘 得到与两向量垂直的向量</span><br><span class="line">3.利用 点法式 求平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122124290.png" alt="image.png"></p><hr><h2 id="曲面与空间曲线"><a href="#曲面与空间曲线" class="headerlink" title="曲面与空间曲线"></a>曲面与空间曲线</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138097.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">柱面：一条直线L平行与定直线,并且沿着定曲线移动所形成的一个面(轨迹)</span><br><span class="line">1.准线: 如果为f(x,y)=0 ;z=0; --&gt; f(x,y)=0表示柱面的轨迹 ,z=0表示投影在xoy平</span><br><span class="line">面--&gt;两者就一起表示柱面在xoy面上的投影曲线,也就是准线 </span><br><span class="line">2.准线：如果为F(x,y,z)=0;G(x,y,z)=0 --&gt; 两个曲面所交得到一条曲线就是准线 --&gt;</span><br><span class="line"> 母线平行于z轴的柱面方程就为两方程联立 消去z =&gt; H(x,y)=0 </span><br><span class="line">为什么f(x,y)=0，在空间上能表示一个柱面？</span><br><span class="line">f(x,y)=0, 在空间坐标中设其方程为 Ax+By+Cz=0 --&gt; 其中C=0 --&gt; 意味着z任意变化</span><br><span class="line">空间上都是Ax+By=0这条曲线 --&gt; 这样就形成了一个柱面</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138321.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122138390.png" alt="image.png"></p><h3 id="常考题型-14"><a href="#常考题型-14" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="建立柱面与旋转面方程"><a href="#建立柱面与旋转面方程" class="headerlink" title="建立柱面与旋转面方程"></a>建立柱面与旋转面方程</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">消去z,得到的H(x,y)就是所要求的柱面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122234655.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">曲线方程法 f(x,y)=0 ,z=0 --&gt; 平行与z轴的柱面在xoy面上投影曲线</span><br><span class="line">2x^2 +y^2 =1 ,z=0 --&gt; 绕x轴旋转，f(x,√(z^2+y^2)) = 2x^2 + y^2 +z^2 =1</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122241142.png" alt="image.png"></p><hr><h2 id="多元微分在几何上的应用"><a href="#多元微分在几何上的应用" class="headerlink" title="多元微分在几何上的应用"></a>多元微分在几何上的应用</h2><h3 id="曲面的切平面与法线"><a href="#曲面的切平面与法线" class="headerlink" title="曲面的切平面与法线"></a>曲面的切平面与法线</h3><h3 id="曲线的切线与法平面"><a href="#曲线的切线与法平面" class="headerlink" title="曲线的切线与法平面"></a>曲线的切线与法平面</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.曲面的切平面的法线</span><br><span class="line">曲面有两种写法，其对应的法向量写法也不同：</span><br><span class="line">1.曲面 F(x,y,z)=0  --&gt; 法向量 n=(Fx&#x27;,Fy&#x27;,Fz&#x27;)</span><br><span class="line"></span><br><span class="line">2.曲面 z=f(x,y) --&gt; 法向量 n=(fx&#x27;,fy&#x27;,-1)</span><br><span class="line">实际与第一种情况一样，将F(x,y,z)=f(x,y) - z</span><br><span class="line">--&gt; 法向量 n=(Fx&#x27;,Fy&#x27;,Fz&#x27;) = (fx&#x27;,fy&#x27;,-1)</span><br><span class="line">2.曲线的切线与法平面</span><br><span class="line">曲线有两种写法，其对应的切向量写法写法也不同：</span><br><span class="line">1.参数方程  --&gt; 如图</span><br><span class="line"></span><br><span class="line">2。两曲面相联立的交线 --&gt; 曲线上某点的切向量 = 两曲面在交线该点的法向量的</span><br><span class="line">叉乘</span><br><span class="line">为什么？</span><br><span class="line">因为曲线上的切线应该与两曲面在该点法向量都垂直</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122254988.png" alt="image.png"></p><hr><h3 id="常考题型-15"><a href="#常考题型-15" class="headerlink" title="常考题型"></a>常考题型</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306122310591.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.曲面的切平面与平面A平行--&gt;则曲线切平面的法向量与平面A的法向量平行</span><br><span class="line">2.求出曲面的法向量与平面A的法向量--&gt;两向量平行，所以对应成比例解得到x,y,z</span><br><span class="line">3.得到了曲面在哪个点的切平面与平面A平行，有又知道切面法向量--&gt;点法式得到切平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131602219.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.求曲线的切线方程</span><br><span class="line">曲线是参数方程，其切线向量=(x&#x27;(t0),y&#x27;(t0),z&#x27;(t0)),再利用对称式直线方程写出该</span><br><span class="line">点的切线方程</span><br><span class="line">2.求曲线某点的法平面方程</span><br><span class="line">求得的切向量与法平面是垂直的所以可以</span><br><span class="line">运用点法式求得法平面方程</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131612343.png" alt="image.png"></p><h2 id="方向导数与梯度"><a href="#方向导数与梯度" class="headerlink" title="方向导数与梯度"></a>方向导数与梯度</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101200824.png" alt="image.png"></p><h2 id="强化题型-5"><a href="#强化题型-5" class="headerlink" title="强化题型"></a>强化题型</h2><h3 id="题型1-建立旋转面方程"><a href="#题型1-建立旋转面方程" class="headerlink" title="题型1-建立旋转面方程"></a>题型1-建立旋转面方程</h3><blockquote><p><strong>*平面曲线</strong>绕某一坐标轴旋转得到旋转面，绕那个轴转，哪个变量就不变，另一个变为另外两变量的平方相加开根号*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101047763.png" alt="image.png"></p><p><strong>*空间直线</strong>，绕坐标轴转没学过，怎么做呢？<em></em>比如绕z轴转，原直线上任一一点(x0,y0,z0) 会形成一个圈 圈上每一点到z轴距离一样，建立一个等式；再将右端利用原等式化为z的式子；最终得到x,y,z的旋转面方程*<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101054388.png" alt="image.png"></p></blockquote><h3 id="题型2-建立曲面的切平面与法线方程"><a href="#题型2-建立曲面的切平面与法线方程" class="headerlink" title="题型2-建立曲面的切平面与法线方程"></a><em>题型2-建立曲面的切平面与法线方程</em></h3><blockquote><p><em>柱面任意一点的法向量，都垂直于轴直线，故利用向量数量积为0，证明存在一条直线就行</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101124797.png" alt="image.png"></p><p><em>点法式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101127280.png" alt="image.png"></p></blockquote><h3 id="题型3-建立空间曲线的切线与法平面"><a href="#题型3-建立空间曲线的切线与法平面" class="headerlink" title="题型3-建立空间曲线的切线与法平面"></a><em>题型3-建立空间曲线的切线与法平面</em></h3><blockquote><p><em>向量的叉乘（向量积），代数计算用行列式快捷方便</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101130290.png" alt="image.png"></p></blockquote><h3 id="题型4-方向导数与梯度的计算"><a href="#题型4-方向导数与梯度的计算" class="headerlink" title="题型4-方向导数与梯度的计算"></a><em>题型4-方向导数与梯度的计算</em></h3><blockquote><p><em>求出A点的各个方向偏导数，再乘以方向余弦，方向余弦是单位化后的方向向量</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101203365.png" alt="image.png"></p><p><em>方向导数是射线，单方向，偏导数存在需要两头都有且相同<br>方向导数，延负方向是与原偏导数的相反数</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101210488.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101212092.png" alt="image.png"></p><p><em>方向导数求法+拉格朗日数乘法求条件最值</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101223340.png" alt="image.png"></p></blockquote><h1 id="高数12-多元积分学及其应用"><a href="#高数12-多元积分学及其应用" class="headerlink" title="高数12-多元积分学及其应用"></a>高数12-多元积分学及其应用</h1><hr><h2 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h2><h3 id="直角坐标"><a href="#直角坐标" class="headerlink" title="直角坐标"></a>直角坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一重积分积分区域是坐标轴的一个区间</span><br><span class="line">二重积分积分区域是平面区域</span><br><span class="line">三重积分的积分区域是一个空间体</span><br><span class="line"></span><br><span class="line">三重积分的直角坐标有两种积分方式</span><br><span class="line">1.先一后二: 穿线法</span><br><span class="line">先对z求积分，后对xy积分--&gt;就由空间体在xoy上的投影作为定限，在这个投</span><br><span class="line">影区域内对z积分</span><br><span class="line">2.先二后一: 切片法</span><br><span class="line">先对xy积分，后对z积分--&gt;积分限由在z轴上投影定限，在这段高度内对xy平</span><br><span class="line">面进行积分</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306131907174.png" alt="image.png"></p><hr><h3 id="柱坐标"><a href="#柱坐标" class="headerlink" title="柱坐标"></a>柱坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r是空间上的点到z轴的距离</span><br><span class="line">θ是空间上的点A 在xoy面上投影点A&#x27;与原点的连线与x轴的夹角</span><br><span class="line">z是点A的z坐标</span><br><span class="line">通过以上s三个信息就可以唯一确定一点</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306132129048.png" alt="image.png"></p><hr><h3 id="球坐标"><a href="#球坐标" class="headerlink" title="球坐标"></a>球坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自己看图理解吧，有点抽象，不好解释</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306132135211.png" alt="image.png"></p><hr><h3 id="利用奇偶性"><a href="#利用奇偶性" class="headerlink" title="利用奇偶性"></a>利用奇偶性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151629686.png" alt="image.png"></p><hr><h3 id="利用变量的对称性"><a href="#利用变量的对称性" class="headerlink" title="利用变量的对称性"></a>利用变量的对称性</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151634144.png" alt="image.png"></p><hr><h3 id="常考题型与典型例题"><a href="#常考题型与典型例题" class="headerlink" title="常考题型与典型例题"></a>常考题型与典型例题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A.函数x是x轴的奇函数，积分区域Ω1关于zoy面对称，所以积分为0</span><br><span class="line">积分区域Ω2属于第I卦限，对x积分不为0，所以A错误</span><br><span class="line">B.函数y是y轴的奇函数，积分区域Ω1关于zox对称，，所以积分为0</span><br><span class="line">...</span><br><span class="line">C.函数z是z轴的奇函数，积分区域Ω1不关于xoy对称; 同样函数z是y轴和x轴的偶函数，且积分</span><br><span class="line">  区域关于x轴对称,所以前一半=后一半，且积分区域关于y轴对称，所以左一半=右一半;</span><br><span class="line">  所以C是对的</span><br><span class="line">D.函数xyz是关于z轴的奇函数,∵f(x,y,-z)=-f(x,y,z)  ;所以同上</span><br><span class="line"></span><br><span class="line">这题主要运用到函数的奇偶性和积分区域的对称性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151708018.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">分析：积分区域是一个球--&gt;采用切片法积分--&gt; 每一块切片都是一个圆x^2+y^2&lt;=1-z^2</span><br><span class="line"> --&gt; 先对其二重积分(函数 x 积分域面积) ，然后对z方向积分 --&gt; 如下</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151739552.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方法2：</span><br><span class="line">积分区域具有变量对称性--&gt;对x^2积分和对y^2、在z^2积分等效--&gt;...</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151746218.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于方程x+y+z=1，随便拿两个变量交换，方程不变--&gt;反应了一种轮换性质</span><br><span class="line">那么对x、y、z积分就是等效的</span><br><span class="line">下面就可以写成对6z的积分</span><br><span class="line">...</span><br><span class="line">既可以穿线法，也可以切片法，此题被积函数6z是z的一元函数，用切片法更简单</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151751448.png" alt="image.png"></p><hr><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306151824750.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">四种方法</span><br><span class="line">1.球坐标</span><br><span class="line">2.直角坐标，先一后二，穿线法</span><br><span class="line">3.直角坐标，先二后一，切片法</span><br><span class="line">4.柱坐标</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152251947.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152252789.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306152259255.png" alt="image.png"></p><hr><h2 id="曲线积分"><a href="#曲线积分" class="headerlink" title="曲线积分"></a>曲线积分</h2><h3 id="一类曲线积分与二类曲线积分区别"><a href="#一类曲线积分与二类曲线积分区别" class="headerlink" title="一类曲线积分与二类曲线积分区别"></a>一类曲线积分与二类曲线积分区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一类曲线是对曲线的长度，二类是对X坐标。怎么理解呢？</span><br><span class="line">告诉你一根线的线密度，问你线的质量，就要用一类。</span><br><span class="line">告诉你路径曲线方程，告诉你Xy两个方向的力，求功，就用二类。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161253118.png" alt="image.png"></p><hr><h3 id="对弧长的曲线积分-第一类线积分"><a href="#对弧长的曲线积分-第一类线积分" class="headerlink" title="对弧长的曲线积分(第一类线积分)"></a>对弧长的曲线积分(第一类线积分)</h3><h4 id="定义与性质"><a href="#定义与性质" class="headerlink" title="定义与性质"></a>定义与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">被积函数f(x,y)就是线的密度，将弧微分，求每一段弧微分与密度的乘积之和=&gt;求得线的质量</span><br><span class="line"></span><br><span class="line">一类线积分是函数值乘弧长，弧长与曲线方向没有关系，所以与路径方向无关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161301817.png" alt="image.png"></p><hr><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><h5 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161337797.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面是公式推导</span><br></pre></td></tr></table></figure><p><strong>一般方程</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161330352.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161330136.png" alt="image.png"><br><strong>参数形式</strong><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161334783.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161342105.png" alt="image.png"></p><p><strong>极坐标形式</strong></p><hr><h5 id="利用奇偶性-1"><a href="#利用奇偶性-1" class="headerlink" title="利用奇偶性"></a>利用奇偶性</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161343425.png" alt="image.png"></p><hr><h5 id="利用对称性"><a href="#利用对称性" class="headerlink" title="利用对称性"></a>利用对称性</h5><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161343149.png" alt="image.png"></p><hr><h3 id="对坐标的线积分-第二类线积分"><a href="#对坐标的线积分-第二类线积分" class="headerlink" title="对坐标的线积分(第二类线积分)"></a>对坐标的线积分(第二类线积分)</h3><h4 id="定义与性质-1"><a href="#定义与性质-1" class="headerlink" title="定义与性质"></a>定义与性质</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">二类线积分，是对 位移x力 ,位移就是路径(曲线)上x方向位移 和y方向位移,位移是矢量有正有负，所以与路径方向有关</span><br><span class="line"></span><br><span class="line">分别对x、y方向的力求积分，分为两部分</span><br><span class="line"></span><br><span class="line">注意这里积分上下限，是看起点和终点，与x,y大小无关，只和是从哪个点开始，哪个点结束有关</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161351198.png" alt="image.png"></p><hr><h4 id="计算方法-平面"><a href="#计算方法-平面" class="headerlink" title="计算方法(平面)"></a>计算方法(平面)</h4><h5 id="直接法-1"><a href="#直接法-1" class="headerlink" title="直接法"></a>直接法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于，要分别dx dy ，不统一，所以计算思路是转化为参数方程，将x,y写成关于t的函数，统一对t求积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161358615.png" alt="image.png"></p><h5 id="格林公式"><a href="#格林公式" class="headerlink" title="格林公式"></a>格林公式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果曲线是封闭的，那么被积函数沿着边界曲线的“正向”--&gt;可以看成下面函数对曲线围成的积分域的二重积分</span><br><span class="line"></span><br><span class="line">&quot;正向&quot;是指，假如你沿着曲线的方向走，围成的区域始终在你的左边</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161358973.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161359230.png" alt="image.png"></p><hr><h5 id="补线用格林公式"><a href="#补线用格林公式" class="headerlink" title="补线用格林公式"></a>补线用格林公式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当曲线没有围成一个封闭区域时，常常补充一条线，使其形成一个封闭区间，使用二重积分求解然后，减去这条补充线的曲线积分</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161420623.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161423198.png" alt="image.png"></p><hr><h5 id="利用线积分与路径无关"><a href="#利用线积分与路径无关" class="headerlink" title="利用线积分与路径无关"></a>利用线积分与路径无关</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.判定线积分是否与路径无关--&gt;∂P/∂y = ∂Q/∂x，则积分与路径无关(前提：单连通区域，没有洞的区域)</span><br><span class="line">2.计算：</span><br><span class="line">a.改换路劲</span><br><span class="line">b.利用原函数</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161425310.png" alt="image.png"></p><hr><h4 id="两类积分的联系"><a href="#两类积分的联系" class="headerlink" title="两类积分的联系"></a>两类积分的联系</h4><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161452946.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161452430.png" alt="image.png"></p><hr><h4 id="计算方法-空间"><a href="#计算方法-空间" class="headerlink" title="计算方法(空间)"></a>计算方法(空间)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">平面上有格林公式--&gt;将封闭线积分转化为内的平面积分</span><br><span class="line">空间上有斯托克公式--&gt;将封闭线积分，转化为以曲线为边界的曲面积分(只要求曲面/平面以线为边界)</span><br><span class="line"></span><br><span class="line">如何确定曲面的上下侧？</span><br><span class="line">以曲线方向，右手螺旋，大拇指朝向方向就是上侧，如果曲面的法向量与大拇指方向相同</span><br><span class="line">则该曲面是上侧，反之为下侧</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161514735.png" alt="image.png"></p><hr><h3 id="常考题型-16"><a href="#常考题型-16" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="第一类曲线积分的计算"><a href="#第一类曲线积分的计算" class="headerlink" title="第一类曲线积分的计算"></a>第一类曲线积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.画出曲线，为一个下半圆</span><br><span class="line">2.被积函数x^2+y^2 沿着该曲线，则必然符合曲线的函数关系，--&gt;x^2+y^2=1</span><br><span class="line">3.被积函数=1，那么对曲线积分就=1*曲线长度=π</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161526216.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运用奇偶性做：</span><br><span class="line">1.画出积分曲线，为一个下半圆</span><br><span class="line">2.被积函数x是关于x轴的奇函数，沿着被积区域(曲线关于y轴对称)，所以积分=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161529192.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这题奇偶性用不了，只能直接做</span><br><span class="line">怎么直接做，ds怎么做？</span><br><span class="line">1.换位参数方程x=cost，y=sint  (π&lt;=t&lt;=2π) ;</span><br><span class="line">2.利用参数方程公式，化为定积分计算</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161533073.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.画出积分曲线，为一个椭圆，是个对称图形</span><br><span class="line">2.被积函数中2xy是关于x轴的奇函数，所以该项为0</span><br><span class="line">3.剩下3x^2 + 4y^2 ,提出12，12(x^2/4 +y^2/3) ,沿着椭圆积分，有这样的函数关系，</span><br><span class="line">  x^2/4 +y^2/3 =1 , ==&gt; 等于12*  1*曲线长度= 12</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161538228.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">没办法利用奇偶性，因为积分曲线不对称,直接法计算</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161545522.png" alt="image.png"></p><hr><h4 id="第二类曲线积分"><a href="#第二类曲线积分" class="headerlink" title="第二类曲线积分"></a>第二类曲线积分</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法1：</span><br><span class="line">1.判断是否是闭合曲线，不是</span><br><span class="line">2.接着判断是否与路径无关--&gt;∂P/∂y = ∂Q/∂x是否成立，不相等，与路径有关</span><br><span class="line">3.所以用直接法，先化为参数方程，然后计算</span><br><span class="line"></span><br><span class="line">方法2：补线法</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161610103.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161623749.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.分析曲线是否闭合，不闭合，不能直接格林公式</span><br><span class="line">2.看是否与路径有关，发现与路径有关</span><br><span class="line">3.补线法、直接求</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161658463.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161658081.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看草稿</span><br><span class="line">常用结论∫(0-&gt;π) xf(sinx) dx = π/2∫(0-&gt;π) f(sinx) dx</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742616.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742028.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161742608.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">斯托克公式就是将一个封闭空间曲线转化为一个一该封闭曲线为边界的曲面或平面在xoz、xoy、yoz平面上的投影之和，注意的是投影方向要与曲线方向结合右手准则判定，方向一致才为正，否则为负，需要加负号</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161815536.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306161815866.png" alt="image.png"></p><hr><h2 id="曲面积分"><a href="#曲面积分" class="headerlink" title="曲面积分"></a>曲面积分</h2><h3 id="对面积的面积分-第一类曲面积分"><a href="#对面积的面积分-第一类曲面积分" class="headerlink" title="对面积的面积分(第一类曲面积分)"></a>对面积的面积分(第一类曲面积分)</h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191544038.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191545364.png" alt="image.png"></p><hr><h3 id="对坐标的面积分-第二类面积分"><a href="#对坐标的面积分-第二类面积分" class="headerlink" title="对坐标的面积分(第二类面积分)"></a>对坐标的面积分(第二类面积分)</h3><p><em>二类面积分，曲面是有方向的，看曲面的法线方向，法线朝上，则沿着曲面上侧作积分，反之</em></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191546443.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191547169.png" alt="image.png"></p><hr><h3 id="常考题型-17"><a href="#常考题型-17" class="headerlink" title="常考题型"></a>常考题型</h3><h4 id="第一类曲面积分的计算"><a href="#第一类曲面积分的计算" class="headerlink" title="第一类曲面积分的计算"></a>第一类曲面积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">利用奇偶性</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191549733.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191600468.png" alt="image.png"></p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191608672.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191629733.png" alt="image.png"></p><hr><h4 id="第二类曲面积分的计算"><a href="#第二类曲面积分的计算" class="headerlink" title="第二类曲面积分的计算"></a>第二类曲面积分的计算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断曲面是否闭合，并且看曲面是外侧还是内侧</span><br><span class="line">2.外侧闭合，直接高斯公式，转化为对体积求三重积分</span><br><span class="line">3.由于这题使用球坐标比较方便，所以，考到了求坐标的转换</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191632021.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191654285.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.曲面积分，并且是第二类曲面积分</span><br><span class="line">2.判断曲面是否闭合--&gt;闭合且都是外侧曲面，用高斯</span><br><span class="line">3.高斯公式，将题目转化为对球体的三重积分</span><br><span class="line">4.球坐标的转化</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191705256.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191704521.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.判断积分曲面是否闭合--&gt;不闭合--&gt;补面，用高斯</span><br><span class="line">2.减去补的面，注意，由于高斯公式对积分曲面都是外侧，所以补的面的外侧是下侧</span><br><span class="line">3.对下侧曲面的二类曲面积分，要注意方向是负的，要取负，所符号负负抵消了</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191732579.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191731078.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意看草稿</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191818333.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202306191817551.png" alt="image.png"></p><h2 id="强化题型-6"><a href="#强化题型-6" class="headerlink" title="强化题型"></a>强化题型</h2><h3 id="题型1-三重积分计算"><a href="#题型1-三重积分计算" class="headerlink" title="题型1-三重积分计算"></a><em>题型1-三重积分计算</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101421800.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101422740.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151141259.png" alt="image.png"></p><p><em>利用求坐标计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151204179.png" alt="image.png"></p><p><em>利用柱坐标计算</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151511534.png" alt="image.png"></p><p><em>终于迈出第一步</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151524205.png" alt="image.png"></p><p><em>降维，将三重积分先两两进行，交换积分次序，达到简化效果</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151534879.png" alt="image.png"></p><h3 id="题型2-弧长积分计算"><a href="#题型2-弧长积分计算" class="headerlink" title="题型2-弧长积分计算"></a><em>题型2-弧长积分计算</em></h3><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101422928.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101422019.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308101433256.png" alt="image.png"></p><p><em>奇偶性的运用</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151537612.png" alt="image.png"></p><p><em>平移，左移加，右移减</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151545902.png" alt="image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151623576.png" alt="image.png"></p><h3 id="题型3-计算对坐标的线积分"><a href="#题型3-计算对坐标的线积分" class="headerlink" title="题型3-计算对坐标的线积分"></a><em>题型3-计算对坐标的线积分</em></h3><p><em>积分与路径无关，改换路径</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151634336.png" alt="image.png"></p><p><em>补线用格林公式</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151649768.png" alt="image.png"></p><p>&gt;<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151735400.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151735917.png" alt="image.png"><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151734336.png" alt="image.png"></p><blockquote><p><em>上题结论</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151736534.png" alt="image.png"></p><p><em>椭圆面积πab</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151746087.png" alt="image.png"></p><p><em>单连通区域，任意闭环路径=0(也就是任意路径积分都相等)，等价于线积分与路径无关，等价于两个偏导数相等</em><br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308151806165.png" alt="image.png"></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 高数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言(二)</title>
      <link href="/undefined/3c47b44b.html"/>
      <url>/undefined/3c47b44b.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305181107321.jpg" alt="ҹ· 小女孩 房屋 动漫壁纸_彼岸壁纸.jpg"></p><h2 id="单链表的新建查找"><a href="#单链表的新建查找" class="headerlink" title="单链表的新建查找"></a>单链表的新建查找</h2><h3 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h3><p>链表的实现需要定义结点的结构体类型，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后需要创建一个头指针，用于指向链表的第一个结点，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 创建一个空链表</span></span><br></pre></td></tr></table></figure><p>接下来，可以通过动态分配内存的方式，创建新的结点，并将它们链接起来，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 创建一个新结点</span></span><br><span class="line">p-&gt;data = <span class="number">10</span>; <span class="comment">// 给数据域赋值</span></span><br><span class="line">p-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 给指针域赋值</span></span><br><span class="line">head = p; <span class="comment">// 将头指针指向新结点</span></span><br></pre></td></tr></table></figure><p>这样就实现了一个只有一个结点的链表。如果要添加更多的结点，可以重复上述过程，并将新结点的地址赋给前一个结点的指针域，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">q</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 创建另一个新结点</span></span><br><span class="line">q-&gt;data = <span class="number">20</span>; <span class="comment">// 给数据域赋值</span></span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 给指针域赋值</span></span><br><span class="line">p-&gt;next = q; <span class="comment">// 将前一个结点的指针域指向新结点</span></span><br></pre></td></tr></table></figure><h3 id="链表的删除-插入-查找"><a href="#链表的删除-插入-查找" class="headerlink" title="链表的删除-插入-查找"></a>链表的删除-插入-查找</h3><p>例如，如果要删除链表中的第三个结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> head; <span class="comment">// temp 指向头结点</span></span><br><span class="line">temp = temp-&gt;next; <span class="comment">// temp 指向第二个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">del</span> =</span> temp-&gt;next; <span class="comment">// del 指向要删除的第三个结点</span></span><br><span class="line">temp-&gt;next = del-&gt;next; <span class="comment">// 将第二个结点的指针域指向第四个结点</span></span><br><span class="line"><span class="built_in">free</span>(del); <span class="comment">// 释放第三个结点的内存空间</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例如，如果要在链表中的第三个结点后插入一个新的结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">new</span> =</span> (<span class="keyword">struct</span> node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> node)); <span class="comment">// 申请一个新的结点</span></span><br><span class="line">new-&gt;data = x; <span class="comment">// 将要插入的数据赋值给新结点的数据域</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">temp</span> =</span> head; <span class="comment">// temp 指向头结点</span></span><br><span class="line">temp = temp-&gt;next-&gt;next; <span class="comment">// temp 指向第三个结点</span></span><br><span class="line">new-&gt;next = temp-&gt;next; <span class="comment">// 将新结点的指针域指向第四个结点</span></span><br><span class="line">temp-&gt;next = new; <span class="comment">// 将第三个结点的指针域指向新结点</span></span><br></pre></td></tr></table></figure><p>例如，如果要在链表中查找第一个值为 x 的结点，可以用以下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">p</span> =</span> head-&gt;next; <span class="comment">// p 指向首元结点</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>; <span class="comment">// i 记录当前结点的位置</span></span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == x) &#123; <span class="comment">// 如果找到值为 x 的结点</span></span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">// 返回位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = p-&gt;next; <span class="comment">// p 指向下一个结点</span></span><br><span class="line">    i++; <span class="comment">// i 加一</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果遍历到尾部，仍未找到，返回 -1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现顺序表-插入-删除"><a href="#实现顺序表-插入-删除" class="headerlink" title="实现顺序表 插入 删除"></a>实现顺序表 插入 删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> length;  </span><br><span class="line">&#125;SqList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入到第二个的函数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Put_arry</span><span class="params">(SqList &amp;L,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i = L.data[<span class="number">1</span>];  </span><br><span class="line">    <span class="type">int</span> j;  </span><br><span class="line">    <span class="keyword">for</span>(j=L.length;j&gt;<span class="number">1</span>;j--)&#123;  </span><br><span class="line">        L.data[j]=L.data[j<span class="number">-1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.data[<span class="number">1</span>]=e;  </span><br><span class="line">    L.length++;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印顺序表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(SqList L)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;L.length;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d &quot;</span>,L.data[i]);<span class="comment">//&quot;%3表示打印的数字占3个空格  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//删除元素方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delet_arry</span><span class="params">(SqList &amp;L,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=e;i&lt;L.length;i++)&#123;  </span><br><span class="line">        L.data[i<span class="number">-1</span>]=L.data[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">    L.length--;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqList L;  </span><br><span class="line">    L.data[<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    L.data[<span class="number">1</span>]=<span class="number">2</span>;  </span><br><span class="line">    L.data[<span class="number">2</span>]=<span class="number">3</span>;  </span><br><span class="line">    L.length=<span class="number">3</span>;  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;e);  </span><br><span class="line">    Put_arry(L,e);  </span><br><span class="line">    print_arr(L);  </span><br><span class="line">  </span><br><span class="line">    ElemType del;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;del);  </span><br><span class="line">    Delet_arry(L,del);  </span><br><span class="line">    print_arr(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="头插法新建链表"><a href="#头插法新建链表" class="headerlink" title="头插法新建链表"></a>头插法新建链表</h3><p>这段代码，实现头插法新建一个链表，每次新建一个结点，都是放到第一个结点（注意头结点不是第一个结点，头结点指向第一个结点），该链表存储int类型数据，通过scanf输入建立对应的存储结点，直到输入9999,结束创建，并且不会包含9999</p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032033156.png" alt="Snipaste_2023-03-07_17-01-14.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032032806.png" alt="Snipaste_2023-03-07_17-07-51.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法新建链表</span></span><br><span class="line"><span class="comment">//定义一个方法，申请头结点的空间  </span></span><br><span class="line"><span class="comment">//LNode*是结构体指针，与LinkList是完全等价的  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_head_insert</span><span class="params">(LNode* &amp;L)</span>&#123;  </span><br><span class="line">    L= (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//给L申请一个头结点结点空间  </span></span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;<span class="comment">//读取的第一个元素  </span></span><br><span class="line">    LinkList s;<span class="comment">//用来指向新节点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));<span class="comment">//给s申请一个新的空间  </span></span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        s-&gt;next=L-&gt;next;<span class="comment">//实现头插法，s成为第一个结点  </span></span><br><span class="line">        L-&gt;next=s;<span class="comment">//L作为头结点，任然指向第一个结点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);<span class="comment">//读取x的值  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_head_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法新建链表"><a href="#尾插法新建链表" class="headerlink" title="尾插法新建链表"></a>尾插法新建链表</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032042218.png" alt="Snipaste_2023-03-07_17-20-00.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点 ,将L赋给s,r ,相当于s,r,L都是头结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  <span class="comment">//将s赋给r,r重新指向尾结点</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-按值查找-按位置查找"><a href="#链表-按值查找-按位置查找" class="headerlink" title="链表-按值查找-按位置查找"></a>链表-按值查找-按位置查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line"> <span class="comment">//说明：L头结点的位置是0</span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按值查找  </span></span><br><span class="line">LinkList <span class="title function_">GetEle_by_value</span><span class="params">(LinkList L,<span class="type">int</span> value)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(L)&#123;<span class="comment">//表示L不为空，循环  </span></span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data!=value)&#123;  </span><br><span class="line">            L=L-&gt;next;  </span><br><span class="line">        &#125;<span class="keyword">if</span>(L-&gt;data==value)&#123;  </span><br><span class="line">            <span class="keyword">return</span> L;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">  </span><br><span class="line">    LinkList pNode1 = GetEle_by_pos(L,<span class="number">3</span>);  </span><br><span class="line">    <span class="keyword">if</span>(pNode1!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nsearch by postion success\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the value is %d\n&quot;</span>,pNode1-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    LinkList pNode2 = GetEle_by_value(L, <span class="number">8</span>);  </span><br><span class="line">    <span class="keyword">if</span>(pNode2!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;search by value success\n&quot;</span>);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the value is %d\n&quot;</span>,pNode2-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表-往第i-个位置插入元素"><a href="#链表-往第i-个位置插入元素" class="headerlink" title="链表 往第i 个位置插入元素"></a>链表 往第i 个位置插入元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line"> LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入方法，往第i个位置插入元素  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListFrontInsert</span><span class="params">(LinkList L,<span class="type">int</span> i,<span class="type">int</span> insert)</span>&#123;  </span><br><span class="line">    <span class="comment">//先找到链表第i-1个位置，并指向  </span></span><br><span class="line">    LinkList p = GetEle_by_pos(L, i<span class="number">-1</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//定义一个新的结点  </span></span><br><span class="line">    LinkList q;  </span><br><span class="line">    q = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    q-&gt;next=p-&gt;next;  </span><br><span class="line">    q-&gt;data=insert;  </span><br><span class="line">    p-&gt;next=q;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;<span class="comment">//定义链表的头指针  </span></span><br><span class="line"></span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    ListFrontInsert(L,<span class="number">2</span>,<span class="number">80</span>);  <span class="comment">//往第二个位置，插入80</span></span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h2><h3 id="单链表删除实战"><a href="#单链表删除实战" class="headerlink" title="单链表删除实战"></a>单链表删除实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032047101.png" alt="Snipaste_2023-03-08_22-06-07.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032048552.png" alt="Snipaste_2023-03-08_22-03-33.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//按位置查找  </span></span><br><span class="line">LinkList <span class="title function_">GetEle_by_pos</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="comment">//说明：L头结点的位置是0  </span></span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&lt;pos)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//单链表的删除方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">delet_list</span><span class="params">(LinkList L,<span class="type">int</span> pos)</span>&#123;  <span class="comment">//删除时，L是不会变得，所以不需要加引用</span></span><br><span class="line">    <span class="keyword">if</span>(pos&gt;<span class="number">1</span>)&#123;  </span><br><span class="line">        LinkList p = GetEle_by_pos(L,pos - <span class="number">1</span>); <span class="comment">//拿到哟啊删除结点的前一个结点指针</span></span><br><span class="line">        LinkList q=p-&gt;next;  <span class="comment">//拿到要删除的结点指针</span></span><br><span class="line">        <span class="keyword">if</span>(q!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            p-&gt;next=q-&gt;next;  </span><br><span class="line">            <span class="built_in">free</span>(q);  <span class="comment">//释放被删除元素的空间</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    delet_list(L,<span class="number">2</span>);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真题，链表转置实战"><a href="#真题，链表转置实战" class="headerlink" title="真题，链表转置实战"></a>真题，链表转置实战</h3><p>转置图示<img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041933031.png" alt="image.png"></p><p>合并图解<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041933379.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义结点结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域  </span></span><br><span class="line">&#125;LNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(LinkList &amp;L)</span>&#123;  </span><br><span class="line">    L=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    LNode *s,*r=L;<span class="comment">//s指向新节点，r指向尾结点  </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_LinKlist</span><span class="params">(LinkList L)</span>&#123;  </span><br><span class="line">    L=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(L!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//找中心结点  </span></span><br><span class="line"><span class="comment">//当链表奇数个结点取中间，偶数个结点取前一个  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">find_middle</span><span class="params">(LinkList L,LinkList &amp;L2)</span>&#123;<span class="comment">//L表示第一条链表头结点，L2表示第二条链表头结点  </span></span><br><span class="line">    L2=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    LinkList p,pp;<span class="comment">//双指针  </span></span><br><span class="line">    p=pp=L-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(pp)&#123;  </span><br><span class="line">        pp=pp-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)&#123;<span class="comment">//必须判断每一步是否为空，防止崩溃  </span></span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        pp=pp-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(pp==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    L2-&gt;next=p-&gt;next;  </span><br><span class="line">    p-&gt;next=<span class="literal">NULL</span>;<span class="comment">//链表最后一个结点next要为空  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//找中心结点，while循环次数是n/2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//逆置方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(LinkList L2)</span>&#123;<span class="comment">//逆转是不改变头指针的  </span></span><br><span class="line">    LinkList r,s,t;  </span><br><span class="line">    r=L2-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(r==<span class="literal">NULL</span>)&#123;<span class="comment">//没有结点  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    s=r-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">NULL</span>)&#123;<span class="comment">//一个结点  </span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    t=s-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(t)&#123;  </span><br><span class="line">        s-&gt;next=r;<span class="comment">//逆转  </span></span><br><span class="line">        r=s;  </span><br><span class="line">        s=t;  </span><br><span class="line">        t=t-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;next=r;  </span><br><span class="line">    L2-&gt;next-&gt;next=<span class="literal">NULL</span>;<span class="comment">//逆置后原链表第一个结点，变成最后一个结点，它的next=NULL;  </span></span><br><span class="line">    L2-&gt;next=s;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//逆转函数逆转的是L2链表，执行次数是n/2,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//合并方法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(LinkList L,LinkList L2)</span>&#123;  </span><br><span class="line">    LinkList pcur,p,q;  </span><br><span class="line">    pcur=L-&gt;next;  </span><br><span class="line">    p=pcur-&gt;next;  </span><br><span class="line">    q=L2-&gt;next;  </span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        pcur-&gt;next=q;  </span><br><span class="line">        q=q-&gt;next;  </span><br><span class="line">        pcur=pcur-&gt;next;  </span><br><span class="line">        pcur-&gt;next=p;  </span><br><span class="line">        p=p-&gt;next;  </span><br><span class="line">        pcur=pcur-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//上面merge函数的while循环遍历次数是n/2,所以时间复杂度是O(n)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkList L;  </span><br><span class="line">    LinkList L2;  </span><br><span class="line">  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">  </span><br><span class="line">    find_middle(L,L2);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    print_LinKlist(L2);  </span><br><span class="line">  </span><br><span class="line">    reverse(L2);  </span><br><span class="line">    print_LinKlist(L2);  </span><br><span class="line">  </span><br><span class="line">    merge(L,L2);  </span><br><span class="line">    <span class="built_in">free</span>(L2);  </span><br><span class="line">    print_LinKlist(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line"><span class="comment">//综上，merge、find_middle、reverse函数总的时间复杂度是1.5n,忽略首项系数O(n)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ测试"><a href="#OJ测试" class="headerlink" title="OJ测试"></a>OJ测试</h3><p>作业说明<img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304032107529.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LNOde,*Linklist;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//尾插法新建链表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_tail_insert</span><span class="params">(Linklist &amp;L)</span>&#123;  </span><br><span class="line">    L=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    L-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    Linklist s,r=L;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;  </span><br><span class="line">        s=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">        s-&gt;data=x;  </span><br><span class="line">        r-&gt;next=s;  </span><br><span class="line">        r=s;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置查找的方法  </span></span><br><span class="line">Linklist <span class="title function_">getEle_by_pos</span><span class="params">(Linklist L,<span class="type">int</span> pos)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> L;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(pos&lt;<span class="number">1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(L&amp;&amp;i&lt;pos)&#123; <span class="comment">//注意：while(i&lt;pos)&#123;&#125; 忽略了L为空 也不能循环 </span></span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> L;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//按位置插入的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">list_insert</span><span class="params">(Linklist L,<span class="type">int</span> i,<span class="type">int</span> insert)</span>&#123;  </span><br><span class="line">    Linklist p = getEle_by_pos(L,i - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Linklist s;  </span><br><span class="line">  </span><br><span class="line">    s=(Linklist) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  </span><br><span class="line">    s-&gt;next=p-&gt;next;  </span><br><span class="line">    s-&gt;data=insert;  </span><br><span class="line">    p-&gt;next=s;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_list</span><span class="params">(Linklist L)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(L)&#123;  </span><br><span class="line">        L=L-&gt;next;  </span><br><span class="line">        <span class="keyword">if</span>(L==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,L-&gt;data);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    Linklist L;  </span><br><span class="line">    list_tail_insert(L);  </span><br><span class="line">    print_list(L);  </span><br><span class="line">    list_insert(L,<span class="number">2</span>,<span class="number">99</span>);  </span><br><span class="line">    print_list(L);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="栈原理解析"><a href="#栈原理解析" class="headerlink" title="栈原理解析"></a>栈原理解析</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042113354.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042114958.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体(栈)</span></span><br><span class="line">typrdef <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">Elemtype data[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时栈为空</span></span><br><span class="line">S.top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="comment">//前加加，先获取栈位置，在加元素</span></span><br><span class="line"><span class="comment">//S.top=S.top+1;</span></span><br><span class="line"><span class="comment">//S.data[S.top]=4;</span></span><br><span class="line">S.data[++S.top]</span><br><span class="line"></span><br><span class="line"><span class="comment">//前加加--&gt;先做加1，后做其他运算；</span></span><br><span class="line"><span class="comment">//后加加--&gt;先做其他运算，在做加1；</span></span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042114934.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="comment">//后减减，先拿到取出的元素</span></span><br><span class="line"><span class="comment">//x=S.data[S.top];</span></span><br><span class="line"><span class="comment">//S.top=S.top-1;</span></span><br><span class="line">x=S.data[S.top--]</span><br></pre></td></tr></table></figure></p><h3 id="初始化栈-入栈-出栈"><a href="#初始化栈-入栈-出栈" class="headerlink" title="初始化栈-入栈-出栈"></a>初始化栈-入栈-出栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 50  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义栈结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ElemType data[Maxsize];<span class="comment">//栈空间  </span></span><br><span class="line">    <span class="type">int</span> top;<span class="comment">//栈针  </span></span><br><span class="line">&#125;SqStack;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化栈方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(SqStack &amp;S)</span>&#123;  </span><br><span class="line">    S.top=<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//压栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==Maxsize<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//S.data[S.top++]=e; //先赋值，然后+</span></span><br><span class="line">    S.data[++S.top]=e;  <span class="comment">//先+，然后赋值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印栈的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_satck</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;S.top+<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,S.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断栈是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//弹栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(isEmpty(S))&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=S.data[S.top--];<span class="comment">//拿完栈顶元素后，弹栈  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqStack S;  </span><br><span class="line">    innit(S);  </span><br><span class="line">      </span><br><span class="line">    Push(S,<span class="number">79</span>);  </span><br><span class="line">    Push(S,<span class="number">2</span>);  </span><br><span class="line">    Push(S,<span class="number">3</span>);  </span><br><span class="line">    print_satck(S);  </span><br><span class="line">  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    <span class="type">bool</span> flag;  </span><br><span class="line">    flag=Pop(S,e);  </span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;  </span><br><span class="line">        print_satck(S);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列循环队列原理解析"><a href="#队列循环队列原理解析" class="headerlink" title="队列循环队列原理解析"></a>队列循环队列原理解析</h3><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042117893.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">队列实现有两种常见方式：数组、链表</span><br><span class="line"></span><br><span class="line">特点：允许头部删除，尾部增加</span><br></pre></td></tr></table></figure><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">循环队列实现是通过数组的方式</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119873.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042144375.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119533.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042119792.png" alt="image.png"></p><h5 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链式队列的实现通过链表</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042121691.png" alt="image.png"></p><h3 id="循环队列数组实现"><a href="#循环队列数组实现" class="headerlink" title="循环队列数组实现"></a>循环队列数组实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Maxsize 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//循环队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ElemType data[Maxsize];<span class="comment">//数组，存储Maxsize-1个元素  </span></span><br><span class="line">    <span class="type">int</span> front,rear;<span class="comment">//队列头，队列尾  </span></span><br><span class="line">&#125;SqQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Innit</span><span class="params">(SqQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%Maxsize==Q.front)&#123;<span class="comment">//判断队列是否满了  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Q.data[Q.rear]=e;<span class="comment">//放入元素  </span></span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%Maxsize;<span class="comment">//改变队尾标记  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    x=Q.data[Q.front];<span class="comment">//拿到删除的元素  </span></span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%Maxsize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(SqQueue Q)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=Q.front;i&lt;Q.rear;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Q.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqQueue Q;  </span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    ElemType e; </span><br><span class="line">    </span><br><span class="line">    Innit(Q);  </span><br><span class="line">    EnQueue(Q,<span class="number">29</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">39</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">9</span>);  </span><br><span class="line">    print_queue(Q);  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    flag=OutQueue(Q,e); </span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pop success ,the pop value is %d\n&quot;</span>,e);</span><br><span class="line">    &#125; </span><br><span class="line">    print_queue(Q);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042122600.png" alt="image.png"></p><h3 id="队列链表实现-1"><a href="#队列链表实现-1" class="headerlink" title="队列链表实现-1"></a>队列链表实现-1</h3><p>这是 带有头结点 的方式实现<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一般队列的头结点是否有数据取决于队列的实现方式：</span><br><span class="line"></span><br><span class="line">-   如果队列是用数组实现的，那么头结点就是数组的第一个元素，它有数据；</span><br><span class="line">-   如果队列是用链表实现的，那么头结点可以是一个空结点，也可以是链表的第一个元素，这取决于是否使用带头结点的链表。如果使用带头结点的链表，那么头结点没有数据，只是一个指针；如果使用不带头结点的链表，那么头结点就是链表的第一个元素，它有数据。</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemype;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>  </span><br><span class="line">    Elemype data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LinkNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    LinkList front,rear;<span class="comment">//链表头，链表尾  </span></span><br><span class="line">&#125;LinkQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  <span class="comment">//这是一种带头结点的实现方式</span></span><br><span class="line">    Q.rear-&gt;next</span><br><span class="line">    =<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数,尾部插入法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,Elemype x)</span>&#123;  </span><br><span class="line">    LinkList s;  </span><br><span class="line">    s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    s-&gt;data=x;  </span><br><span class="line">    Q.rear-&gt;next=s;  </span><br><span class="line">    Q.rear=s;<span class="comment">//注意这一步容易漏掉  </span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//判断一个元素也没有  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LinkList s=Q.front-&gt;next;  </span><br><span class="line">    Q.front-&gt;next=s-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==s)&#123;<span class="comment">//判断删除的是最后一个元素  </span></span><br><span class="line">        Q.rear=Q.front;<span class="comment">//队列为空  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    LinkQueue Q;  </span><br><span class="line">    innit(Q);  </span><br><span class="line">  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">    EnQueue(Q,<span class="number">20</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">bool</span> ret;  </span><br><span class="line">    ret= OutQueue(Q);  </span><br><span class="line">    <span class="keyword">if</span>(ret)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pop success&quot;</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Pop fail&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列链表的实现-2"><a href="#队列链表的实现-2" class="headerlink" title="队列链表的实现-2"></a>队列链表的实现-2</h3><ul><li>带头结点的队列，队列的头指针和尾指针都指向一个空的头结点，头结点的next指针指向第一个元素，尾结点的next指针为NULL。</li><li></li><li>不带头结点的队列，队列的头指针指向第一个元素，尾指针指向最后一个元素，尾结点的<br>不带头结点</li></ul><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042149365.png" alt="image.png"></p><p>不带头结点的链表<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*实现不带头结点的链式队列*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">bool</span> Status;</span><br><span class="line"><span class="comment">/*0.定义链式队列的基本结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> &#123;</span></span><br><span class="line">    <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode* front, * rear; <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"><span class="comment">/*1.初始化链式队列 (不带头结点)*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(LinkQueue&amp; Q)</span> &#123;<span class="comment">//初始时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*2.判断队列是为空（不带头结点）*/</span></span><br><span class="line">Status <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*3.入队 (不带头结点)*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue&amp; Q, ElemType x)</span> &#123;</span><br><span class="line">    LinkNode* s = (LinkNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>) <span class="comment">//在空的队列中插入第一元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">        Q.front = s; <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Q.rear-&gt;next = s; <span class="comment">//新结点插入到rear之后</span></span><br><span class="line">        Q.rear = s; <span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*4.出队（不带头结点）*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue&amp; Q, ElemType&amp; x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//空队</span></span><br><span class="line">    LinkNode* p = Q.front; <span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data; <span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next; <span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span> (Q.rear == p) <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q.front = <span class="literal">NULL</span>; <span class="comment">//front指向NULL</span></span><br><span class="line">        Q.rear = <span class="literal">NULL</span>; <span class="comment">//rear指向NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    LinkQueue Q;</span><br><span class="line">    ElemType x = <span class="number">-1</span>;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    EnQueue(Q, <span class="number">3</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">6</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">8</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">9</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">7</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        DeQueue(Q, x);</span><br></pre></td></tr></table></figure></p><h3 id="OJ测试-1"><a href="#OJ测试-1" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042124302.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 5  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义一个栈结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> top;  </span><br><span class="line">&#125;SqStack;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义一个循环队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType data[MaxSize];  </span><br><span class="line">    <span class="type">int</span> front,rear;<span class="comment">//队列头，队列尾  </span></span><br><span class="line">&#125;SqQueue;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化栈方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(SqStack &amp;S)</span>&#123;  </span><br><span class="line">    S.top=<span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Push</span><span class="params">(SqStack &amp;S,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==MaxSize<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    S.data[++S.top]=e;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出栈方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(S.top==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=S.data[S.top--];  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印栈的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_stack</span><span class="params">(SqStack S)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;S.top+<span class="number">1</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,S.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(SqQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize==Q.front)&#123;<span class="comment">//判断队列是否满  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Q.data[Q.rear]=e;  </span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MaxSize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列方法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;e)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    e=Q.data[Q.front];  </span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MaxSize;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印队列的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_queue</span><span class="params">(SqQueue Q)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=Q.front;i&lt;Q.rear;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,Q.data[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SqStack S;  </span><br><span class="line">    initStack(S);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i,num;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);  </span><br><span class="line">        Push(S,num);  </span><br><span class="line">    &#125;  </span><br><span class="line">    print_stack(S);  </span><br><span class="line">  </span><br><span class="line">    ElemType m;<span class="comment">//用来存放拿出来的元素  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;  </span><br><span class="line">        Pop(S,m);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the ride num is %d\n&quot;</span>,m);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    SqQueue Q;  </span><br><span class="line">    ElemType e;  </span><br><span class="line">    initQueue(Q);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i2,num2;  </span><br><span class="line">    <span class="type">bool</span> flag;  </span><br><span class="line">    <span class="keyword">for</span>(i2=<span class="number">0</span>;i2&lt;<span class="number">5</span>;i2++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num2);  </span><br><span class="line">        flag=EnQueue(Q,num2);  </span><br><span class="line">        <span class="keyword">if</span>(!flag)&#123;  </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;flase Queue is full\n&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(i2=<span class="number">0</span>;i2&lt;<span class="number">4</span>;i2++)&#123;  </span><br><span class="line">        OutQueue(Q,e);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,e);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二叉树的建树和遍历"><a href="#二叉树的建树和遍历" class="headerlink" title="二叉树的建树和遍历"></a>二叉树的建树和遍历</h2><h3 id="树与二叉树原理解析"><a href="#树与二叉树原理解析" class="headerlink" title="树与二叉树原理解析"></a>树与二叉树原理解析</h3><h4 id="树原理解析"><a href="#树原理解析" class="headerlink" title="树原理解析"></a>树原理解析</h4><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042158536.png" alt="image.png"></p><h4 id="二叉树原理"><a href="#二叉树原理" class="headerlink" title="二叉树原理"></a>二叉树原理</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、满二叉树:每一层都放满了</span><br><span class="line"></span><br><span class="line">2、完全二叉树:除了最后一层，前面层数全部放满，最后一层从左往右，只能是右侧有空</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042159720.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042200909.png" alt="image.png"></p><h3 id="二叉树的层次建树"><a href="#二叉树的层次建树" class="headerlink" title="二叉树的层次建树"></a>二叉树的层次建树</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201927.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201135.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上面层次建树的实现通过辅助队列实现</span><br><span class="line">每加一个元素，辅助队列就往队尾加一个元素</span><br><span class="line">而pcur指针判断结点的左右两侧都放满了时，才往后移动</span><br><span class="line">这样就实现了层次建树</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042201587.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">以下代码实现了，输入abcdefgj一串连续字符，然后按层次建树存储</span><br><span class="line"></span><br><span class="line">这里的辅助队列有四个指针：front-rear-listpnew-pcur 起初都赋值为NULL,就是没有头结点得方式创建队列</span><br><span class="line"></span><br><span class="line">front指向第一个结点</span><br><span class="line">rear指向末尾结点</span><br><span class="line">listpnew指向新加元素</span><br><span class="line">pcur指向当前结点</span><br><span class="line"></span><br><span class="line">这里的二叉树有一个指针:pnew指向树的最新结点</span><br></pre></td></tr></table></figure><p>头文件  function.h 代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure></p><p>主文件 main.cpp 代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//赋值为NULL用于下面的if判断  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//但是二叉树没有头结点</span></span><br><span class="line">    <span class="comment">//第一个结点就是树根，用来存数据 </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur=<span class="literal">NULL</span>;<span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        <span class="comment">//if无论是否满足条件都会向下执行，else if只有在上一个条件不满足的情况下才会执行</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的-前中后-序遍历"><a href="#二叉树的-前中后-序遍历" class="headerlink" title="二叉树的-前中后-序遍历"></a>二叉树的-前中后-序遍历</h3><p>递归思想</p><pre><code>1前序遍历:PreOrder     前序遍历也叫深度优先遍历2中序遍历：InOrder3后序遍历：PostOrder</code></pre><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure></p><p>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历，先序遍历，也叫深度优先遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        PreOrder(p-&gt;lift);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(p-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        InOrder(p-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//后序遍历  </span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">PostOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        PostOrder(p-&gt;lift);  </span><br><span class="line">        PostOrder(p-&gt;right);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//用来指向树根  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    InOrder(root);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h3><p>也称广度优先遍历<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[二叉树的广度优先遍历是一种按层次遍历二叉树的方法，它的顺序是从上到下，从左到右，依次访问每一层的节点][。广度优先遍历的原则就是对每一层的节点依次访问，一层访问结束后，进入下一层，直到最后一个节点，每个节点都只访问一次]</span><br><span class="line">[二叉树的广度优先遍历的实现需要借助队列（Queue）这种数据结构，它的特点是先进先出。首先将根节点入队，然后循环执行以下操作，直到队列为空：从队列中取出一个节点，访问它，然后将它的左右子节点（如果有的话）入队]。</span><br><span class="line"></span><br><span class="line">例如，对于下图的二叉树，广度优先遍历的结果是 &#123;1，2，3，4，5，6，7，8，9，10&#125;，遍历过程如下：</span><br><span class="line"></span><br><span class="line">1.  将根节点1入队，队列为【1】</span><br><span class="line">2.  取出节点1，访问它，将它的左右子节点2和3入队，队列为【2，3】</span><br><span class="line">3.  取出节点2，访问它，将它的左右子节点4和5入队，队列为【3，4，5】</span><br><span class="line">4.  取出节点3，访问它，将它的右子节点6入队，队列为【4，5，6】</span><br><span class="line">5.  取出节点4，访问它，将它的左右子节点8和9入队，队列为【5，6，8，9】</span><br><span class="line">6.  取出节点5，访问它，将它的右子节点10入队，队列为【6，8，9，10】</span><br><span class="line">7.  取出节点6，访问它，没有子节点，队列为【8，9，10】</span><br><span class="line">8.  取出节点8，访问它，没有子节点，队列为【9，10】</span><br><span class="line">9.  取出节点9，访问它，没有子节点，队列为【10】</span><br><span class="line">10.  取出节点10，访问它，没有子节点，队列为空，遍历结束</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042208835.png" alt="image.png"></p><p>代码采用3给文件</p><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by 123 on 2023/3/11.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INC_1_TREE_FUNCTION_H  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INC_1_TREE_FUNCTION_H  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//树相关结构  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BiElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span>  </span><br><span class="line">    BiElemType c;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次建树的辅助队列  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次遍历的辅助队列相关结构  </span></span><br><span class="line"><span class="keyword">typedef</span> BiTree ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>* <span class="title">next</span>;</span>  </span><br><span class="line">&#125;LinkNode,*LinkList;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    LinkList front,rear;<span class="comment">//链表头，链表尾  </span></span><br><span class="line">&#125;LinkQueue;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化队列  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>;  </span><br><span class="line"><span class="comment">//入队  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>;  </span><br><span class="line"><span class="comment">//出队  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>;  </span><br><span class="line"><span class="comment">//判断是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//INC_1_TREE_FUNCTION_H</span></span></span><br></pre></td></tr></table></figure></p><p>Queue.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by 123 on 2023/3/11.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line"><span class="comment">//初始化链表的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">innit</span><span class="params">(LinkQueue &amp;Q)</span>&#123;  </span><br><span class="line">    Q.rear=Q.front=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    Q.rear-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//入队列函数,尾部插入法  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span>&#123;  </span><br><span class="line">    LinkList s;  </span><br><span class="line">    s=(LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));  </span><br><span class="line">    s-&gt;data=x;  </span><br><span class="line">    Q.rear-&gt;next=s;  </span><br><span class="line">    Q.rear=s;<span class="comment">//注意这一步容易漏掉  </span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//出队列函数  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">OutQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.front-&gt;next==<span class="literal">NULL</span>)&#123;<span class="comment">//判断一个元素也没有  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LinkList s=Q.front-&gt;next;  </span><br><span class="line">    x=s-&gt;data;  </span><br><span class="line">    Q.front-&gt;next=s-&gt;next;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==s)&#123;<span class="comment">//判断删除的是最后一个元素  </span></span><br><span class="line">        Q.rear=Q.front;<span class="comment">//队列为空  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">free</span>(s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//判断是否为空  </span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(LinkQueue Q)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历，先序遍历，也叫深度优先遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        PreOrder(p-&gt;lift);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(p-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, p-&gt;c);  </span><br><span class="line">        InOrder(p-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//后序遍历  </span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">PostOrder</span><span class="params">(BiTree p)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        PostOrder(p-&gt;lift);  </span><br><span class="line">        PostOrder(p-&gt;right);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;c);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//层次遍历（广度优先遍历）  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="comment">//辅助队列  </span></span><br><span class="line">    LinkQueue Q;  </span><br><span class="line">    <span class="comment">//初始化队列  </span></span><br><span class="line">    innit(Q);  </span><br><span class="line">    BiTree p;<span class="comment">//获取出队元素  </span></span><br><span class="line">    <span class="comment">//树根入队  </span></span><br><span class="line">    EnQueue(Q,T);  </span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;  </span><br><span class="line">        <span class="comment">//出队列的同时，判断出去的这个元素，左右子树是否存在，存在就入队  </span></span><br><span class="line">        <span class="comment">//循环这个过程，直到队列为空  </span></span><br><span class="line">        OutQueue(Q,p);<span class="comment">//出队函数，能获得出队元素，切将出队元素赋值给p  </span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;c);  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lift!=<span class="literal">NULL</span>)&#123;<span class="comment">//入队左子树  </span></span><br><span class="line">            EnQueue(Q,p-&gt;lift);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right!=<span class="literal">NULL</span>)&#123;<span class="comment">//入队右子树  </span></span><br><span class="line">            EnQueue(Q,p-&gt;right);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//首先层次建树</span></span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//用来指向树根  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向队列的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);   <span class="comment">//前序遍历（深度优先遍历）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); </span><br><span class="line">    InOrder(root);    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    PreOrder(root);   <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    LevelOrder(root);  <span class="comment">//广度优先遍历</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="真题-求带权路径长度"><a href="#真题-求带权路径长度" class="headerlink" title="真题-求带权路径长度"></a>真题-求带权路径长度</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042210307.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由于与深度有关，可采用深度优先遍历方式(可以获取深度)，最后返回wpl</span><br></pre></td></tr></table></figure><p>function.h代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElenType;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树的链表结点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElenType c;<span class="comment">//数据域  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span><span class="comment">//指针域:左指针、右指针  </span></span><br><span class="line">&#125;BiTNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//辅助队列的链表结点  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tag</span>&#123;</span>  </span><br><span class="line">    BiTree p;<span class="comment">//p获取数的结点  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">pnext</span>;</span>  </span><br><span class="line">&#125;tag,*ptag;</span><br></pre></td></tr></table></figure><br>main.cpp代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;function.h&quot;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//int wpl=0;  </span></span><br><span class="line"><span class="comment">//全局变量，和静态局部变量都是放在数据段  </span></span><br><span class="line"><span class="comment">//静态局部变量只能局部访问，全局变量全局访问  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//前序遍历,参数增加一个深度deep  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">PreOrder</span><span class="params">(BiTree p,<span class="type">int</span> deep)</span>&#123;  </span><br><span class="line">    <span class="comment">//静态变量，只会初始化一次，递归的时候不会再次执行，直接访问  </span></span><br><span class="line">    <span class="comment">//只能局部访问，所以将其以返回值的形式返回  </span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl=<span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lift==<span class="literal">NULL</span>&amp;&amp;p-&gt;right==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            wpl+=p-&gt;c*deep;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ele%c---deep%d\n&quot;</span>, p-&gt;c,deep);  </span><br><span class="line">        PreOrder(p-&gt;lift,deep+<span class="number">1</span>);<span class="comment">//打印左子树  </span></span><br><span class="line">        PreOrder(p-&gt;right,deep+<span class="number">1</span>);<span class="comment">//打印又子树  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> wpl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree pnew;<span class="comment">//用来指向树的新节点  </span></span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;<span class="comment">//这里赋值NULL用于下面的判断  </span></span><br><span class="line">    <span class="comment">//注意，树根不像链表头结点  </span></span><br><span class="line">    <span class="comment">//链表头结点用来指向第一个结点，里面可以不放东西  </span></span><br><span class="line">    <span class="comment">//根就相当于第一个结点，必须有数据  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span> c;  </span><br><span class="line">    <span class="comment">//队列头、队列尾、指向树的新节点、指向当前队列结点  </span></span><br><span class="line">    ptag front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">//calloc申请的空间大小是两个参数相乘，并且初始化空间，赋值为Null(左右指针赋值为Null)  </span></span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BiTNode));  </span><br><span class="line">        pnew-&gt;c=c;  </span><br><span class="line">        listpnew= (ptag)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(tag));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="comment">//如果是树的第一个结点  </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;<span class="comment">//root指向根结点  </span></span><br><span class="line">            rear=front=listpnew;  </span><br><span class="line">            pcur=listpnew;<span class="comment">//pcur要指向要进入树的父亲元素(当前元素)  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;pnext=listpnew;<span class="comment">//入队列  </span></span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;<span class="comment">//左为空，放入左  </span></span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;<span class="comment">//右为空，放入右  </span></span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                <span class="comment">//此时结点满了  </span></span><br><span class="line">                <span class="comment">//pcur往后移一位  </span></span><br><span class="line">                pcur=pcur-&gt;pnext;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;=================\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;wpl=%d&quot;</span>,PreOrder(root,<span class="number">0</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OJ测试-2"><a href="#OJ测试-2" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304042211919.png" alt="image.png"></p><p>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;  </span><br><span class="line"><span class="comment">//二叉树结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span>  </span><br><span class="line">    ElemType data;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;TNode,*BiTree;  </span><br><span class="line"><span class="comment">//辅助队列结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span>  </span><br><span class="line">    BiTree p;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span>  </span><br><span class="line">&#125;QNode,*Queue;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOreder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);  </span><br><span class="line">        PreOreder(T-&gt;lift);  </span><br><span class="line">        PreOreder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    ElemType c;  </span><br><span class="line">    BiTree root=<span class="literal">NULL</span>;  </span><br><span class="line">    BiTree pnew;  </span><br><span class="line">  </span><br><span class="line">    Queue front=<span class="literal">NULL</span>,rear=<span class="literal">NULL</span>,listpnew=<span class="literal">NULL</span>,pcur=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;c))&#123;  </span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;\n&#x27;</span>)&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (TNode));  </span><br><span class="line">        pnew-&gt;data=c;  </span><br><span class="line">        listpnew=(Queue) <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(QNode));  </span><br><span class="line">        listpnew-&gt;p=pnew;  </span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            root=pnew;  </span><br><span class="line">            front=rear=pcur=listpnew;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            rear-&gt;next=listpnew;  </span><br><span class="line">            rear=listpnew;  </span><br><span class="line">            <span class="keyword">if</span>(pcur-&gt;p-&gt;lift==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                pcur-&gt;p-&gt;lift=pnew;  </span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pcur-&gt;p-&gt;right==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                pcur-&gt;p-&gt;right=pnew;  </span><br><span class="line">                pcur=pcur-&gt;next;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    PreOreder(root);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="顺序表查找原理及实战"><a href="#顺序表查找原理及实战" class="headerlink" title="顺序表查找原理及实战"></a>顺序表查找原理及实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ELemType* elem;<span class="comment">//整数型指针，申请的对空间起始地址存入elem  </span></span><br><span class="line">    <span class="type">int</span> TableLen;<span class="comment">//存储动态数组里边元素的个数  </span></span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_init</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    <span class="comment">//多申请一个位置，是为了存哨兵的，不用哨兵也可以的  </span></span><br><span class="line">    ST.TableLen=len+<span class="number">1</span>;  </span><br><span class="line">    ST.elem= (ELemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ELemType)*ST.TableLen);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));<span class="comment">//随机数生成  </span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;ST.TableLen;i++)&#123;<span class="comment">//因为第0个放的位置是哨兵，所以从1开始随机  </span></span><br><span class="line">        ST.elem[i]=rand() % <span class="number">100</span>;<span class="comment">//生成1-99之间的随机数  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">st_print</span><span class="params">(SSTable ST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;ST.TableLen;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ST.elem[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">Search_Seq</span><span class="params">(SSTable ST,ELemType e)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=ST.TableLen<span class="number">-1</span>;ST.elem[i]!=e;--i)&#123;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> i;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable ST;  </span><br><span class="line">    st_init(ST,<span class="number">9</span>);  </span><br><span class="line">    st_print(ST);  </span><br><span class="line">    ELemType key;  </span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input search by\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);  </span><br><span class="line">    pos=Search_Seq(ST,key);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the postion is %d&quot;</span>,pos);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找原理及实战"><a href="#二分查找原理及实战" class="headerlink" title="二分查找原理及实战"></a>二分查找原理及实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ELemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>  </span><br><span class="line">    ELemType* elem;  </span><br><span class="line">    <span class="type">int</span> Tablelen;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_init</span><span class="params">(SSTable &amp;ST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    ST.Tablelen=len;  </span><br><span class="line">    ST.elem=(ELemType*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ELemType)*ST.Tablelen);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.Tablelen;i++)&#123;  </span><br><span class="line">        ST.elem[i]=rand() % <span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">st_print</span><span class="params">(SSTable ST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;ST.Tablelen;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,ST.elem[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二分查找方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(SSTable ST,<span class="type">int</span> key)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> mid;  </span><br><span class="line">    <span class="type">int</span> end=ST.Tablelen<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;  </span><br><span class="line">        mid=(begin+end)/<span class="number">2</span>;  </span><br><span class="line">        <span class="comment">//注意：是else if 不能写成if，并且三个判断只能执行一个  </span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;ST.elem[mid])&#123;  </span><br><span class="line">            end=mid<span class="number">-1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key&gt;ST.elem[mid])&#123;  </span><br><span class="line">            begin=mid+<span class="number">1</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//函数名中存储的是函数入口地址，也是一个指针，是函数指针类型  </span></span><br><span class="line"><span class="comment">//qsort规定如果left指针指向的值，大于right指针指向的值,返回正值  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *left,<span class="type">const</span> <span class="type">void</span> *right)</span>&#123;<span class="comment">//固定形式，照着写就行  </span></span><br><span class="line">    <span class="comment">//要先强转成int类型指针然后取值 比较  </span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)left-*(<span class="type">int</span>*)right;<span class="comment">//从小到大排序  </span></span><br><span class="line">    <span class="comment">//return *(int*)right-*(int*)left;//从小到大排序  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable ST;  </span><br><span class="line">    <span class="type">int</span> key;  </span><br><span class="line">    st_init(ST,<span class="number">10</span>);<span class="comment">//初始化  </span></span><br><span class="line">    st_print(ST);<span class="comment">//打印  </span></span><br><span class="line">    qsort(ST.elem,ST.Tablelen,<span class="keyword">sizeof</span> (ELemType),compare);<span class="comment">//升序排序  </span></span><br><span class="line">    st_print(ST);<span class="comment">//打印  </span></span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;please input the number that you want to search\n&quot;</span>);  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;key);  </span><br><span class="line">    pos=binary_search(ST,key);  </span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">-1</span>)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;false,the number is not exit&quot;</span>);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the pos is %3d&quot;</span>,pos);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉排序树原理及建树"><a href="#二叉排序树原理及建树" class="headerlink" title="二叉排序树原理及建树"></a>二叉排序树原理及建树</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041946000.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">lift</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BSNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树元素插入  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(BiTree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T= (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    BiTree p=T;<span class="comment">//p是用来遍历的  </span></span><br><span class="line">    BiTree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;<span class="comment">//指向p的父节点，以便追加加点  </span></span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;lift;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//开始申请新节点的空间  </span></span><br><span class="line">    BiTree pnew;  </span><br><span class="line">    pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="comment">//判断是加在parent结点的左子节点还是右子节点  </span></span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;lift=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;right=pnew;  </span><br><span class="line">    &#125;<span class="comment">//不用判断等于的情况，因为上面遍历树的时候当结点值相等时，该方法就结束了  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建二叉树  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_bstree</span><span class="params">(BiTree &amp;T,ElemType str[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    T=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        BST_insert(T,str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(T-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, T-&gt;key);  </span><br><span class="line">        InOrder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    BiTree T;  </span><br><span class="line">    ElemType str[<span class="number">9</span>]=&#123;<span class="number">12</span>,<span class="number">34</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">12</span>&#125;;  </span><br><span class="line">    creat_bstree(T,str,<span class="number">9</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的删除实战"><a href="#二叉查找树的删除实战" class="headerlink" title="二叉查找树的删除实战"></a>二叉查找树的删除实战</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">left</span>,*<span class="title">righr</span>;</span>  </span><br><span class="line">&#125;BSNode,*BiTree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(BiTree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    BiTree p=T;  </span><br><span class="line">    BiTree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;  </span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;left;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;righr;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//申请要加入元素的新节点空间  </span></span><br><span class="line">    BiTree pnew;  </span><br><span class="line">    pnew=(BiTree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;left=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;righr=pnew;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//创建二叉查找树的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_BSTree</span><span class="params">(BiTree &amp;T,ElemType str[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    T=<span class="literal">NULL</span>;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        BST_insert(T,str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历打印二叉树  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree T)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        InOrder(T-&gt;left);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,T-&gt;key);  </span><br><span class="line">        InOrder(T-&gt;righr);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二叉树的查找方法  </span></span><br><span class="line">BiTree <span class="title function_">BS_Search</span><span class="params">(BiTree T,ElemType key)</span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(T!=<span class="literal">NULL</span>&amp;&amp;key!=T-&gt;key)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(key&lt;T-&gt;key)&#123;  </span><br><span class="line">            T=T-&gt;left;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            T=T-&gt;righr;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> T;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//删除二叉排序树元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_BSNode</span><span class="params">(BiTree &amp;root,ElemType x)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(x&lt;root-&gt;key)&#123;  </span><br><span class="line">        delete_BSNode(root-&gt;left,x);  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;key)&#123;  </span><br><span class="line">        delete_BSNode(root-&gt;righr,x);  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//查找到了要删的结点  </span></span><br><span class="line">        <span class="comment">//如果左子树为空，右结点顶上去  </span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            BiTree tempNode=root;  </span><br><span class="line">            root=root-&gt;righr;  </span><br><span class="line">            <span class="built_in">free</span>(tempNode);  </span><br><span class="line">            <span class="comment">//如果右子树为空，左节点顶上去  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;righr==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">            BiTree tempNode=root;  </span><br><span class="line">            root=root-&gt;left;  </span><br><span class="line">            <span class="built_in">free</span>(tempNode);  </span><br><span class="line">            <span class="comment">//如果左右子树都不为空  </span></span><br><span class="line">            <span class="comment">//1-左子树最大顶上去；2-右子树最下顶上去  </span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            BiTree p=root-&gt;left;<span class="comment">//遍历左子树，寻找左子树最大  </span></span><br><span class="line">            <span class="keyword">while</span>(p-&gt;righr!=<span class="literal">NULL</span>)&#123;  </span><br><span class="line">                p=p-&gt;righr;  </span><br><span class="line">            &#125;  </span><br><span class="line">            root-&gt;key=p-&gt;key;<span class="comment">//将p的值赋给root  </span></span><br><span class="line">            <span class="comment">//然后删除p  </span></span><br><span class="line">            delete_BSNode(root-&gt;left,p-&gt;key);  </span><br><span class="line">                <span class="comment">//这里得从左子树找，因为root的key也是和p一样  </span></span><br><span class="line">                <span class="comment">//这样可以略过根结点  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    BiTree T;  </span><br><span class="line">    ElemType str[<span class="number">8</span>]=&#123;<span class="number">13</span>,<span class="number">4</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">23</span>,<span class="number">7</span>,<span class="number">95</span>,<span class="number">48</span>&#125;;  </span><br><span class="line">    ElemType key;  </span><br><span class="line">  </span><br><span class="line">    creat_BSTree(T,str,<span class="number">8</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    ElemType x;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ndelet 23\n&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    delete_BSNode(T,<span class="number">23</span>);  </span><br><span class="line">    InOrder(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OJ测试-3"><a href="#OJ测试-3" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041948855.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span>&#123;</span>  </span><br><span class="line">    ElemType key;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSNode</span> *<span class="title">lift</span>,*<span class="title">right</span>;</span>  </span><br><span class="line">&#125;BSNode,*Bitree;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//插入元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BST_insert</span><span class="params">(Bitree &amp;T,ElemType k)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)&#123;  </span><br><span class="line">        T=(Bitree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span> (BSNode));  </span><br><span class="line">        T-&gt;key=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Bitree p;<span class="comment">//p用来遍历树  </span></span><br><span class="line">    p=T;  </span><br><span class="line">    Bitree parent;  </span><br><span class="line">    <span class="keyword">while</span>(p)&#123;  </span><br><span class="line">        parent=p;<span class="comment">//用来指向p的父节点  </span></span><br><span class="line">        <span class="keyword">if</span>(k==p-&gt;key)&#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k&lt;p-&gt;key)&#123;  </span><br><span class="line">            p=p-&gt;lift;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            p=p-&gt;right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Bitree pnew;  </span><br><span class="line">    pnew=(Bitree) <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="keyword">sizeof</span>(BSNode));  </span><br><span class="line">    pnew-&gt;key=k;  </span><br><span class="line">    <span class="keyword">if</span>(k&lt;parent-&gt;key)&#123;  </span><br><span class="line">        parent-&gt;lift=pnew;  </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">        parent-&gt;right=pnew;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_bstree</span><span class="params">(Bitree &amp;T,ElemType *str,<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">   T=<span class="literal">NULL</span>;  </span><br><span class="line">   <span class="type">int</span> i;  </span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;  </span><br><span class="line">       BST_insert(T,str[i]);  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//中序遍历二叉树  </span></span><br><span class="line">ElemType* <span class="title function_">InOrder</span><span class="params">(Bitree T)</span>&#123;<span class="comment">//无法直接返回数组形式，但是可以返回一个数组形式的指针  </span></span><br><span class="line">    <span class="type">static</span> ElemType str2[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(T!=<span class="literal">NULL</span>) &#123;  </span><br><span class="line">        InOrder(T-&gt;lift);  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>, T-&gt;key);  </span><br><span class="line">        str2[i]=T-&gt;key;  </span><br><span class="line">        i++;  </span><br><span class="line">        InOrder(T-&gt;right);  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">return</span> str2;<span class="comment">//返回一个指针  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//二分查找的方法 ，返回元素下标 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(ElemType str[],<span class="type">int</span> x)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> begin=<span class="number">0</span>,mid,end=<span class="number">10</span>;  </span><br><span class="line">    <span class="keyword">while</span>(begin&lt;=end)&#123;  </span><br><span class="line">        mid=(begin+end)/<span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(x==str[mid])&#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;str[mid])&#123;  </span><br><span class="line">            begin=mid;  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            end=mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    Bitree root;<span class="comment">//定义一个舒更  </span></span><br><span class="line">    ElemType str[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> k;<span class="comment">//存放输入的数据  </span></span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);  </span><br><span class="line">        str[i]=k;  </span><br><span class="line">    &#125;  </span><br><span class="line">    creat_bstree(root,str,<span class="number">10</span>);<span class="comment">//  </span></span><br><span class="line">    ElemType *pInt = InOrder(root);<span class="comment">//打印，并接收返回的排序后的数组指针  </span></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> pos;  </span><br><span class="line">    pos=binary_search(pInt,<span class="number">6</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,pos);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果<br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041948552.png" alt="image.png"></p><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="排序算法分类"><a href="#排序算法分类" class="headerlink" title="排序算法分类"></a>排序算法分类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">排序算法分为 交换类排序、插入类排序、选择类排序、归并类排序</span><br><span class="line"></span><br><span class="line">交换类排序</span><br><span class="line"></span><br><span class="line">冒泡排序</span><br><span class="line">初冒泡排序,一般靠选择题，考大题几率小</span><br><span class="line">快速排序</span><br><span class="line">更重要，考大题</span><br><span class="line"></span><br><span class="line">插入类排序</span><br><span class="line"></span><br><span class="line">直接插入</span><br><span class="line"></span><br><span class="line">折半插入</span><br><span class="line"></span><br><span class="line">希尔排序，以上三种插入算法，一般考选择题，考大题概率低</span><br><span class="line">选择排序</span><br><span class="line"></span><br><span class="line">简单选择排序</span><br><span class="line"></span><br><span class="line">堆排序(重要)</span><br><span class="line">很有可能考大题</span><br></pre></td></tr></table></figure><h3 id="冒泡排序原理及实战"><a href="#冒泡排序原理及实战" class="headerlink" title="冒泡排序原理及实战"></a>冒泡排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041927093.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(ElemType arr[],<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="type">bool</span> flag;  <span class="comment">//用来标记是否发生了交换</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外层循环需要比较n-1次  </span></span><br><span class="line">        flag=<span class="literal">false</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;i;j--)&#123;<span class="comment">//内层循环  </span></span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);  </span><br><span class="line">                flag=<span class="literal">true</span>;<span class="comment">//有交换就返回true  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="literal">false</span>)&#123;<span class="comment">//如果这一趟没有比较，直接结束无须比较  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    <span class="type">int</span> len=<span class="number">9</span>;  </span><br><span class="line">    init_table(T,len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    bubble_sort(T.str,T.len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041926485.png" alt="image.png"></p><h3 id="快速排序原理及实战"><a href="#快速排序原理及实战" class="headerlink" title="快速排序原理及实战"></a>快速排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041930109.png" alt="Snipaste_2023-03-18_15-37-22.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">一个顺序表</span><br><span class="line">以第一个数为基准</span><br><span class="line">定义两个指针i j</span><br><span class="line">i从左往右找比3大的数，i停止</span><br><span class="line">j从右往左找比3小的数，j停止</span><br><span class="line">然后i j 对应的数完成一次交换，i j 继续前进</span><br><span class="line">循环..直到ij相遇</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码实战<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//分割方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;<span class="comment">//用于存放分割界限数(选取数组第一个数）  </span></span><br><span class="line">    temp=str[low];<span class="comment">//相当于将low位置外一个坑，先让high往前放入元素  </span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="comment">//右指针用来找比分割数小的数  </span></span><br><span class="line">        <span class="comment">//停了说明找到了  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;str[high]&gt;=temp)&#123;  </span><br><span class="line">            high--;<span class="comment">//移动  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        str[low]=str[high];<span class="comment">//将找到的值给str[low],因为这时的str[low]赋给了temp  </span></span><br><span class="line">        <span class="comment">//左指针，用来找比分割数大的数  </span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;str[low]&lt;=temp)&#123;  </span><br><span class="line">            low++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        str[high]=str[low];  </span><br><span class="line">    &#125;  </span><br><span class="line">    str[low]=temp;<span class="comment">//结束时，low位置是空的  </span></span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//快速排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(ElemType *str,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;<span class="comment">//low high用来限定分割的范围  </span></span><br><span class="line">        <span class="type">int</span> postion = partition(str, low, high);<span class="comment">//partition方法是核心方法，是每一次分割的方法  </span></span><br><span class="line">        quick_sort(str, low, postion - <span class="number">1</span>);<span class="comment">//递归左边的数组  </span></span><br><span class="line">        quick_sort(str, postion + <span class="number">1</span>, high);<span class="comment">//递归数组右边  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    <span class="type">int</span> len=<span class="number">9</span>;  </span><br><span class="line">    init_table(T,len);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">    quick_sort(T.str,<span class="number">0</span>,T.len<span class="number">-1</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041930643.png" alt="image.png"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304191541637.png" alt="image.png"><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(ElemType *str,<span class="type">int</span> n)</span>&#123; <span class="comment">//n为数组长度 </span></span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)&#123;  </span><br><span class="line">        temp=str[i];<span class="comment">//暂时存目标元素  </span></span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;str[j]&gt;temp;j--)&#123;<span class="comment">//将比插入的数大的全部往后移一格  </span></span><br><span class="line">            str[j+<span class="number">1</span>]=str[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        str[j+<span class="number">1</span>]=temp;<span class="comment">//j来到了插入位置，将temp插入  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304191608087.png" alt="image.png"></p><h3 id="OJ测试-4"><a href="#OJ测试-4" class="headerlink" title="OJ测试"></a>OJ测试</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041934190.png" alt="image.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//初始化顺序表，手动输入十个数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    T.str=(ElemType*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemType)*T.len);  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;T.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);  </span><br><span class="line">        T.str[i]=x;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//================================================================================  </span></span><br><span class="line"><span class="comment">//交换的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//冒泡排序算法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;T.len<span class="number">-1</span>;i++)&#123;  </span><br><span class="line">        <span class="keyword">for</span>(j=T.len<span class="number">-1</span>;j&gt;i;j--)&#123;  </span><br><span class="line">            <span class="keyword">if</span>(T.str[j]&gt;T.str[j<span class="number">-1</span>])&#123;  </span><br><span class="line">                swap(T.str[j],T.str[j<span class="number">-1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//==============================================================================</span></span><br><span class="line"><span class="comment">//分割方法  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">split</span><span class="params">(SSTable &amp;T,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> temp;  </span><br><span class="line">    temp=T.str[low];  </span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;T.str[high]&gt;=temp)&#123;  </span><br><span class="line">            high--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[low]=T.str[high];  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;T.str[low]&lt;=temp)&#123;  </span><br><span class="line">            low++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[high]=T.str[low];  </span><br><span class="line">    &#125;  </span><br><span class="line">    T.str[low]=temp;  </span><br><span class="line">    <span class="keyword">return</span> low;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//快速排序法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(SSTable &amp;T,<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;  </span><br><span class="line">       <span class="type">int</span> pos;  </span><br><span class="line">       pos= split(T,low,high);  </span><br><span class="line">        quick_sort(T,low,pos<span class="number">-1</span>);  </span><br><span class="line">        quick_sort(T,pos+<span class="number">1</span>,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//================================================================================ </span></span><br><span class="line"><span class="comment">//插入排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(SSTable &amp;T)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i,j,temp;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;T.len;i++)&#123;  </span><br><span class="line">        temp=T.str[i];  </span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>&amp;&amp;T.str[j]&gt;temp;j--)&#123;  </span><br><span class="line">            T.str[j+<span class="number">1</span>]=T.str[j];  </span><br><span class="line">        &#125;  </span><br><span class="line">        T.str[j+<span class="number">1</span>]=temp;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable SST;  </span><br><span class="line">    SST.len=<span class="number">10</span>;  </span><br><span class="line">    init_table(SST);  </span><br><span class="line">    print_table(SST);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * //冒泡排序  </span></span><br><span class="line"><span class="comment">    bubble_sort(SST);    print_table(SST);*/</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    //快速排序  </span></span><br><span class="line"><span class="comment">    quick_sort(SST,0,9);    print_table(SST);*/</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//插入排序  </span></span><br><span class="line">    insert_sort(SST);  </span><br><span class="line">    print_table(SST);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序原理及实战"><a href="#选择排序原理及实战" class="headerlink" title="选择排序原理及实战"></a>选择排序原理及实战</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041935436.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041935724.png" alt="image.png"></p><p>代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//选择排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">select_sort</span><span class="params">(ElemType *A,<span class="type">int</span> n)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> min,i,j;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;<span class="comment">//外循环,i只需要进行n-1轮就可以了  </span></span><br><span class="line">        min=i;  </span><br><span class="line">        <span class="keyword">for</span>(j=min+<span class="number">1</span>;j&lt;n;j++)&#123;<span class="comment">//内循环，j从左到右遍历最小  </span></span><br><span class="line">            <span class="keyword">if</span>(A[j]&lt;A[min])&#123;<span class="comment">//找到更小的  </span></span><br><span class="line">                min=j;<span class="comment">//交换下标数，意味着j下标表示的数更小，j赋值给min  </span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        swap(A[i],A[min]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;<span class="comment">//定义顺序表  </span></span><br><span class="line">    init_table(T,<span class="number">10</span>);<span class="comment">//初始化  </span></span><br><span class="line">    print_table(T);<span class="comment">//打印  </span></span><br><span class="line">  </span><br><span class="line">    select_sort(T.str,<span class="number">10</span>);<span class="comment">//选择排序  </span></span><br><span class="line">    print_table(T);<span class="comment">//再次打印，看排序效果  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041936675.png" alt="image.png"></p><h3 id="堆排序原理及实战"><a href="#堆排序原理及实战" class="headerlink" title="堆排序原理及实战"></a>堆排序原理及实战</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">实际上就是一个数组，并不是真正意义的树</span><br><span class="line">就是把数组，想象成一个树</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若父结点的值恒大于等于子结点的值，则该堆称为最大堆（max heap）。堆中最顶端的那个结点称为根结点（root node），根结点本身没有父结点（parent node）。平时在工作中，我们将最小堆称为小根堆或小顶堆，把最大堆称为大根堆或大顶堆</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041937290.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">堆排序步骤：</span><br><span class="line">堆排序的步骤是首先把堆调整为大根堆，然后我们交换根部元素也就是A[0]，和最后一个元素，这</span><br><span class="line">样最大的元素就放到了数组最后，接着我们将剩余 9 个元素继续调整为大根堆，然后交换 A[0]和</span><br><span class="line">9 个元素的最后一个，循环往复，直到有序</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938126.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938535.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041938986.png" alt="image.png"></p><p>代码实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//调整单个子树为大根堆的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjust_down1</span><span class="params">(ElemType A[],<span class="type">int</span> k,<span class="type">int</span> len)</span>&#123;<span class="comment">//k表示父节点位置，开始调整的位置  </span></span><br><span class="line">    <span class="type">int</span> dad=k;<span class="comment">//父节点的下标  </span></span><br><span class="line">    <span class="type">int</span> son=<span class="number">2</span>*dad+<span class="number">1</span>;<span class="comment">//子节点的下标  </span></span><br><span class="line">    <span class="keyword">while</span>(son&lt;len)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(son+<span class="number">1</span>&lt;len&amp;&amp;A[son]&lt;A[son+<span class="number">1</span>])&#123;<span class="comment">//左节点应该比右结点小,son+1且不能越界  </span></span><br><span class="line">            son++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(A[dad]&lt;A[son])&#123;  </span><br><span class="line">            swap(A[son],A[dad]);  </span><br><span class="line">            dad=son;  </span><br><span class="line">            son=<span class="number">2</span>*dad+<span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//堆排序的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(ElemType *A,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从最末尾的子树开始一个一个向前调整为大根堆  </span></span><br><span class="line">        adjust_down1(A,i,len);  </span><br><span class="line">    &#125;  </span><br><span class="line">    swap(A[<span class="number">0</span>],A[len<span class="number">-1</span>]);<span class="comment">//交换根结点和尾结点  </span></span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;<span class="number">1</span>;i--)&#123;<span class="comment">//剩余的数组进入循环  </span></span><br><span class="line">        adjust_down1(A,<span class="number">0</span>,i);<span class="comment">//从根结点开始重新调整为大堆根,此时数组长度变化-1  </span></span><br><span class="line">        swap(A[<span class="number">0</span>],A[i<span class="number">-1</span>]);<span class="comment">//交换根结点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    init_table(T,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    heap_sort(T.str,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041939457.png" alt="image.png"></p><h3 id="归并排序原理及实战"><a href="#归并排序原理及实战" class="headerlink" title="归并排序原理及实战"></a>归并排序原理及实战</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">归并排序是我们不断进行二分，最终各自剩余 1 个元素，自然有序，然后先将每两个元</span><br><span class="line">素进行合并，变为有序，然后再将两个小组合并，变为有序，循环往复，直到整个数组有序</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041939460.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041940642.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归到最底部后，开始层层merge，low,high,mid任然对应分组时的位置</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041940894.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge的时候，需要三个指针,i指向A的有序的前半段，j指向A有序的后半段，k指向放入的数组的当前位置</span><br><span class="line"></span><br><span class="line">1、将A[] 元素全部复制放到B[] ，i ,j分别对应low\mid+1起始位置，k=i.</span><br><span class="line"></span><br><span class="line">2、i j 先比较，小的放入A[k],i++,j不动，k++</span><br><span class="line"></span><br><span class="line">3、直到有剩余，i到头了，j还没到头;或者j到头了，i还没到头。while循环将剩余的全部放入,k随着++</span><br></pre></td></tr></table></figure><p>代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  </span><br><span class="line"><span class="comment">//定义顺序表结构体  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>  </span><br><span class="line">    ElemType *str;  </span><br><span class="line">    <span class="type">int</span> len;  </span><br><span class="line">&#125;SSTable;  </span><br><span class="line"><span class="comment">//顺序表初始化，添加随机数  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_table</span><span class="params">(SSTable &amp;SST,<span class="type">int</span> len)</span>&#123;  </span><br><span class="line">    srand(time(<span class="literal">NULL</span>));  </span><br><span class="line">    SST.len=len;  </span><br><span class="line">    SST.str=(ElemType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> (ElemType)*SST.len);  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        SST.str[i]=rand()%<span class="number">100</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//打印顺序表  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_table</span><span class="params">(SSTable SST)</span>&#123;  </span><br><span class="line">    <span class="type">int</span> i;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SST.len;i++)&#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%3d&quot;</span>,SST.str[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//交换两个元素的方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(ElemType &amp;a,ElemType &amp;b)</span>&#123;  </span><br><span class="line">    ElemType temp;  </span><br><span class="line">    temp=a;  </span><br><span class="line">    a=b;  </span><br><span class="line">    b=temp;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="comment">//用额外的空间存放，避免原数组交换次数过多  </span></span><br><span class="line">    <span class="comment">//static修饰防止递归时，重复加载  </span></span><br><span class="line">    <span class="comment">//因为申请了额外的空间，所以空间复杂度是O(n),n是元素个数  </span></span><br><span class="line">    <span class="type">static</span> ElemType B[<span class="number">10</span>];  </span><br><span class="line">    <span class="type">int</span> i,j,k;  </span><br><span class="line">    <span class="keyword">for</span>(k=low;k&lt;=high;k++)&#123;<span class="comment">//复制元素到B中  </span></span><br><span class="line">        B[k]=A[k];  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=low,j=mid+<span class="number">1</span>,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++) &#123;<span class="comment">//合并两个有序数组  </span></span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;  </span><br><span class="line">            A[k] = B[i];  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            A[k] = B[j];  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;<span class="comment">//如果左半边数组有剩余接着放入  </span></span><br><span class="line">        A[k] = B[i];  </span><br><span class="line">        k++;  </span><br><span class="line">        i++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;<span class="comment">//如果右半边数组有剩余接着放入  </span></span><br><span class="line">        A[k] = B[j];  </span><br><span class="line">        k++;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//归并排序方法  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(ElemType A[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(low&lt;high) &#123;  </span><br><span class="line">        <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;  </span><br><span class="line">        merge_sort(A, low, mid);  </span><br><span class="line">        merge_sort(A, mid+<span class="number">1</span>,high);  </span><br><span class="line">        merge(A,low,mid,high);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    SSTable T;  </span><br><span class="line">    init_table(T,<span class="number">10</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">  </span><br><span class="line">    merge_sort(T.str,<span class="number">0</span>,<span class="number">9</span>);  </span><br><span class="line">    print_table(T);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MergeSort 函数的递归 次数是 log 2 n， Merge 函数的循环了 n 次， 因此时间复杂度是 O(nlog 2 n)。</span><br><span class="line">归并排序最好、最坏、平均时间复杂度都是 O(nlog 2 n)。</span><br><span class="line">归并排序的空间复杂度是 O(n)，因为使用了数组 B，它的大小与 A 一样，占用 n 个元素的</span><br><span class="line">空间。</span><br></pre></td></tr></table></figure><h3 id="所有算法空间时间复杂度"><a href="#所有算法空间时间复杂度" class="headerlink" title="所有算法空间时间复杂度"></a>所有算法空间时间复杂度</h3><p><img src="https://raw.githubusercontent.com/whu1233334/picgo-picture-room/picgo/img/202304041941683.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>obisidain图床</title>
      <link href="/undefined/7b58c309.html"/>
      <url>/undefined/7b58c309.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305192341533.jpg" alt="赛博朋克 动漫女孩 è 雨 霓虹灯 城市灯光 瓶子 电脑高清壁纸_彼岸壁纸.jpg"></p><h1 id="github图床"><a href="#github图床" class="headerlink" title="github图床"></a>github图床</h1><h2 id="安装Picgo"><a href="#安装Picgo" class="headerlink" title="安装Picgo"></a>安装Picgo</h2><p>GitHub搜索picgo</p><h2 id="申请一个token"><a href="#申请一个token" class="headerlink" title="申请一个token"></a>申请一个token</h2><p>注意必须勾选仓库权限</p><h2 id="配置仓库信息"><a href="#配置仓库信息" class="headerlink" title="配置仓库信息"></a>配置仓库信息</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302333755.png" alt="image.png"></p><h2 id="使用CDN域名加速"><a href="#使用CDN域名加速" class="headerlink" title="使用CDN域名加速"></a>使用CDN域名加速</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305022155952.png" alt="image.png"></p><p>1.直接引用格式<br><code>https://cdn.jsdelivr.net/gh/GitHub账户名/仓库名/&lt;文件及路径&gt;</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 直接引用cdn域名加速默认加速master分支所以设定picgo存贮分支要改为master</span><br><span class="line">- 文件及路径可以不填,picgo上传会自动分配路径</span><br><span class="line">- 如果加速已存在的图片需要填写路径名</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>2.按分支/版本号格式<br><code>https://cdn.jsdelivr.net/gh/&lt;用户名&gt;/&lt;仓库名&gt;@[分支/版本号]/&lt;文件及路径&gt;</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 可以指定加速的分支名或版本号</span><br></pre></td></tr></table></figure></p><h2 id="下载obsidian中的picgo插件"><a href="#下载obsidian中的picgo插件" class="headerlink" title="下载obsidian中的picgo插件"></a>下载obsidian中的picgo插件</h2><h2 id="设置几个插件选项"><a href="#设置几个插件选项" class="headerlink" title="设置几个插件选项"></a>设置几个插件选项</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302333597.png" alt="image.png"></p><h1 id="七牛云图床"><a href="#七牛云图床" class="headerlink" title="七牛云图床"></a>七牛云图床</h1><p>前置准备与上面一致，注册好七牛云后存储仓库每月10G免费上传空间，但是访问的域名是测试域名有效期30天，因此需要一个备案好的域名。</p><h2 id="设置picgo七牛云设置"><a href="#设置picgo七牛云设置" class="headerlink" title="设置picgo七牛云设置"></a>设置picgo七牛云设置</h2><p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302328938.png" alt="image.png"></p><h2 id="关于测试域名过期问题"><a href="#关于测试域名过期问题" class="headerlink" title="关于测试域名过期问题"></a>关于测试域名过期问题</h2><p>由于测试域名有效期只有30天，但是又不想花钱搞个域名，可以通过，连续创建新的存储空间，一直白嫖30天测试域名，再通过qshell工具将原空间的数据，拷贝到新的空间里</p><h3 id="qshell工具的使用"><a href="#qshell工具的使用" class="headerlink" title="qshell工具的使用"></a>qshell工具的使用</h3><p><a href="https://developer.qiniu.com/kodo/1302/qshell">官网下载</a></p><h4 id="闪退问题"><a href="#闪退问题" class="headerlink" title="闪退问题"></a>闪退问题</h4><p>下载好之后，对于windows系统来说，不要双击方式运行qshell.exe,通过进入文件夹，运行cmd命令，输入qshell.exe执行</p><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>1.窗口中输入 ```</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qshell listbucket 要复制的空间名 -o test.txt</span><br></pre></td></tr></table></figure><p>扒取要复制的空间的所有文件信息,前面两个是命令,不解释 后面一个是要复制的空间吗,-o之后是你要指定一个文件名</p><p>2.执行之后会生成test.txt文件<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302339821.png" alt="image.png"></p><p>生成的文件是这样的,这不是我们要的,ctrl+A复制全部,用Excel表格打开<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340692.png" alt="image.png"></p><p>只留下前面的名字,复制回原来的test.txt里,<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202305010929090.png" alt="image.png"></p><p>只要这些,之后<br>命令行执行<br>qshell batchcopy —force —overwrite —success-list success.txt —failure-list failure.txt 源空间名 目标空间名 -i test.txt<br>解释:qshell batchcopy 执行的是复制操作,也可以改成qshell batchmove ,<br>–force,不加这个的话会给你手机发个验证码验证,会很久,还是加上,-<br>-overwrite 同名文件覆盖<br>–success-list success.txt —failure-list failure.txt:设置复制成功或者失败的文件放置位置,就是哪些文件成功了哪些失败了,都会列到你指定的文件<br>源空间名 目标空间名 :就是空间名称,源空间就是你要复制的那个,目标空间名就是要粘贴到的那个.<br>-i test.txt:上一条命令生成的文件</p><p>这样就复制过去了,底下的图是另一个账号授权的源空间<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340089.png" alt="image.png"></p><p>这里是我复制的空间<br><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picture-room/img/202304302340166.png" alt="image.png"></p><h4 id="图片换新链接"><a href="#图片换新链接" class="headerlink" title="图片换新链接"></a>图片换新链接</h4><p>由于换了一个新的测试域名，访问地址变化，但是知道保证复制之后的文件名称不变，只需要改变图url的域名位置，通过正则表达式批量修改，可以解决链接问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> obisidian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术随想</title>
      <link href="/undefined/dfb8a81f.html"/>
      <url>/undefined/dfb8a81f.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/whu1233334/picgo-picturn2/img/202308011938968.jpg" alt="ˮī 女孩 尖耳朵 ai绘画 动漫高清壁纸_彼岸壁纸.jpg"></p><h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><h2 id="Github-Pages-和-Hexo-搭建自己的独立博客"><a href="#Github-Pages-和-Hexo-搭建自己的独立博客" class="headerlink" title="Github Pages 和 Hexo 搭建自己的独立博客"></a><a href="https://anzhiy.cn/posts/ddae.html#Hexo-%E5%AE%89%E8%A3%85">Github Pages 和 Hexo 搭建自己的独立博客</a></h2><h2 id="一图流实现"><a href="#一图流实现" class="headerlink" title="一图流实现"></a><a href="https://zfe.space/post/65396.html">一图流实现</a></h2><h2 id="打字机效果"><a href="#打字机效果" class="headerlink" title="打字机效果"></a><a href="https://zhuanlan.zhihu.com/p/492207978">打字机效果</a></h2><h2 id="Hexo-Butterfly-一些常见问题"><a href="#Hexo-Butterfly-一些常见问题" class="headerlink" title="Hexo + Butterfly 一些常见问题"></a><a href="https://tzy1997.com/articles/hexo1612/#%E9%A6%96%E9%A1%B5%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C">Hexo + Butterfly 一些常见问题</a></h2><h2 id="Algolia搜索系统"><a href="#Algolia搜索系统" class="headerlink" title="Algolia搜索系统"></a><a href="https://www.fomal.cc/posts/d1927166.html">Algolia搜索系统</a></h2><h2 id="页面布局优化"><a href="#页面布局优化" class="headerlink" title="页面布局优化"></a><a href="">页面布局优化</a></h2><h2 id="右边按钮阅读进度"><a href="#右边按钮阅读进度" class="headerlink" title="右边按钮阅读进度"></a><a href="https://www.fomal.cc/posts/2d7ac914.html">右边按钮阅读进度</a></h2><h2 id="文章三栏"><a href="#文章三栏" class="headerlink" title="文章三栏"></a><a href="https://www.fomal.cc/posts/d739261b.html">文章三栏</a></h2><h2 id="为文章封面图片"><a href="#为文章封面图片" class="headerlink" title="为文章封面图片"></a>为文章封面图片</h2><p>要为每一篇文章的栏目配置图片，需要在文章的top_imge和cover标签传一个图片的url链接，注意不是图片链接<br>url链接通过上传至图床获取<br>文章的 markdown 文档上，在 添加 ，并填上要显示的图片地址。Front-mattercover<br>如果不配置 ，可以设置显示默认的 cover。cover<br>如果不想在首页显示 cover， 可以设置为 。false</p><h2 id="自定义字体"><a href="#自定义字体" class="headerlink" title="自定义字体"></a><a href="https://tzy1997.com/articles/hexo1605/">自定义字体</a></h2><h2 id="修改头像及网站图标"><a href="#修改头像及网站图标" class="headerlink" title="修改头像及网站图标"></a>修改头像及网站图标</h2><p>改网站图标：修改主题文件找到favicon,修改本地的图片<br>改头像：修改主题配置文件找到avater，修改图片url</p><h2 id="双栏修改"><a href="#双栏修改" class="headerlink" title="双栏修改"></a><a href="https://zfe.space/post/hexo-butterfly-article-double-row.html">双栏修改</a></h2><h2 id="加载动画"><a href="#加载动画" class="headerlink" title="加载动画"></a><a href="https://anzhiy.cn/posts/52d8.html">加载动画</a></h2><p>遇到问题：按照流程，发现存在半屏加载页面不消失的情况，于是换用4.4版本的步骤，解决了上述问题。所以butterfly版本只最为参考，实际还是按照实际情况判断选择哪种方式</p><h2 id="利用clion修改本地文件存在的问题"><a href="#利用clion修改本地文件存在的问题" class="headerlink" title="利用clion修改本地文件存在的问题"></a>利用clion修改本地文件存在的问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用clion修改本地博客配置文件，无法检测到stly,pug,文件的改动，导致推送时漏掉上述类型配置文件</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>放弃用clion修改配置文件，换用其他编辑器；或者，直接在文件夹执行git操作</p><h2 id="Hexo-github-netlify快速搭建"><a href="#Hexo-github-netlify快速搭建" class="headerlink" title="Hexo+github+netlify快速搭建"></a><a href="https://blog.csdn.net/qq_34769162/article/details/107687755?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168070747016800180693297%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168070747016800180693297&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-107687755-null-null.142^v81^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=github%20netlify%20%E5%8D%9A%E5%AE%A2&amp;spm=1018.2226.3001.4187">Hexo+github+netlify快速搭建</a></h2><h2 id="github-action自动部署"><a href="#github-action自动部署" class="headerlink" title="github action自动部署"></a><a href="https://anzhiy.cn/posts/asdx.html">github action自动部署</a></h2><h2 id="博客迁移到新电脑"><a href="#博客迁移到新电脑" class="headerlink" title="博客迁移到新电脑"></a><a href="https://www.fomal.cc/posts/d1927166.html">博客迁移到新电脑</a></h2><h2 id="hexo中插入pdf"><a href="#hexo中插入pdf" class="headerlink" title="hexo中插入pdf"></a><a href="https://zhuanlan.zhihu.com/p/550626417">hexo中插入pdf</a></h2><p>1-下载插件<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-pdf</span><br></pre></td></tr></table></figure></p><p>2-建立存放pdf文件夹</p><pre><code>在source文件夹下创建一个叫pdf的文件夹，把xxx.pdf文件放在这里</code></pre><p>3-引用<br>    在_post文件夹中的xxx.md直接使用<br><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf /pdf/xxx.pdf %&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用本地图片"><a href="#使用本地图片" class="headerlink" title="使用本地图片"></a>使用本地图片</h2><ul><li>修改配置文件<code>_config.yml</code> ,中的<code>post_asset_folder: true</code>，设为true</li><li>注意图片文件夹位置，如果是与其处于同一级路径例如：<code>source/_post  与source/_img</code><br> 那么要引用同级的img,直接<code>/img/xxx</code>;</li></ul><h1 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h1><h2 id="服务器的使用"><a href="#服务器的使用" class="headerlink" title="服务器的使用"></a><a href="https://blog.csdn.net/weixin_57024510/article/details/126292491?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168070719016800182115444%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168070719016800182115444&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-126292491-null-null.142^v81^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&amp;utm_term=%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8&amp;spm=1018.2226.3001.4187">服务器的使用</a></h2><h3 id="甲骨文云服务器"><a href="#甲骨文云服务器" class="headerlink" title="甲骨文云服务器"></a><a href="https://www.youtube.com/watch?v=X9sexl1wXyE">甲骨文云服务器</a></h3><h1 id="静态主机"><a href="#静态主机" class="headerlink" title="静态主机"></a>静态主机</h1><h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><p><a href="https://wenjie.org/archives/netlify">https://wenjie.org/archives/netlify</a> 博客地址</p><h1 id="windows触控板手势"><a href="#windows触控板手势" class="headerlink" title="windows触控板手势"></a>windows触控板手势</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.一根手指单击或按压触控板的左下部分：鼠标左键</span><br><span class="line">2.两根手指单击或按压触控板右下部分：鼠标右键</span><br><span class="line">3.双指放开或者捏合，即可控制页面的放大和缩小</span><br><span class="line">4.双指上下滑可以让页面垂直滚动</span><br><span class="line">5.三指单击，可以调出搜索框搜索</span><br><span class="line">6.三指左右滑动，可切换不同任务界面</span><br><span class="line">7.三指向下滑动，可以最小化所有软件</span><br><span class="line">8.三指向上滑动即可恢复原样</span><br><span class="line">9.三指再向上滑动可以调出任务视图</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> butterfly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"风起之时`Blog","short_name":"风起之时","theme_color":"#3b70fc","background_color":"#3b70fc","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"/img/siteicon/16.png","sizes":"16x16","type":"image/png"},{"src":"/img/siteicon/32.png","sizes":"32x32","type":"image/png"},{"src":"/img/siteicon/48.png","sizes":"48x48","type":"image/png"},{"src":"/img/siteicon/64.png","sizes":"64x64","type":"image/png"},{"src":"/img/siteicon/128.png","sizes":"128x128","type":"image/png"},{"src":"/img/siteicon/144.png","sizes":"144x144","type":"image/png"},{"src":"/img/siteicon/512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* @ce {  font-family: Candyhome;  src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf);  font-display: swap;  font-weight: lighter;} */@font-face {    font-family: ZhuZiAYuanJWD;    src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2);    font-display: swap;    font-weight: normal;}/*div#menus {    font-family: "ZhuZiAYuanJWD";}h1#site-title {    font-family: ZhuZiAYuanJWD;    font-size: 3em !important;}a.article-title,a.blog-slider__title,a.categoryBar-list-link,h1.post-title {    font-family: ZhuZiAYuanJWD;}.iconfont {    font-family: "iconfont" !important;    font-size: 3em;    !* 可以定义图标大小 *!    font-style: normal;    -webkit-font-smoothing: antialiased;    -moz-osx-font-smoothing: grayscale;}!* bilibli番剧插件 *!#article-container .bangumi-tab.bangumi-active {    background: var(--anzhiyu-theme);    color: var(--anzhiyu-ahoverbg);    border-radius: 10px;}a.bangumi-tab:hover {    text-decoration: none !important;}.bangumi-button:hover {    background: var(--anzhiyu-theme) !important;    border-radius: 10px !important;    color: var(--anzhiyu-ahoverbg) !important;}a.bangumi-button.bangumi-nextpage:hover {    text-decoration: none !important;}.bangumi-button {    padding: 5px 10px !important;}a.bangumi-tab {    padding: 5px 10px !important;}svg.icon.faa-tada {    font-size: 1.1em;}.bangumi-info-item {    border-right: 1px solid #f2b94b;}.bangumi-info-item span {    color: #f2b94b;}.bangumi-info-item em {    color: #f2b94b;}!* 解决artitalk的图标问题 *!#uploadSource > svg {    width: 1.19em;    height: 1.5em;}!*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 *!#page-header:not(.not-top-img):before {    background-color: transparent !important;}!* 首页文章卡片 *!#recent-posts > .recent-post-item {    background: rgba(255, 255, 255, 0.9);}!* 首页侧栏卡片 *!#aside-content .card-widget {    background: rgba(255, 255, 255, 0.9);}!* 文章页面正文背景 *!div#post {    background: rgba(255, 255, 255, 0.9);}!* 分页页面 *!div#page {    background: rgba(255, 255, 255, 0.9);}!* 归档页面 *!div#archive {    background: rgba(255, 255, 255, 0.9);}!* 标签页面 *!div#tag {    background: rgba(255, 255, 255, 0.9);}!* 分类页面 *!div#category {    background: rgba(255, 255, 255, 0.9);}!*夜间模式伪类遮罩层透明*![data-theme="dark"] #recent-posts > .recent-post-item {    background: #121212;}[data-theme="dark"] .card-widget {    background: #121212 !important;}[data-theme="dark"] div#post {    background: #121212 !important;}[data-theme="dark"] div#tag {    background: #121212 !important;}[data-theme="dark"] div#archive {    background: #121212 !important;}[data-theme="dark"] div#page {    background: #121212 !important;}[data-theme="dark"] div#category {    background: #121212 !important;}[data-theme="dark"] div#category {    background: transparent !important;}*//* 页脚透明 */#footer {    background: transparent !important;}/* 头图透明 */#page-header {    background: transparent !important;}#rightside > div > button {    border-radius: 5px;}/* 滚动条 */::-webkit-scrollbar {    width: 7px;    height: 7px;}::-webkit-scrollbar-thumb {    background-color: #8be9fd;    border-radius: 2em;}::-webkit-scrollbar-corner {    background-color: transparent;}::-moz-selection {    color: #fff;    background-color: #3b70fc;}/*!* 音乐播放器 *!!* .aplayer .aplayer-lrc {  display: none !important;} *!.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {    left: -66px !important;    transition: all 0.3s;    !* 默认情况下缩进左侧66px，只留一点箭头部分 *!}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {    left: 0 !important;    transition: all 0.3s;    !* 鼠标悬停是左侧缩进归零，完全显示按钮 *!}.aplayer.aplayer-fixed {    z-index: 999999 !important;}*//* 评论框  */.vwrap {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 30px 0px;}/* 设置评论框 */.vcard {    box-shadow: 2px 2px 5px #bbb;    background: rgba(255, 255, 255, 0.3);    border-radius: 8px;    padding: 30px;    margin: 30px 0px 0px 0px;}/* md网站下划线 */#article-container a:hover {    text-decoration: none !important;}#article-container #hpp_talk p img {    display: inline;}/* 404页面 */#error-wrap {    position: absolute;    top: 40%;    right: 0;    left: 0;    margin: 0 auto;    padding: 0 1rem;    max-width: 1000px;    transform: translate(0, -50%);}#error-wrap .error-content {    display: flex;    flex-direction: row;    justify-content: center;    align-items: center;    margin: 0 1rem;    height: 18rem;    border-radius: 8px;    background: var(--card-bg);    box-shadow: var(--card-box-shadow);    transition: all 0.3s;}#error-wrap .error-content .error-img {    box-flex: 1;    flex: 1;    height: 100%;    border-top-left-radius: 8px;    border-bottom-left-radius: 8px;    background-color: #3b70fc;    background-position: center;    background-size: cover;}#error-wrap .error-content .error-info {    box-flex: 1;    flex: 1;    padding: 0.5rem;    text-align: center;    font-size: 14px;    font-family: Titillium Web, "PingFang SC", "Hiragino Sans GB", "Microsoft JhengHei", "Microsoft YaHei", sans-serif;}#error-wrap .error-content .error-info .error_title {    margin-top: -4rem;    font-size: 9em;}#error-wrap .error-content .error-info .error_subtitle {    margin-top: -3.5rem;    word-break: break-word;    font-size: 1.6em;}#error-wrap .error-content .error-info a {    display: inline-block;    margin-top: 0.5rem;    padding: 0.3rem 1.5rem;    background: var(--btn-bg);    color: var(--btn-color);}#body-wrap.error .aside-list {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    bottom: 0px;    position: absolute;    padding: 1rem;    width: 100%;    overflow: scroll;}#body-wrap.error .aside-list .aside-list-group {    display: flex;    flex-direction: row;    flex-wrap: nowrap;    max-width: 1200px;    margin: 0 auto;}#body-wrap.error .aside-list .aside-list-item {    padding: 0.5rem;}#body-wrap.error .aside-list .aside-list-item img {    width: 100%;    object-fit: cover;    border-radius: 12px;}#body-wrap.error .aside-list .aside-list-item .thumbnail {    overflow: hidden;    width: 230px;    height: 143px;    background: var(--anzhiyu-card-bg);    display: flex;}#body-wrap.error .aside-list .aside-list-item .content .title {    -webkit-line-clamp: 2;    overflow: hidden;    display: -webkit-box;    -webkit-box-orient: vertical;    line-height: 1.5;    justify-content: center;    align-items: flex-end;    align-content: center;    padding-top: 0.5rem;    color: white;}#body-wrap.error .aside-list .aside-list-item .content time {    display: none;}/* 代码框主题 */#article-container figure.highlight {    border-radius: 10px;}/* 归档样式 */span.card-archive-list-count {    width: auto;    text-align: left;    font-size: 1.5rem;    line-height: 0.9;    font-weight: 700;}.card-archive-list-count-group {    display: flex;    flex-direction: row;    align-items: baseline;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:last-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:last-child {    width: fit-content;    margin-left: 4px;}span.card-archive-list-count {    width: auto;    text-align: left;    font-size: 1.1rem;    line-height: 0.9;    font-weight: 700;}.card-archive-list-date {    font-size: 14px;    opacity: 0.6;}li.card-archive-list-item {    width: 100%;    flex: 0 0 48%;}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,#aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {    color: var();    background-color: var(--btn-bg);    box-shadow: var(--btn-bg);    border-radius: 8px;    padding-left: 0.5rem;    padding-right: 0.5rem;}@media screen and (min-width: 1300px) {    #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:hover,    #aside-content .card-categories ul.card-category-list > .card-category-list-item a:hover {        transform: scale(1.03);    }    #aside-content .card-archives ul.card-archive-list > .card-archive-list-item a:active,    #aside-content .card-categories ul.card-category-list > .card-category-list-item a:active {        transform: scale(0.97);    }}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a,#aside-content .card-categories ul.card-category-list > .card-category-list-item a {    border-radius: 8px;    margin: 4px 0;    display: flex;    flex-direction: column;    align-content: space-between;    border: var(--style-border);}#aside-content .card-archives ul.card-archive-list > .card-archive-list-item a span:first-child,#aside-content .card-categories ul.card-category-list > .card-category-list-item a span:first-child {    width: auto;    flex: inherit;}#aside-content .card-archives ul.card-archive-list,#aside-content .card-categories ul.card-category-list {    display: flex;    flex-direction: row;    justify-content: space-between;    flex-wrap: wrap;}/*渐变条*/.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/*魔改菜单栏*//* 一级菜单居中 *//*#nav .menus_items {    position: absolute !important;    width: fit-content !important;    left: 50% !important;    transform: translateX(-50%) !important;}*//* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {    display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(2) .menus_item_child {    left: -125px;}/*名片渐变色*//* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(            -45deg,            #e8d8b9,            #eccec5,            #a3e9eb,            #bdbdf0,            #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@-moz-keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}@keyframes Gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;}/*loading动画*/.loading-img {    background: url(https://s1.ax1x.com/2023/04/01/ppWibxf.jpg) no-repeat center center;    background-size: cover;}/*黑夜霓虹灯*//* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {    animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {    animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {    animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {    animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {    0% {        text-shadow: #5636ed 0 0 15px;    }    12.5% {        text-shadow: #11ee5e 0 0 15px;    }    25% {        text-shadow: #f14747 0 0 15px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 15px;    }    50% {        text-shadow: #b347f1 0 0 15px;    }    62.5% {        text-shadow: #002afa 0 0 15px;    }    75% {        text-shadow: #ed709b 0 0 15px;    }    87.5% {        text-shadow: #39c5bb 0 0 15px;    }    100% {        text-shadow: #5636ed 0 0 15px;    }}@keyframes light_10px {    0% {        text-shadow: #5636ed 0 0 10px;    }    12.5% {        text-shadow: #11ee5e 0 0 10px;    }    25% {        text-shadow: #f14747 0 0 10px;    }    37.5% {        text-shadow: #f1a247 0 0 10px;    }    50% {        text-shadow: #f1ee47 0 0 10px;    }    50% {        text-shadow: #b347f1 0 0 10px;    }    62.5% {        text-shadow: #002afa 0 0 10px;    }    75% {        text-shadow: #ed709b 0 0 10px;    }    87.5% {        text-shadow: #39c5bb 0 0 10px;    }    100% {        text-shadow: #5636ed 0 0 10px;    }}@keyframes light_5px {    0% {        text-shadow: #5636ed 0 0 5px;    }    12.5% {        text-shadow: #11ee5e 0 0 5px;    }    25% {        text-shadow: #f14747 0 0 5px;    }    37.5% {        text-shadow: #f1a247 0 0 15px;    }    50% {        text-shadow: #f1ee47 0 0 5px;    }    50% {        text-shadow: #b347f1 0 0 5px;    }    62.5% {        text-shadow: #002afa 0 0 5px;    }    75% {        text-shadow: #ed709b 0 0 5px;    }    87.5% {        text-shadow: #39c5bb 0 0 5px;    }    100% {        text-shadow: #5636ed 0 0 5px;    }}/*侧边栏最近文章修改*/#aside-content .aside-list > .aside-list-item .content > time {    display: none;}#aside-content .aside-list > .aside-list-item .content > .title {    -webkit-line-clamp: 3;    font-weight: 700;    padding: 2px 0;}#aside-content .aside-list > .aside-list-item {    padding: 8px;    padding-top: 6px !important;    padding-bottom: 6px !important;    border-radius: 12px;    transition: 0.3s;    margin: 4px 0;    cursor: pointer;}@media screen and (min-width: 1300px) {    #aside-content .aside-list > .aside-list-item:hover {        transform: scale(1.03);    }    #aside-content .aside-list > .aside-list-item:active {        transform: scale(0.97);    }}#aside-content .aside-list > .aside-list-item:hover .thumbnail > img {    transform: scale(1);}#aside-content .aside-list > .aside-list-item:not(:last-child) {    border-bottom: 0 dashed var(--anzhiyu-background) !important;}#aside-content .aside-list > .aside-list-item .thumbnail {    border-radius: 8px;    border: var(--style-border);}#aside-content .aside-list > .aside-list-item:hover {    background: var(--anzhiyu-blue-main);    color: var(--anzhiyu-white);    transition: 0.3s;    box-shadow: var(--anzhiyu-shadow-main);}#aside-content .aside-list > .aside-list-item:hover a {    color: var(--anzhiyu-white) !important;}.card-widget.card-recent-post {    padding: 0.4rem 0.6rem !important;}/* 文章页H1-H6图标样式效果 *//* 控制风车转动速度 4s那里可以自己调节快慢 */h1::before,h2::before,h3::before,h4::before,h5::before,h6::before {    -webkit-animation: ccc 4s linear infinite;    animation: ccc 4s linear infinite;}/* 控制风车转动方向 -1turn 为逆时针转动，1turn 为顺时针转动，相同数字部分记得统一修改 */@-webkit-keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}@keyframes ccc {    0% {        -webkit-transform: rotate(0deg);        transform: rotate(0deg);    }    to {        -webkit-transform: rotate(-1turn);        transform: rotate(-1turn);    }}/* 设置风车颜色 */#content-inner.layout h1::before {    color: #ef50a8;    margin-left: -1.55rem;    font-size: 1.3rem;    margin-top: -0.23rem;}#content-inner.layout h2::before {    color: #fb7061;    margin-left: -1.35rem;    font-size: 1.1rem;    margin-top: -0.12rem;}#content-inner.layout h3::before {    color: #ffbf00;    margin-left: -1.22rem;    font-size: 0.95rem;    margin-top: -0.09rem;}#content-inner.layout h4::before {    color: #a9e000;    margin-left: -1.05rem;    font-size: 0.8rem;    margin-top: -0.09rem;}#content-inner.layout h5::before {    color: #57c850;    margin-left: -0.9rem;    font-size: 0.7rem;    margin-top: 0rem;}#content-inner.layout h6::before {    color: #5ec1e0;    margin-left: -0.9rem;    font-size: 0.66rem;    margin-top: 0rem;}/* s设置风车hover动效 6s那里可以自己调节快慢*/#content-inner.layout h1:hover,#content-inner.layout h2:hover,#content-inner.layout h3:hover,#content-inner.layout h4:hover,#content-inner.layout h5:hover,#content-inner.layout h6:hover {    color: var(--theme-color);}#content-inner.layout h1:hover::before,#content-inner.layout h2:hover::before,#content-inner.layout h3:hover::before,#content-inner.layout h4:hover::before,#content-inner.layout h5:hover::before,#content-inner.layout h6:hover::before {    color: var(--theme-color);    -webkit-animation: ccc 6s linear infinite;    animation: ccc 6s linear infinite;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/progress_bar.css"/>
      <url>/css/progress_bar.css</url>
      
        <content type="html"><![CDATA[.pace {    -webkit-pointer-events: none;    pointer-events: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    z-index: 2000;    position: fixed;    margin: auto;    top: 10px;    left: 0;    right: 0;    height: 8px;    border-radius: 8px;    width: 4rem;    background: #eaecf2;    border: 1px #e3e8f7;    overflow: hidden;}.pace-inactive .pace-progress {    opacity: 0;    transition: 0.3s ease-in;}.pace .pace-progress {    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;    -ms-box-sizing: border-box;    -o-box-sizing: border-box;    box-sizing: border-box;    -webkit-transform: translate3d(0, 0, 0);    -moz-transform: translate3d(0, 0, 0);    -ms-transform: translate3d(0, 0, 0);    -o-transform: translate3d(0, 0, 0);    transform: translate3d(0, 0, 0);    max-width: 200px;    position: absolute;    z-index: 2000;    display: block;    top: 0;    right: 100%;    height: 100%;    width: 100%;    background: linear-gradient(-45deg, #ee7752, #e73c7e, #23a6d5, #23d5ab);    animation: gradient 1.5s ease infinite;    background-size: 200%;}.pace.pace-inactive {    opacity: 0;    transition: 0.3s;    top: -8px;}@keyframes gradient {    0% {        background-position: 0% 50%;    }    50% {        background-position: 100% 50%;    }    100% {        background-position: 0% 50%;    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/readPercent.css"/>
      <url>/css/readPercent.css</url>
      
        <content type="html"><![CDATA[/* 返回顶部 */button#go-up #percent {    display: none;    font-weight: bold;    font-size: 15px !important;}button#go-up span {    font-size: 12px!important;    margin-right: -1px;}/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i {    display: block !important;}button#go-up:hover #percent {    display: none !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/ali_font.js"/>
      <url>/js/ali_font.js</url>
      
        <content type="html"><![CDATA[!(function (c) {    var l,        h,        a,        t,        i,        v =            '<svg><symbol id="icon-dragon_chen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-498.122105 265.620211L431.157895 754.526316V485.052632h-66.074948c-14.470737 110.645895-44.355368 197.066105-102.696421 260.742736l-39.747368-36.432842C306.526316 617.876211 323.368421 462.901895 323.368421 242.526316V215.578947h377.263158v53.894737H377.182316c-0.404211 58.260211-2.209684 112.128-6.359579 161.684211H700.631579v53.894737h-122.152421a481.172211 481.172211 0 0 0 76.826947 119.70021l66.479158-39.855158 27.728842 46.214737-54.460631 32.687158c29.507368 24.953263 63.757474 45.675789 102.80421 58.098526l-16.303158 51.361684c-134.224842-42.711579-222.773895-167.073684-261.551158-268.207157H485.052632v221.857684l68.985263-41.391158 27.728842 46.214737-109.783579 65.886316zM646.736842 377.263158h-215.578947v-53.894737h215.578947v53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-dog_xu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-375.592421 150.393263c33.684211 44.544 75.210105 74.698105 124.739369 90.812632l11.425684 3.718737 10.401684-6.009264C781.204211 727.740632 808.421053 622.565053 808.421053 592.842105h-53.894737c0 22.069895-19.132632 80.869053-33.711158 103.504842-34.816-14.605474-64.538947-39.262316-89.249684-74.13221 48.316632-55.269053 92.079158-117.328842 120.535579-179.900632l-49.044211-22.285473c-23.767579 52.250947-59.742316 104.717474-100.055579 152.656842-24.010105-50.930526-41.148632-115.927579-51.658105-195.395369H700.631579v-53.894737h-155.189895A1848.050526 1848.050526 0 0 1 538.947368 161.684211h-53.894736c0 58.206316 2.155789 112.074105 6.494315 161.68421H323.368421v26.947368c0 216.549053-13.177263 263.545263-100.702316 359.046737l39.747369 36.432842c63.326316-69.093053 92.806737-118.272 105.714526-206.848H485.052632v-53.894736h-111.319579a1742.147368 1742.147368 0 0 0 3.449263-107.789474h120.158316c12.611368 98.250105 35.031579 177.475368 67.395368 238.187789-61.978947 65.536-128.053895 117.975579-173.298526 142.282106l25.519158 47.481263c47.589053-25.573053 114.095158-77.446737 177.55621-142.821053z m125.170526-411.971368l-80.842105-80.842106-38.103579 38.103579 80.842105 80.842106 38.103579-38.103579z" fill="#231F20" ></path></symbol><symbol id="icon-dog" viewBox="0 0 1024 1024"><path d="M894.814316 904.434526l83.240421-183.134315-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939369-185.263158-0.134737-7.922526-0.134737-33.953684-0.134736-55.996631-30.693053 15.306105-70.090105 19.887158-106.09179 19.887157-92.752842 0-163.624421-23.983158-210.647579-71.275789a192.512 192.512 0 0 1-27.944421-36.513684H377.263158v377.263158c342.662737 0 403.105684 51.092211 494.592 128.377263 7.922526 6.682947 15.521684 13.312 22.959158 19.86021z" fill="#85C3DE" ></path><path d="M326.063158 282.947368c0 34.250105-13.231158 44.463158-29.642105 44.463158s-29.642105-10.213053-29.642106-44.463158c0-34.223158 13.231158-44.463158 29.642106-44.463157s29.642105 10.24 29.642105 44.463157zM269.473684 430.295579v311.646316L190.275368 916.210526h59.203369L323.368421 753.637053V377.263158h-26.947368c-119.403789 0-172.732632-53.382737-185.505685-107.789474h35.624421c51.092211 0 68.581053-15.764211 120.535579-62.544842 12.773053-11.506526 28.079158-25.276632 47.023158-41.741474l18.351158-15.952842-69.658947-99.139368-44.085895 30.989474 41.768421 59.472842c-11.183158 9.862737-20.884211 18.593684-29.480421 26.327579C180.736 212.156632 176.235789 215.578947 146.539789 215.578947H53.894737v26.947369c0 88.710737 66.910316 178.149053 215.578947 187.769263z m216.710737-161.414737c2.290526 71.733895 28.698947 136.326737 75.048421 182.918737C618.711579 509.628632 702.437053 538.947368 810.091789 538.947368c18.593684 0 36.190316-1.158737 52.628211-3.449263 3.745684 111.265684 33.630316 170.334316 51.496421 196.015158l-38.507789 84.722526C782.174316 742.049684 688.774737 700.631579 377.263158 700.631579v53.894737c34.277053 0 65.697684 0.512 94.639158 1.509052L374.595368 970.105263h59.203369l96.013474-211.240421c66.182737 4.338526 117.005474 11.829895 157.911578 22.016L626.229895 916.210526h59.176421l54.16421-119.134315c47.616 18.405053 79.737263 42.091789 113.125053 69.739789L805.753263 970.105263h59.203369l113.071157-248.778105-13.824-13.204211c-0.485053-0.458105-45.648842-47.589053-47.939368-185.263158C985.168842 498.553263 1024 447.811368 1024 377.263158c0-95.205053-66.506105-161.684211-161.684211-161.684211v53.894737c65.482105 0 107.789474 42.307368 107.789474 107.789474 0 89.088-87.013053 107.789474-160.013474 107.789474-92.752842 0-163.624421-23.983158-210.647578-71.27579-30.315789-30.504421-45.891368-65.832421-53.35579-98.735158 11.210105 6.952421 22.932211 13.338947 35.274105 19.186527l23.04-48.720843c-92.106105-43.654737-148.992-128.646737-219.243789-243.981473l-46.026105 28.05221c49.448421 81.246316 92.968421 148.506947 147.051789 199.302737z" fill="#231F20" ></path></symbol><symbol id="icon-goat" viewBox="0 0 1024 1024"><path d="M548.378947 646.736842a952.32 952.32 0 0 1 140.90779-161.68421H107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L66.721684 754.526316h417.172211c20.345263-41.472 43.654737-77.446737 64.485052-107.789474z" fill="#F7C768" ></path><path d="M608.256 144.734316C555.762526 115.577263 506.098526 107.789474 485.052632 107.789474V53.894737c32.579368 0 91.270737 11.452632 149.369263 43.735579 75.290947 41.822316 130.694737 94.531368 171.385263 150.878316C755.873684 288.013474 697.101474 323.368421 646.736842 323.368421h-107.789474v-53.894737h107.789474c20.506947 0 48.424421-11.210105 80.437895-31.285895a471.04 471.04 0 0 0-118.918737-93.453473zM832.673684 342.231579c-16.384 0-29.642105 10.24-29.642105 44.463158 0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642105-44.463158c0-34.223158-13.231158-44.463158-29.642105-44.463158zM1024 619.789474C1024 347.109053 901.066105 122.448842 686.753684 3.395368l-26.165895 47.104C914.324211 191.461053 964.688842 440.400842 969.647158 592.842105h-84.506947c-17.92-35.624421-45.352421-69.12-87.013053-101.995789l-16.788211-13.285053-16.734315 13.392842c-66.128842 52.897684-134.629053 127.083789-187.311158 209.677474H102.965895l-8.272842-20.318316C159.043368 617.013895 161.684211 603.109053 161.684211 485.052632v-53.894737h485.052631v-53.894737H161.684211c0-80.384 14.309053-110.026105 66.586947-137.916632l-25.384421-47.535158C123.365053 234.226526 107.789474 291.920842 107.789474 377.263158v107.789474c0 107.600842 0 107.600842-63.649685 169.283368l-13.069473 12.665263L110.618947 862.315789h58.206316l-43.897263-107.789473h103.477895l43.897263 107.789473h58.206316l-43.897263-107.789473h259.47621C508.981895 824.939789 485.052632 899.152842 485.052632 970.105263h53.894736c0-68.688842 27.270737-144.060632 68.958316-215.578947H687.157895c7.410526 0 13.473684 6.063158 13.473684 13.473684V862.315789h53.894737v-94.315789c0-37.160421-30.208-67.368421-67.368421-67.368421h-44.65179c40.771368-58.017684 89.438316-111.427368 138.913684-153.626947C841.512421 600.037053 862.315789 655.225263 862.315789 754.526316h53.894737c0-38.912-2.748632-74.482526-11.102315-107.789474H1024v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-goat_wei" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 50.202947c52.304842 70.925474 136.973474 152.144842 232.528843 190.383158l19.994947-50.041263c-109.271579-43.708632-202.805895-152.629895-238.780632-217.49221H808.421053v-53.894737H538.947368v-53.894737h215.578948v-53.894737h-215.578948V161.684211h-53.894736v161.68421h-215.578948v53.894737h215.578948v53.894737H215.578947v53.894737h255.757474c-35.974737 64.862316-129.536 173.783579-238.807579 217.49221l20.021895 50.041263c95.528421-38.238316 180.197053-119.484632 232.501895-190.383158V808.421053h53.894736v-246.218106z" fill="#231F20" ></path></symbol><symbol id="icon-dragon" viewBox="0 0 1024 1024"><path d="M366.376421 344.441263l152.980211-152.98021c43.142737-43.142737 141.204211-9.216 270.201263 115.738947-15.225263 9.835789-25.114947 15.818105-44.13979 32.256s-38.076632 35.489684-59.418947 56.832c-4.203789 4.203789-51.173053 53.221053-78.740211 82.027789-10.805895-12.126316-22.743579-24.171789-34.654315-36.082526L493.136842 362.792421l-54.218105 54.218105-72.542316-72.569263zM862.315789 512c0 46.834526-45.352421 80.842105-107.789473 80.842105-108.948211 0-189.359158-28.806737-267.129263-56.697263C414.100211 509.871158 344.872421 485.052632 258.182737 485.052632 80.788211 485.052632 0 588.126316 0 683.897263h53.894737C73.216 659.779368 135.302737 646.736842 177.340632 646.736842c77.338947 0 223.124211 23.282526 291.893894 47.912421C547.462737 722.701474 615.989895 754.526316 734.315789 754.526316 862.315789 754.526316 916.210526 670.315789 916.210526 512h-53.894737z" fill="#FF8787" ></path><path d="M552.421053 1024c-69.766737 0-113.825684-13.958737-156.402527-27.459368-54.487579-17.273263-110.807579-35.004632-232.421052-26.516211l-3.826527-53.733053c131.718737-9.458526 195.934316 10.967579 252.52379 28.887579 42.226526 13.365895 78.686316 24.926316 140.126316 24.926316 92.752842 0 148.210526-57.936842 148.210526-113.960421 0-16.949895-5.524211-101.618526-114.634105-101.618526-64.970105 0-112.747789 23.336421-163.328 48.02021C365.325474 830.571789 300.301474 862.315789 204.288 862.315789 85.908211 862.315789 0 787.294316 0 683.897263 0 588.126316 80.788211 485.052632 258.182737 485.052632c86.689684 0 155.917474 24.818526 229.214316 51.09221 45.810526 16.410947 92.564211 33.172211 145.488842 44.166737 9.000421-7.033263 13.850947-16.276211 13.850947-26.758737 0-37.187368-37.672421-74.859789-74.13221-111.265684l-3.287579-3.287579 38.103579-38.103579 3.260631 3.287579C652.853895 446.275368 700.631579 494.026105 700.631579 553.552842c0 12.719158-2.802526 24.926316-7.976421 36.109474A594.997895 594.997895 0 0 0 754.526316 592.842105c62.437053 0 107.789474-34.007579 107.789473-80.842105 0-58.853053-52.870737-110.268632-108.840421-164.702316l-8.057263-7.841684c-19.024842 16.437895-38.076632 35.489684-59.418947 56.832l-38.103579-38.103579c74.805895-74.832842 134.898526-134.898526 268.314947-141.931789V55.619368c-63.407158 7.787789-120.993684 39.424-121.667368 39.801264l-15.818105 8.811789-14.120421-11.344842C731.701895 66.452211 709.712842 53.894737 673.684211 53.894737c-41.418105 0-74.347789 25.869474-109.190737 53.301895-26.624 20.911158-54.137263 42.549895-86.851369 53.194105L469.342316 161.684211h-69.093053l-105.525895 105.525894-38.103579-38.130526L324.015158 161.684211H161.684211V107.789474h303.104c22.231579-8.272842 43.708632-25.168842 66.398315-42.981053C569.829053 34.438737 613.618526 0 673.684211 0c48.909474 0 81.408 17.946947 110.888421 40.097684C813.702737 26.300632 877.729684 0 943.157895 0h26.947368v323.368421h-53.894737v-53.167158c-54.164211 3.098947-92.914526 15.845053-127.002947 36.675369l1.832421 1.778526C852.587789 368.505263 916.210526 430.376421 916.210526 512c0 60.928-43.708632 109.945263-107.789473 127.622737V700.631579h53.894736v-53.894737h53.894737v53.894737h53.894737v53.894737h-53.894737v53.894737h-53.894737v-53.894737h-53.894736c-29.722947 0-53.894737-24.171789-53.894737-53.894737v-53.894737c-118.325895 0-207.063579-31.797895-285.318737-59.877053C400.437895 562.229895 335.494737 538.947368 258.182737 538.947368 117.059368 538.947368 53.894737 611.732211 53.894737 683.897263 53.894737 757.221053 115.738947 808.421053 204.288 808.421053c11.910737 0 23.228632-0.538947 34.034526-1.536C248.454737 796.321684 269.473684 770.640842 269.473684 739.166316c0-33.118316-43.088842-70.979368-58.152421-81.596632l30.935579-44.139789c8.299789 5.793684 81.111579 58.664421 81.111579 125.736421 0 19.429053-4.527158 37.052632-10.994526 52.304842 30.773895-10.051368 58.314105-23.498105 86.662737-37.349053C452.877474 727.848421 508.577684 700.631579 585.997474 700.631579 702.410105 700.631579 754.526316 778.725053 754.526316 856.144842 754.526316 938.657684 678.912 1024 552.421053 1024z m-21.180632-623.104L493.136842 362.792421l137.889684-137.889684 38.103579 38.103579-137.889684 137.889684z m-126.760421-18.351158l-38.103579-38.103579 152.980211-152.98021 38.103579 38.103579-152.980211 152.98021z m282.004211-218.624c15.494737-9.754947 43.331368-31.447579 43.331368-31.447579-25.734737-27.809684-49.556211-33.333895-67.368421-29.07621-19.240421 4.608-37.753263 24.602947-37.753263 24.602947s42.253474 22.447158 61.790316 35.920842z" fill="#231F20" ></path></symbol><symbol id="icon-horse" viewBox="0 0 1024 1024"><path d="M776.003368 646.736842c16.599579-99.947789 43.439158-181.086316 83.213474-256.538947l6.817684-12.934737H269.473684c-36.756211 0-53.894737 54.945684-53.894737 92.05221 0 46.753684 6.656 77.527579 70.278737 176.074106l84.533895 128.269473L498.876632 646.736842h277.126736z" fill="#FFAF6E" ></path><path d="M1024 0v404.210526c0 33.333895 0 134.736842-92.079158 134.736842h-13.824l-78.362947-109.056c-22.743579 49.906526-40.340211 103.046737-53.490527 162.950737h115.092211C937.310316 592.842105 970.105263 625.637053 970.105263 661.638737c0 60.631579-69.389474 154.300632-77.312 164.75621l-43.008-32.471579C875.466105 759.861895 916.210526 693.813895 916.210526 661.638737c0-5.982316-8.919579-14.901895-14.901894-14.901895h-125.332211C761.128421 736.121263 754.526316 840.569263 754.526316 970.105263h-53.894737c0-283.971368 31.097263-453.605053 110.888421-605.049263l20.318316-38.534737 112.801684 156.995369c14.443789-4.419368 25.465263-20.938105 25.465263-79.306106V0h53.894737z m-161.684211 161.684211h53.894737V0h-53.894737v80.842105c-17.381053-14.955789-38.184421-26.947368-80.842105-26.947368h-134.736842v53.894737h134.736842c37.672421 0 80.842105 40.906105 80.842105 53.894737z m-107.789473 0h-215.578948v53.894736h161.684211l53.894737-53.894736zM300.894316 766.544842L400.680421 916.210526h64.754526l-95.043368-142.551579L498.876632 646.736842h167.855157a1212.631579 1212.631579 0 0 1 9.431579-53.894737h-199.383579l-175.885473 173.702737z m109.97221-184.400842l-37.861052-38.319158-132.419369 130.802526C173.729684 571.095579 161.684211 529.812211 161.684211 469.315368 161.684211 398.578526 199.464421 323.368421 269.473684 323.368421h323.368421l53.894737-53.894737H269.473684c-6.709895 0-13.258105 0.565895-19.698526 1.482105C234.927158 249.451789 204.638316 215.578947 160.633263 215.578947 65.967158 215.578947 0 349.291789 0 469.315368c0 70.170947 16.141474 136.650105 49.232842 202.671158L6.197895 723.833263l41.472 34.41179 66.128842-79.737264-8.704-16.033684C83.105684 622.133895 53.894737 558.214737 53.894737 469.315368 53.894737 368.451368 106.765474 269.473684 160.633263 269.473684c13.231158 0 25.815579 9.889684 35.43579 20.533895C142.874947 321.967158 107.789474 388.500211 107.789474 469.315368c0 78.201263 19.698526 130.937263 93.642105 243.981474l-55.296 54.622316L280.899368 970.105263h64.754527l-130.048-195.072 195.260631-192.889263z" fill="#231F20" ></path></symbol><symbol id="icon-monkey_shen" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 134.736842h161.684211v53.894737h53.894737V269.473684h-215.578948V161.684211h-53.894736v107.789473h-215.578948v431.157895h53.894737v-53.894737h161.684211v215.578947h53.894736v-215.578947z m0-161.68421h161.684211v107.789473h-161.684211v-107.789473z m-215.578947 0h161.684211v107.789473h-161.684211v-107.789473z m215.578947-161.684211h161.684211v107.789474h-161.684211v-107.789474z m-215.578947 0h161.684211v107.789474h-161.684211v-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-ox_chou" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#D6B196" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-161.68421 188.631579h-159.555369c13.985684-172.813474 43.115789-357.429895 70.817684-385.158737L700.631579 269.473684H323.368421v53.894737h107.169684c-1.940211 45.756632-8.192 103.962947-15.76421 161.684211H323.368421v53.894736h83.968c-9.862737 68.446316-20.264421 130.128842-25.734737 161.684211H215.578947v53.894737h592.842106v-53.894737z m-346.543158-161.684211h149.800421a3313.717895 3313.717895 0 0 0-16.842105 161.684211h-158.477474c6.036211-35.247158 16.114526-95.636211 25.519158-161.684211z m22.608842-215.578947h171.735579c-15.198316 41.121684-27.405474 100.594526-36.890948 161.684211h-150.123789c7.383579-57.505684 13.419789-115.361684 15.279158-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-monkey" viewBox="0 0 1024 1024"><path d="M757.733053 485.052632H565.894737a80.842105 80.842105 0 0 0-80.842105 80.842105v215.578947c0 40.96 43.546947 99.678316 77.446736 139.210105C596.426105 960.215579 603.055158 970.105263 603.055158 970.105263H754.526316s15.144421-18.674526 45.891368-58.071579S862.315789 809.984 862.315789 717.608421c0-89.573053-47.993263-166.346105-104.582736-232.555789z" fill="#C3D686" ></path><path d="M538.947368 1024h-53.894736c0-32.794947 25.869474-87.417263 77.446736-103.316211C528.599579 881.152 485.052632 822.433684 485.052632 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h80.842105v53.894737h-80.842105a26.947368 26.947368 0 0 0-26.947369 26.947368c0 19.725474 36.675368 77.473684 92.133053 134.736842h88.602947c20.210526-14.147368 88.737684-71.464421 88.737685-198.602105 0-108.382316-93.237895-202.967579-168.151579-278.986105-49.502316-50.202947-88.576-89.842526-98.735158-128.61979-11.749053-44.732632-21.584842-112.586105-26.327579-148.318315H377.263158c-45.136842 0-89.519158 8.434526-121.802105 53.894736H431.157895v53.894737c-97.28 0-107.789474 113.071158-107.789474 161.684211v53.894737h53.894737v161.68421h-53.894737v-107.789474h-26.947368c-170.253474 0-188.631579-94.234947-188.631579-134.736842 0-31.043368 35.220211-72.326737 55.727158-93.722947 2.694737-14.686316 5.847579-28.348632 9.431579-41.013895H161.684211V215.578947h31.528421C239.642947 120.993684 317.224421 107.789474 377.263158 107.789474h185.640421l2.802526 23.794526c0.134737 1.050947 12.719158 106.657684 27.944421 164.756211 6.494316 24.872421 44.624842 63.514947 84.965053 104.448C760.481684 483.813053 862.315789 587.129263 862.315789 717.608421c0 92.375579-31.124211 155.028211-61.898105 194.425263C904.919579 892.146526 970.105263 803.004632 970.105263 673.684211c0-91.405474-42.819368-154.381474-84.237474-215.255579C847.791158 402.458947 808.421053 344.576 808.421053 269.473684c0-119.349895 87.093895-161.684211 161.68421-161.68421v53.894737c-32.417684 0-107.789474 10.509474-107.789474 107.789473 0 58.502737 31.555368 104.933053 68.096 158.639158C974.282105 492.597895 1024 565.679158 1024 673.684211c0 177.286737-108.301474 296.421053-269.473684 296.421052h-161.684211c-37.672421 0-53.894737 40.906105-53.894737 53.894737zM229.214316 269.473684a384.808421 384.808421 0 0 0-14.012632 58.341053l-1.401263 8.488421-6.090105 6.117053c-22.878316 22.932211-44.813474 52.601263-46.026105 62.275368 0 56.805053 53.76 75.264 107.789473 79.386947V431.157895c0-58.691368 13.473684-119.619368 46.511158-161.684211h-86.770526zM323.368421 1024h-53.894737c0-32.794947 25.869474-87.417263 77.446737-103.316211C313.020632 881.152 269.473684 822.433684 269.473684 781.473684c0-44.570947 36.271158-80.842105 80.842105-80.842105h45.16379A188.847158 188.847158 0 0 1 565.894737 592.842105h134.736842v53.894737h-134.736842c-74.293895 0-134.736842 60.442947-134.736842 134.736842v26.516211l-53.894737 0.377263V781.473684c0-9.162105 0.646737-18.135579 1.913263-26.947368H350.315789c-14.848 0-26.947368 12.072421-26.947368 26.947368 0 19.725474 36.675368 77.473684 92.133053 134.736842H431.157895v53.894737h-53.894737c-37.672421 0-53.894737 40.906105-53.894737 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-horse_wu" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 26.947368h269.473685v-53.894736H538.947368v-161.684211h161.684211v-53.894737H411.001263c12.045474-33.28 20.156632-69.793684 20.156632-107.789473h-53.894737c0 121.963789-105.364211 233.391158-106.415158 234.496l38.858105 37.349052c2.883368-3.018105 43.816421-46.133895 77.392842-110.160842H485.052632v161.684211H215.578947v53.894736h269.473685v323.368421h53.894736V538.947368z" fill="#231F20" ></path></symbol><symbol id="icon-ox" viewBox="0 0 1025 1024"><path d="M540.294737 754.526316h215.578947c20.210526 0 35.112421 1.374316 53.894737 4.581052 91.863579 15.656421 145.354105 67.691789 161.684211 86.069895V916.210526h53.894736V635.580632l-7.895579-7.895579c-9.269895-9.269895-36.513684-49.232842-44.032-196.527158H540.294737a161.684211 161.684211 0 0 0-161.684211 161.68421v131.098948c43.304421 20.210526 97.28 30.585263 161.684211 30.585263z" fill="#FFAF6E" ></path><path d="M1025.347368 635.580632V916.210526h-53.894736v-71.033263c-16.330105-18.405053-69.820632-70.413474-161.684211-86.069895V916.210526h-53.894737v-161.68421h-107.789473v215.578947h-53.894737V700.631579h161.68421c100.998737 0 172.570947 38.669474 215.578948 71.868632v-115.738948c-33.684211-43.627789-51.712-137.458526-53.706106-279.498105H701.978947c-76.934737 0-127.218526-26.219789-175.804631-51.550316a1556.048842 1556.048842 0 0 0-26.839579-13.743158c-26.839579 26.004211-66.209684 44.921263-115.738948 55.511579 24.441263 22.986105 60.874105 52.116211 106.469053 72.838737l-22.312421 49.044211c-76.584421-34.816-129.589895-88.926316-150.824421-113.125053-10.644211 0.619789-21.477053 1.024-32.687158 1.024a473.734737 473.734737 0 0 1-123.365053-15.952842l-93.022315 186.314105 68.581052 53.86779C167.882105 579.557053 237.891368 538.947368 324.715789 538.947368v53.894737c-95.986526 0-170.361263 62.490947-171.088842 63.137684l-16.78821 14.282106-136.838737-107.358316 109.729684-219.809684C46.430316 314.448842 1.347368 267.371789 1.347368 199.868632 1.347368 89.815579 121.586526 53.894737 163.031579 53.894737v53.894737c-14.120421 0-107.789474 17.165474-107.789474 92.079158C55.242105 290.465684 192.188632 323.368421 284.240842 323.368421c67.907368 0 122.421895-12.988632 157.696-35.624421-42.711579-14.336-95.097263-23.120842-169.337263-18.324211l-3.503158-53.786947c95.878737-6.117053 160.148211 8.515368 211.429053 28.833684C484.244211 235.439158 486.4 225.818947 486.4 215.578947c0-48.855579-57.829053-76.288-58.394947-76.557473l22.393263-49.017263C454.063158 91.648 540.294737 131.826526 540.294737 215.578947c0 18.566737-3.422316 35.84-9.997474 51.631158 7.060211 3.584 13.985684 7.168 20.776421 10.698106C597.854316 302.322526 638.248421 323.368421 701.978947 323.368421h269.473685v26.947368c0 214.689684 35.220211 266.590316 45.999157 277.369264l7.895579 7.895579z m-729.384421 25.141894l-98.789052 118.541474 86.797473 137.835789 45.594948-28.725894-65.913263-104.690527 37.052631-44.43621C358.642526 785.192421 439.080421 808.421053 540.294737 808.421053v-53.894737c-99.893895 0-175.077053-24.549053-223.474526-72.946527l-20.857264-20.857263z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit_mao" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-377.263158-188.631579h107.789474v323.368421c-20.48 0-39.936-11.264-40.016842-11.317895l-27.728842 46.214737c3.206737 1.940211 32.660211 18.997895 67.745684 18.997895 30.746947 0 53.894737-23.147789 53.894737-53.894737V269.473684h-215.578948v538.947369h53.894737V323.368421z m-107.789473 242.526316v-242.526316h-53.894737v196.904421l-107.789474 40.421053v-243.927579l169.094737-48.316632-14.821053-51.819789L269.473684 276.102737v304.801684l-36.405895 13.662316 18.917053 50.472421 178.741895-67.018105c-5.039158 69.928421-55.269053 106.981053-165.133474 122.933894l7.733895 53.328842C325.712842 746.657684 485.052632 723.536842 485.052632 565.894737z" fill="#231F20" ></path></symbol><symbol id="icon-rabbit" viewBox="0 0 1024 1024"><path d="M680.96 488.744421a1666.667789 1666.667789 0 0 0-54.433684-23.95621c-16.006737 12.234105-33.899789 20.264421-60.631579 20.264421h-80.842105c-36.810105 0-83.644632 30.396632-104.394106 67.772631-42.819368 77.123368-53.409684 117.813895-11.021473 201.701053C397.096421 808.879158 431.157895 876.409263 431.157895 970.105263h338.539789l68.338527-138.859789c20.129684-40.96 24.252632-73.701053 24.252631-110.349474 0.026947-57.397895-25.061053-159.717053-181.328842-232.151579z" fill="#FFBDD8" ></path><path d="M862.315789 720.896c0 36.621474-4.122947 69.389474-24.252631 110.349474L769.697684 970.105263H485.052632v-53.894737h48.370526C507.877053 880.074105 485.052632 833.509053 485.052632 781.473684c0-59.418947 24.171789-113.313684 63.218526-152.360421l38.103579 38.103579A161.091368 161.091368 0 0 0 538.947368 781.473684c0 54.784 35.381895 104.043789 63.514948 134.736842h133.712842l53.490526-108.759579c15.710316-31.851789 18.755368-55.834947 18.755369-86.554947 0-80.976842-63.434105-150.096842-178.607158-195.503158-17.542737 8.138105-38.292211 13.554526-63.919158 13.554526h-80.842105c-13.958737 0-43.924211 15.979789-57.290106 40.016843l-47.104-26.165895C401.408 515.449263 448.242526 485.052632 485.052632 485.052632h80.842105c37.268211 0 57.478737-15.440842 79.090526-36.45979C625.367579 336.195368 549.753263 269.473684 485.052632 269.473684h-107.789474a21.288421 21.288421 0 0 0-5.955369 2.021053A683.762526 683.762526 0 0 0 302.187789 194.021053c-35.84-34.223158-61.763368-58.933895-94.908631-79.440842A42.442105 42.442105 0 0 0 185.478737 107.789474a22.824421 22.824421 0 0 0-17.381053 7.194947c-10.913684 11.425684-6.063158 28.240842 1.428211 39.181474 21.989053 32.121263 47.912421 56.858947 83.752421 91.109052 20.614737 19.671579 49.259789 43.169684 77.392842 63.08379C281.007158 367.400421 215.578947 484.432842 215.578947 592.842105c0 74.482526 24.791579 124.065684 51.065264 176.586106C294.534737 825.209263 323.368421 882.903579 323.368421 970.105263h-53.894737c0-74.482526-24.791579-124.065684-51.065263-176.586105C190.517895 737.738105 161.684211 680.043789 161.684211 592.842105c0-90.866526 42.226526-197.685895 93.453473-274.485894a803.759158 803.759158 0 0 1-39.046737-34.115369C177.852632 247.754105 150.231579 221.399579 125.035789 184.616421c-24.441263-35.759158-22.797474-78.686316 4.069053-106.819368 26.300632-27.567158 70.898526-31.043368 106.522947-9.000421 37.941895 23.444211 65.562947 49.798737 103.774316 86.258526 9.970526 9.512421 33.037474 32.309895 56.93979 60.550737h68.634947c-27.621053-37.780211-60.416-72.730947-88.522105-99.543579-28.833684-27.540211-54.730105-52.116211-84.533895-74.024421L326.305684 0.296421c31.232 23.228632 57.802105 48.532211 87.309474 76.719158 53.840842 51.388632 94.450526 100.594526 121.74821 146.83621 82.836211 26.650947 150.042947 116.870737 165.025685 230.750316l1.724631 13.177263-9.404631 9.404632c-3.772632 3.772632-7.706947 7.653053-11.802948 11.587368C837.227789 561.178947 862.315789 663.498105 862.315789 720.896zM309.463579 754.526316c3.934316 8.057263 7.895579 16.087579 11.991579 24.144842C348.887579 832.970105 377.263158 889.128421 377.263158 970.105263h53.894737c0-93.696-34.061474-161.226105-61.520842-215.578947h-60.173474z m597.90821 53.894737c-3.422316 9.404632-7.814737 19.806316-13.770105 31.959579L829.790316 970.105263h60.065684l52.143158-105.957052c10.778947-21.935158 17.515789-40.016842 21.90821-55.727158h-56.535579zM514.694737 390.736842c0-34.223158-13.231158-44.463158-29.642105-44.463158s-29.642105 10.24-29.642106 44.463158c0 34.250105 13.231158 44.463158 29.642106 44.463158s29.642105-10.213053 29.642105-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rat_zi" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-431.157895 188.631579v-215.578947h269.473685v-53.894737H538.947368v-39.585684c26.543158-18.081684 94.585263-65.050947 177.852632-127.488L700.631579 215.578947H323.368421v53.894737h295.316211a4221.008842 4221.008842 0 0 1-121.640421 85.369263l-11.991579 8.003369V431.157895H242.526316v53.894737h242.526316v215.578947c0 48.343579-13.850947 53.894737-134.736843 53.894737v53.894737c105.391158 0 188.631579 0 188.631579-107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-rat" viewBox="0 0 1024 1024"><path d="M727.659789 431.157895c-132.581053 0-220.348632 47.454316-285.803789 154.354526-19.779368 32.309895-15.845053 76.503579-9.404632 96.579368 3.260632 10.159158 7.760842 18.647579 12.422737 25.546106C464.761263 737.010526 499.927579 754.526316 538.947368 754.526316h66.829474c1.158737 17.893053-1.967158 34.762105-15.144421 53.975579-12.692211 18.539789-37.807158 40.151579-56.32 54.810947 25.249684-0.673684 52.709053-0.997053 83.240421-0.997053C877.487158 862.315789 970.105263 711.922526 970.105263 571.176421 936.421053 512 882.364632 431.157895 727.659789 431.157895z" fill="#85C3DE" ></path><path d="M210.432 1012.897684l-43.573895-31.690105c106.954105-147.051789 185.317053-171.196632 423.828211-172.705684 21.396211-31.258947 16.249263-56.266105 9.377684-89.70779-3.557053-17.138526-7.221895-34.842947-7.221895-54.433684 0-68.958316 25.330526-104.636632 63.407158-136.973474l34.896842 41.040842c-29.453474 25.061053-44.409263 46.780632-44.409263 95.932632 0 14.093474 2.937263 28.402526 6.063158 43.546947 5.901474 28.510316 12.8 62.032842-1.131789 99.462737 166.373053-10.24 264.542316-96.902737 264.542315-236.193684C916.210526 418.330947 827.580632 323.368421 684.921263 323.368421c-83.644632 0-153.303579 29.696-174.187789 39.612632a224.875789 224.875789 0 0 1-20.533895 31.339789l-41.741474-34.115368 20.884211 17.057684-20.911158-16.976842C448.781474 359.828211 485.052632 314.287158 485.052632 262.736842c0-34.816-8.946526-60.766316-26.570106-77.069474-17.515789-16.249263-44.786526-24.602947-81.219368-24.953263V323.368421h-53.894737V109.783579l24.872421-1.913263c64.700632-4.931368 114.095158 7.895579 146.863158 38.238316C524.207158 173.056 538.947368 212.291368 538.947368 262.736842c0 11.102316-1.131789 21.908211-3.072 32.202105 37.268211-12.584421 89.842526-25.465263 149.045895-25.465263C858.165895 269.473684 970.105263 387.907368 970.105263 571.176421 970.105263 711.922526 877.487158 862.315789 617.552842 862.315789c-258.667789 0-311.942737 19.698526-407.120842 150.581895z m19.105684-256.835368c-12.045474 0-24.387368-0.565895-37.025684-1.64379l-22.096842-1.859368-2.425263-22.016C167.747368 728.144842 161.684211 672.444632 161.684211 631.026526c0-103.585684 21.450105-178.903579 53.894736-259.045052V107.789474h53.894737v274.782315l-2.021052 4.904422C235.439158 465.758316 215.578947 533.800421 215.578947 631.026526c0 22.878316 2.101895 51.442526 3.826527 70.979369 99.678316 2.802526 172.813474-35.408842 222.450526-116.493474l48.020211 24.090947c-11.237053 28.133053-11.371789 51.577263-0.377264 67.853474 9.701053 14.282105 28.645053 23.174737 49.448421 23.174737v53.894737c-39.019789 0-74.186105-17.515789-94.073263-46.888421a100.244211 100.244211 0 0 1-12.422737-25.546106c-53.221053 49.178947-121.128421 73.943579-202.913684 73.970527zM379.957895 525.473684c0-34.223158-13.231158-44.463158-29.642106-44.463158s-29.642105 10.24-29.642105 44.463158c0 34.250105 13.231158 44.463158 29.642105 44.463158s29.642105-10.213053 29.642106-44.463158z" fill="#231F20" ></path></symbol><symbol id="icon-rooster_you" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#BBC4C9" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-215.578947-188.631579h-161.684211v-26.947368h161.684211V242.526316H269.473684v53.894737h161.684211v26.947368h-161.684211v485.052632h53.894737v-53.894737h377.263158v53.894737h53.894737V323.368421zM323.368421 646.736842h377.263158v53.894737H323.368421v-53.894737z m0-269.473684h107.789474c0 103.316211-72.784842 107.654737-81.084632 107.789474L350.315789 538.947368c46.592 0 134.736842-33.792 134.736843-161.68421h53.894736v107.789474c0 29.722947 24.171789 53.894737 53.894737 53.894736h107.789474v53.894737H323.368421v-215.578947z m377.263158 0v107.789474h-107.789474v-107.789474h107.789474z m-215.578947-80.842105h53.894736v26.947368h-53.894736v-26.947368z" fill="#231F20" ></path></symbol><symbol id="icon-rooster" viewBox="0 0 1024 1024"><path d="M891.688421 506.421895C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V116.224l-323.368421 195.745684V323.368421c0 78.524632 14.928842 131.664842 29.372632 183.053474 12.611368 44.894316 24.522105 87.282526 24.522105 140.314947 0 101.618526-77.931789 176.693895-168.286316 203.991579l5.416422 11.587368h215.578947c24.333474 0 43.385263-0.242526 58.556631-2.128842C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947z" fill="#FF8787" ></path><path d="M673.684211 354.357895c-16.384 0-29.642105-10.213053-29.642106-44.463158 0-34.223158 13.231158-44.463158 29.642106-44.463158s29.642105 10.24 29.642105 44.463158c0 34.250105-13.258105 44.463158-29.642105 44.463158zM540.106105 970.105263l-50.58021-107.789474h156.05221l50.607158 107.789474h59.553684l-51.60421-109.918316C811.52 846.821053 916.210526 764.550737 916.210526 646.736842c0-53.032421-11.910737-95.420632-24.522105-140.314947C877.244632 455.033263 862.315789 401.893053 862.315789 323.368421V107.789474c0-59.445895-48.343579-107.789474-107.789473-107.789474a107.924211 107.924211 0 0 0-107.789474 106.172632 100.890947 100.890947 0 0 0-24.117895-3.314527 88.710737 88.710737 0 0 0-88.602947 88.602948c0 20.668632 5.227789 39.720421 10.671158 53.921684l-99.489684 59.688421 93.749894 14.470737V377.263158c0 14.416842-5.901474 21.692632-33.360842 49.152l-11.129263 11.129263C398.228211 326.521263 324.985263 269.473684 215.740632 269.473684 96.768 269.473684 0 366.241684 0 485.214316V646.736842h53.894737v-161.522526A162.007579 162.007579 0 0 1 215.740632 323.368421c82.081684 0 140.422737 36.244211 240.64 152.252632l-38.615579 38.615579C367.804632 461.285053 323.098947 431.157895 259.584 431.157895A151.983158 151.983158 0 0 0 107.789474 582.952421V754.526316h53.894737v-171.573895A98.007579 98.007579 0 0 1 259.584 485.052632c46.322526 0 79.629474 20.911158 137.027368 86.016l18.970948 21.530947 128.080842-128.080842C572.200421 435.981474 592.842105 415.366737 592.842105 377.263158v-97.926737l23.309474-14.120421-13.662316-23.04c-0.161684-0.242526-14.578526-24.899368-14.578526-50.688 0-19.132632 15.575579-34.708211 34.70821-34.708211 5.093053 0 26.785684 3.179789 39.558737 18.647579l26.327579 46.026106 39.774316-24.090948-20.372211-49.367579C704.754526 140.449684 700.631579 117.517474 700.631579 107.789474c0-29.722947 24.171789-53.894737 53.894737-53.894737s53.894737 24.171789 53.894737 53.894737v215.578947c0 85.935158 16.680421 145.300211 31.366736 197.632C851.887158 564.008421 862.315789 601.141895 862.315789 646.736842c0 95.285895-99.408842 161.684211-188.631578 161.684211h-209.461895l-68.419369-145.704421C375.242105 618.954105 338.108632 592.842105 296.448 592.842105A80.976842 80.976842 0 0 0 215.578947 673.711158V862.315789h53.894737v-188.604631c0-14.874947 12.099368-26.974316 26.974316-26.974316 20.533895 0 38.965895 14.147368 50.553263 38.858105L480.579368 970.105263h59.526737z" fill="#231F20" ></path></symbol><symbol id="icon-snake_si" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#FF8787" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-242.041263 180.762947l-52.116211-13.797052C657.219368 749.864421 651.425684 754.526316 619.789474 754.526316h-242.526316V485.052632h269.473684v53.894736h53.894737V215.578947H323.368421v538.947369c0 29.722947 24.171789 53.894737 53.894737 53.894737h242.526316c77.689263 0 91.189895-51.065263 108.274526-115.658106zM377.263158 269.473684h269.473684v161.684211H377.263158v-161.684211z" fill="#231F20" ></path></symbol><symbol id="icon-tiger_yin" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#7DD47F" ></path><path d="M970.105263 512c0 224.983579-163.166316 412.186947-377.263158 450.533053v-54.460632C777.135158 870.507789 916.210526 707.206737 916.210526 512c0-222.881684-181.328842-404.210526-404.210526-404.210526S107.789474 289.118316 107.789474 512s181.328842 404.210526 404.210526 404.210526c9.081263 0 18.000842-0.754526 26.947368-1.374315v53.894736c-8.973474 0.538947-17.866105 1.374316-26.947368 1.374316-252.604632 0-458.105263-205.500632-458.105263-458.105263S259.395368 53.894737 512 53.894737s458.105263 205.500632 458.105263 458.105263z m-257.42821 299.250526l-107.789474-53.894737-24.117895 48.208843 107.789474 53.894736 24.117895-48.208842z m-269.473685-5.658947l-24.117894-48.208842-107.789474 53.894737 24.117895 48.208842 107.789473-53.894737zM700.631579 431.157895h-161.684211v-53.894737h107.789474v-53.894737H377.263158v53.894737h107.789474v53.894737h-161.684211v323.368421h53.894737v-53.894737h269.473684v53.894737h53.894737V431.157895z m-161.684211 161.68421h107.789474v53.894737h-107.789474v-53.894737z m-161.68421 0h107.789474v53.894737h-107.789474v-53.894737z m161.68421-107.789473h107.789474v53.894736h-107.789474v-53.894736z m-161.68421 0h107.789474v53.894736h-107.789474v-53.894736zM754.526316 215.578947h-223.097263l-20.803369-62.410105-51.119158 17.057684L474.624 215.578947H269.473684v107.789474h53.894737v-53.894737h377.263158v53.894737h53.894737V215.578947z" fill="#231F20" ></path></symbol><symbol id="icon-snake" viewBox="0 0 1024 1024"><path d="M107.789474 790.474105c0-72.434526 67.880421-91.513263 121.451789-91.513263 74.401684 0 153.815579 34.438737 237.891369 70.925474 50.580211 21.935158 104.609684 45.325474 162.250105 63.083789-52.412632 44.786526-118.784 74.347789-195.152842 83.078737-143.171368 16.357053-326.440421 7.006316-326.440421-125.574737zM377.263158 215.578947c-15.575579 0-30.288842 3.449263-43.654737 9.377685A250.691368 250.691368 0 0 0 323.368421 296.421053c0 115.550316 76.422737 169.391158 137.83579 212.614736 8.138105 5.712842 16.141474 11.371789 23.848421 17.057685V323.368421a107.789474 107.789474 0 0 0-107.789474-107.789474z" fill="#C3D686" ></path><path d="M671.528421 788.857263c44.328421 11.964632 89.626947 19.563789 136.892632 19.56379 89.168842 0 161.684211-60.442947 161.68421-134.736842s-72.515368-134.736842-161.68421-134.736843c-19.078737 0-37.025684 1.509053-54.218106 4.015158-0.754526-101.402947-38.211368-172.355368-79.413894-219.648L673.684211 323.368421a1749.962105 1749.962105 0 0 1-79.036632-1.751579c45.702737 35.866947 108.705684 107.870316 105.984 232.367158 0 0.431158-0.080842 0.808421-0.10779 1.239579-34.923789 10.994526-66.155789 26.731789-95.097263 45.190737a163.085474 163.085474 0 0 0-15.845052-42.388211c-21.557895-39.639579-60.065684-66.775579-97.360842-93.022316C433.098105 423.343158 377.263158 384 377.263158 296.421053c0-130.290526 108.274526-188.631579 215.578947-188.631579 64.134737 0 132.715789 12.045474 214.366316 37.807158C802.330947 180.250947 780.099368 209.381053 700.631579 214.635789V161.684211h-53.894737v53.679157c-63.272421-1.024-104.528842-5.200842-104.986947-5.254736l-5.578106 53.598315C538.408421 263.949474 592.357053 269.473684 673.684211 269.473684c125.170526 0 188.631579-48.128 188.631578-143.063579V106.981053l-18.432-6.144C747.789474 68.823579 668.025263 53.894737 592.842105 53.894737c-158.666105 0-269.473684 99.732211-269.473684 242.526316 0 115.550316 76.422737 169.391158 137.83579 212.614736 33.684211 23.713684 65.509053 46.106947 81.003789 74.698106 9.539368 17.542737 13.285053 33.414737 12.341895 47.750737 21.153684 9.108211 42.118737 17.839158 62.949052 25.977263C671.151158 620.193684 729.977263 592.842105 808.421053 592.842105c59.445895 0 107.789474 36.271158 107.789473 80.842106s-48.343579 80.842105-107.789473 80.842105c-105.472 0-203.237053-42.388211-297.768421-83.429053-94.800842-41.094737-184.346947-79.952842-281.411369-79.952842C122.718316 591.171368 53.894737 644.715789 53.894737 727.578947c0 79.063579 67.098947 136.434526 159.555368 136.434527 142.174316 0 230.426947-66.883368 306.79579-129.886316 31.420632 13.419789 62.787368 26.058105 94.450526 37.133474-47.077053 49.637053-110.969263 82.566737-186.610526 91.270736l5.066105 53.625264c93.453474-7.006316 143.144421 9.350737 195.718737 26.543157 46.457263 15.225263 94.127158 30.854737 169.822316 30.854737 19.994947 0 41.957053-1.077895 66.344421-3.557052l-5.416421-53.625263c-105.283368 10.778947-158.100211-6.548211-213.935158-24.872422-22.150737-7.275789-44.624842-14.632421-70.305684-20.345263a334.848 334.848 0 0 0 96.14821-82.297263z m-458.078316 21.261474C162.573474 810.118737 107.789474 784.276211 107.789474 727.578947c0-60.847158 62.733474-82.539789 121.451789-82.539789 77.850947 0 154.731789 30.288842 235.250526 64.943158-66.263579 52.924632-139.722105 100.136421-251.041684 100.136421z" fill="#231F20" ></path></symbol><symbol id="icon-tiger" viewBox="0 0 1024 1024"><path d="M431.157895 162.250105V134.736842c0-41.552842-39.289263-80.842105-80.842106-80.842105-28.833684 0-57.128421 4.661895-58.314105 4.850526L269.473684 62.490947v83.887158C144.788211 223.824842 89.222737 346.839579 66.991158 431.157895h266.051368c240.747789 0 415.851789 107.789474 415.85179 269.473684-14.848-25.114947-43.924211-53.894737-88.68379-53.894737-67.988211 0-121.263158 71.033263-121.263158 161.684211 0 66.802526 30.477474 119.888842 60.712421 156.16 12.638316 15.171368 36.055579 37.726316 59.014737 58.88 5.066105 0.107789 9.781895 0.538947 15.009685 0.538947 219.297684 0 350.315789-191.811368 350.315789-377.263158C1024 327.545263 679.855158 172.813474 431.157895 162.250105z" fill="#F7C768" ></path><path d="M673.684211 1024c-114.768842 0-188.820211-33.333895-254.167579-62.787368-53.625263-24.144842-99.974737-45.002105-161.28-45.002106-40.448 0-83.590737 23.255579-103.639579 45.16379l-39.747369-36.432842C142.497684 894.787368 199.168 862.315789 258.236632 862.315789c68.392421 0 119.861895 21.288421 172.921263 45.056V673.684211c0-35.166316-17.542737-64.107789-30.639158-80.815158-15.198316 9.835789-32.067368 18.890105-50.741895 26.947368l-21.342316-49.475368C469.800421 509.413053 485.052632 377.317053 485.052632 323.368421V221.642105A597.827368 597.827368 0 0 0 404.210526 215.578947h-26.947368V134.736842c0-12.099368-14.848-26.947368-26.947369-26.947368-9.377684 0-18.836211 0.592842-26.947368 1.347368V269.473684h-53.894737V211.671579c-136.030316 102.912-158.450526 266.886737-161.306947 295.882105 9.135158 9.108211 38.992842 25.061053 71.976421 38.669474l38.103579-59.365053 12.449684-1.589894C321.212632 473.653895 377.263158 392.192 377.263158 323.368421h53.894737c0 88.333474-68.796632 192.242526-180.870737 213.342316l-48.397474 75.398737-20.291368-7.437474C53.894737 557.756632 53.894737 523.317895 53.894737 512c0-50.041263 37.025684-254.733474 215.578947-365.621895V62.490947l22.528-3.745684C293.187368 58.556632 321.482105 53.894737 350.315789 53.894737c41.552842 0 80.842105 39.289263 80.842106 80.842105v27.513263c248.697263 10.563368 592.842105 165.295158 592.842105 484.486737 0 185.451789-131.018105 377.263158-350.315789 377.263158z m-13.473685-323.368421c-36.513684 0-67.368421 49.367579-67.368421 107.789474 0 85.746526 68.096 145.084632 89.465263 161.549473 91.540211-2.533053 164.378947-45.487158 213.827369-107.654737H700.631579v-53.894736h230.238316c8.919579-17.273263 16.357053-35.354947 22.285473-53.894737h-239.885473l-6.467369-17.650527C706.290526 735.582316 692.439579 700.631579 660.210526 700.631579zM485.052632 931.112421c33.926737 14.066526 70.521263 26.597053 114.607157 33.468632C569.424842 928.309895 538.947368 875.223579 538.947368 808.421053c0-90.650947 53.274947-161.684211 121.263158-161.684211 44.759579 0 73.835789 28.779789 88.68379 53.894737h217.007158c2.775579-17.866105 4.203789-35.920842 4.203789-53.894737 0-38.938947-5.658947-74.752-15.925895-107.627789l-126.706526 126.679579-38.103579-38.103579L932.001684 485.052632a367.939368 367.939368 0 0 0-57.775158-81.596632l-154.543158 154.543158-38.103579-38.103579 153.573053-153.573053a537.869474 537.869474 0 0 0-82.593684-56.751158l-140.665263 140.638316-38.103579-38.103579 128.134737-128.134737A794.731789 794.731789 0 0 0 538.947368 231.046737V323.368421c0 50.149053-11.102316 156.698947-95.932631 236.328421 18.378105 23.417263 42.037895 63.407158 42.037895 113.987369v257.42821zM215.578947 431.157895v-53.894737c39.774316 0 53.894737-29.022316 53.894737-53.894737h53.894737c0 53.571368-37.025684 107.789474-107.789474 107.789474z" fill="#231F20" ></path></symbol><symbol id="icon-boar" viewBox="0 0 1024 1024"><path d="M732.079158 377.263158c-107.789474 0-186.421895 31.393684-281.869474 126.841263L180.331789 773.982316C257.724632 807.909053 348.725895 808.421053 485.052632 808.421053h96.013473c55.834947-34.411789 133.551158-53.894737 227.354948-53.894737h121.344L970.105263 680.555789V572.631579c0-94.315789-130.236632-195.368421-238.026105-195.368421z" fill="#FFBDD8" ></path><path d="M808.421053 700.631579v53.894737c-196.446316 0-323.368421 84.641684-323.368421 215.578947h-53.894737c0-163.705263 148.075789-269.473684 377.263158-269.473684z m-323.368421 107.789474v-53.894737c-158.342737 0-245.598316 0-319.649685-49.367579L158.612211 700.631579H80.842105c-21.692632 0-26.624-14.821053-26.947368-26.947368v-82.620632c84.156632-11.183158 161.684211-74.913684 161.68421-186.853053V215.578947H161.684211v161.684211H134.736842c-66.964211 0-134.736842 37.025684-134.736842 107.789474h53.894737c0-42.630737 52.870737-53.894737 80.842105-53.894737h24.629895C147.132632 504.912842 85.153684 538.947368 26.947368 538.947368H0v134.736843c0 32.498526 21.530947 80.842105 80.842105 80.842105h61.682527c32.687158 20.506947 67.125895 33.145263 105.957052 41.013895A232.879158 232.879158 0 0 0 215.578947 916.210526h53.894737c0-41.930105 14.012632-80.303158 39.424-112.505263C358.885053 808.151579 415.959579 808.421053 485.052632 808.421053z m-72.946527-342.420211L323.368421 554.738526V431.157895h-53.894737v253.682526l180.736-180.736-38.103579-38.103579zM323.368421 161.684211h-53.894737v190.032842a769.536 769.536 0 0 1 53.894737-49.098106V161.684211z m323.368421-53.894737c-72.623158 0-146.809263 23.336421-215.578947 58.637473V107.789474h-53.894737v154.138947C458.832842 205.392842 555.331368 161.684211 646.736842 161.684211c148.587789 0 269.473684 120.885895 269.473684 269.473684v235.654737L809.579789 862.315789h61.359158L970.105263 680.555789V431.157895c0-178.310737-145.057684-323.368421-323.368421-323.368421z" fill="#231F20" ></path></symbol><symbol id="icon-boar_hai" viewBox="0 0 1024 1024"><path d="M512 512m-296.421053 0a296.421053 296.421053 0 1 0 592.842106 0 296.421053 296.421053 0 1 0-592.842106 0Z" fill="#85C3DE" ></path><path d="M309.975579 804.756211l-27.136-46.592c103.073684-60.011789 183.026526-132.473263 241.475368-219.24379H350.315789l-13.473684-50.283789c58.88-33.980632 99.435789-117.571368 118.703158-165.295158H242.526316v-53.894737h538.947368v53.894737h-268.18021c-12.395789 34.088421-42.469053 106.603789-90.435369 161.68421h134.009263a680.555789 680.555789 0 0 0 46.349474-107.708631l51.092211 17.057684c-58.421895 175.265684-171.034947 309.490526-344.333474 410.381474z m192.350316-2.937264L467.806316 760.454737c88.414316-73.728 154.516211-158.773895 202.105263-259.907369l48.801684 22.959158a797.372632 797.372632 0 0 1-82.351158 137.781895c32.741053 15.009684 83.456 44.867368 137.647158 101.591579l-38.938947 37.268211c-57.236211-59.877053-109.325474-85.557895-133.766737-95.178106a850.997895 850.997895 0 0 1-98.977684 96.848842z m48.613052-536.872421l-80.842105-53.894737 29.884632-44.840421 80.842105 53.894737-29.884632 44.840421zM512 53.894737C259.395368 53.894737 53.894737 259.395368 53.894737 512s205.500632 458.105263 458.105263 458.105263c9.081263 0 17.973895-0.835368 26.947368-1.374316v-53.894736c-8.946526 0.619789-17.866105 1.374316-26.947368 1.374315-222.881684 0-404.210526-181.328842-404.210526-404.210526S289.118316 107.789474 512 107.789474s404.210526 181.328842 404.210526 404.210526c0 195.206737-139.075368 358.507789-323.368421 396.045474v54.460631c214.096842-38.346105 377.263158-225.549474 377.263158-450.533052C970.105263 259.395368 764.604632 53.894737 512 53.894737z" fill="#231F20" ></path></symbol><symbol id="icon-bilibili1" viewBox="0 0 1129 1024"><path d="M234.909 9.656a80.468 80.468 0 0 1 68.398 0 167.374 167.374 0 0 1 41.843 30.578l160.937 140.82h115.07l160.936-140.82a168.983 168.983 0 0 1 41.843-30.578A80.468 80.468 0 0 1 930.96 76.445a80.468 80.468 0 0 1-17.703 53.914 449.818 449.818 0 0 1-35.406 32.187 232.553 232.553 0 0 1-22.531 18.508h100.585a170.593 170.593 0 0 1 118.289 53.109 171.397 171.397 0 0 1 53.914 118.288v462.693a325.897 325.897 0 0 1-4.024 70.007 178.64 178.64 0 0 1-80.468 112.656 173.007 173.007 0 0 1-92.539 25.75H212.377a341.186 341.186 0 0 1-72.421-4.024A177.835 177.835 0 0 1 28.91 939.065a172.202 172.202 0 0 1-27.36-92.539V388.662a360.498 360.498 0 0 1 0-66.789A177.03 177.03 0 0 1 162.487 178.64h105.414c-16.899-12.07-31.383-26.555-46.672-39.43a80.468 80.468 0 0 1-25.75-65.984 80.468 80.468 0 0 1 39.43-63.57M216.4 321.873a80.468 80.468 0 0 0-63.57 57.937 108.632 108.632 0 0 0 0 30.578v380.615a80.468 80.468 0 0 0 55.523 80.469 106.218 106.218 0 0 0 34.601 5.632h654.208a80.468 80.468 0 0 0 76.444-47.476 112.656 112.656 0 0 0 8.047-53.109v-354.06a135.187 135.187 0 0 0 0-38.625 80.468 80.468 0 0 0-52.304-54.719 129.554 129.554 0 0 0-49.89-7.242H254.22a268.764 268.764 0 0 0-37.82 0z m0 0" fill="#20B0E3" ></path><path d="M348.369 447.404a80.468 80.468 0 0 1 55.523 18.507 80.468 80.468 0 0 1 28.164 59.547v80.468a80.468 80.468 0 0 1-16.094 51.5 80.468 80.468 0 0 1-131.968-9.656 104.609 104.609 0 0 1-10.46-54.719v-80.468a80.468 80.468 0 0 1 70.007-67.593z m416.02 0a80.468 80.468 0 0 1 86.102 75.64v80.468a94.148 94.148 0 0 1-12.07 53.11 80.468 80.468 0 0 1-132.773 0 95.757 95.757 0 0 1-12.875-57.133V519.02a80.468 80.468 0 0 1 70.007-70.812z m0 0" fill="#20B0E3" ></path></symbol><symbol id="icon-yinle" viewBox="0 0 1024 1024"><path d="M512.2976 0a531.2 531.2 0 0 0-512 548.48V960h128V548.48a398.72 398.72 0 0 1 384-411.52 398.72 398.72 0 0 1 384 411.52V960h128V548.48A531.2 531.2 0 0 0 512.2976 0z" fill="#5c8add" ></path><path d="M64.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path><path d="M704.2976 576l256 0 0 448-256 0 0-448Z" fill="#5c8add" ></path></symbol><symbol id="icon-icon-test-copy" viewBox="0 0 1024 1024"><path d="M512 512m-229.517241 0a229.517241 229.517241 0 1 0 459.034482 0 229.517241 229.517241 0 1 0-459.034482 0Z" fill="#5c8add" ></path><path d="M512 1024A512 512 0 1 1 1024 512 512 512 0 0 1 512 1024z m0-141.241379A370.758621 370.758621 0 1 0 141.241379 512 370.758621 370.758621 0 0 0 512 882.758621z" fill="#5c8add" ></path></symbol><symbol id="icon-V" viewBox="0 0 1024 1024"><path d="M1012.47774251 492.58192592L544.94137566 87.22962963a49.96686561 49.96686561 0 0 0-65.88275132 0L11.63784127 492.6975097c-21.03624691 18.26223633-23.3479224 49.93219048-5.08568606 70.96843739 18.03106878 21.03624691 49.93219048 23.3479224 70.96843738 5.08568607L512 191.83294532l434.71057495 376.91868784c9.47786949 8.20644797 21.26741446 12.25188008 32.82579189 12.13629629 14.10122046 0 27.97127337-5.77918871 38.02706173-17.33756613 18.14665256-20.92066314 15.95056084-52.70620106-5.08568606-70.9684374z" fill="#5c8add" ></path><path d="M109.30613051 567.59579541V896.89396825c0 42.53482892 34.90629982 77.44112875 77.44112875 77.44112875h220.76500882V666.30433862c0-25.54401411 20.92066314-46.46467725 46.46467724-46.46467724h116.16169313c25.54401411 0 46.46467725 20.92066314 46.46467725 46.46467724V974.335097h220.76500882c42.53482892 0 77.44112875-34.90629982 77.44112874-77.44112875l0.11558377-329.29817284L512 218.18604586 109.30613051 567.59579541zM848.00203175 197.49655027h-63.91782716c-12.82979894 0-23.23233862 10.40253968-23.23233863 23.23233862v24.27259259l110.49808818 95.70336508V220.72888889h-0.11558377c0-12.82979894-10.40253968-23.23233862-23.23233862-23.23233862zM905.44716754 83.18419754s-34.90629982 56.86721693-89.11508994 100.32671603c152.68616579 13.98563668 127.83565432-133.26809171 127.83565432-133.2680917-134.07717813-10.28695591-132.92134039 102.29164021-131.072 127.83565432 20.92066314-20.92066314 49.70102293-62.64640564 92.35143562-94.89427865zM798.53217637 174.61096297c-19.64924162-16.52847972-40.56990476-43.45949912-51.203612-53.97762258 0 0 32.94137566 20.57391182 56.40488184 49.3542716 2.42725926-18.37782011 6.47269135-93.3916896-93.16052205-85.3008254 0 0-13.98563668 104.71889947 87.95925221 89.92417638z" fill="#5c8add" ></path></symbol><symbol id="icon-zhifeiji" viewBox="0 0 1167 1024"><path d="M41.201759 463.52493L1110.665064 30.117647c10.32605-4.159104 21.942857 0.860504 26.101961 11.043137 1.434174 3.728852 1.864426 7.744538 1.003921 11.616807L949.033691 978.823529c-2.151261 10.89972-12.764146 17.927171-23.663865 15.632493-2.72493-0.573669-5.306443-1.721008-7.601121-3.298599L634.80624 789.79944l-163.065546 133.951821c-16.492997 13.62465-40.87395 11.186555-54.498599-5.306443-3.011765-3.728852-5.306443-7.887955-6.884034-12.477311l-102.973669-313.080112-265.178712-91.787115c-10.469468-3.585434-16.062745-15.058824-12.333893-25.528291 1.864426-5.44986 6.023529-9.895798 11.329972-12.047059z" fill="#FCFDFC" ></path><path d="M929.385512 1023.569748c-3.155182 0-6.453782-0.286835-9.752381-1.003922-6.740616-1.434174-12.907563-4.015686-18.50084-8.031372L635.953579 825.940616l-146.142297 120.040336c-13.911485 11.473389-31.408403 16.779832-49.335574 15.058824-17.927171-1.721008-34.133333-10.32605-45.463305-24.237535-5.306443-6.453782-9.322129-13.768067-11.903642-21.79944l-98.527731-299.598879-251.697479-87.19776c-12.333894-4.302521-22.229692-13.05098-27.966386-24.811204s-6.453782-24.954622-2.151261-37.288515c4.589356-13.337815 14.771989-23.9507 27.82297-29.257143L1099.908761 3.585434c24.954622-10.039216 53.351261 2.007843 63.533894 26.819048 3.585434 8.891877 4.445938 18.644258 2.581513 28.109804L977.143495 984.560224c-4.732773 23.090196-25.098039 39.009524-47.757983 39.009524z m-294.579272-233.770308l282.962465 201.357983c2.294678 1.577591 4.87619 2.72493 7.601121 3.298599 10.89972 2.151261 21.512605-4.87619 23.663865-15.632493L1137.914364 52.777591c0.860504-3.872269 0.430252-7.887955-1.003922-11.616807-4.159104-10.32605-15.919328-15.202241-26.101961-11.043137L41.201759 463.52493c-5.306443 2.151261-9.465546 6.597199-11.47339 12.047059-1.721008 5.019608-1.434174 10.469468 0.860505 15.345658 2.294678 4.87619 6.453782 8.461625 11.473389 10.182633l265.178711 91.787115L410.214644 905.967507c1.434174 4.589356 3.872269 8.748459 6.884033 12.477311 6.597199 8.031373 15.919328 12.907563 26.101961 13.911485 10.32605 1.003922 20.365266-2.007843 28.396639-8.605042l163.208963-133.951821z" fill="#4A4A4A" ></path><path d="M307.097557 592.743978l105.698599 316.091876c6.310364 18.787675 26.532213 28.970308 45.319888 22.659944 4.159104-1.434174 7.887955-3.442017 11.186555-6.166946l164.786555-133.951821-165.360224-118.892997c297.017367-287.982073 447.462185-433.980952 451.191036-437.853222 0.573669-0.573669 2.581513-3.442017 0.430252-7.027451-1.290756-1.577591-3.298599-3.298599-7.027451-2.15126-202.218487 120.327171-404.293557 242.805602-606.22521 367.291877z" fill="#CAE0EE" ></path><path d="M446.786072 934.794398c-5.736695 0-11.329972-1.290756-16.636414-3.872269-8.891877-4.445938-15.632493-12.047059-18.787675-21.512605L305.376549 592.313725l1.003921-0.573669C507.308201 467.684034 711.391114 344.058263 912.60568 224.161345l0.286835-0.143418c3.585434-1.147339 6.310364-0.286835 8.605042 2.581513l0.143417 0.143417c2.438095 4.015686 0.573669 7.457703-0.573669 8.74846-3.872269 4.015686-155.177591 150.87507-450.043698 436.705882l165.503642 119.036414-166.220728 135.09916c-3.442017 2.868347-7.457703 5.019608-11.760225 6.453782-3.728852 1.290756-7.744538 2.007843-11.760224 2.007843z m-137.967507-341.333334l105.268348 314.944538c2.868347 8.748459 9.035294 15.77591 17.210084 19.935014 8.17479 4.159104 17.496919 4.732773 26.245378 1.864426 3.872269-1.290756 7.60112-3.298599 10.756302-5.880112l163.352381-132.804482L466.434252 672.627451l1.290756-1.147339C763.308201 384.932213 915.043775 237.642577 918.772627 233.626891c0 0 2.007843-2.294678 0.286835-5.306443-1.003922-1.290756-2.438095-2.438095-5.306443-1.577591-200.784314 119.610084-404.293557 242.94902-604.934454 366.718207z" fill="#CAE0EE" ></path><path d="M460.840974 924.898599l7.457703-253.561904 165.933894 119.896918-168.658824 135.959664c-1.290756 1.003922-3.011765 0.860504-4.015686-0.430252-0.430252-0.430252-0.717087-1.147339-0.717087-1.864426z" fill="#94C3E2" ></path><path d="M463.709322 929.344538c-1.290756 0-2.438095-0.573669-3.2986-1.577591-0.573669-0.860504-1.003922-1.864426-1.003921-2.868348l7.60112-256.286834 169.519328 122.621848-1.434174 1.147339-168.658823 135.959664c-0.860504 0.717087-1.721008 1.003922-2.72493 1.003922z m6.023529-255.282913l-7.457703 250.836974c0 0.286835 0.143417 0.717087 0.286835 1.003922 0.430252 0.573669 1.434174 0.717087 2.007843 0.286835l167.22465-134.812325-162.061625-117.315406z" fill="#94C3E2" ></path></symbol><symbol id="icon-lianjie" viewBox="0 0 1079 1024"><path d="M695.355535 432.666896c-0.553495-1.10699-0.885592-2.186305-1.383737-3.265619-0.193723-0.193723-0.193723-0.359772-0.359771-0.719543-12.508983-26.318678-39.436506-43.366319-69.325226-41.013966-39.076734 3.265619-68.439634 39.021384-65.312388 79.841627 0.857917 10.516401 3.653066 20.147211 7.998 28.83708 19.78744 46.659613 11.097571 103.448181-25.377737 141.750022l-191.094085 199.950001a118.088119 118.088119 0 0 1-171.998513 0c-47.434506-49.537786-47.434506-130.098956 0-179.636742l71.234782-74.389703-0.52582-0.553494a75.911814 75.911814 0 0 0 24.326097-61.880721c-3.127246-40.820243-37.3609-71.51153-76.437634-68.24591a69.463599 69.463599 0 0 0-46.908685 23.966325l-0.166049-0.193723-72.618519 75.856464c-103.226783 107.793115-103.226783 282.36538 0 390.158495 103.171433 107.793115 270.299193 107.793115 373.498301 0l191.619904-200.1714c80.256748-83.992838 97.636485-208.307773 52.83108-310.289193z" fill="#5c8add" ></path><path d="M1002.047012 80.865592c-103.226783-107.82079-270.382217-107.82079-373.581325 0l-191.619905 200.199075c-80.284423 83.854464-97.66416 208.197074-52.997128 310.233843 0.52582 1.079315 0.857917 2.15863 1.383737 3.26562 0.166048 0.166048 0.166048 0.359772 0.332097 0.719543 12.536658 26.291004 39.46418 43.366319 69.3529 41.013966 39.076734-3.265619 68.439634-39.021384 65.312388-79.869302a78.679288 78.679288 0 0 0-7.998-28.864755c-19.78744-46.631938-11.097571-103.448181 25.377737-141.750022l191.287808-199.839302a118.088119 118.088119 0 0 1 172.026188 0c47.434506 49.537786 47.434506 130.126631 0 179.692091l-71.234782 74.417378 0.52582 0.553495a75.939489 75.939489 0 0 0-24.353772 61.88072c3.15492 40.847917 37.3609 71.51153 76.465309 68.245911a69.463599 69.463599 0 0 0 46.908685-23.938651l0.166049 0.166048 72.646194-75.856464c103.03306-107.82079 103.03306-282.642127 0-390.269194z" fill="#5c8add" ></path></symbol><symbol id="icon-liaotian" viewBox="0 0 1171 1024"><path d="M1068.71699 0.243751H102.193768C46.228437 0.243751 0.500666 45.045267 0.500666 99.74309v696.251622c0 54.697824 45.727771 99.450589 101.693102 99.450589h329.113198l120.851966 114.465677a48.652788 48.652788 0 0 0 66.641644 0l120.851966-114.465677h329.064448c55.965331 0 101.741852-44.752765 101.741852-99.450589V99.74309C1170.458842 45.045267 1124.682321 0.243751 1068.71699 0.243751z m-439.776354 596.849784h-370.989696c-27.933915 0-50.846551-22.425133-50.846551-49.774045 0-27.348912 22.912636-49.725294 50.846551-49.725294h370.989696c27.933915 0 50.846551 22.376382 50.846551 49.725294 0 27.348912-22.912636 49.774045-50.846551 49.774045z m287.18795-211.381252H254.782171a50.456549 50.456549 0 0 1-50.846551-49.725294c0-27.397662 22.912636-49.774045 50.846551-49.774045h661.346415c27.933915 0 50.846551 22.376382 50.846551 49.774045 0 27.348912-22.912636 49.725294-50.846551 49.725294z" fill="#5C8ADD" ></path></symbol><symbol id="icon-xinfeng" viewBox="0 0 1400 1024"><path d="M1301.63733163 214.78520234a207.81921797 207.81921797 0 0 1 7.02423018 52.42036465v489.73590176a205.10753818 205.10753818 0 0 1-205.05853125 205.05853125H283.05853124A205.15654424 205.15654424 0 0 1 77.99999999 756.79444971V267.20556699a201.36672685 201.36672685 0 0 1 7.02423106-52.42036465L586.24393329 562.1905874c69.44187217 51.96297217 146.36536612 49.13694404 214.1736961 0zM1103.60303056 62.0000167H283.05853124A204.50312753 204.50312753 0 0 0 106.37462518 163.41030547l489.71956641 335.75823018c62.43397646 50.77048623 127.85733457 50.31309463 194.62019765 0L1280.28693749 163.41030547A204.68281729 204.68281729 0 0 0 1103.60303056 62.0000167z m0 0" fill="#5c8add" ></path></symbol><symbol id="icon-QQ1" viewBox="0 0 1024 1024"><path d="M0 512a512 512 0 1 0 1024 0A512 512 0 1 0 0 512z" fill="#18ACFC" ></path><path d="M500.113 228.39c118.396-1.518 178.924 61.004 201 156 3.497 15.048 0.15 34.807 0 50 27.143 5.682 33.087 60.106 10 75v1h1c8.26 14.33 19.04 28.125 26 44 7.332 16.723 9.306 35.16 14 55 4.024 17.01-2.287 51.505-10 57-0.771 0.683-2.231 1.312-3 2-14.601-3.016-30.377-16.865-38-27-3.065-4.074-5.275-9.672-10-12-0.395 21.568-12.503 41.15-22 55-3.514 5.123-14.073 13.217-14 18 3.691 2.836 8.305 2.956 13 5 10.513 4.577 25.449 13.168 32 22 2.334 3.146 5.548 7.555 7 11 16.193 38.414-36.527 48.314-63 54-27.185 5.839-77.818-10.224-92-19-8.749-5.414-16.863-18.573-29-19-3.666 2.389-14.438 1.132-20 1-16.829 32.804-101.913 47.868-148 31-14.061-5.146-43.398-17.695-38-40 4.437-18.327 19.947-29.224 35-37 5.759-2.975 18.915-4.419 22-10-13.141-8.988-24.521-28.659-31-44-3.412-8.077-4.193-25.775-9-32-7.789 12.245-32.097 36.91-52 33-3.071-4.553-7.213-9.097-9-15-4.792-15.835-1.81-40.379 2-54 8.117-29.02 16.965-50.623 32-72 4.672-6.643 11.425-12.135 16-19-8.945-9.733-6.951-37.536-1-49 4.002-7.709 9.701-7.413 10-20-1.92-3.022-0.071-8.604-1-13-4.383-20.75 3.273-47.552 9-63 19.8-53.421 53.712-90.466 105-112 11.986-5.033 25.833-7.783 39-11 5.322-1.3 11.969 0.518 16-2z" fill="#FFFFFF" ></path></symbol><symbol id="icon-rss" viewBox="0 0 1024 1024"><path d="M749.61196492 908.06119793C749.61196492 560.41848146 463.58151854 274.36328126 115.93880207 274.36328126V115.93880207c434.50388795 0 792.12239584 357.61850789 792.12239586 792.12239586zM224.55858562 690.72261555a108.91682943 108.91682943 0 0 1 108.69404499 108.74355267C333.25263061 859.29616292 284.24005737 908.06119793 224.31104736 908.06119793 164.48105265 908.06119793 115.96355592 859.41993206 115.96355592 799.46616822s48.69077351-108.71879883 108.61978351-108.74355267zM641.01693522 908.06119793h-153.96879069c0-203.60020956-167.50913289-371.13409627-371.10934246-371.13409629v-153.96879068c288.03550619 0 525.07813313 237.11688843 525.07813315 525.10288697z" fill="#FFA500" ></path></symbol><symbol id="icon-youxiang" viewBox="0 0 1024 1024"><path d="M583.60666667 972h-68.08c-8.43333333 0-15.33333333-6.9-15.33333334-15.33333333V609.52c0-8.43333333 6.9-15.33333333 15.33333334-15.33333333h68.08c8.43333333 0 15.33333333 6.9 15.33333333 15.33333333V956.66666667c0 8.43333333-6.9 15.33333333-15.33333333 15.33333333z" fill="#629FF9" ></path><path d="M294.42 167c-113.62 0-205.77333333 92-205.77333333 205.31333333v336.72h411.39333333V372.31333333c0.15333333-113.31333333-92-205.31333333-205.62-205.31333333z" fill="#2166CC" ></path><path d="M519.97333333 627H216.98666667c-25.45333333 0-46-20.54666667-46-46V393.78c0-25.45333333 20.54666667-46 46-46h302.98666666c25.45333333 0 46 20.54666667 46 46V581c0 25.45333333-20.54666667 46-46 46z" fill="#D2E4FF" ></path><path d="M565.97333333 397a49.22 49.22 0 0 0-49.37333333-49.22H220.36c-27.29333333 0-49.37333333 22.08-49.37333333 49.22v10.27333333l179.4 94.60666667c11.34666667 5.98 24.84 5.98 36.18666666 0l179.4-94.60666667v-10.27333333z" fill="#FFFFFF" ></path><path d="M730.5 167h-427.8v0.46c109.78666667 4.29333333 197.49333333 94.3 197.49333333 205.00666667v336.72h411.39333334c27.29333333 0 49.37333333-22.08 49.37333333-49.22V397c0-126.96-103.19333333-230-230.46-230z" fill="#4E8DF6" ></path><path d="M845.80666667 52H681.12666667c-9.04666667 0-16.40666667 7.36-16.40666667 16.40666667v336.72a24.67133333 24.67133333 0 1 0 49.37333333 0V134.18666667h131.71333334c9.04666667 0 16.40666667-7.36 16.40666666-16.40666667V68.40666667c0-9.04666667-7.36-16.40666667-16.40666666-16.40666667z" fill="#2166CC" ></path><path d="M896.25333333 659.81333333h-35.11333333c-8.43333333 0-15.33333333-6.9-15.33333333-15.33333333v-35.11333333c0-8.43333333 6.9-15.33333333 15.33333333-15.33333334h35.11333333c8.43333333 0 15.33333333 6.9 15.33333334 15.33333334v35.11333333c0 8.58666667-6.9 15.33333333-15.33333334 15.33333333z" fill="#FFFFFF" ></path><path d="M88.8 709.18666667l-24.22666667 131.40666666c-9.66 54.43333333 26.83333333 98.59333333 81.26666667 98.59333334h213.9c54.58666667 0 106.56666667-44.16 116.22666667-98.59333334l23.15333333-131.40666666H88.8z" fill="#2974CE" ></path></symbol><symbol id="icon-gitHub" viewBox="0 0 1049 1024"><path d="M523.6581816 52C262.83923907 52 52 262.8401375 52 523.6581816c0 208.49703047 135.09433812 384.97758117 322.50789391 447.44906532 23.42658172 4.68531653 32.01647887-10.15136894 32.01647796-22.64584583 0-10.93210574-0.78163433-48.41463703-0.78163433-87.45953855-131.18885996 28.11189824-158.5200223-56.22379738-158.52002231-56.22379739-21.08437312-54.66232469-52.3201152-68.71827336-52.3201152-68.71827335-42.94858371-28.89353348 3.12384382-28.89353348 3.12384384-28.89353348 47.63479867 3.12384382 72.62285398 48.41643391 72.62285398 48.4164339 42.16784782 71.84121875 110.10538527 51.53758242 137.43654672 39.04400399 3.90457972-30.45500618 16.3990566-51.5393793 29.67427028-63.25222094-104.64023039-10.93300418-214.74561566-51.53848086-214.74561657-232.70524742 0-51.53848086 18.74126609-93.70632867 48.4164339-126.50444187-4.68621496-11.71284164-21.08527156-60.12837711 4.6844181-124.94207075 0 0 39.82563922-12.49447688 129.62738726 48.41463704 37.48253129-10.15136894 78.08980484-15.61742227 117.91454562-15.61742137s80.43201433 5.46605242 117.91454473 15.61742137c89.80264648-60.90911391 129.62828571-48.41463703 129.62828571-48.41463704 25.76879122 64.81369363 9.37063305 113.22922911 4.68531651 124.94207075 30.45410773 32.79721477 48.41463703 74.96506258 48.41463703 126.50444187 0 181.16676656-110.10538527 220.99150644-215.52545401 232.70524742 17.1797934 14.83668547 32.01647887 42.94858371 32.01647886 87.45953946 0 63.25222094-0.78163433 114.009965-0.78163523 129.62738636 0 12.49447688 8.59079468 27.33116234 32.01737731 22.64584583 187.41265734-62.4705866 322.50699547-238.95203574 322.50699546-447.44996375C995.31636231 262.8401375 783.69369203 52 523.6581816 52z" fill="#663399" ></path><path d="M230.82365863 729.03136735c-0.7807359 2.34310703-4.68531653 3.12384382-7.80916035 1.56237113s-5.46605242-4.68531653-3.90368129-7.02842356c0.7807359-2.34220859 4.68531653-3.12384382 7.80826192-1.56147269s4.68531653 4.68531653 3.90457972 7.02752512z m18.7412661 21.08437312c-2.34220859 2.34220859-7.02752512 0.78163433-9.37063305-2.34310703-3.12294539-3.12294539-3.90457972-7.80826192-1.5614727-10.15136894 2.34220859-2.34220859 6.24678922-0.7807359 9.37063305 2.34310702 3.12384382 3.90457972 3.90457972 8.58899782 1.5614727 10.15136895zM268.30618992 777.44690281c-3.12294539 2.34220859-7.80826192 0-10.15136895-3.90457972-3.12384382-3.90457972-3.12384382-9.37063305 0-10.93210574 3.12384382-2.34310703 7.80916035 0 10.15226739 3.90457972 3.12294539 3.90368129 3.12294539 8.58899782 0 10.93210574z m25.76968965 26.55042555c-2.34220859 3.12294539-7.80916035 2.34220859-12.49447688-1.56237113-3.90457972-3.90368129-5.46605242-9.37063305-2.34220859-11.71284164 2.34220859-3.12384382 7.80826192-2.34310703 12.49447687 1.56147269 3.90368129 3.12384382 4.68531653 8.58989625 2.3422086 11.71374008z m35.1403227 14.83668637c-0.78163433 3.90457972-6.24768766 5.46605242-11.71374008 3.90457972-5.46605242-1.5614727-8.58899782-6.24768766-7.80916036-9.37063305 0.78163433-3.90457972 6.24768766-5.46605242 11.71374009-3.90457972 5.46605242 1.5614727 8.58899782 5.46605242 7.80916035 9.37063305z m38.26416562 3.12384382c0 3.90457972-4.68621496 7.02752512-10.15226738 7.02752512-5.46605242 0-10.15226738-3.12294539-10.15226739-7.02752512s4.68621496-7.02842356 10.15226739-7.02842445c5.46605242 0 10.15226738 3.12384382 10.15226738 7.02842445z m35.92016106-6.24768766c0.78163433 3.90457972-3.12384382 7.80916035-8.58899872 8.58989625-5.46695086 0.78163433-10.15226738-1.5614727-10.93390172-5.46605241-0.77983747-3.90457972 3.12384382-7.80916035 8.5907947-8.58899872 5.46605242-0.78163433 10.15136894 1.56057426 10.93210574 5.46515488z m0 0" fill="#663399" ></path></symbol><symbol id="icon-bilibili" viewBox="0 0 1024 1024"><path d="M832.61667555 181.33447111h-164.32545185l74.45617778-74.45617778c12.84020148-12.84020148 12.84020148-30.8140563 0-43.65425778-12.84020148-12.84020148-30.8140563-12.84020148-43.65425778 0L573.2882963 189.04101925H450.04420741L324.2272237 63.23617185c-10.26730667-12.84020148-25.68040297-15.40096-41.08136295-7.70654815-2.57289482 0-2.57289482 2.57289482-5.13365334 5.13365333-12.84020148 12.84020148-12.84020148 30.8140563 0 43.65425779l77.02907259 77.02907259h-164.32545185c-89.86927408 0-164.32545185 74.45617778-164.32545185 164.32545184v408.24073483c0 87.29637925 74.45617778 161.75255703 164.32545185 161.75255703h25.68040296c0 30.8140563 25.68040297 53.92156445 53.92156444 53.92156444s53.92156445-25.68040297 53.92156445-53.92156444H704.23893333c2.57289482 30.8140563 28.24116148 53.92156445 59.05521778 51.34866964 28.24116148-2.57289482 48.78791111-23.10750815 51.34866964-51.34866964h20.53461333c89.86927408 0 164.32545185-74.45617778 164.32545184-164.32545186V343.09916445c-2.56075852-89.86927408-77.02907259-161.76469333-166.88621037-161.76469334z m-5.13365333 634.19429926H200.99527111c-33.37481482 0-59.05521778-28.24116148-61.61597629-61.61597629l-2.57289482-415.94728297c0-33.37481482 28.24116148-61.6159763 61.6159763-61.61597629h626.48775111c33.37481482 0 59.05521778 28.24116148 61.61597629 61.61597629l2.57289482 415.94728297c-2.57289482 35.93557333-28.24116148 61.6159763-61.6159763 61.61597629z" fill="#ff7299" ></path><path d="M403.82919111 417.55534222l15.40096 77.0290726-205.40681481 38.50846815-15.40096-77.0290726 205.40681481-38.50846815z m197.70026667 77.0290726l15.40096-77.0290726 205.40681481 38.50846815-15.40096 77.0290726-205.40681481-38.50846815z m41.08136297 161.75255703c0 2.57289482 0 7.70654815-2.57289483 10.26730667-12.84020148 28.24116148-41.08136297 46.2150163-74.45617777 48.78791111-20.53461333 0-41.08136297-10.26730667-53.92156445-25.68040296-15.40096 15.40096-33.37481482 25.68040297-53.92156445 25.68040296-30.8140563-2.57289482-59.05521778-20.53461333-74.45617777-48.78791111 0-2.57289482-2.57289482-5.13365333-2.57289481-10.26730667 0-10.26730667 7.70654815-17.97385482 17.97385481-20.53461333h2.57289482c7.70654815 0 12.84020148 2.57289482 15.40096 10.26730666 0 0 20.53461333 28.24116148 38.50846815 28.24116149 35.94770963 0 35.94770963-30.8140563 56.48232296-53.92156445 23.10750815 25.68040297 23.10750815 53.92156445 56.48232296 53.92156445 23.10750815 0 38.50846815-28.24116148 38.50846815-28.24116149 2.57289482-5.13365333 10.26730667-10.26730667 15.40096-10.26730666 10.26730667-2.57289482 17.97385482 5.13365333 20.53461333 15.40096v5.13365333h0.0364089z" fill="#ff7299" ></path></symbol></svg>',        o = (o = document.getElementsByTagName("script"))[o.length - 1].getAttribute("data-injectcss"),        p = function (c, l) {            l.parentNode.insertBefore(c, l);        };    if (o && !c.__iconfont__svg__cssinject__) {        c.__iconfont__svg__cssinject__ = !0;        try {            document.write(                "<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>"            );        } catch (c) {            console && console.log(c);        }    }    function d() {        i || ((i = !0), a());    }    function m() {        try {            t.documentElement.doScroll("left");        } catch (c) {            return void setTimeout(m, 50);        }        d();    }    (l = function () {        var c,            l = document.createElement("div");        (l.innerHTML = v),            (v = null),        (l = l.getElementsByTagName("svg")[0]) &&        (l.setAttribute("aria-hidden", "true"),            (l.style.position = "absolute"),            (l.style.width = 0),            (l.style.height = 0),            (l.style.overflow = "hidden"),            (l = l),            (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l));    }),        document.addEventListener            ? ~["complete", "loaded", "interactive"].indexOf(document.readyState)            ? setTimeout(l, 0)            : ((h = function () {                document.removeEventListener("DOMContentLoaded", h, !1), l();            }),                document.addEventListener("DOMContentLoaded", h, !1))            : document.attachEvent &&            ((a = l),                (t = c.document),                (i = !1),                m(),                (t.onreadystatechange = function () {                    "complete" == t.readyState && ((t.onreadystatechange = null), d());                }));})(window);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime/runtime.js"/>
      <url>/js/runtime/runtime.js</url>
      
        <content type="html"><![CDATA[var now = new Date;function createtime() {    var t = new Date("03/29/2023 00:00:00");    now.setTime(now.getTime() + 250);    var e = (now - t) / 1e3 / 60 / 60 / 24, a = Math.floor(e), n = (now - t) / 1e3 / 60 / 60 - 24 * a,        r = Math.floor(n);    1 == String(r).length && (r = "0" + r);    var s = (now - t) / 1e3 / 60 - 1440 * a - 60 * r, i = Math.floor(s);    1 == String(i).length && (i = "0" + i);    var o = (now - t) / 1e3 - 86400 * a - 3600 * r - 60 * i, l = Math.round(o);    1 == String(l).length && (l = "0" + l);    let g = "";    g = r < 18 && r >= 9        ? `<br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>` : `<br> 本站居然运行了 ${a} 天</span><span id='runtime'> ${r} 小时 ${i} 分 ${l} 秒 </span> <i class='fas fa-heartbeat' style='color:red'></i>`, document.getElementById("workboard") && (document.getElementById("workboard").innerHTML = g)}setInterval((() => {    createtime()}), 250);]]></content>
      
    </entry>
    
    
  
</search>
